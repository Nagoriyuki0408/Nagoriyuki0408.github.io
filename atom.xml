<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柳瀬しおこうの夢</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-18T08:31:03.200Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>SHIOKOU</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MUSICUS!</title>
    <link href="http://example.com/2024/10/18/MUSICUS/"/>
    <id>http://example.com/2024/10/18/MUSICUS/</id>
    <published>2024-10-18T02:22:46.000Z</published>
    <updated>2024-10-18T08:31:03.200Z</updated>
    
    <content type="html"><![CDATA[<p>MUSICUS！启动</p><h3 id="共通"><a href="#共通" class="headerlink" title="共通"></a>共通</h3><p>タイトル画面から「NEW GAME」を選択</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">進学のために頑張ってきたけど、正直なところほかの道もあるんじゃないかなって迷う気持ちもある</td></tr><tr><td align="center">これも音楽の力なのか……？</td></tr><tr><td align="center">両方をやる</td></tr><tr><td align="center">そうかもしれない</td></tr><tr><td align="center">尾崎さんにバンド活動を含め、夏休みの出来事を話す</td></tr><tr><td align="center">先のことはわかりませんが、世の中にはそういう道もあります</td></tr><tr><td align="center">なんと思われても構いません。僕は自分の道は自分の価値観で選びます</td></tr><tr><td align="center">まだわからないですが、彼が何を見たのか、知ることが出来ればとは思います</td></tr></tbody></table><p>**<a href="https://mono-iki.com/musicus-pc-guide/#1">セーブポイント①</a>**<strong>作成</strong><br><a href="https://mono-iki.com/musicus-pc-guide/#yako">弥子√</a>分岐</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">誰かを犠牲にすることは出来ない。でも、何かにかける生き方もあるんだ</td></tr><tr><td align="center">ライブは表現の場所だと思う。心の中の何かを伝えるため、最高のサウンドを目指すバンドにしたい</td></tr><tr><td align="center">まだわからない</td></tr><tr><td align="center">なんか格好いいからですよ。それじゃダメですか？</td></tr><tr><td align="center">気が向いたらね。どういう風に受け止められてるのかなって寂しくなった時にでも見るよ</td></tr><tr><td align="center">いや、どっちかといえば香坂さんに近いかな</td></tr></tbody></table><p>**<a href="https://mono-iki.com/musicus-pc-guide/#2">セーブポイント②</a>**<strong>作成</strong><br><a href="https://mono-iki.com/musicus-pc-guide/#meguru">めぐる√</a>分岐</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">基本的には三日月と似てるかな。やっぱり、音楽や演奏を通して何かを伝えたいという気持ちがある</td></tr><tr><td align="center">そりゃ、多くの人に認められれば嬉しいけれど</td></tr><tr><td align="center">これでいい。ステージには等身大の自分を上げるんだ</td></tr></tbody></table><p>**<a href="https://mono-iki.com/musicus-pc-guide/#3">セーブポイント③</a>**<strong>作成</strong><br><a href="https://mono-iki.com/musicus-pc-guide/#sumi">澄√</a>・<a href="https://mono-iki.com/musicus-pc-guide/#mika">三日月√</a>分岐</p><h3 id="尾崎弥子"><a href="#尾崎弥子" class="headerlink" title="尾崎弥子"></a>尾崎弥子</h3><p><img src="https://mono-iki.com/wp-content/uploads/2022/09/yako.jpg" alt="尾崎弥子">@OVERDRIVE『MUSICUS!』</p><p><a href="https://mono-iki.com/musicus-pc-guide/#1">セーブポイント①</a>から</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">どんな形であれ、自分の人生をギャンブルにするなんてあってはいけない</td></tr><tr><td align="center">その手を取る。</td></tr></tbody></table><p><strong>ED：尾崎弥子</strong></p><h3 id="香坂めぐる"><a href="#香坂めぐる" class="headerlink" title="香坂めぐる"></a>香坂めぐる</h3><p><img src="https://mono-iki.com/wp-content/uploads/2022/09/meguru.jpg" alt="香坂めぐる">@OVERDRIVE『MUSICUS!』</p><p><a href="https://mono-iki.com/musicus-pc-guide/#2">セーブポイント②</a>から</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">香坂さんよりかもしれないなあ。表現どうこうより、音楽そのものを楽しみたい</td></tr></tbody></table><p><strong>ED：香坂めぐる</strong></p><h3 id="来島澄"><a href="#来島澄" class="headerlink" title="来島澄"></a>来島澄</h3><p><img src="https://mono-iki.com/wp-content/uploads/2022/09/sumi.jpg" alt="来島澄">@OVERDRIVE『MUSICUS!』</p><p><a href="https://mono-iki.com/musicus-pc-guide/#3">セーブポイント③</a>から</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">僕らの新曲として発表する。花井さんが作曲したことは公表しない</td></tr><tr><td align="center">バンドのことは後で考えよう。とにかくやるべきだ</td></tr></tbody></table><p><strong>ED：来島澄（No title）</strong></p><h3 id="花井三日月"><a href="#花井三日月" class="headerlink" title="花井三日月"></a>花井三日月</h3><p><img src="https://mono-iki.com/wp-content/uploads/2022/09/mika.jpg" alt="花井三日月">@OVERDRIVE『MUSICUS!』</p><p><a href="https://mono-iki.com/musicus-pc-guide/#3">セーブポイント③</a>から</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">花井さんの遺作であることを告知して、今度の三回忌で発表する</td></tr><tr><td align="center">賛成出来ない。これからバンド活動も忙しくなる。両立は不可能だ</td></tr></tbody></table><p><strong>ED：花井三日月</strong></p><p>人名：</p><p>対馬 馨 つしま けい</p><p>花井 三日月 はない みかづき</p><p>香坂 めぐる こうさか めぐる</p><p>尾崎 弥子 おざき やこ</p><p>花井 是清 はない これきよ</p><p>来島 澄 きしま すみ</p><p>髙橋 風雅  たかはし ふうが</p><p>金田 かねだ</p><p>田崎 京香 たざき きょうか</p><p>対馬 直美 つしま なおみ </p><p>対馬 脩作 つしま しゅうさく</p><p>田村 怜 たむら れい</p><p>篠崎 しのざき </p><p>佐藤 未来  さとう みらい</p><p>村田 龍一 むらた りゅういち</p><p>八木原 やぎはら</p><p>　そうしてスタッフさんとメンバーがやりとりをしながら、それぞれの楽器をかき鳴らしてゆく。どうやら音の調整をしているようだった。　それぞれの音のチェックが終わると、曲を流してチェック。　あ、結構良い曲だ。聴いたことがないけれど、これが『花鳥風月』の曲なのか。　続きが聴きたいなあと思っているところで、花井さんが手をあげて止める。</p><p>「そうなんですかあ。見たことがないイケメンがいるから、誰かなあってさっきから気になってて。……あ、私、『プテラノドン』のＲＡＹです。『花鳥風月』さんにはいつもお世話になってます」「対馬と言います。『花鳥風月』のお知り合いですか？」</p><p>　特に花井さんがやたらと天才と書かれているのが目に付く。当時の写真などもあって、見てみるけれど……それはあんまり今と変わっていないな。僕より年下のはずだけど、どう見ても年上にしか見えない。老けてる。でも今より少し痩せていて、目つきが鋭い。やっぱり、今より意欲に満ちあふれていたんだろうか？　その頃の記事はやたらとある。が、最近の活動を扱った記事は少ないようだ。それでも、熱狂的なファンはいるようだけれど。</p><p>「頑張ろうが、何をしようが、クソなもんはクソなんだよ。残念なことにね……」　と溜息をついた。</p><p>　ステージには煌々と照明があたっているけれど、客席の方は真っ暗だ。鳥居さんはその間をずんずんと進む。僕はそれについてゆく。　</p><p>​特に関係者用の席というものはないらしい。鳥居さんは奥の方の人が少ないスペースを見つけ、壁にもたれかかった。　そこは会場を一望出来る場所だった。　客たちの黒い影の折り重なる向こうに、演奏する人々の輝く姿が頭一つ分くらい浮かんでいる。</p><p>　ここはそういうところを気にする場所ではないと、僕だってそれくらいは理解出来る。でも、飼い猫を外に出すと鼠やら雀やらを捕まえてきて血みどろの死体をテーブルの下に並べるように、勝手におかしなところを捕まえては僕の前に差し出してくる。</p><p>　もしステージの上の人たちが、僕みたいな素人がそんなふうに感じていると知ったら、さぞかし不愉快だろう。　ひどい自己嫌悪だ。</p><p>　ああ、こんな仕事は請けるべきじゃなかったな。　亡くなった祖母の作る料理は全然僕の好みじゃなかった。僕は祖母のことが大好きだったけれど、料理はまずくてまずくて仕方なかった。いつも美味しい美味しいと言って食べていたけれど、でも内心ではまずくて仕方なくて、そんな風に感じる自分がひどい人間に思えて、いやで、ぽろぽろ涙をこぼして泣いてしまったことがある。　急にその時のことを思い出した。</p><p><img src="https://i.postimg.cc/qBDgCj2N/image-20241018105208725.png"></p><p><img src="https://i.postimg.cc/FH7yLYf4/image-20241018105309859.png" alt="もしステージの上の人たちが、僕みたいな素人がそんなふうに感じていると知ったら、さぞかし不愉快だろう。"></p><p>　僕は壁にもたれかかる。壁もみんなの蒸気でしめっている。　激しく揺れる人の向こうに、花井さんが歌っているのが見えた。こんなに興奮のど真ん中にいる彼は、やっぱり汗だくだったけれど、目つきはとても冷静で、表情は冷たくこわばって、死神みたいだ。　その顔を見ていると、僕はまた何も考えられなくなる。</p><p>「その時は、ピーマンを廃止しようと思ってたな。嫌いだったから。ピーマン農家とか、料理にピーマンを入れる人をみんな牢屋に入れようと思ってた」</p><p>​狭窄的Live House会场，硕大的音箱放射出震耳欲聋的声响，</p><p>​『花鳥風月がね、解散するんだそうだ』「えっ」</p><p>「ライブハウスにお金を払って夢を見させてもらってるだけなんだから、客としかいいようがないだろう？　バンドがどうやったら収益を上げられるかを考えず、工夫もせず、ただせっせと独りよがりな曲を書いてライブをやるだけ。いつか自分たちの演奏する素晴らしい曲が、真実を理解する大物プロデューサーか何かに届くと信じながら、交通整理だとかテレアポだとかのバイトで貯めたなけなしの金をライブハウスに貢いで、貢いで、貢ぎ続けて、そのうち心が折れてやめてゆくんだ。裏路地の居酒屋でホッピーか何かを飲みながら、世間は何もわかってないとか言ってな！　そして携帯電話を見ると、親から『田舎に帰ってきなさい。まだ人生のやり直</p><p>『お前は続けろよ。いや、続けて欲しいんだ。お前なら絶対『花鳥風月』を成功させられる。おれなんかはただ好きでやってるだけで、いてもいなくてもいいような存在だけど、花井是清のバンドは業界に必要なんだ』　でも、この盟友の言葉でも花井さんは意見を変えなかった。</p><p>　教室にはクーラーがついているから涼しいが、廊下に出ると昼の熱気が残っていてむっとする。　夏の夜のこの暗くて生暖かいという空気に触れるたび、僕にはなにか大気そのものが体温をもった獣のように感じられる。　夏は夜、と言ったものだが僕はあまり好きではない。</p><p>　どこに座ったらいいのかな？　わからないままぼんやり机の上に開いたままになった雑誌を見ると、それは就職情報誌だった。　あっ、こんなものを買ったのか。しかも、未経験ＯＫの求人広告ばかりを集めたページが開かれていて、倉庫内の軽作業だとか、引っ越しの手伝いといった仕事が紹介されている。</p><p>「ねえきみ、音楽の神って存在すると思うかい？」</p><p>「おれの知人にピアニストがいたんだけれど、彼女は生まれつき病気にかかっていてね、筋肉がおとろえて段々身体が動かなくなってゆくんだ。そして最後には心臓が止まって死んでしまう。おれが知り合ったうちじゃ一番才能があるとんでもないやつだったんだが、世に出る前に死んでしまった。これは、そいつが最後に演奏した曲の録音だ。葬式の時に親から手渡されたんだ。どうしてもおれに聴いて欲しいと言って、親に身体を支えてもらいながら弾いたんだそうだ」</p><p>我坚持音乐的理由是什么？蝉鸣声萦绕在我的耳畔，终端中逐渐播放的音乐，仿佛是从老旧八音盒中浸染出来的一般。称之为死的深渊在背后凝视着孱弱的生命，向前亦是无尽的深渊，无力的双手敲击着键盘，将自我蕴含的所有生命力全部注入到音符当中，形成音乐之河，观众的神思被蒸馏，徘徊于音乐编织的梦之幻境。</p><p>「映画やドラマでは、主人公が路上で演奏して通りすがりの人がみな感動したり、ひどいと泣いたりする描写があったりするけれど、実際は音だけで全ての人間を魅了するような音楽は存在しない。魂をこめた演奏なんて言っても、実際にはそんなの誰にも聴きわけることは出来ない。みんな音じゃなくてストーリーに騙されるんだ。専門の批評家たちが、そろってゴーストライターに騙されたこともある。音楽の世界だけじゃない。哲学の世界でも、偽物の数式をそれらしくちりばめた嘘の論文に騙されたことがあったそうだ。誰もよくわからないものを、よくわからないまま背景だけでありがたがるなんてのはありふれた話だ」</p><p>「別にそういう感じ方を否定するつもりはないんだよ。そういうのも含めて音楽だしね。時間に間に合わせるためにでっちあげた曲が評価されて、自分の魂を削って作った曲が酷評されたりするのもどうでもいいさ。批評家だとかはまだしも、熱烈におれの曲が好きだとかいう人がそんなことを言ってると多少はゲッソリするがね。まあ、それだっておれの知ったことじゃない。おれはただ自分の好きな曲を作っていればいいと、ずっとそう思ってやってた」</p><p>「でも、最近それに何の意味があるのかなって思い始めてたところなんだよ。聴く人間の感じ方なんか無視してやるのなら、最初から他人に見せないで、自分の頭の中で作って、頭の中で流れる曲を自分で聴いてればいいんだって。わざわざパソコン画面とにらめっこしながら音を並べるのもめんどくさいし、みんなと練習してライブをするのもだるいし、無駄が多いんだ。……鳥居が抜けるって言った時、それを思い出したね。ああ、理想の音楽環境を実行に移すときがきたんだなって。そもそもおれが音楽をはじめたのは、音を並べて曲を作るゲームを買ったのがきっかけで、それを自分で聴いてるだけで幸せだったのさ。……ほら、一緒にやろうぜ」</p><p>「それに、ゲームが下手だなあ。どれだけ下手なんだ。おれも下手だけど、きみには負けた。こんな下手な人間を見たことがない」　花井さんはしかめっつらで溜息をつく。</p><p><img src="https://i.postimg.cc/VkDhYrxP/image-20241018153728988.png" alt="それに、ゲームが下手だなあ。どれだけ下手なんだ。おれも下手だけど、きみには負けた。こんな下手な人間を見たことがない"></p><p>　花井さんの周りにはいくらでも喜んで引き受けるバンドマンがいるはずじゃないか。　彼は確かにちょっと人の好き嫌いが強いようだけど、それにしたって一人も仲の良いギタリストがいないってこともないだろう。　なのに、よりによって僕を選んだのはなぜだ？　ロックの『ロ』の字も、エレキギターの『エ』の字も知らないようなド素人なのに。</p><p><img src="https://i.postimg.cc/4NMZX0V1/image-20241018161939656.png" alt="ごっ、ごめんなさいっ！　せっ、性欲がっ、我慢出来なくなっちゃってっ！」　彼女はベッドに両手を突いて頭を下げ、土下座のポーズをする。"></p><p>　彼女が白いのは髪の毛だけでなく、眉毛も、そして豊かで長い睫毛も雪のように真っ白だった。そしてその瞳は、南国の白い砂浜に打ち寄せる波を思わせるような薄い水色だ。　この感じはブリーチやカラーコンタクトじゃない。　眼皮膚白皮症……いわゆるアルビノだ。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MUSICUS！启动&lt;/p&gt;
&lt;h3 id=&quot;共通&quot;&gt;&lt;a href=&quot;#共通&quot; class=&quot;headerlink&quot; title=&quot;共通&quot;&gt;&lt;/a&gt;共通&lt;/h3&gt;&lt;p&gt;タイトル画面から「NEW GAME」を選択&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th a</summary>
      
    
    
    
    
    <category term="galgame" scheme="http://example.com/tags/galgame/"/>
    
  </entry>
  
  <entry>
    <title>galgame补全计划</title>
    <link href="http://example.com/2024/10/15/galgame%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/"/>
    <id>http://example.com/2024/10/15/galgame%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/</id>
    <published>2024-10-14T22:54:04.000Z</published>
    <updated>2024-10-15T10:04:41.116Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从三个角度出发补全galgame名作</p></blockquote><h2 id="会社："><a href="#会社：" class="headerlink" title="会社："></a>会社：</h2><h4 id="Makura-KeroQ-PetitKeroQ-水镜：-H2O-～FOOTPRINTS-IN-THE-SAND～-√after-and-another"><a href="#Makura-KeroQ-PetitKeroQ-水镜：-H2O-～FOOTPRINTS-IN-THE-SAND～-√after-and-another" class="headerlink" title="Makura&#x2F;KeroQ&#x2F;PetitKeroQ&#x2F;水镜：**  H2O** ～FOOTPRINTS IN THE SAND～** ** √after and another"></a>Makura&#x2F;KeroQ&#x2F;PetitKeroQ&#x2F;水镜：**  H2O** <strong>～FOOTPRINTS IN THE SAND～</strong>** ** √after and another</h4><p> H2O -FOOTPRINTS IN THE SAND-</p><p>サクラノ詩 -The tear flows because of tenderness.- 春ノ雪</p><p>しゅぷれ～むキャンディ～王道には王道たる理由があるんです！</p><p>いきなりあなたに恋している</p><p>向日葵の教会と長い夏休み</p><p>サクラノ詩 —櫻の森の上を舞う—</p><p> ATRI -My Dear Moments-</p><p>サクラノ刻 -櫻の森の下を歩む-</p><p><strong>Leaf</strong>：</p><p><strong>DR2ナイト雀鬼</strong></p><p><strong>痕 ～きずあと～</strong></p><p><strong>Filsnown</strong> <strong>～光と刻～</strong></p><p><strong>雫 ～しずく～</strong></p><p><strong>初音のないしょ！！</strong></p><h4 id="To-Heart"><a href="#To-Heart" class="headerlink" title="To Heart"></a><strong>To Heart</strong></h4><h4 id="To-Heart-PSE"><a href="#To-Heart-PSE" class="headerlink" title="To Heart PSE"></a>To Heart PSE</h4><p>ToHeart2 XRATED</p><p>ToHeart2 AnotherDays</p><h3 id="WHITE-ALBUM"><a href="#WHITE-ALBUM" class="headerlink" title="WHITE ALBUM"></a>WHITE ALBUM</h3><p> WHITE ALBUM -綴られる冬の想い出-</p><p>WHITE ALBUM2 -closing chapter-</p><p>WHITE ALBUM2 -幸せの向こう側-<br> WHITE ALBUM2 EXTENDED EDITION</p><h3 id="猪名川でいこう！！"><a href="#猪名川でいこう！！" class="headerlink" title="猪名川でいこう！！"></a>猪名川でいこう！！</h3><p><strong>こみっくパーティー</strong></p><p><strong>まじかる☆アンティーク</strong></p><p><strong>誰彼～たそがれ～</strong></p><p><strong>うたわれるもの<br> Routes -ルーツ</strong>-</p><p><strong>天使のいない12月</strong></p><p><strong>アルルゥとあそぼ!!</strong></p><p><strong>Tears to Tiara</strong> <strong>～ティアーズ</strong>・<strong>トゥ</strong>・<strong>ティアラ～</strong></p><p><strong>鎖</strong> <strong>-クサリ</strong>-<br><strong>フルアニ</strong></p><p><strong>君が呼ぶ、メギドの丘で</strong></p><p><strong>愛佳でいくの!～Leaf Amusement Soft Vol.5～</strong></p><p><strong>WHITE ALBUM -綴られる冬の想い出-</strong></p><p><strong>星の王子くん</strong></p><h2 id="Key："><a href="#Key：" class="headerlink" title="Key："></a>Key：</h2><h2 id="Yuzusoft："><a href="#Yuzusoft：" class="headerlink" title="Yuzusoft："></a>Yuzusoft：</h2><h2 id="Minori："><a href="#Minori：" class="headerlink" title="Minori："></a>Minori：</h2><h2 id="Nitro："><a href="#Nitro：" class="headerlink" title="Nitro："></a>Nitro：</h2><h2 id="August："><a href="#August：" class="headerlink" title="August："></a>August：</h2><h2 id="Purple-Software："><a href="#Purple-Software：" class="headerlink" title="Purple Software："></a>Purple Software：</h2><h2 id="Palette："><a href="#Palette：" class="headerlink" title="Palette："></a>Palette：</h2><h2 id="脚本家"><a href="#脚本家" class="headerlink" title="脚本家"></a>脚本家</h2><h3 id="久弥直树："><a href="#久弥直树：" class="headerlink" title="久弥直树："></a>久弥直树：</h3><h3 id="竜騎士07"><a href="#竜騎士07" class="headerlink" title="竜騎士07"></a><a href="https://bangumi.tv/person/2962">竜騎士07</a></h3><p><strong>祝姫</strong></p><p><strong>Silent Hill f</strong></p><p><strong>ひぐらしのなく頃に</strong><br> <strong>Rewrite</strong></p><p><strong>トライアンソロジー ～三面鏡の国のアリス～</strong></p><h3 id="田中罗密欧："><a href="#田中罗密欧：" class="headerlink" title="田中罗密欧："></a>田中罗密欧：</h3><p><strong>加奈 〜いもうと〜</strong><br> <strong>星空☆ぷらねっと</strong></p><p><strong>ドーターメーカー</strong><br> <strong>黒の図書館</strong></p><p><strong>夏夢夜話</strong></p><p><strong>PIZZICATO POLKA－彗星幻夜－</strong></p><p><strong>神樹の館</strong></p><p><strong>ユメミルクスリ</strong><br> I&#x2F;O**</p><p><strong>雪影</strong> **-setsuei-<br>** <strong>おたく☆っしぐら</strong></p><p><strong>Chanter -キミの歌がとどいたら-</strong></p><p><strong>彗星（ほし）に願いを…</strong></p><p><strong>セカンドノベル ～彼女の夏、15分の記憶～</strong><br><strong>ピアノ～紅楼館の隷嬢達～</strong></p><p><strong>終のステラ</strong></p><p><strong>和香様の座する世界</strong></p><p><strong>水平線まで何マイル？-ORIGINAL FLIGHT-</strong>**<br><strong>CROSS†CHANNEL</strong></p><p><strong>最果てのイマ</strong></p><p><strong>家族計画～再開～</strong></p><p><strong>Rewrite</strong></p><h3 id="麻枝准："><a href="#麻枝准：" class="headerlink" title="麻枝准："></a>麻枝准：</h3><p><strong>Rewrite</strong></p><p><strong>Little Busters! EX</strong></p><p><strong>Summer Pockets</strong></p><p><strong>Kanon</strong></p><h3 id="ルースぽーい："><a href="#ルースぽーい：" class="headerlink" title="ルースぽーい："></a>ルースぽーい：</h3><p><strong>車輪の国、悠久の少年少女</strong></p><p><strong>車輪の国、向日葵の少女</strong></p><p><strong>G線上の魔王</strong></p><p><strong>夏の燈火</strong><br> <strong>A Profile ア・プロフィール</strong></p><h3 id="丸户史明："><a href="#丸户史明：" class="headerlink" title="丸户史明："></a>丸户史明：</h3><p><strong>パルフェ ～chocolat second brew～</strong></p><p><strong>この青空に約束を―</strong></p><p><strong>フォセット - Cafe au Le Ciel Bleu -</strong></p><p><strong>世界でいちばんNG（だめ）な恋</strong></p><p><strong>WHITE ALBUM2 -introductory chapter-</strong></p><p><strong>WHITE ALBUM2 -closing chapter-</strong></p><h3 id="星空めてお："><a href="#星空めてお：" class="headerlink" title="星空めてお："></a>星空めてお：</h3><p><strong>腐り姫 ～<strong><strong>euthanasia</strong></strong>～</strong></p><p><strong>CANNONBALL****～ねこねこマシン猛レース</strong></p><p><a href="https://bangumi.tv/subject/5395"><strong>Forest</strong></a></p><p><strong>腐り姫 帰省～<strong><strong>jamais vu</strong></strong>～</strong></p><h3 id="瀬戸口廉也："><a href="#瀬戸口廉也：" class="headerlink" title="瀬戸口廉也："></a>瀬戸口廉也：</h3><p><strong>ロックンロール兄弟</strong></p><p><strong>CARNIVAL</strong></p><p><strong>SWAN SONG</strong></p><p><strong>キラ☆キラ</strong></p><p><strong>暗い部屋</strong></p><p><strong>セカンドノベル ～彼女の夏、<strong><strong>15</strong></strong>分の記憶～</strong></p><p><strong>MUSICUS!<br> BLACK SHEEP TOWN</strong></p><p><strong>ヒラヒラヒヒル</strong></p><h4 id="小说："><a href="#小说：" class="headerlink" title="小说："></a>小说：</h4><p>CARNIVAL<a href="https://bangumi.tv/subject/6931">**<br>** PSYCHE</a><a href="https://bangumi.tv/subject/162097">**<br>** 犬附少女</a></p><p>ドッペルゲンガーの恋人</p><p>死体泥棒</p><p>電気サーカス</p><p>つめたいオゾン</p><h3 id="SCA-自："><a href="#SCA-自：" class="headerlink" title="SCA-自："></a>SCA-自：</h3><p><strong>終ノ空</strong></p><p>二重影</p><p><strong>二重箱</strong></p><p><strong>モエかん</strong></p><p><strong>モエてん</strong></p><p><strong>モエカす</strong></p><p><strong>灯穂奇譚</strong>**<br> H2O** <strong>～<strong><strong>FOOTPRINTS IN THE SAND</strong></strong>～**</strong><br>** <strong>√after and another</strong></p><p><strong>サクラノ詩 -The tear flows because of tenderness.- 春ノ雪</strong></p><p><strong>しゅぷれ～むキャンディ～王道には王道たる理由があるんです！</strong></p><p><strong>素晴らしき日々～不連続存在～</strong></p><p><strong>いきなりあなたに恋している</strong></p><p><strong>向日葵の教会と長い夏休み</strong></p><p><strong>サクラノ詩</strong> <strong>—<strong><strong>櫻の森の上を舞う</strong></strong>—</strong></p><p><strong>終ノ空</strong> <strong>remake</strong></p><p><strong>サクラノ刻</strong> <strong>-<strong><strong>櫻の森の下を歩む</strong></strong>-</strong></p><h2 id="原画"><a href="#原画" class="headerlink" title="原画"></a>原画</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从三个角度出发补全galgame名作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;会社：&quot;&gt;&lt;a href=&quot;#会社：&quot; class=&quot;headerlink&quot; title=&quot;会社：&quot;&gt;&lt;/a&gt;会社：&lt;/h2&gt;&lt;h4 id=&quot;Makura-K</summary>
      
    
    
    
    
    <category term="galgame" scheme="http://example.com/tags/galgame/"/>
    
  </entry>
  
  <entry>
    <title>words</title>
    <link href="http://example.com/2024/10/08/words/"/>
    <id>http://example.com/2024/10/08/words/</id>
    <published>2024-10-08T15:45:19.000Z</published>
    <updated>2024-10-09T03:39:51.472Z</updated>
    
    <content type="html"><![CDATA[<p>Epidemiology stockbroker invalidism penetrate aristocracy  </p><blockquote><p>In old days books are written by  men of letters and read by the public. Nowadays books are written by the public and read by nobody.</p></blockquote><p>asthma </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Epidemiology stockbroker invalidism penetrate aristocracy  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In old days books are written by  men of letters and read</summary>
      
    
    
    
    
    <category term="English" scheme="http://example.com/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>算法：二叉树</title>
    <link href="http://example.com/2024/09/11/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2024/09/11/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2024-09-11T08:51:14.000Z</published>
    <updated>2024-09-11T11:22:59.984Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树总结笔记"><a href="#二叉树总结笔记" class="headerlink" title="二叉树总结笔记"></a>二叉树总结笔记</h3><hr><h4 id="二叉树的类别"><a href="#二叉树的类别" class="headerlink" title="二叉树的类别"></a><strong>二叉树的类别</strong></h4><ol><li><p><strong>满二叉树</strong>  </p><ul><li>一个深度为 <code>k</code>，且包含 <code>2^k - 1</code> 个节点的二叉树。</li><li>每一层的节点数都是最大值。</li></ul></li><li><p><strong>完全二叉树</strong>  </p><ul><li>除最后一层外，所有层的节点都充满，且最后一层的节点从左到右排列。</li></ul></li><li><p><strong>二叉搜索树（BST, Binary Search Tree）</strong>  </p><ul><li>对于每个节点，左子树上的所有节点值都小于该节点值，右子树上的所有节点值都大于该节点值。</li><li>具有高效的查找、插入和删除操作，时间复杂度为 <code>O(log n)</code>（在平衡情况下）。</li></ul></li><li><p><strong>平衡二叉树</strong>  </p><ul><li>保证任何节点的左、右子树的高度差不超过 1。</li><li>常见类型有 AVL 树和红黑树。</li></ul></li><li><p><strong>完全二叉树</strong>  </p><ul><li>所有叶子节点都集中在最后两层，且最后一层的节点集中在最左侧。</li></ul></li></ol><hr><h4 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a><strong>二叉树的概念</strong></h4><ul><li><p><strong>根节点 (Root)</strong><br>树的最顶层节点，没有父节点。</p></li><li><p><strong>节点 (Node)</strong><br>每个节点包含三个部分：值、左子节点、右子节点。</p></li><li><p><strong>子树 (Subtree)</strong><br>任何节点和其所有后代构成的树。</p></li><li><p><strong>父节点 (Parent)</strong><br>具有子节点的节点。</p></li><li><p><strong>叶子节点 (Leaf)</strong><br>没有子节点的节点。</p></li><li><p><strong>深度 (Depth)</strong><br>节点到根节点的距离。</p></li><li><p><strong>高度 (Height)</strong><br>节点到叶子节点的最长路径。</p></li></ul><hr><h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a><strong>二叉树的遍历方式</strong></h4><ol><li><p><strong>前序遍历 (Pre-order Traversal)</strong></p><ul><li>顺序：根节点 -&gt; 左子树 -&gt; 右子树</li><li>过程：访问当前节点，递归前序遍历左子树，再递归前序遍历右子树。</li><li>应用：可以用来复制树结构。</li></ul></li><li><p><strong>中序遍历 (In-order Traversal)</strong></p><ul><li>顺序：左子树 -&gt; 根节点 -&gt; 右子树</li><li>过程：递归中序遍历左子树，访问当前节点，再递归中序遍历右子树。</li><li>应用：可以用于输出有序的节点值（如果是二叉搜索树）。</li></ul></li><li><p><strong>后序遍历 (Post-order Traversal)</strong></p><ul><li>顺序：左子树 -&gt; 右子树 -&gt; 根节点</li><li>过程：递归后序遍历左子树，递归后序遍历右子树，最后访问当前节点。</li><li>应用：适合用于删除树或释放资源。</li></ul></li><li><p><strong>层次遍历 (Level-order Traversal)</strong></p><ul><li>顺序：从上到下、从左到右逐层访问。</li><li>应用：适合用于按层操作节点。</li></ul></li></ol><hr><h4 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a><strong>平衡树</strong></h4><ul><li><p><strong>平衡二叉树 (Balanced Binary Tree)</strong></p><ul><li>定义：保证任何节点的左右子树高度差不超过1，以避免极端情况如链表状树（退化为线性结构）。</li><li>优点：查找、插入和删除操作能始终保持 <code>O(log n)</code> 的时间复杂度。</li></ul></li><li><p><strong>常见平衡树类型：</strong></p><ol><li><p><strong>AVL树</strong></p><ul><li>定义：一种严格平衡的二叉搜索树，确保每个节点的左右子树高度差至多为1。</li><li>调整：通过旋转操作（左旋、右旋、左右旋、右左旋）来保持平衡。</li><li>应用：适用于读操作远多于写操作的场景。</li></ul></li><li><p><strong>红黑树 (Red-Black Tree)</strong></p><ul><li>定义：一种自平衡二叉搜索树，确保树在最坏情况下也是接近平衡的。</li><li>性质：<ul><li>每个节点要么是红色，要么是黑色。</li><li>根节点是黑色，所有叶节点（空节点）都是黑色。</li><li>如果一个节点是红色，它的子节点必须是黑色（不能有连续的红色节点）。</li><li>从根到叶子节点的每条路径上必须包含相同数量的黑色节点。</li></ul></li><li>应用：广泛用于许多系统中的平衡二叉树，如 Java 中的 <code>TreeMap</code> 和 C++ 中的 <code>map</code>。</li></ul></li></ol></li></ul><h3 id="深度优先搜索（DFS-Depth-First-Search）"><a href="#深度优先搜索（DFS-Depth-First-Search）" class="headerlink" title="深度优先搜索（DFS, Depth-First Search）"></a>深度优先搜索（DFS, Depth-First Search）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>深度优先搜索是一种遍历或搜索图和树的算法，它尽可能深入每一个分支，直到无法继续为止，再回溯到最近的未探索节点继续搜索。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li><strong>递归性</strong>：DFS通常使用递归的方式实现，沿着某个路径深入到最深处，再逐步回溯。</li><li><strong>栈结构</strong>：如果使用迭代方式实现，DFS依赖栈结构来记录节点的路径。</li><li><strong>遍历顺序</strong>：优先探索每个节点的所有子节点，只有在无法深入时才回溯。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li>适合用于<strong>找路径</strong>或<strong>找到树或图的连通性</strong>。</li><li>解决问题如<strong>迷宫问题</strong>，<strong>拓扑排序</strong>，<strong>岛屿数量</strong>等。</li></ul><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a><strong>实现方法</strong></h4><ol><li><p>递归实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 处理当前节点</span></span><br><span class="line">    <span class="built_in">visit</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> child : node-&gt;children) &#123;</span><br><span class="line">        <span class="built_in">DFS</span>(child);  <span class="comment">// 递归处理子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代实现（使用栈）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;Node*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* current = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">visit</span>(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child : current-&gt;children) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(child);  <span class="comment">// 将子节点压入栈中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li>对于树和图的分支，能够深入到最深处。</li><li>在有解的情况下，如果目标节点比较深，DFS通常能较早找到解。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li>可能会陷入<strong>无限深度</strong>的递归，尤其是当存在环的图中，DFS可能需要额外的机制避免重复访问。</li><li>不适合用于寻找最短路径。</li></ul><hr><h3 id="广度优先搜索（BFS-Breadth-First-Search）"><a href="#广度优先搜索（BFS-Breadth-First-Search）" class="headerlink" title="广度优先搜索（BFS, Breadth-First Search）"></a>广度优先搜索（BFS, Breadth-First Search）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>广度优先搜索是一种遍历图和树的算法，逐层展开，先访问与起点距离最近的节点，然后逐层向外扩展。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li><strong>队列结构</strong>：BFS依赖队列（FIFO）来保证节点按层次顺序被访问。</li><li><strong>层次遍历</strong>：先访问当前节点的所有邻居节点，再继续访问这些邻居节点的子节点。</li><li><strong>找到最短路径</strong>：在无权图中，BFS保证找到起点到任意节点的最短路径。</li></ul><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li>适合用于寻找<strong>最短路径</strong>。</li><li>解决问题如<strong>最短路径问题</strong>，<strong>图的遍历</strong>，<strong>广度优先迷宫</strong>，<strong>连通性检测</strong>等。</li></ul><h4 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a><strong>实现方法</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* current = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">visit</span>(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child : current-&gt;children) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(child);  <span class="comment">// 将子节点加入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li>在无权图中，能够找到起点到目标节点的<strong>最短路径</strong>。</li><li>对于树的广度遍历非常直观，能够完整遍历所有节点。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li>由于广度优先扩展，BFS的空间复杂度可能会较高，尤其是当图的广度非常大时。</li></ul><hr><h3 id="对比-DFS-和-BFS"><a href="#对比-DFS-和-BFS" class="headerlink" title="对比 DFS 和 BFS"></a><strong>对比 DFS 和 BFS</strong></h3><ul><li><p><strong>DFS 深度优先搜索</strong>：  </p><ul><li>优先探索尽可能深的路径，适合用于找路径、连通性检测。</li><li>空间复杂度通常较低，但在深度很大时可能引发栈溢出（递归方式）。</li></ul></li><li><p><strong>BFS 广度优先搜索</strong>：  </p><ul><li>按层次遍历，保证找到最短路径，适合用于无权图的最短路径问题。</li><li>空间复杂度较高，尤其是图的广度较大时。</li></ul></li></ul><p>在实际使用中，根据问题的具体需求选择合适的算法。例如，在寻找迷宫最短路径问题中，BFS较为适合；在连通性检测或路径问题中，DFS可能更为高效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;二叉树总结笔记&quot;&gt;&lt;a href=&quot;#二叉树总结笔记&quot; class=&quot;headerlink&quot; title=&quot;二叉树总结笔记&quot;&gt;&lt;/a&gt;二叉树总结笔记&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;二叉树的类别&quot;&gt;&lt;a href=&quot;#二叉树的类别&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>概率论第二课</title>
    <link href="http://example.com/2024/09/05/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E4%BA%8C%E8%AF%BE/"/>
    <id>http://example.com/2024/09/05/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E4%BA%8C%E8%AF%BE/</id>
    <published>2024-09-05T08:56:52.000Z</published>
    <updated>2024-09-05T16:00:51.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概率的公理化定义"><a href="#概率的公理化定义" class="headerlink" title="概率的公理化定义"></a>概率的公理化定义</h3><p>概率的公理化定义由俄罗斯数学家 <strong>安德烈·柯尔莫哥洛夫</strong>（Andrey Kolmogorov）在1933年提出，称为<strong>柯尔莫哥洛夫公理</strong>。该定义将概率理论建立在严密的数学公理基础之上，主要有三个公理：</p><h4 id="1-非负性公理"><a href="#1-非负性公理" class="headerlink" title="1. 非负性公理"></a>1. <strong>非负性公理</strong></h4><p>对于任何一个事件 ( A )，其概率 $( P(A) )$ 都是一个非负数：<br>$$<br>P(A) \geq 0<br>$$<br>这意味着任何事件发生的概率不能为负数。</p><h4 id="2-规范性公理"><a href="#2-规范性公理" class="headerlink" title="2. 规范性公理"></a>2. <strong>规范性公理</strong></h4><p>全集（或样本空间）( S ) 的概率为 1：<br>$$<br>P(S) &#x3D; 1<br>$$<br>这表示在样本空间内，某些事件肯定会发生，因此概率为 1。</p><h4 id="3-可加性公理"><a href="#3-可加性公理" class="headerlink" title="3. 可加性公理"></a>3. <strong>可加性公理</strong></h4><p>对于任何两个互不相容的事件 ( A ) 和 ( B ) （即$( A \cap B &#x3D; \emptyset )$），它们的联合概率等于各自概率之和：<br>$$<br>P(A \cup B) &#x3D; P(A) + P(B)<br>$$<br>如果事件 ( A ) 和 ( B ) 互不重叠，它们共同发生的概率是各自发生的概率之和。</p><h3 id="拓展定义"><a href="#拓展定义" class="headerlink" title="拓展定义"></a>拓展定义</h3><p>根据这三个公理，可以推导出概率的其他性质和规则。例如：</p><ul><li><p><strong>有限可加性</strong>：对于有限个两两互不相容的事件 $( A_1, A_2, …, A_n )$，有<br>$$<br>P(A_1 \cup A_2 \cup … \cup A_n) &#x3D; P(A_1) + P(A_2) + … + P(A_n)<br>$$</p></li><li><p><strong>单调性</strong>：如果事件 $( A \subseteq B )$，则 $( P(A) \leq P(B) )$。</p></li><li><p><strong>补事件的概率</strong>：对于任何事件 ( A )，补集事件 ( A^c ) 的概率为<br>$$<br>P(A^c) &#x3D; 1 - P(A)<br>$$</p></li></ul><h3 id="公理化定义的意义"><a href="#公理化定义的意义" class="headerlink" title="公理化定义的意义"></a>公理化定义的意义</h3><p>柯尔莫哥洛夫的公理化定义提供了一个严密、统一的数学框架，确保概率论具有自洽性和逻辑一致性。通过这套公理，概率的计算和应用变得更加系统化，广泛应用于统计学、物理学、经济学等领域。</p><h3 id="概率的公理化定义（详细版）"><a href="#概率的公理化定义（详细版）" class="headerlink" title="概率的公理化定义（详细版）"></a>概率的公理化定义（详细版）</h3><p>概率论的公理化定义由<strong>柯尔莫哥洛夫</strong>提出，它基于三个基本公理构建而成，用数学的方式定义了事件及其发生的概率。下面是概率的详细公理化定义：</p><h3 id="事件与样本空间"><a href="#事件与样本空间" class="headerlink" title="事件与样本空间"></a>事件与样本空间</h3><p>设 ( S ) 为样本空间，即所有可能结果的集合。事件 ( A ) 是样本空间的一个子集，表示某个特定的结果或一组结果。</p><h3 id="概率的三个公理"><a href="#概率的三个公理" class="headerlink" title="概率的三个公理"></a>概率的三个公理</h3><ol><li><p><strong>非负性公理（Non-negativity Axiom）</strong><br>对于任何事件 ( A \subseteq S )，其概率 ( P(A) ) 为非负数：<br>$$<br>P(A) \geq 0<br>$$<br><strong>解释</strong>：任意事件发生的概率是一个非负数，不能为负。</p></li><li><p><strong>规范性公理（Normalization Axiom）</strong><br>样本空间 ( S ) 中包含的所有可能结果的总概率为 1：<br>$$<br>P(S) &#x3D; 1<br>$$<br><strong>解释</strong>：在样本空间中，必然会发生某个事件，因此所有可能结果的总概率为 1。</p></li><li><p><strong>可加性公理（Additivity Axiom）</strong><br>如果事件 ( A ) 和 ( B ) 互斥（即 ( A \cap B &#x3D; \emptyset )，它们不能同时发生），则事件 ( A \cup B ) 的概率等于两个事件的概率之和：<br>$$<br>P(A \cup B) &#x3D; P(A) + P(B) \quad \text{当} \quad A \cap B &#x3D; \emptyset<br>$$<br><strong>解释</strong>：对于两个互不相容的事件，合并发生的概率等于它们各自发生概率的总和。</p></li></ol><h3 id="推论和拓展"><a href="#推论和拓展" class="headerlink" title="推论和拓展"></a>推论和拓展</h3><p>从柯尔莫哥洛夫公理，可以推导出一系列其他重要性质：</p><h4 id="1-有限可加性"><a href="#1-有限可加性" class="headerlink" title="1. 有限可加性"></a>1. <strong>有限可加性</strong></h4><p>   对于有限多个两两互不相容的事件 ( A_1, A_2, \dots, A_n )，则它们并集的概率为：<br>$$<br>   P\left(\bigcup_{i&#x3D;1}^{n} A_i\right) &#x3D; \sum_{i&#x3D;1}^{n} P(A_i) \quad \text{当} \quad A_i \cap A_j &#x3D; \emptyset \quad \text{对于} \quad i \neq j<br>$$</p><h4 id="2-单调性"><a href="#2-单调性" class="headerlink" title="2. 单调性"></a>2. <strong>单调性</strong></h4><p>   如果 ( A \subseteq B )（即事件 ( A ) 是事件 ( B ) 的子集，发生 ( A ) 意味着 ( B ) 也发生），那么：<br>$$<br>   P(A) \leq P(B)<br>$$</p><h4 id="3-补事件的概率"><a href="#3-补事件的概率" class="headerlink" title="3. 补事件的概率"></a>3. <strong>补事件的概率</strong></h4><p>   对于任何事件 ( A )，其补集（事件 ( A ) 不发生的事件） ( A^c ) 的概率为：<br>$$<br>   P(A^c) &#x3D; 1 - P(A)<br>$$<br>   其中，( A^c ) 表示事件 ( A ) 不发生的情况。</p><h4 id="4-全概率公式"><a href="#4-全概率公式" class="headerlink" title="4. 全概率公式"></a>4. <strong>全概率公式</strong></h4><p>   如果事件 ( A_1, A_2, …, A_n ) 形成样本空间 ( S ) 的一个划分，即 ( S &#x3D; A_1 \cup A_2 \cup … \cup A_n ) 且 ( A_i \cap A_j &#x3D; \emptyset )，则对于任何事件 ( B )，有：<br>$$<br>   P(B) &#x3D; \sum_{i&#x3D;1}^{n} P(B \cap A_i) &#x3D; \sum_{i&#x3D;1}^{n} P(B | A_i) P(A_i)<br>$$<br>   <strong>解释</strong>：全概率公式用于计算事件 ( B ) 的概率，其中事件 ( B ) 可能通过不同的途径（事件 ( A_i ) ）发生。</p><h4 id="5-条件概率"><a href="#5-条件概率" class="headerlink" title="5. 条件概率"></a>5. <strong>条件概率</strong></h4><p>   给定事件 ( A ) 和事件 ( B )，如果 ( P(B) &gt; 0 )，则事件 ( A ) 在事件 ( B ) 已经发生的条件下的概率为：<br>$$<br>   P(A | B) &#x3D; \frac{P(A \cap B)}{P(B)} \quad \text{当} \quad P(B) &gt; 0<br>$$<br>   <strong>解释</strong>：条件概率描述了事件 ( B ) 发生时，事件 ( A ) 的发生概率。</p><h4 id="6-乘法法则"><a href="#6-乘法法则" class="headerlink" title="6. 乘法法则"></a>6. <strong>乘法法则</strong></h4><p>   由条件概率公式可得，事件 ( A ) 和 ( B ) 同时发生的概率为：<br>$$<br>   P(A \cap B) &#x3D; P(A | B) P(B)<br>$$</p><h4 id="7-贝叶斯定理"><a href="#7-贝叶斯定理" class="headerlink" title="7. 贝叶斯定理"></a>7. <strong>贝叶斯定理</strong></h4><p>   如果事件 ( A_1, A_2, …, A_n ) 形成样本空间 ( S ) 的划分，则对于任意事件 ( B ) 和 ( A_i )，有：<br>$$<br>   P(A_i | B) &#x3D; \frac{P(B | A_i) P(A_i)}{\sum_{j&#x3D;1}^{n} P(B | A_j) P(A_j)}<br>$$<br>   <strong>解释</strong>：贝叶斯定理用于通过已知条件重新计算事件的概率，广泛应用于统计推断和机器学习中。</p><p>下面是几个经典的概率论证明例题，涵盖了基本概率计算、条件概率、全概率公式、贝叶斯定理等内容。</p><h3 id="例题-1：掷骰子的联合概率问题"><a href="#例题-1：掷骰子的联合概率问题" class="headerlink" title="例题 1：掷骰子的联合概率问题"></a>例题 1：掷骰子的联合概率问题</h3><p><strong>问题</strong>：两枚骰子同时掷出，求两枚骰子的点数之和为7的概率。</p><p><strong>解法</strong>：</p><p>样本空间 ( S ) 包含所有可能的结果，即两枚骰子可能的组合。因为每个骰子有6种可能的结果，所以样本空间的大小为：<br>$$<br>|S| &#x3D; 6 \times 6 &#x3D; 36<br>$$</p><p>满足两枚骰子点数之和为7的事件 ( A ) 包含以下组合：<br>$$<br>A &#x3D; {(1,6), (2,5), (3,4), (4,3), (5,2), (6,1)}<br>$$</p><p>共有6种可能的组合，因此事件 ( A ) 的概率为：<br>$$<br>P(A) &#x3D; \frac{|A|}{|S|} &#x3D; \frac{6}{36} &#x3D; \frac{1}{6}<br>$$</p><h3 id="例题-2：条件概率问题"><a href="#例题-2：条件概率问题" class="headerlink" title="例题 2：条件概率问题"></a>例题 2：条件概率问题</h3><p><strong>问题</strong>：盒子中有3个红球和2个蓝球，从中随机取出2个球。已知第一个取出的球是红球，求第二个球是红球的概率。</p><p><strong>解法</strong>：</p><p>这是一个条件概率问题，要求的是在第一个球为红球的条件下，第二个球是红球的概率。记事件 ( A ) 为 “第一个球是红球”，事件 ( B ) 为 “第二个球是红球”。</p><p>已知 ( P(A) &#x3D; \frac{3}{5} )，因为盒子中最初有3个红球和2个蓝球。</p><p>在取出第一个红球之后，剩下的球中有2个红球和2个蓝球，因此第二个球是红球的条件概率为：<br>$$<br>P(B | A) &#x3D; \frac{2}{4} &#x3D; \frac{1}{2}<br>$$</p><h3 id="例题-3：全概率公式"><a href="#例题-3：全概率公式" class="headerlink" title="例题 3：全概率公式"></a>例题 3：全概率公式</h3><p><strong>问题</strong>：某射手进行射击比赛，每次射击命中的概率为0.8。如果射手射击三次，求至少命中一次的概率。</p><p><strong>解法</strong>：</p><p>先计算射手<strong>每次都未命中</strong>的概率。因为每次命中的概率为0.8，所以每次未命中的概率为：<br>$$<br>P(\text{未命中}) &#x3D; 1 - 0.8 &#x3D; 0.2<br>$$</p><p>射手在三次射击中都未命中的概率为：<br>$$<br>P(\text{三次未命中}) &#x3D; 0.2 \times 0.2 \times 0.2 &#x3D; 0.008<br>$$</p><p>因此，至少命中一次的概率为：<br>$$<br>P(\text{至少命中一次}) &#x3D; 1 - P(\text{三次未命中}) &#x3D; 1 - 0.008 &#x3D; 0.992<br>$$</p><h3 id="例题-4：贝叶斯定理"><a href="#例题-4：贝叶斯定理" class="headerlink" title="例题 4：贝叶斯定理"></a>例题 4：贝叶斯定理</h3><p><strong>问题</strong>：某种疾病的检验准确率为90%，即有90%的几率检验结果正确（包括阳性和阴性）。某地疾病的患病率为1%，假设一个人检测结果呈阳性，求该人实际患病的概率（即患病条件下阳性检测的概率）。</p><p><strong>解法</strong>：</p><p>记事件：</p><ul><li>( A )：患病</li><li>( B )：检测结果呈阳性</li></ul><p>已知：</p><ul><li>( P(A) &#x3D; 0.01 )（患病率）</li><li>( P($A^c$) &#x3D; 0.99 )（不患病率）</li><li>( P(B | A) &#x3D; 0.9 )（患病时检测阳性的概率）</li><li>( P(B | $A^c$) &#x3D; 0.1 )（不患病时检测阳性的概率）</li></ul><p>根据贝叶斯定理，有：<br>$$<br>P(A | B) &#x3D; \frac{P(B | A) P(A)}{P(B)}<br>$$</p><p>首先，利用全概率公式计算 ( P(B) )：<br>$$<br>P(B) &#x3D; P(B | A) P(A) + P(B | A^c) P(A^c)<br>$$<br>$$<br>P(B) &#x3D; 0.9 \times 0.01 + 0.1 \times 0.99 &#x3D; 0.009 + 0.099 &#x3D; 0.108<br>$$</p><p>然后，代入贝叶斯公式计算 ( P(A | B) )：<br>$$<br>P(A | B) &#x3D; \frac{0.9 \times 0.01}{0.108} &#x3D; \frac{0.009}{0.108} \approx 0.0833<br>$$</p><p>因此，检测阳性时，实际患病的概率为约8.33%。</p><h3 id="例题-5：独立事件的联合概率"><a href="#例题-5：独立事件的联合概率" class="headerlink" title="例题 5：独立事件的联合概率"></a>例题 5：独立事件的联合概率</h3><p><strong>问题</strong>：两个人分别投篮，每次投篮命中的概率分别为0.7和0.6，求两人都命中的概率。</p><p><strong>解法</strong>：</p><p>这是一个独立事件的联合概率问题，记事件 ( A ) 为 “第一个人命中”，事件 ( B ) 为 “第二个人命中”。因为两人投篮是独立的，联合概率为：<br>$$<br>P(A \cap B) &#x3D; P(A) \times P(B) &#x3D; 0.7 \times 0.6 &#x3D; 0.42<br>$$</p><p>因此，两人都命中的概率为0.42。</p><hr><p>这些例题展示了概率论中的一些经典证明方法和公式的应用，涵盖了独立事件、条件概率、全概率公式、贝叶斯定理等重要概念。</p><h3 id="古典概型（Classical-Probability-Model）笔记"><a href="#古典概型（Classical-Probability-Model）笔记" class="headerlink" title="古典概型（Classical Probability Model）笔记"></a><strong>古典概型（Classical Probability Model）笔记</strong></h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>古典概型是概率论中的一种基本概率模型，适用于有限且等可能的结果集。其基本特点是所有实验的基本事件发生的可能性相同。古典概型适用于计算离散型随机事件的概率。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ol><li><strong>有限性</strong>：样本空间中的基本事件个数是有限的。</li><li><strong>等可能性</strong>：每个基本事件发生的概率相同。</li><li><strong>概率的计算方式简单</strong>：只需考虑事件的有利结果数与总结果数的比例。</li></ol><h4 id="古典概型的概率公式"><a href="#古典概型的概率公式" class="headerlink" title="古典概型的概率公式"></a><strong>古典概型的概率公式</strong></h4><p>设样本空间 ( S ) 包含 ( n ) 个等可能的结果，某事件 ( A ) 包含 ( m ) 个与 ( A ) 有关的有利结果，则事件 ( A ) 发生的概率 ( P(A) ) 由以下公式计算：</p><p>$$<br>P(A) &#x3D; \frac{m}{n}<br>$$</p><ul><li>( P(A) )：事件 ( A ) 发生的概率</li><li>( m )：事件 ( A ) 对应的有利结果数</li><li>( n )：样本空间中所有可能结果的总数</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><ol><li><p><strong>掷骰子</strong>  </p><ul><li>样本空间 ( S &#x3D; {1, 2, 3, 4, 5, 6} )</li><li>求掷出偶数的概率 ( P(A) )，其中 ( A ) 是偶数事件 ( A &#x3D; {2, 4, 6} )</li><li>结果数 ( n &#x3D; 6 )，有利结果数 ( m &#x3D; 3 )</li><li>计算概率：<br>$$<br>P(A) &#x3D; \frac{m}{n} &#x3D; \frac{3}{6} &#x3D; 0.5<br>$$</li></ul></li><li><p><strong>从一副扑克牌中抽一张牌</strong>  </p><ul><li>样本空间 ( S ) 包含52张牌</li><li>求抽到红心的概率，红心牌数为13</li><li>结果数 ( n &#x3D; 52 )，有利结果数 ( m &#x3D; 13 )</li><li>计算概率：<br>$$<br>P(A) &#x3D; \frac{13}{52} &#x3D; 0.25<br>$$</li></ul></li></ol><h4 id="古典概型的条件"><a href="#古典概型的条件" class="headerlink" title="古典概型的条件"></a><strong>古典概型的条件</strong></h4><p>古典概型成立时需要满足以下条件：</p><ol><li><strong>实验结果有限</strong>：实验的所有可能结果数量必须是有限的。</li><li><strong>等可能性</strong>：所有基本事件发生的概率必须是相同的。</li></ol><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ol><li><strong>抛硬币</strong>：每次抛硬币时，正反两面是等可能出现的。</li><li><strong>掷骰子</strong>：每个面出现的概率相等，符合古典概型。</li><li><strong>抽扑克牌</strong>：从一副标准扑克牌中随机抽牌，所有牌的抽取概率相等。</li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ul><li>古典概型适用于<strong>等可能事件</strong>，如果事件的发生概率不等，则不能使用古典概型计算。</li><li>古典概型只适用于有限个结果，若有无限多可能结果，需要使用其他概率模型。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>古典概型通过等可能结果的简单计算方法来确定事件的概率，适用于有限的样本空间，在一些典型的随机实验（如掷骰子、抛硬币等）中有广泛应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概率的公理化定义&quot;&gt;&lt;a href=&quot;#概率的公理化定义&quot; class=&quot;headerlink&quot; title=&quot;概率的公理化定义&quot;&gt;&lt;/a&gt;概率的公理化定义&lt;/h3&gt;&lt;p&gt;概率的公理化定义由俄罗斯数学家 &lt;strong&gt;安德烈·柯尔莫哥洛夫&lt;/strong&gt;（An</summary>
      
    
    
    
    
    <category term="概率论" scheme="http://example.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构：树和二叉树</title>
    <link href="http://example.com/2024/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2024/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2024-09-04T14:42:58.000Z</published>
    <updated>2024-09-05T08:49:10.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>树（Tree）是一种重要的非线性数据结构，由一组节点（Node）和边（Edge）组成，用于表示具有层次关系的数据。树具有以下几个特点：</p><ul><li><strong>层次性</strong>：树是一种分层结构，每个节点与其他节点之间有明确的父子关系。</li><li><strong>有根性</strong>：树中有且只有一个根节点（Root Node），它是树的起点，没有父节点。</li><li><strong>递归性</strong>：树结构具有递归的性质，每棵树由一个根节点和若干子树组成，每棵子树本身也是一棵树。</li><li><img src="https://i.postimg.cc/tRKdzdtV/36a04d2fc8f6a5d03173a01a27b4d451.png"></li></ul><h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><p><strong>节点（Node）</strong><br>节点是树中的基本元素，每个节点包含一个数据值，并且可能有零个或多个子节点。节点是树的基本构成单元。</p><p><strong>根节点（Root Node）</strong><br>根节点是树的起始节点，是层次结构中的最高层。根节点没有父节点，它是树的唯一入口点。</p><p><strong>子节点（Child Node）</strong><br>子节点是某个节点的直接后继节点。一个节点可以有多个子节点，表示树中的层次关系。</p><p><strong>父节点（Parent Node）</strong><br>父节点是某个节点的直接前驱节点。子节点与父节点之间由一条边连接。</p><p><strong>叶子节点（Leaf Node）</strong><br>叶子节点是没有子节点的节点，位于树的最底层，也称为终端节点。</p><p><strong>兄弟节点（Sibling Node）</strong><br>兄弟节点是同一个父节点的子节点，它们在树的层次结构中位于同一层。</p><p><strong>路径（Path）</strong><br>路径是从一个节点到另一个节点的边的序列。路径长度是路径上边的数量。</p><p><strong>深度（Depth）</strong><br>深度是从根节点到某个节点的路径长度，也可以理解为该节点的层数。</p><p><strong>高度（Height）</strong><br>高度是从该节点到叶节点的最长路径长度。树的高度是其根节点的高度。</p><p><strong>层（Level）</strong><br>层表示节点在树中的层级，根节点的层级为0，其子节点的层级为1，依此类推。</p><p><strong>度（Degree）</strong><br>度是一个节点拥有的子节点的数量。树的度是所有节点度的最大值。</p><p><strong>子树（Subtree）</strong><br>子树是树的一个子集，它由某个节点及其所有后代节点组成。子树本身也是一棵树。</p><p><strong>森林（Forest）</strong><br>森林是由多棵互不相连的树组成的集合。将树的根节点删除后会得到一个森林。</p><p>通过这些定义和基本术语，可以全面了解树这种数据结构及其在各种应用场景中的重要性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;树的定义&quot;&gt;&lt;a href=&quot;#树的定义&quot; class=&quot;headerlink&quot; title=&quot;树的定义&quot;&gt;&lt;/a&gt;树的定义&lt;/h3&gt;&lt;p&gt;树（Tree）是一种重要的非线性数据结构，由一组节点（Node）和边（Edge）组成，用于表示具有层次关系的数据。树具有以下</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>writing</title>
    <link href="http://example.com/2024/09/04/acedemic%20English%20writing/"/>
    <id>http://example.com/2024/09/04/acedemic%20English%20writing/</id>
    <published>2024-09-04T02:38:00.000Z</published>
    <updated>2024-09-04T09:08:24.501Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>key words:</p><p>format、differences、research paper writing 、writing process、cohesive devices、summary、topic、thesis、focus、paraphrasing、hedging words、reporting verbs、interested topic、EWA.</p></blockquote><h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><hr><h3 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h3><p><strong>Definition</strong><br>Refers to the structure and layout of an academic paper, including the title page, abstract, introduction, body, conclusion, and references. Proper formatting enhances the readability and professionalism of the paper.</p><p><strong>Example</strong>  </p><ul><li><strong>Title Page</strong>: Includes the paper’s title, author’s name, institution, and date.</li><li><strong>Abstract</strong>: “This study examines the effects of climate change on agricultural productivity, highlighting significant trends and potential impacts.”</li><li><strong>Introduction</strong>: “Climate change has become a critical issue with far-reaching effects on various aspects of life, particularly agriculture.”</li><li><strong>Body</strong>: Contains sections like literature review, methodology, results, and discussion.</li><li><strong>Conclusion</strong>: “The findings suggest that climate change is likely to reduce crop yields, necessitating the adoption of adaptive agricultural practices.”</li><li><strong>References</strong>: “Smith, J. (2020). <em>Climate Change and Agriculture</em>. Cambridge University Press.”</li></ul><hr><h3 id="Differences"><a href="#Differences" class="headerlink" title="Differences"></a>Differences</h3><p><strong>Definition</strong><br>In academic writing, refers to the discrepancies in viewpoints or results between different sources. It is crucial to compare and contrast relevant research accurately to demonstrate analytical skills.</p><p><strong>Example</strong>  </p><ul><li><strong>Comparing Studies</strong>: “While Smith (2020) argues that climate change significantly impacts crop yields, Jones (2019) finds that the effects are less pronounced, suggesting regional variability.”</li><li><strong>Different Perspectives</strong>: “The theoretical framework proposed by Brown (2018) differs from that of White (2017) in its approach to economic impacts.”</li></ul><hr><h3 id="Research-Paper-Writing"><a href="#Research-Paper-Writing" class="headerlink" title="Research Paper Writing"></a>Research Paper Writing</h3><p><strong>Definition</strong><br>Encompasses the entire process from topic selection, literature review, research methods, data analysis to conclusions. The key is to ensure logical clarity and thorough argumentation.</p><p><strong>Example</strong>  </p><ul><li><strong>Topic Selection</strong>: “The impact of urbanization on biodiversity.”</li><li><strong>Literature Review</strong>: “Previous studies have shown mixed results regarding urbanization’s effects on local species (Green, 2019; Lee, 2021).”</li><li><strong>Research Methods</strong>: “This study employs a mixed-methods approach, combining quantitative surveys with qualitative interviews.”</li><li><strong>Data Analysis</strong>: “Statistical analysis revealed a significant decline in native species in urban areas (p &lt; 0.05).”</li><li><strong>Conclusion</strong>: “The study concludes that urbanization negatively affects biodiversity, with implications for conservation strategies.”</li></ul><hr><h3 id="Writing-Process"><a href="#Writing-Process" class="headerlink" title="Writing Process"></a>Writing Process</h3><p><strong>Definition</strong><br>The writing process typically includes prewriting, drafting, revising, and proofreading stages. Each stage focuses on different tasks, such as brainstorming, writing the first draft, modifying content, and checking for errors.</p><p><strong>Example</strong>  </p><ul><li><strong>Prewriting</strong>: “Brainstorming ideas for a research paper on renewable energy technologies.”</li><li><strong>Drafting</strong>: “Writing an initial draft of the paper, focusing on the introduction and literature review.”</li><li><strong>Revising</strong>: “Revising the draft based on feedback from peers, adjusting arguments and adding evidence.”</li><li><strong>Proofreading</strong>: “Checking the final draft for grammatical errors, typos, and formatting inconsistencies.”</li></ul><hr><h3 id="Cohesive-Devices"><a href="#Cohesive-Devices" class="headerlink" title="Cohesive Devices"></a>Cohesive Devices</h3><p><strong>Definition</strong><br>Also known as linking words or coherence devices, they help create smooth transitions between sentences and paragraphs. Examples include “therefore,” “however,” and “additionally.”</p><p><strong>Example</strong>  </p><ul><li><strong>Therefore</strong>: “The experiment showed significant results; therefore, the hypothesis was supported.”</li><li><strong>However</strong>: “The initial findings were promising; however, further research is needed to confirm these results.”</li><li><strong>Additionally</strong>: “The study also explored the impact on local wildlife. Additionally, it examined the socioeconomic effects.”</li></ul><hr><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><strong>Definition</strong><br>A brief overview of a paper or document, highlighting key points and conclusions. An effective summary should be concise and cover the core content.</p><p><strong>Example</strong>  </p><ul><li><strong>Paper Summary</strong>: “This paper investigates the relationship between exercise and mental health. Results indicate that regular physical activity is associated with reduced symptoms of depression and anxiety.”</li></ul><hr><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p><strong>Definition</strong><br>The subject or research question of a paper, serving as the foundation for all research and discussion. Choosing a clear, researchable topic is crucial for successful writing.</p><p><strong>Example</strong>  </p><ul><li><strong>Topic</strong>: “The effects of social media on academic performance.”</li><li><strong>Research Question</strong>: “How does the use of social media platforms impact students’ academic achievements?”</li></ul><hr><h3 id="Thesis"><a href="#Thesis" class="headerlink" title="Thesis"></a>Thesis</h3><p><strong>Definition</strong><br>The central argument or claim of a paper, typically stated in the introduction and supported throughout the paper.</p><p><strong>Example</strong>  </p><ul><li><strong>Thesis Statement</strong>: “While social media offers significant benefits for communication, its excessive use negatively impacts students’ academic performance by reducing study time and increasing distractions.”</li></ul><hr><h3 id="Focus"><a href="#Focus" class="headerlink" title="Focus"></a>Focus</h3><p><strong>Definition</strong><br>Refers to the specific issue or angle a paper will concentrate on. Maintaining focus helps prevent deviation from the main topic and clarifies the argument.</p><p><strong>Example</strong>  </p><ul><li><strong>Focus</strong>: “This paper will focus on the impact of social media on high school students’ GPA, rather than exploring its effects on college students or professionals.”</li></ul><hr><h3 id="Paraphrasing"><a href="#Paraphrasing" class="headerlink" title="Paraphrasing"></a>Paraphrasing</h3><p><strong>Definition</strong><br>Rewriting information in different words and sentence structures to avoid direct quotation and demonstrate understanding of the material. Effective paraphrasing should preserve the original meaning.</p><p><strong>Example</strong>  </p><ul><li><strong>Original</strong>: “Global warming is leading to an increase in extreme weather events.”</li><li><strong>Paraphrased</strong>: “The rise in global temperatures is contributing to a higher frequency of extreme weather conditions.”</li></ul><hr><h3 id="Hedging-Words"><a href="#Hedging-Words" class="headerlink" title="Hedging Words"></a>Hedging Words</h3><p><strong>Definition</strong><br>Words used to express uncertainty or to avoid making absolute statements, such as “may,” “seems,” or “to some extent.” These words help add a level of caution to academic writing.</p><p><strong>Example</strong>  </p><ul><li><strong>May</strong>: “The findings may suggest a trend towards increased biodiversity in urban areas.”</li><li><strong>Seems</strong>: “The data seems to indicate a positive correlation between exercise and mental health improvements.”</li></ul><hr><h3 id="Reporting-Verbs"><a href="#Reporting-Verbs" class="headerlink" title="Reporting Verbs"></a>Reporting Verbs</h3><p><strong>Definition</strong><br>Verbs used to attribute information or viewpoints to other authors, such as “argues,” “claims,” “finds,” etc. Choosing the right reporting verb can accurately convey the original author’s intention.</p><p><strong>Example</strong>  </p><ul><li><strong>Argues</strong>: “Smith (2020) argues that climate change is the primary driver of biodiversity loss.”</li><li><strong>Finds</strong>: “The study finds a significant relationship between early childhood education and later academic success.”</li></ul><hr><h3 id="Interested-Topic"><a href="#Interested-Topic" class="headerlink" title="Interested Topic"></a>Interested Topic</h3><p><strong>Definition</strong><br>A topic related to one’s academic interests. Choosing a topic of personal interest can enhance motivation and quality of research.</p><p><strong>Example</strong>  </p><ul><li><strong>Interested Topic</strong>: “The role of artificial intelligence in personalized medicine.”</li><li><strong>Research Direction</strong>: “Examining how AI technologies can tailor medical treatments to individual patient needs.”</li></ul><hr><h3 id="EWA-English-for-Academic-Purposes"><a href="#EWA-English-for-Academic-Purposes" class="headerlink" title="EWA (English for Academic Purposes)"></a>EWA (English for Academic Purposes)</h3><p><strong>Definition</strong><br>Focuses on improving academic writing, reading, listening, and speaking skills to meet the language demands of academic environments.</p><p><strong>Example</strong>  </p><ul><li><strong>Academic Writing</strong>: “Learning to write research papers with clear arguments and proper citations.”</li><li><strong>Academic Reading</strong>: “Developing skills to analyze and understand complex academic texts and articles.”</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;key words:&lt;/p&gt;
&lt;p&gt;format、differences、research paper writing 、writing process、cohesive devices、summary、topic、thesis、focus、par</summary>
      
    
    
    
    
    <category term="English" scheme="http://example.com/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>概率论</title>
    <link href="http://example.com/2024/09/02/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    <id>http://example.com/2024/09/02/%E6%A6%82%E7%8E%87%E8%AE%BA/</id>
    <published>2024-09-02T12:17:48.000Z</published>
    <updated>2024-09-04T11:51:19.545Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正态分布（Normal Distribution），也称为高斯分布（Gaussian Distribution），是统计学中最重要、最常见的一种概率分布。它广泛应用于自然科学、社会科学、经济学和工程学等领域。以下是正态分布的详细讲解：</p></blockquote><h2 id="正态分布的定义"><a href="#正态分布的定义" class="headerlink" title="正态分布的定义"></a><strong>正态分布的定义</strong></h2><p>正态分布是一种连续概率分布，其概率密度函数（PDF）由下式定义：</p><p>$f(x∣μ,σ2)&#x3D;12πσ2exp⁡(−(x−μ)22σ2)f(x | \mu, \sigma^2) &#x3D;\ \frac{1}{\sqrt{2\pi\sigma^2}} \exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)f(x∣μ,σ2)&#x3D;\2πσ21exp(−2σ2(x−μ)2)$</p><p>其中：</p><ul><li>$\mu$是均值，表示分布的中心位置。</li></ul><ul><li><p>$\sigma^2$是方差，表示数据分布的离散程度。</p></li><li><p>$\sigma$ 是标准差，等于方差的平方根。</p></li></ul><h3 id="正态分布的形状"><a href="#正态分布的形状" class="headerlink" title="正态分布的形状"></a><strong>正态分布的形状</strong></h3><p>正态分布的概率密度函数呈现出一个对称的钟形曲线，其主要特征包括：</p><ul><li><p>均值 $\mu$：决定了曲线的中心位置。正态分布是以均值为中心对称的。均值</p></li><li><p>标准差 $\sigma$：决定了曲线的宽度。标准差越大，曲线越宽，数据分布越分散；标准差越小，曲线越窄，数据分布越集中。</p></li></ul><h3 id="正态分布的性质"><a href="#正态分布的性质" class="headerlink" title="正态分布的性质"></a><strong>正态分布的性质</strong></h3><ul><li><p><strong>对称性</strong>：</p><p>正态分布是关于均值$\mu$对称的，意味着平均值的两侧分布是镜像的。</p></li><li><p><strong>68-95-99.7 规则</strong>：</p><p>在正态分布中，数据有约68%落在均值的一个标准差范围内，约95%落在两个标准差范围内，约99.7%落在三个标准差范围内。</p></li><li><p><strong>单峰性</strong>：</p><p>正态分布只有一个峰值，即均值$ \mu$ 处。</p></li></ul><h3 id="标准正态分布"><a href="#标准正态分布" class="headerlink" title="标准正态分布"></a><strong>标准正态分布</strong></h3><p>标准正态分布是均值为0、标准差为1的特殊正态分布。其概率密度函数为：</p><p>其中<br>$$<br>z&#x3D;x−μσz &#x3D; \frac{x - \mu}{\sigma}z&#x3D;σx−μ<br>$$</p><p> 是标准分数（Z分数）。标准正态分布常用于将任意正态分布标准化，从而方便进行统计分析。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h3><p>正态分布在许多领域有广泛应用，如：</p><ul><li><strong>自然现象</strong>：许多自然现象（如身高、智商）的数据近似服从正态分布。</li><li><strong>统计推断</strong>：假设数据服从正态分布，可以进行参数估计、假设检验等统计分析。</li><li><strong>误差分析</strong>：由于中心极限定理的作用，很多随机变量的和或平均值趋近于正态分布，即使这些变量本身不服从正态分布。</li></ul><h3 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h3><p>中心极限定理（Central Limit Theorem）是正态分布中的一个重要结果，它表明：对于一个具有任意分布的随机变量，其独立同分布的样本均值，当样本量足够大时，将近似服从正态分布。该定理解释了正态分布在自然界中的普遍性。</p><h3 id="正态分布的图示"><a href="#正态分布的图示" class="headerlink" title="正态分布的图示"></a>正态分布的图示</h3><p>正态分布的图形是一条光滑的钟形曲线，左侧和右侧对称，曲线的宽度由标准差决定。</p><p>样本空间和随机事件是概率论的基本概念，它们构成了概率论的基础。以下是对这两个概念的详细总结：</p><h2 id="样本空间（Sample-Space）"><a href="#样本空间（Sample-Space）" class="headerlink" title="样本空间（Sample Space）"></a><strong>样本空间（Sample Space）</strong></h2><p>   样本空间是概率论中用于描述所有可能结果的集合。</p><p>它是一个实验或随机试验的所有可能结果的集合，用符号$ ( S )$ 或 $( \Omega )$ 表示。</p><ul><li><p><strong>定义</strong>：样本空间是一个集合，其中包含了所有可能的实验结果。例如，在抛掷一枚硬币的实验中，样本空间 ( S ) 包含两个结果，即 $( S &#x3D; { \text{正面}, \text{反面} } )$ 或者 $( S &#x3D; { H, T } )$。</p></li><li><p><strong>离散样本空间</strong>：如果样本空间包含有限个或可数无限多个结果，则称为离散样本空间。例如，掷一个六面骰子的样本空间为$( S &#x3D; {1, 2, 3, 4, 5, 6} )$。</p></li><li><p><strong>连续样本空间</strong>：如果样本空间包含不可数无限多个结果，则称为连续样本空间。例如，在区间 [0, 1] 上随机选取一个数，样本空间为 $( S &#x3D; [0, 1] )$。</p></li></ul><h3 id="随机事件（Random-Event）"><a href="#随机事件（Random-Event）" class="headerlink" title="随机事件（Random Event）"></a><strong>随机事件（Random Event）</strong></h3><p>   随机事件是样本空间的一个子集，它表示实验中可能发生的结果集合。</p><ul><li><p><strong>定义</strong>：随机事件是样本空间的子集，可以包括一个或多个实验结果。例如，在抛掷一枚硬币的实验中，事件 ( A ) 可以是“出现正面”，即 $( A &#x3D; { \text{正面} } )$。</p></li><li><p><strong>简单事件</strong>：简单事件（Elementary Event）是样本空间中的单个元素，表示某个特定的结果。例如，掷骰子得到1的事件是一个简单事件$( A &#x3D; {1} )$。</p></li><li><p><strong>复合事件</strong>：复合事件（Compound Event）是样本空间的一个子集，包含多个可能的结果。例如，掷骰子得到偶数的事件$( B &#x3D; {2, 4, 6} )$是一个复合事件。</p></li><li><p><strong>必然事件</strong>：必然事件（Certain Event）是样本空间本身，表示实验中总会发生的结果。它的概率为1。例如，在掷骰子的实验中，样本空间$( S &#x3D; {1, 2, 3, 4, 5, 6} )$是一个必然事件。</p></li><li><p><strong>不可能事件</strong>：</p><p>不可能事件（Impossible Event）是空集$ ( \emptyset )$，表示实验中永远不会发生的结果。它的概率为0。</p></li></ul><h3 id="随机事件的运算"><a href="#随机事件的运算" class="headerlink" title="随机事件的运算"></a><strong>随机事件的运算</strong></h3><p>   随机事件可以通过集合运算进行组合，形成新的事件。</p><ul><li><p><strong>并集（Union）</strong>：事件 ( A ) 和事件 ( B ) 的并集 </p><p>事件 ( A ) 和事件 ( B ) 的并集$ ( A \cup B )$ 表示“事件 ( A )”或“事件 ( B )”发生的集合。它包含所有在 ( A ) 或 ( B ) 中的元素。</p></li><li><p><strong>交集（Intersection）</strong>：</p><p>事件 ( A ) 和事件 ( B ) 的交集 $( A \cap B )$表示“事件 ( A )”且“事件 ( B )”同时发生的集合。它包含所有同时在 ( A ) 和 ( B ) 中的元素。</p></li><li><p><strong>补集（Complement）</strong>：</p><p>事件 ( A ) 的补集$ ( A^c )$ 表示“事件 ( A )”不发生的集合。它包含所有在样本空间中但不在 ( A ) 中的元素。</p></li></ul><h3 id="随机事件的分类"><a href="#随机事件的分类" class="headerlink" title="随机事件的分类"></a>随机事件的分类</h3><ul><li><p><strong>互斥事件</strong>：两个事件 ( A ) 和 ( B ) 是互斥的（也称为不相容的），如果它们不能同时发生，即 $( A \cap B &#x3D; \emptyset )$。</p></li><li><p><strong>独立事件</strong>：两个事件 ( A ) 和 ( B ) 是独立的，如果其中一个事件的发生不影响另一个事件的发生概率，即$( P(A \cap B) &#x3D; P(A) \times P(B) )$。</p></li></ul><h2 id="概率的定义"><a href="#概率的定义" class="headerlink" title="概率的定义"></a><strong>概率的定义</strong></h2><p>   概率是随机事件发生的可能性度量，通常用 ( P(A) ) 表示事件 ( A ) 的概率。</p><ul><li><p><strong>经典概率</strong>：在有限样本空间中，事件 ( A ) 的概率定义为：<br>$$<br>[<br>P(A) &#x3D; \frac{|A|}{|S|}<br>]<br>$$<br>其中 ( |A| ) 表示事件 ( A ) 中的结果数，( |S| ) 表示样本空间中的总结果数。</p></li><li><p><strong>频率解释</strong>：概率也可以理解为在大量重复实验中事件发生的相对频率。</p></li><li><p><strong>公理化定义</strong>：安德雷·科尔莫戈罗夫（Andrey Kolmogorov）提出的公理化概率定义，包括三个公理：</p><ol><li><p>$( 0 \leq P(A) \leq 1 )$对任意事件 ( A ) 成立。</p></li><li><p>$( P(S) &#x3D; 1 )$。</p></li><li><p>若事件$( A_1, A_2, \dots )$是互斥事件，则<br>$$<br>( P\left(\bigcup_{i&#x3D;1}^{\infty} A_i\right) &#x3D; \sum_{i&#x3D;1}^{\infty} P(A_i) )<br>$$</p></li></ol></li></ul><p>事件的关系及其运算是概率论中的重要内容，涉及如何组合不同的随机事件以及如何计算这些组合事件的概率。以下是关于事件关系及其运算的详细总结：</p><h3 id="事件的基本概念"><a href="#事件的基本概念" class="headerlink" title="事件的基本概念"></a><strong>事件的基本概念</strong></h3><ul><li><p><strong>事件（Event）</strong>：事件是样本空间的一个子集，表示实验中可能发生的结果集合。</p></li><li><p><strong>简单事件</strong>：只包含一个样本点的事件。</p></li><li><p><strong>复合事件</strong>：包含多个样本点的事件。</p></li><li><p><strong>必然事件</strong>：包含样本空间中所有可能结果的事件，通常表示为 ( S )。</p></li><li><p><strong>不可能事件</strong>：不包含任何样本点的事件，表示为空集 $( \emptyset )$</p><p>。</p></li></ul><h3 id="事件之间的关系"><a href="#事件之间的关系" class="headerlink" title="事件之间的关系"></a>事件之间的关系</h3><ul><li><p><strong>包含关系</strong>：如果事件 ( A ) 的所有结果都包含在事件 ( B ) 中，则称事件 ( A ) 包含于事件 ( B ) 中，记为 </p><p>$( A \subseteq B )$。</p></li><li><p><strong>相等关系</strong>：如果事件 ( A ) 和 ( B ) 包含完全相同的结果，则 ( A &#x3D; B )。</p></li></ul><h3 id="事件的运算"><a href="#事件的运算" class="headerlink" title="事件的运算"></a>事件的运算</h3><p>   事件可以通过集合运算进行组合，形成新的事件。常见的运算包括并集、交集和补集。</p><ul><li><p><strong>并集（Union）</strong>：事件 ( A ) 和事件 ( B ) 的并集 $( A \cup B )$</p><p>表示“事件 ( A )”或“事件 ( B )”发生的集合。并集包含所有在 ( A ) 或 ( B ) 中的结果。用语言描述就是“或”。</p><ul><li><strong>运算公式</strong>：<br>$$<br>( P(A \cup B) &#x3D; P(A) + P(B) - P(A \cap B) )<br>$$</li></ul></li><li><p><strong>交集（Intersection）</strong>：事件 ( A ) 和事件 ( B ) 的交集 $( A \cap B )$</p><p>表示“事件 ( A )”且“事件 ( B )”同时发生的集合。交集包含所有同时在 ( A ) 和 ( B ) 中的结果。用语言描述就是“且”。</p><ul><li><strong>运算公式</strong>：若 ( A ) 和 ( B ) 独立，则<br>$$<br>( P(A \cap B) &#x3D; P(A) \times P(B) )<br>$$<br>。</li></ul></li><li><p><strong>补集（Complement）</strong>：事件 ( A ) 的补集 $( A^c )$</p><p>表示“事件 ( A )”不发生的集合。补集包含所有在样本空间中但不在 ( A ) 中的结果。</p><ul><li><strong>运算公式</strong>：<br>$$<br>( P(A^c) &#x3D; 1 - P(A) )<br>$$</li></ul></li></ul><h3 id="事件的分类"><a href="#事件的分类" class="headerlink" title="事件的分类"></a>事件的分类</h3><ul><li><p><strong>互斥事件（Mutually Exclusive Events）</strong>：两个事件 ( A ) 和 ( B ) 是互斥的，如果它们不能同时发生，即 </p><p>$( A \cap B &#x3D; \emptyset )$</p><p>。互斥事件的并集概率为两个事件概率的和：</p><ul><li><strong>公式</strong>：<br>$$<br>( P(A \cup B) &#x3D; P(A) + P(B) )<br>$$<br>（仅适用于互斥事件）。</li></ul></li><li><p><strong>独立事件（Independent Events）</strong>：两个事件 ( A ) 和 ( B ) 是独立的，如果其中一个事件的发生不影响另一个事件的发生概率。对于独立事件，交集概率为两个事件概率的乘积：</p><ul><li><strong>公式</strong>：<br>$$<br>( P(A \cap B) &#x3D; P(A) \times P(B) )<br>$$<br>。</li></ul></li></ul><h3 id="全概率公式和贝叶斯公式"><a href="#全概率公式和贝叶斯公式" class="headerlink" title="全概率公式和贝叶斯公式"></a>全概率公式和贝叶斯公式</h3><ul><li><p><strong>全概率公式</strong>：用于计算一个事件的概率，基于事件的分解。设<br>$$<br>( B_1, B_2, \dots, B_n )<br>$$<br> 是样本空间的一个划分，则对任意事件 ( A ) 有：<br>$$<br>[<br>P(A) &#x3D; \sum_{i&#x3D;1}^{n} P(A \cap B_i) &#x3D; \sum_{i&#x3D;1}^{n} P(A | B_i) \cdot P(B_i)<br>]<br>$$</p></li><li><p><strong>贝叶斯公式（Bayes’ Theorem）</strong>：用于反向计算条件概率。设 ( B_1, B_2, \dots, B_n ) 是样本空间的一个划分，则对于任意事件 ( A ) 和 ( B_j )，有：<br>$$<br>[<br>P(B_j | A) &#x3D; \frac{P(A | B_j) \cdot P(B_j)}{\sum_{i&#x3D;1}^{n} P(A | B_i) \cdot P(B_i)}<br>]<br>$$</p></li></ul><h3 id="事件的运算性质"><a href="#事件的运算性质" class="headerlink" title="事件的运算性质"></a>事件的运算性质</h3><ul><li><p><strong>交换律</strong>：</p><ul><li>$$<ul><li>( A \cup B &#x3D; B \cup A )\\</li><li>( A \cap B &#x3D; B \cap A )<br>$$</li></ul></li></ul></li><li><p><strong>结合律</strong>：</p><ul><li>$$<ul><li>( (A \cup B) \cup C &#x3D; A \cup (B \cup C) )\\</li><li>( (A \cap B) \cap C &#x3D; A \cap (B \cap C) )<br>$$</li></ul></li></ul></li><li><p><strong>分配律</strong>：</p><ul><li>$$<ul><li>( A \cap (B \cup C) &#x3D; (A \cap B) \cup (A \cap C) )\\</li><li>( A \cup (B \cap C) &#x3D; (A \cup B) \cap (A \cup C) )<br>$$</li></ul></li></ul></li><li><p><strong>德·摩根律（De Morgan’s Laws）</strong>：</p><ul><li>$$<ul><li>( (A \cup B)^c &#x3D; A^c \cap B^c )\\</li><li>( (A \cap B)^c &#x3D; A^c \cup B^c )<br>$$</li></ul></li></ul></li></ul><h3 id="事件的运算实例"><a href="#事件的运算实例" class="headerlink" title="事件的运算实例"></a>事件的运算实例</h3><ul><li><p><strong>例1：掷骰子</strong>。设事件 ( A ) 表示“掷出偶数”，事件 ( B ) 表示“掷出的数大于4”。则：</p><ul><li>$$<ul><li>( A &#x3D; {2, 4, 6} )\\</li><li>( B &#x3D; {5, 6} )\\</li><li>( A \cup B &#x3D; {2, 4, 5, 6} )\\</li><li>( A \cap B &#x3D; {6} )\\</li><li>( A^c &#x3D; {1, 3, 5} )<br>$$</li></ul></li></ul></li><li><p><strong>例2：抽牌</strong>。从一副52张的扑克牌中随机抽取一张。设事件 ( A ) 表示“抽到红色的牌”，事件 ( B ) 表示“抽到一张A”。则：</p><ul><li>$$<ul><li>( A &#x3D; {红心A, 红心2, \dots, 红心K, 方块A, 方块2, \dots, 方块K} )\\</li><li>( B &#x3D; {红心A, 黑桃A, 梅花A, 方块A} )\\</li><li>( A \cup B ) 包含所有红色牌和其他两张A牌。\\</li><li>( A \cap B &#x3D; {红心A, 方块A} )\\</li><li>( A^c ) 包含所有黑色牌。<br>$$</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;正态分布（Normal Distribution），也称为高斯分布（Gaussian Distribution），是统计学中最重要、最常见的一种概率分布。它广泛应用于自然科学、社会科学、经济学和工程学等领域。以下是正态分布的详细讲解：&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法：数学</title>
    <link href="http://example.com/2024/08/20/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E5%AD%A6/"/>
    <id>http://example.com/2024/08/20/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E5%AD%A6/</id>
    <published>2024-08-20T11:41:21.000Z</published>
    <updated>2024-08-20T12:26:43.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1矩阵"><a href="#1-1矩阵" class="headerlink" title="1.1矩阵"></a>1.1矩阵</h1><h2 id="1-1-1矩阵类"><a href="#1-1-1矩阵类" class="headerlink" title="1.1.1矩阵类"></a>1.1.1矩阵类</h2><ul><li>任务：</li></ul><p>实现矩阵的基本变换</p><ul><li>接口</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">结构体：Matrix</span><br><span class="line">成员变量：</span><br><span class="line"><span class="type">int</span> n,m 矩阵大小</span><br><span class="line"><span class="type">int</span> a[][] 矩阵内容</span><br><span class="line">重载运算符：+、-、x</span><br><span class="line">成员函数：</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> 清空矩阵</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="type">int</span> a[MAXN][MAXM];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n=m=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    &#125; </span><br><span class="line">    Matrix <span class="keyword">operator</span>+(<span class="type">const</span> Matrix&amp;b) <span class="type">const</span>&#123;</span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n;</span><br><span class="line">        tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.a[i][j]=a[i][j]+b.a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>-(<span class="type">const</span> Matrix&amp;b) <span class="type">const</span>&#123;</span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n;</span><br><span class="line">        tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.a[i][j]=a[i][j]-b.a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix&amp;b) <span class="type">const</span>&#123;</span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n;</span><br><span class="line">        tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.a[i][j]+=a[i][k]*b.a[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><h4 id="矩阵乘法分析，在线性代数里面，矩阵的乘法规则如下："><a href="#矩阵乘法分析，在线性代数里面，矩阵的乘法规则如下：" class="headerlink" title="矩阵乘法分析，在线性代数里面，矩阵的乘法规则如下："></a>矩阵乘法分析，在线性代数里面，矩阵的乘法规则如下：</h4></li></ul><p>矩阵中某行（n）某列（m）确定的元素的值，等于前一个矩阵的该行向量（n，k）与后一个矩阵的该列向量（k，m）的乘积，k代表行向量和列向量中的第几个值。</p><ul><li><h4 id="重载运算符的规则"><a href="#重载运算符的规则" class="headerlink" title="重载运算符的规则"></a>重载运算符的规则</h4></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix&amp;b) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="comment">//本质是一个函数，传入的参数是常引用，函数本身是常函数，不可更改</span></span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n;</span><br><span class="line">        tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.a[i][j]+=a[i][k]*b.a[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1-1-2Gauss消元"><a href="#1-1-2Gauss消元" class="headerlink" title="1.1.2Gauss消元"></a>1.1.2Gauss消元</h2><ul><li>任务：</li></ul><p>给一个n元一次方程组，求它们的解集</p><ul><li>说明</li></ul><p>将方程组做成矩阵形式，再利用三种初等矩阵变换，得到上三角矩阵，最后回代得到解集。</p><ul><li>接口</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">double</span> a[][MAXN],<span class="type">bool</span> l[],<span class="type">double</span> ans[],<span class="type">const</span> <span class="type">int</span>&amp;n)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>复杂度</li></ul><p>$$<br>O(n^3)<br>$$</p><ul><li>输入</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 方程组对应的矩阵</span><br><span class="line">n 未知数个数</span><br><span class="line">l，ans 存储解，l[]表示是否为自由元</span><br></pre></td></tr></table></figure><ul><li>输出</li></ul><p>解空间的维数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-1矩阵&quot;&gt;&lt;a href=&quot;#1-1矩阵&quot; class=&quot;headerlink&quot; title=&quot;1.1矩阵&quot;&gt;&lt;/a&gt;1.1矩阵&lt;/h1&gt;&lt;h2 id=&quot;1-1-1矩阵类&quot;&gt;&lt;a href=&quot;#1-1-1矩阵类&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：栈与队列</title>
    <link href="http://example.com/2024/08/20/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2024/08/20/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2024-08-20T01:00:40.000Z</published>
    <updated>2024-09-04T14:42:33.376Z</updated>
    
    <content type="html"><![CDATA[<p>1212</p><h2 id="栈与队列理论基础"><a href="#栈与队列理论基础" class="headerlink" title="栈与队列理论基础"></a>栈与队列理论基础</h2><h3 id="栈（stack）："><a href="#栈（stack）：" class="headerlink" title="栈（stack）："></a>栈（stack）：</h3><p>先进后出，属于STL中的数据结构，提供push、pop等外部接口，栈不提供走访功能，以及迭代器（iterator）。</p><h4 id="初始化语句"><a href="#初始化语句" class="headerlink" title="初始化语句"></a>初始化语句</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure><h3 id="队列（queue）："><a href="#队列（queue）：" class="headerlink" title="队列（queue）："></a>队列（queue）：</h3><p>先进先出，属于STL中的数据结构，如果是双向队列，简写就是deque。</p><h4 id="初始化语句-1"><a href="#初始化语句-1" class="headerlink" title="初始化语句"></a>初始化语句</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235346563.png" alt="栈与队列理论1"></p><blockquote><p>在STL中，栈和队列两种数据结构都不被归类为容器，而被归类为container adapter（容器适配器）</p></blockquote><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初等构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接复用栈的push函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="comment">//pop的逻辑是退出一个元素，如果还有元素，那就不用再从s1中push元素。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将s1的所有元素都push到s2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> a=s2.<span class="built_in">top</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> a;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        s2.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>()&amp;&amp;s2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>例如用双栈实现队列的以下功能</p><ul><li>pop</li><li>peek</li><li>empty</li><li>push</li></ul><p>实现功能的前提是熟知这个功能的具体内容是什么。</p><h5 id="pop函数的功能："><a href="#pop函数的功能：" class="headerlink" title="pop函数的功能："></a>pop函数的功能：</h5><p>将最先进入队列的元素推出队列，并返回它的值。我们将功能依次翻译为代码，最先进入队列的元素：使用双栈，用out栈反向接受in栈的元素（我们只有栈作为工具，栈的特点是后进后出，我们的操作是为了让最先进队列的元素变成最先进栈的元素）、使用一个值记录要推出的元素的值，再对栈使用pop函数，将该元素退出。</p><h5 id="peek函数的功能："><a href="#peek函数的功能：" class="headerlink" title="peek函数的功能："></a>peek函数的功能：</h5><p>要返回最后进入队列的元素，搭载队列的底层数据结构是栈，直接将队列当栈使用，调用栈的top函数。</p><h5 id="empty函数的功能："><a href="#empty函数的功能：" class="headerlink" title="empty函数的功能："></a>empty函数的功能：</h5><p>当in栈和out栈都为空时，队列才为空，我们只需要返回一个判定两者是否同时为空的布尔变量。</p><h5 id="push函数的功能："><a href="#push函数的功能：" class="headerlink" title="push函数的功能："></a>push函数的功能：</h5><p>要返回最后进入队列的元素，搭载队列的底层数据结构是栈，直接将队列当栈使用，调用栈的push函数。</p><blockquote><p>整体的程序设计其实有部分问题，在使用过队列的pop函数过后，in栈的元素全都逆向进入了out栈，此时再用栈的push函数，新元素进入in栈，这个时候问题就出现了，in栈和out栈的元素失去了原先的顺序特征。因此，在pop函数达到目标功能过后，最好把out栈的元素归位。</p><p>注意：上方的注释忽略了一个事实，pop函数在执行的时候是有前提的，out栈为空，这样函数整体的逻辑就像从要从顶部将竹子分为竹节，我们为了便利（等竹子生长），从竹子的根部以上将其砍开，先分解上部的竹节，而下面竹子的生长能够继续，当我们分解完上部的竹节之后，再将下面的竹节砍下，继续分解，这样既不会耽误我们分解竹子，也不会耽误竹子生长。</p></blockquote><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的标准操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // 返回 2</span><br><span class="line">myStack.pop(); // 返回 2</span><br><span class="line">myStack.empty(); // 返回 False</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li><li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li></ul><p><strong>进阶：</strong>你能否仅用一个队列来实现栈。</p><p>利用队列实现栈</p><blockquote><p>这部分的程序设计可以抽象出队列元素的特点，就像用栈实现队列的时候一样，是从顶上开始分解竹子的逻辑。这边将优先级放到了顶部的竹节上，类似地，可以将这个属性进行迁移。就像重要度不同的一系列人请你帮忙，假设队列的逻辑是从最重要的人开始处理，那栈的逻辑就是从最不重要的人开始处理，要用队列的逻辑实现栈的逻辑，就得将最重要的人转变为最不重要的人，这里选择的方式是将重要的人（具有优先处理权）直接转移到另一个队列里，然后将最不重要的人视为最重要的人处理。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que2; <span class="comment">// 辅助队列，用来备份</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que1.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123; <span class="comment">// 将que1 导入que2，但要留下最后一个元素</span></span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = que1.<span class="built_in">front</span>(); <span class="comment">// 留下的最后一个元素就是要返回的值</span></span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line">        que1 = que2;            <span class="comment">// 再将que2赋值给que1</span></span><br><span class="line">        <span class="keyword">while</span> (!que2.<span class="built_in">empty</span>()) &#123; <span class="comment">// 清空que2</span></span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element.</span></span><br><span class="line"><span class="comment">     ** Can not use back() direactly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que1.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--)&#123;</span><br><span class="line">            <span class="comment">// 将que1 导入que2，但要留下最后一个元素</span></span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = que1.<span class="built_in">front</span>(); <span class="comment">// 留下的最后一个元素就是要回返的值</span></span><br><span class="line">        que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());   <span class="comment">// 获取值后将最后一个元素也加入que2中，保持原本的结构不变</span></span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        que1 = que2; <span class="comment">// 再将que2赋值给que1</span></span><br><span class="line">        <span class="keyword">while</span> (!que2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 清空que2</span></span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>整体的程序设计其实有部分问题，在使用过队列的pop函数过后，in栈的元素全都逆向进入了out栈，此时再用栈的push函数，新元素进入in栈，这个时候问题就出现了，in栈和out栈的元素失去了原先的顺序特征。因此，在pop函数达到目标功能过后，最好把out栈的元素归位。</p></blockquote><p>我在用栈实现队列的时候，提到了这个细节，现在它能在队列实现栈时派上用场。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>在使用单个队列进行模拟的时候发现，将最不重要的元素化为最重要的元素就可以了，然而在实现的过程中，需要新开队列空间，将需要移除的元素暂存，等处理完目标元素之后，再将它们放回来，实际上并不需要这样操作。要做的事情就只有将元素移除，再添加进当前队列，直接让最加入的元素变成最先加入的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123; <span class="comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span></span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = que.<span class="built_in">front</span>(); <span class="comment">// 此时弹出的元素顺序就是栈的顺序了</span></span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element.</span></span><br><span class="line"><span class="comment">     ** Can not use back() direactly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--)&#123;</span><br><span class="line">            <span class="comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span></span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = que.<span class="built_in">front</span>(); <span class="comment">// 此时获得的元素就是栈顶的元素了</span></span><br><span class="line">        que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());    <span class="comment">// 将获取完的元素也重新添加到队列尾部，保证数据结构没有变化</span></span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><p><img src="https://code-thinking.cdn.bcebos.com/gifs/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="20.有效括号"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果s的长度为奇数，一定不符合要求</span></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span></span><br><span class="line">            <span class="comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>(); <span class="comment">// st.top() 与 s[i]相等，栈弹出元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h2><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= S.length &lt;= 20000</code></li><li><code>S</code> 仅由小写英文字母组成。</li></ol><p><img src="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif" alt="1047.删除字符串中的所有相邻重复项"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> s : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || s != st.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// s 与 st.top()相等的情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123; <span class="comment">// 将栈中元素放到result字符串汇总</span></span><br><span class="line">            result += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span> (result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 此时字符串需要反转一下</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h2><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p><strong>注意：</strong></p><ul><li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><p><img src="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="150.逆波兰表达式求值"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 力扣修改了后台测试数据，需要用longlong</span></span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; st; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(num2 + num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;-&quot;</span>) st.<span class="built_in">push</span>(num2 - num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;*&quot;</span>) st.<span class="built_in">push</span>(num2 * num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;/&quot;</span>) st.<span class="built_in">push</span>(num2 / num1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoll</span>(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>(); <span class="comment">// 把栈里最后一个元素弹出（其实不弹出也没事）</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><p>在解决滑动窗口最大值的问题的时候，我们注意到P：小窗口向右移动、Q：窗口右端达到数组的右端，在P中，小窗口的元素进出规律如下：小窗口最多容纳k个元素，小窗口每次向右移动一格，会push一个新元素，而窗口内部，最先进来的那个元素被pop出去，这就是队列的先进先出的思想。而整个题目还给我们留下了一个R：输出滑动窗口的最大值。</p><p>最后我们解决这个题目要做到的就是<br>$$<br>P\cap Q\cap R<br>$$<br>实现思路就是建立一个单向队列充当小窗口，然后我们每次从滑动窗口里面取k个元素，总体的进程是让窗口向滑动窗口的右端移动。</p><p>队列的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="built_in">empty</span>()&amp;&amp;val==que.<span class="built_in">front</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(val&gt;que.<span class="built_in">back</span>()&amp;&amp;!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对此处代码的理解，现在回忆代码内容，能注意到正确的逻辑如下：push函数的意义是，当val大于back处的值时，将back处的值pop掉，一直这样操作，直到val大于back处的值，将val作为back处的值，一直这样操作，让整个队列处于递增的情况。</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">queue</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="built_in">empty</span>()&amp;&amp;val==que.<span class="built_in">front</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()&amp;&amp;val&gt;que.<span class="built_in">back</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i-k]);</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p><p>要解决这个题目，我们首先需要了解堆是什么。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1212&lt;/p&gt;
&lt;h2 id=&quot;栈与队列理论基础&quot;&gt;&lt;a href=&quot;#栈与队列理论基础&quot; class=&quot;headerlink&quot; title=&quot;栈与队列理论基础&quot;&gt;&lt;/a&gt;栈与队列理论基础&lt;/h2&gt;&lt;h3 id=&quot;栈（stack）：&quot;&gt;&lt;a href=&quot;#栈（stack）</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>离散数学：逻辑与证明（1）</title>
    <link href="http://example.com/2024/08/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    <id>http://example.com/2024/08/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</id>
    <published>2024-08-19T06:09:35.000Z</published>
    <updated>2024-08-19T06:10:52.636Z</updated>
    
    <content type="html"><![CDATA[<p>113</p><h2 id="第⼀章-逻辑与证明-Logic-and-Proof"><a href="#第⼀章-逻辑与证明-Logic-and-Proof" class="headerlink" title="第⼀章 逻辑与证明 Logic and Proof"></a>第⼀章 逻辑与证明 Logic and Proof</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;113&lt;/p&gt;
&lt;h2 id=&quot;第⼀章-逻辑与证明-Logic-and-Proof&quot;&gt;&lt;a href=&quot;#第⼀章-逻辑与证明-Logic-and-Proof&quot; class=&quot;headerlink&quot; title=&quot;第⼀章 逻辑与证明 Logic and Proof&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="离散数学" scheme="http://example.com/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>算法：程序自由度</title>
    <link href="http://example.com/2024/08/19/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%87%AA%E7%94%B1%E5%BA%A6/"/>
    <id>http://example.com/2024/08/19/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%87%AA%E7%94%B1%E5%BA%A6/</id>
    <published>2024-08-19T02:01:29.000Z</published>
    <updated>2024-08-20T02:11:40.631Z</updated>
    
    <content type="html"><![CDATA[<p>在研究算法的时间复杂度和空间复杂度的时候，总是会遇到，在写出一个完整的算法程序之前，无法预判这个算法的时间复杂度和空间复杂度的情况，从而出现思路混乱，每一步都依靠灵感思考的问题。在这篇文章，我将着重于时间复杂度和空间复杂度背后的底层逻辑，在写出算法前，预判其两种复杂度。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在反转链表的算法练习中，我们着重于分析链表反转的基本自由度，在一开始的陌生化思考过程中，我们提到了一种类似于数组反转的算法，即直接对链表中的元素做一个镜像对称，但是在思考过后，我们发现这种算法并不可取，为什么呢？问题就出在程序的自由度上，由于这是我自己的算法笔记，我就在这里规定一些我个人定义的概念：</p><ul><li><strong>空间自由度：</strong></li></ul><p>是指元素受数据结构的影响，必须按照某种规则进行操作的受限程度。比如在链表这个数据结构中，对元素的表示不能使用索引，必须遍历到某个特定的节点之上才能调用节点的成员，对数据结构的限制的抵抗体现为这个遍历的过程。很明显，链表的遍历是一维遍历，而这里的由于链表的数据结构，在数组中属于单元操作的步骤，变成了一维操作。</p><ul><li><strong>遍历自由度</strong></li></ul><p>就是指必须完成的运算步骤（遍历过程）需要运算的规模。比如链表，我们对其的遍历自由度是一维，然而矩阵则是二维.</p><ul><li><strong>基元程序</strong></li></ul><p>基本算法就是执行同一个步骤的程序.例如反转链表之中,就只需要存元素、反向、移动元素、移动元素这个循环。</p><ul><li><h5 id="距离格数"><a href="#距离格数" class="headerlink" title="距离格数"></a>距离格数</h5></li></ul><p>在处理双指针问题的时候，通常会遇到不知道怎么处理循环次数的问题,这里提出一种从距离视角出发，解决循环次数问题的方法。</p><p>总所周知,如果有n棵树，那么就会有n-1个间隔，在数组的数据结构的背景下，索引会比实际的元素序数少1位。在进行一个基元操作之后,实际上是跨越了一个距离，可以在观测元素未知的时候，从三个角度出发：其一是序数，其二是索引，其三是跨度。</p><ul><li>序数</li></ul><p>序数对应实际考虑问题时，分析的对象。</p><ul><li>索引</li></ul><p>索引是在写代码时，需要序数转化为的对象。</p><ul><li>跨度</li></ul><p>跨度是某个维度遍历，在空间上呈现的变化。</p><p>在考虑第n个元素时，可以知道它的索引应该是n-1，而跨度也是n-1。如果考虑镜像对称的元素，能发现对称元素的序数和恒定为n+1，索引恒定为n-1，跨度之和为n-1（对称之后处于同一位置）。</p><h4 id="while语句与for语句的对比"><a href="#while语句与for语句的对比" class="headerlink" title="while语句与for语句的对比"></a>while语句与for语句的对比</h4><p>在使用两个循环语句的时候，while语句更适合条件循环，而for语句则更适合扫描循环，这使得while在更复杂的条件下，使用起来更加方便，可以用抽象条件来控制循环。</p><h4 id="逻辑语句的快速判断"><a href="#逻辑语句的快速判断" class="headerlink" title="逻辑语句的快速判断"></a>逻辑语句的快速判断</h4><p>现在观察到的逻辑运算符号中，比较容易弄混的有：！&#x3D;、while语句判断条件、a？b：c运算。</p><ul><li>a！+while（for）：a不成立时运行。</li></ul><h4 id="高精度循环"><a href="#高精度循环" class="headerlink" title="高精度循环"></a>高精度循环</h4><p>在复杂的算法问题中，我们经常用到非二维遍历的双重循环。在用到这样的循环时，应该考虑些什么问题呢？</p><ul><li>筛选型</li></ul><p>这类高精度循环，外层通常套了抽象条件的循环，而内层存在if语句，作为目标条件的筛选，到达外部抽象条件后，内部循环处理的是题目要求的内容。</p><ul><li>去重型</li></ul><p>在三数之和的问题中，用到了while语句进行去重，算是一个条件指令。</p><h4 id="仿射变换实现"><a href="#仿射变换实现" class="headerlink" title="仿射变换实现"></a>仿射变换实现</h4><h4 id="功能性程序"><a href="#功能性程序" class="headerlink" title="功能性程序"></a>功能性程序</h4><p>例如用双栈实现队列的以下功能</p><ul><li>pop</li><li>peek</li><li>empty</li><li>push</li></ul><p>实现功能的前提是熟知这个功能的具体内容是什么。</p><h5 id="pop函数的功能："><a href="#pop函数的功能：" class="headerlink" title="pop函数的功能："></a>pop函数的功能：</h5><p>将最先进入队列的元素推出队列，并返回它的值。我们将功能依次翻译为代码，最先进入队列的元素：使用双栈，用out栈反向接受in栈的元素（我们只有栈作为工具，栈的特点是后进后出，我们的操作是为了让最先进队列的元素变成最先进栈的元素）、使用一个值记录要推出的元素的值，再对栈使用pop函数，将该元素退出。</p><h5 id="peek函数的功能："><a href="#peek函数的功能：" class="headerlink" title="peek函数的功能："></a>peek函数的功能：</h5><p>要返回最后进入队列的元素，搭载队列的底层数据结构是栈，直接将队列当栈使用，调用栈的top函数。</p><h5 id="empty函数的功能："><a href="#empty函数的功能：" class="headerlink" title="empty函数的功能："></a>empty函数的功能：</h5><p>当in栈和out栈都为空时，队列才为空，我们只需要返回一个判定两者是否同时为空的布尔变量。</p><h5 id="push函数的功能："><a href="#push函数的功能：" class="headerlink" title="push函数的功能："></a>push函数的功能：</h5><p>要返回最后进入队列的元素，搭载队列的底层数据结构是栈，直接将队列当栈使用，调用栈的push函数。</p><blockquote><p>整体的程序设计其实有部分问题，在使用过队列的pop函数过后，in栈的元素全都逆向进入了out栈，此时再用栈的push函数，新元素进入in栈，这个时候问题就出现了，in栈和out栈的元素失去了原先的顺序特征。因此，在pop函数达到目标功能过后，最好把out栈的元素归位。</p><p>注意：上方的注释忽略了一个事实，pop函数在执行的时候是有前提的，out栈为空，这样函数整体的逻辑就像从要从顶部将竹子分为竹节，我们为了便利（等竹子生长），从竹子的根部以上将其砍开，先分解上部的竹节，而下面竹子的生长能够继续，当我们分解完上部的竹节之后，再将下面的竹节砍下，继续分解，这样既不会耽误我们分解竹子，也不会耽误竹子生长。</p></blockquote><p>利用队列实现栈</p><p>这部分的程序设计可以抽象出队列元素的特点，就像用栈实现队列的时候一样，是从顶上开始分解竹子的逻辑。这边将优先级放到了顶部的竹节上，类似地，可以将这个属性进行迁移。就像重要度不同的一系列人请你帮忙，假设队列的逻辑是从最重要的人开始处理，那栈的逻辑就是从最不重要的人开始处理，要用队列的逻辑实现栈的逻辑，就得将最重要的人转变为最不重要的人，这里选择的方式是将重要的人（具有优先处理权）直接转移到另一个队列里，然后将最不重要的人视为最重要的人处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在研究算法的时间复杂度和空间复杂度的时候，总是会遇到，在写出一个完整的算法程序之前，无法预判这个算法的时间复杂度和空间复杂度的情况，从而出现思路混乱，每一步都依靠灵感思考的问题。在这篇文章，我将着重于时间复杂度和空间复杂度背后的底层逻辑，在写出算法前，预判其两种复杂度。&lt;/</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>神樹の館竜胆線</title>
    <link href="http://example.com/2024/08/17/%E7%A5%9E%E6%A8%B9%E3%81%AE%E9%A4%A8%E7%AB%9C%E8%83%86%E7%B7%9A/"/>
    <id>http://example.com/2024/08/17/%E7%A5%9E%E6%A8%B9%E3%81%AE%E9%A4%A8%E7%AB%9C%E8%83%86%E7%B7%9A/</id>
    <published>2024-08-17T14:51:04.000Z</published>
    <updated>2024-08-19T12:55:37.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="竜胆01a"><a href="#竜胆01a" class="headerlink" title="竜胆01a"></a>竜胆01a</h2><p>◇00000001◇―――時という言葉は―――<br>◆00000001◆―――所谓时间―――</p><p>◇00000002◇―――『とける』とか『とかす』という言葉と似ていると思わない？<br>◆00000002◆―――不觉得和“融化”还有溶解这样的言语相似吗？</p><p>◇00000003◇―――硬く冷たい氷が溶けて流れ出すように。<br>◆00000003◆―――不觉得宛若坚硬冰冷的冰块溶解流淌一般。</p><p>◇00000004◇―――物事がたえず移り変わり、流れていくことを言うのだと思わない？<br>◆00000004◆―――事物在不断迁移变换，流动着吗？</p><p>◇00000005◇―――変わらないで、凍りついたままでいるのは、時が停まっているのと同じ。<br>◆00000005◆―――处于不变之中，持续冰封的状态，直与时间停滞仿佛。</p><p>◇00000006◇―――それは死んでいるのと一緒よ。<br>◆00000006◆―――那与持续死亡是一样的。</p><p>◇00000007◇―――だから―――<br>◆00000007◆―――于是乎―――</p><p>◇00000008◇―――凍りついた私の時を動かして―――<br>◆00000008◆―――驱以被冰封之吾之时间―――</p><p>◇00000009◇―――嘆かないで。<br>◆00000009◆―――勿要叹息。</p><p>◇00000010◇―――哀しまないで。<br>◆00000010◆―――勿要哀伤。</p><p>◇00000011◇―――恐れないで。<br>◆00000011◆―――勿要恐慌。</p><p>◇00000012◇―――なにかが変わってしまったとしても。<br>◆00000012◆―――就算将至何物之改变。</p><p>◇00000013◇―――たとえお互い見失ってしまったとしても。<br>◆00000013◆―――就算目睹彼此之沦丧。</p><p>◇00000014◇―――私はいる。<br>◆00000014◆―――吾永远于此。</p><p>◇00000015◇―――ずっとあなたを待っている。<br>◆00000015◆―――等候汝之到来。</p><p>◇00000016◇―――また、逢いましょう―――<br>◆00000016◆―――再次，逢迎吧―――</p><p>◇00000017◇―――ボォ―――ォ―――ォ―――<br>◆00000017◆―――嘣―――哦―――哦―――</p><p>◇00000018◇―――ンンン―――ンンンン…………<br>◆00000018◆―――嗯嗯嗯―――嗯嗯嗯嗯…………</p><p>◇00000019◇蜜蜂の唸るような旋音が、まだその弾力の深い余韻を工月の耳孔の中に引き残し―――<br>◆00000019◆宛若蜜蜂呢喃的转音，仍旧在工月的耳中，留下富于弹性的余韵―――</p><p>◇00000020◇―――ォ―――ォ―――ンンン―――<br>◆00000020◆―――ォ―――ォ―――ンンン―――</p><p>◇00000021◇―――ンンン―――ンンンン…………<br>◆00000021◆―――ンンン―――ンンンン…………</p><p>◇00000022◇眠りに逃避しようとする彼の意識を縫い止めた。<br>◆00000022◆想要躲避睡意的他，将意识缝补静止。</p><p>◇00000023◇―――ンンン―――ンンンン…………<br>◆00000023◆―――ンンン―――ンンンン…………</p><p>◇00000024◇……ンン……ンンン………………<br>◆00000024◆……ンン……ンンン………………</p><p>◇00000025◇柱時計がどこかで時鐘を鳴らし、機構が巻き戻る音までが{静:せい}{寂:じゃく}を濁らせているのだなと、うとうとと。<br>◆00000025◆不知何处的柱钟敲响了时钟，席卷而来的机器声污浊了静寂，进入浅睡眠。</p><p>◇00000026◇旋音の輪唱も一つ一つと鎮まり、しまいに全き沈黙が立ち返ってきたが、一度破られた眠りはどうあがいても工月の手をすり抜け―――<br>◆00000026◆旋音的轮唱也一阵阵镇定下来，最终万物归寂，不管涌现的睡意如何浓郁，工月都不睡了―――</p><p>◇00000027◇―――ン―――<br>◆00000027◆―――ン―――</p><p>◇00000028◇――――――<br>◆00000028◆――――――</p><p>◇00000029◇なぜ眠りに固執せねばならぬのかという疑念にかられた時、工月はようやく目を覚ました。<br>◆00000029◆此时，怀着为何不得不执着于睡眠的疑问，工月逐渐睁开双眼。</p><p>◇00000030◇覚醒直後の視界は水気が多く焦点がぶれ、はじめはなぜ丸太が頭上にあるのだとどうにも{怪訝:け　げ　ん}だったが、やがてそれが{梁:はり}なのだと思い当たる。<br>◆00000030◆刚苏醒后，眼前有着许多水汽结成的点，刚开始还在惊讶为什么头上有去皮的木材，最后才发现那是房梁。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000031◇（……また随分丈夫そうな造りだな……）<br>◆00000031◆（……还有这样结实的建筑啊……）</p><p>◇00000032◇梁から天井を伝い{欄間:ら　ん　ま}を支える柱も頑丈な屋造り、どれもが艶々と手沢に黒光りしている。<br>◆00000032◆从房梁到天花板，用来支撑栏间的柱子也是兼顾的房屋建筑，无论哪一个都熠熠生辉，散发着经手抛光而有的黑色光泽。</p><p>◇00000033◇敷き布団の綿も暖かで、畳も毛羽立った目などいささかもなく、見事な座敷ではあったが豪奢を押しつけてくるような嫌味はない。<br>◆00000033◆铺设的布团的棉花很温暖，榻榻米也是一尘不染，坐席虽漂亮，但却不显故作奢侈。</p><p>◇00000034◇なのに工月は今まで安らかに抱かれてあった掛け布団が、急に変に蒸し暑く感じられ、自分の息を詰まらせるのではないかという恐怖にかられた。<br>◆00000034◆然而工月在那迄今为止安心地怀抱着的布团上，突然感受到了异常的闷热，他感到恐惧，担心这会让他喘不过气来。</p><p>◇00000035◇布団を蹴り剥がし、まごまごと座敷を見回す。<br>◆00000035◆踢开布团，神思恍惚得回望坐席。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000036◇（ここは―――）<br>◆00000036◆（这个是―――）</p><p>◇00000037◇座敷の調度はやけに巨大に見え、自分へのしかかって押し潰してくるような。<br>◆00000037◆坐席的规模变得十分巨大，开始向着自己拥来。</p><p>◇00000038◇異様な圧迫感にひしがれる工月に、自分が小さな子供に逆戻りしたかのような恐慌が波となって押し寄せる。<br>◆00000038◆工月对此，感受到了异样的压迫感，是否要像小孩子一样调转方向回去的恐惧如同海波一般像他涌来。</p><p>◇00000039◇―――そう、母に手を引いてもらわないと怖くて外にも出られなかったあの頃に。<br>◆00000039◆―――对，就像向母亲伸手却没有应答一般恐怖，那时，出不去外面。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000040◇（いったい―――）<br>◆00000040◆（到底―――）</p><p>◇00000041◇座敷の中に自分以外の誰もいないという孤独がふいごとなって、工月の恐慌をことさらに猛らせるような風を送る。<br>◆00000041◆坐席中除自己外谁都不在，这样的孤独袭来，工月的恐慌愈加强烈，像猛烈的飓风般袭来。</p><p>◇00000042◇なんと恐ろしいのだろう。<br>◆00000042◆这是怎样的恐怖啊。</p><p>◇00000043◇目覚めた時、誰もいてくれないと言うのは。<br>◆00000043◆醒来的时刻，所谓谁都不在身旁。</p><p>◇00000044◇この座敷を隙間なく埋めているこの心細さ、一体誰に抗議すればいいのか判らなくなるほどの心細さに、工月の全身の細胞がてんでばらばらに震え出す。<br>◆00000044◆不给这个坐席留任何死角的谨慎，到了判别不了应该像谁抗争程度的谨慎，工月全身的细胞就像要一粒粒坠落一般。</p><p>◇00000045◇その心細さは喩えるなら、昼とは全く異質の相に様変わりした夜の学校、それも見知らぬ校舎で迷子になった心細さを何倍にも拡大したのに近い。<br>◆00000045◆如果要将这份谨慎作一个比喻，那就是，幻化模样变成了与白天全然为异质相位的夜晚学校，那和将在这座未知校园里迷路的恐惧放大数倍很接近。</p><p>◇00000046◇恐怖は{抗:こう}しようもなく、工月にできることといったら、{強硬症:カ タ レ プ シ ー}を起こした者がするように、背を丸め膝を抱き寄せるくらい。<br>◆00000046◆想与恐惧对抗也没有办法，要说工月能做到的事情的话，就只能像患有强迫症的患者那样，弯着抱膝的程度罢了。</p><p>◇00000047◇己から外界を閉め出して胎児の形に閉じこもろうとした工月の耳に。<br>◆00000047◆将自己以外的世界封闭，化为胎儿的形状的工月的耳朵处。</p><p>☆AAAAAAAA★ ？？？</p><p>◇00000048◇「―――くすっ」<br>◆00000048◆「―――啊啊」</p><p>☆AAAAAAAA★ ？？？</p><p>◇00000049◇「あはは……っ」<br>◆00000049◆「啊哈哈……っ」</p><p>◇00000050◇届いたのは障子戸越しで、座敷の沈黙がなければ聞き逃しそうなほどに{幽:かす}かなものだったが、その声がなければ工月は発狂していたかも知れない。<br>◆00000050◆传达到的是越过了障碍门，那是坐席不陷入沉默就会逃走的细微声响，如果没有那个声音，工月说不定会发狂。</p><p>◇00000051◇かろうじて聴き取った声は、それで体の内側を暖かく安堵させるには至らなかったけれど、ひたすらに退行していこうとする工月に細い糸を垂らした。<br>◆00000051◆艰辛地听到的那声音，虽不至于温暖地安抚身体内部，但向一心想着退缩的工月垂下了一缕细绳。</p><p>◇00000052◇希望に繋がる糸と思われたのは、声に聞き覚えがあったからだった。<br>◆00000052◆之所以认为那是通往希望的线索，那时因为对那个声音感到熟悉。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000053◇（知っている……）<br>◆00000053◆（知道……）</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000054◇（俺は、今の声を知っている……！）<br>◆00000054◆（我，知道刚才那个声音……！）</p><p>◇00000055◇心細さの呪縛にほんの僅かな隙間が開いた。<br>◆00000055◆不安的束缚隙开了细微的裂缝。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000056◇（知っているけれど―――誰だったろうか）<br>◆00000056◆（虽说是知道―――但这是谁呢）</p><p>◇00000057◇物を考えられるようになる、というのはそれだけの余地を頭の中に取り戻すこと。<br>◆00000057◆思考事物，是取回思考余地的唯一办法。</p><p>◇00000058◇ほんの少しだけ思考できる余裕を取り戻した工月は、どうして自分がこんなにも心細いのか、その理由に見当がついたのである。<br>◆00000058◆取回了稍微思考余裕的工月，找到了为什么自己会如此的不安的理由。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000059◇（今の声は、誰だ……そしてここはどこで、なぜ俺はここにいる……！？）<br>◆00000059◆（刚才是声音，是谁……以及这里是哪里，为什么我会在此处……！？）</p><p>◇00000060◇見当がついたのは理由だけ。<br>◆00000060◆寻找到的只有理由。</p><p>◇00000061◇工月の恐怖、心細さは、この座敷がどこで、自分が何故ここにいるのか思い出せないと言う事に拠っていたのだった。<br>◆00000061◆工月的恐惧与不安是由，这个坐席在哪里，自己是因为什么在这里，这样的事情想不起来了导致的。</p><p>◇00000062◇いきなり見知らぬ世界に放り出された赤子の根源的な恐怖に等しく、唯一の救いは自分が何者であるのか、それだけは判っていると言うこと。<br>◆00000062◆与突然之间被流放到了未知世界的婴儿的根源性的恐怖对等，唯一的救赎就是自己到底是谁，唯有这件事是能够判别的。</p><p>◇00000063◇その点だけがまだ自我さえ構築できていない赤子と違うが、状況が判らないことにかけては赤子と同じ。<br>◆00000063◆只有这一点和仍然连自我都不能构筑的婴儿不同，但与不能判别状况的婴儿相同。</p><p>☆AAAAAAAA★ ？？？</p><p>◇00000064◇「―――くすす」<br>◆00000064◆「―――くすす」</p><p>☆AAAAAAAA★ ？？？</p><p>◇00000065◇「ふふ……」<br>◆00000065◆「ふふ……」</p><p>◇00000066◇また声が、声ばかりが聞こえた。<br>◆00000066◆又是那个声音，只有那个声音能听见。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000067◇（―――！）<br>◆00000067◆（―――！）</p><p>◇00000068◇いや、救いはもう一つあった。<br>◆00000068◆不对，救赎还有一个。</p><p>◇00000069◇今の声だ。<br>◆00000069◆就是刚才的声音。</p><p>◇00000070◇その声に聞き覚えがあるということだ。<br>◆00000070◆那个声音我有听过的记忆。</p><p>◇00000071◇溺れる者は藁にもすがると言って、状況に窮じた人間があてにもならない物を必死に追い求める様を喩えるが、今の工月がまさにそれ。<br>◆00000071◆俗话说溺水之人连稻草也会抓住，形容在绝境之中拼命追寻哪怕是没用的东西，此时的工月正是如此。</p><p>◇00000072◇{掴:つか}んだ蜘蛛の糸が伸びきってちぎれてしまうのを恐れるように、工月は声がどこから聞こえてきたのか判らなくなる前に必死で当りをつける。<br>◆00000072◆工月拼命地试图确定声音的来源，正如他害怕手中紧握的蜘蛛丝会被拉断一样，他生怕在找到声音的来源之前就迷失了方向。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000073◇（こっちからだ……っ）<br>◆00000073◆（这边……っ）</p><p>◇00000074◇いったい音というものは、少しでも遮蔽があれば反響でたちどころに源が怪しくなるものだが、今それを言いたてて{躊躇:た　め　ら}えばきっと動き出せなくなる。<br>◆00000074◆声音这种东西，只要有一点遮蔽，就会因为回响而难以确定源头，可是如果现在因为这个犹豫不决，恐怕就再也无法行动了。</p><p>◇00000075◇疑念が自分をがんじがらめにする前に、工月は声が響いてきたとおぼしき障子戸を繰り開けた。<br>◆00000075◆在疑虑将自己束缚住之前，工月迅速拉开了那扇他认为声音传来的障子门。</p><h2 id="竜胆01b"><a href="#竜胆01b" class="headerlink" title="竜胆01b"></a>竜胆01b</h2><p>◇00000001◇工月の足取りは著しく乱れ、心臓は追いかけ回された獲物のように激しく動悸し、破裂しそうなほどのありさま。<br>◆00000001◆工月的脚步变得混乱非凡，心脏宛若被角逐的猎物一般悸动，到了像是要破裂的程度。</p><p>◇00000002◇ここまで彼を追い立てる恐怖というのは、はじめは確かにこの広い座敷に一人きりという心細さだったのだが。<br>◆00000002◆迄今为止追赶工月的恐怖最初确实是，这宽敞房间中独自一人的不安。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000003◇（なぜ―――なぜ追いつけない！？）<br>◆00000003◆（为何———为何不追赶上来！？）</p><p>◇00000004◇もう何度も声のすぐそばまで迫った。<br>◆00000004◆声音已然不知何次，协迫到了身边。</p><p>◇00000005◇今度こそと、もう何度猛然と{襖:ふすま}を開けたろう。<br>◆00000005◆这次才是，已经不知推开了几次拉门。</p><p>◇00000006◇その都度無人の部屋が工月を出迎えた。<br>◆00000006◆每次推开都是空无一人的房间迎接工月。</p><p>◇00000007◇二度、三度それをやられるうちは怒りが工月を突き動かしたのだが、度を超して打ち続くとなると怒りは冷える。<br>◆00000007◆两次，三次被玩弄，工月怒不可遏，三番五次的戏弄浇灭了工月的怒火。</p><p>◇00000008◇怒りが収まれば心細さが再び頭をもたげ、手に負えないことに別の恐怖まで引きつれてきていた。<br>◆00000008◆平息怒气不安再度袭来，招至不输当前的以外的恐怖。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000009◇（ついさっきまで、ほんの数瞬―――いや一瞬前まで間違いなくいた筈なんだ、なのに……）<br>◆00000009◆（截止刚才，在数秒之间———不对，是一瞬间，那明明还在的，但是……）</p><p>◇00000010◇恐怖は疲労を倍加させるし気力も奪う。<br>◆00000010◆恐惧倍增疲劳，夺走了体力。</p><p>◇00000011◇工月は途方に暮れ、ついに廊下にへたりこむ。<br>◆00000011◆工月陷入了穷途末路，瘫坐于走廊。</p><p>◇00000012◇こうして全ての気概を使い果たし、立ちあがる事もできなくなる。<br>◆00000012◆如此竭尽全身气力，已然不能站起。</p><p>◇00000013◇後はこの薄暗い廊下で、干からびていくだけ。<br>◆00000013◆随后只能于这昏暗走廊中，干涸然后逝去。</p><p>◇00000014◇工月が最期の息を虚空に放つ瞬間、廊下の両脇の扉が一斉に開き、無数の顔が突きだされてきて嘲笑うのではないか。<br>◆00000014◆在工月将最后的吐息，朝向虚空的时刻，廊道两侧的门倏忽齐齐洞开，无数的脸庞，探出门外，宛作揶揄模样。</p><p>◇00000015◇ぞっとしたが疲労で手足が鈍くなっているのも事実であり、少し休まないことには本当にこの長大な廊下に途中で行き倒れにもなりかねない。<br>◆00000015◆虽确感一丝寒意，但因疲劳，手脚迟钝。若不适作休息，恐怕真会在这漫长走廊上中途倒下。</p><p>◇00000016◇少し休息をとり、体力を回復させないことにはと、座りこんで{襖:ふすま}に寄り掛かろうとした、ら。<br>◆00000016◆思索着，定要稍作休息，回复体力，于是支起身子，想靠于拉门，结果……。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000017◇「……わあ！？」<br>◆00000017◆「……哇啊！？」</p><p>◇00000018◇バランスが崩れて視界が流れた。背中を預けようとした{襖:ふすま}が前触れなく開いたのだからたまらない。<br>◆00000018◆平衡崩塌，视线模糊。预先准备靠在背后的拉门，结果拉门毫无预兆地打开，是时手足无措。。</p><p>◇00000019◇見事に透かされもんどりうって仰向けの、天井を睨むことになった工月の視界をひょいと覗いた顔がある。<br>◆00000019◆工月靠门未果，结实摔倒于走廊，仰面朝天，凝视天花板，倏忽，有一人脸，现于工月面前。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000020◇「秋成？　なにしてるのよこんな廊下で」<br>◆00000020◆「秋成？　在走廊里做什么呢」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000021◇「寝る場所ならこの通り、いくらでもお座敷があるのに、なにもこんな硬い廊下を選ばなくってもいいじゃない」<br>◆00000021◆「明明这里有那么多房间可以睡觉，为什么偏偏选择这么硬的走廊呢」</p><p>◇00000022◇大学の構内で挨拶を交わすような全く自然な物言いに、工月はなにも自分が寄り掛かったタイミングを見計らうように{襖:ふすま}を開けずとも、と憤然となる。<br>◆00000022◆对方用一种就像在大学校园里打招呼一样自然的语气说话，这让工月感到愤怒。他心想，根本不需要故意在我靠上去的那一刻打开拉门。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000023◇「ご挨拶だなッ。君はもしかして俺が寄り掛かる隙をこっそり{窺:うかが}っていたんじゃなかろうな麻子ッ」<br>◆00000023◆「真是好一套招呼啊！麻子，你不会是在偷偷窥伺我什么时候靠上去的吧」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000024◇「―――？」<br>◆00000024◆「―――？」</p><p>◇00000025◇驚きは、一拍遅れてやってきた。<br>◆00000025◆惊讶来得稍微迟了一拍。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000026◇「あさ、こ―――？」<br>◆00000026◆「あさ、こ―――？」</p><p>◇00000027◇長く口にしていなかったように、麻子の名を口の中で転がしてその響きを確かめる。<br>◆00000027◆还未叫出那个，麻子的名字就辗转着从口中传出，确认着那个回响。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000028◇「……なんで人をそんな目で見るかなあ」<br>◆00000028◆「……为什么要用那种眼神看别人啊」</p><p>◇00000029◇彼女はつい先程別れたような口調だったが、工月の脳裏に―――<br>◆00000029◆她用着与之前不同的语气，在工月的脑内―――</p><p>◇00000030◇麻子の顔を見たのがきっかけとなって、溢れ出す記憶があった。<br>◆00000030◆以看见麻子的脸为契机，有记忆涌现了出来。</p><p>◇00000031◇記憶が次々と、工月を突き抜けていく。<br>◆00000031◆记忆依涌入工月的脑海。</p><p>◇00000032◇だがそれなのに、そういうことが確かにあったのだと断片的に思い出されるばかり。<br>◆00000032◆就算如此，也净是那些记忆也确实存在般断片的回忆。</p><p>◇00000033◇それらの記憶を貫くはずの物語がどうしても思い出せないのだった。<br>◆00000033◆为什么连贯的记忆的故事无论如何也回忆不起来呢。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000034◇「ちょっと……どうしたの本当に？　倒れた拍子に頭でも打った？」<br>◆00000034◆「等一下……怎么了真的吗？在倒下的时候撞到脑子了？」</p><p>◇00000035◇麻子と共有した物語は、目覚めて思い出せない夢のように哀しく{儚:はかな}いものだったと、そのイメージばかりが工月の喉を熱くする。<br>◆00000035◆与麻子共同经历的故事，像记得但却回忆不起的梦境一般哀伤，只有印象让工月的喉咙感到一阵热意。</p><p>◇00000036◇なのに麻子の方は、まるで何事もなかったように工月に接している。<br>◆00000036◆然而对于麻子，就像什么事情都没有发生一样对待工月。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000037◇「麻子……君なのか、本当に？」<br>◆00000037◆「麻子……吗，真的吗？」</p><p>◇00000038◇……にわかに麻子が不安そうに眉根を曇らせた。<br>◆00000038◆……麻子突然眉头紧蹙，感到不安。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000039◇「あああ……やっぱり頭打ったんだ……っ」<br>◆00000039◆「啊啊啊……果然是撞到头了吗……っ」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000040◇「秋成、あのね、これは何本！？」<br>◆00000040◆「秋成，那个，这是几根手指！？」</p><p>◇00000041◇工月の前に人差し指と中指を立てて突きだす、表情はあくまで真剣そのもの。<br>◆00000041◆在工月的面前伸出食指和中指，表情依旧严肃认真。</p><p>◇00000042◇釣りこまれるように『二本』と素直に答えてから工月は。<br>◆00000042◆在是被引导一般，直接回答“两根”之后。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000043◇「どこも打ってはいないぞっ」<br>◆00000043◆「什么地方也没打到哦」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000044◇「わあ！」<br>◆00000044◆「哇啊！」</p><p>◇00000045◇そこで麻子が上手く頭を引っこめなかったら、猛然と起きあがった工月の額に鼻筋を強打されていたことだろう。<br>◆00000045◆如果麻子当时没能及时把头缩回去，猛然坐起的工月的额头就会被她的鼻梁撞到。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000046◇「ただ俺は、君達を捜していただけなんだっ」<br>◆00000046◆「我只是想找你们而已」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000047◇「起きてみれば、このだだっ広い屋敷に俺一人」<br>◆00000047◆「醒来时发现这个大宅子里只有我一个人」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000048◇「不安になって捜し回っても仕方ないと思わないか！？」<br>◆00000048◆「不觉得不安到到处找也没什么用吗！？」</p><p>◇00000049◇と真剣そのものの工月なのに、麻子の眼差しに浮かんだ輝きは、猫が格好の遊び相手を見つけた時のそれ。<br>◆00000049◆尽管工月非常认真，麻子眼中的光辉却像是猫发现了一个理想的玩伴。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000050◇「へえ……不安だったんだ、秋成が」<br>◆00000050◆「哎……秋成竟然不安了」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000051◇「あ。なんだその目は。そのいかにも『獲物を見つけました』って目は」<br>◆00000051◆「啊。那是什么眼神？那种一看就像是‘发现了猎物’的眼神」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000052◇「日頃から冷静沈着を旨としている秋成が、ねえ」<br>◆00000052◆「一向冷静沉着的秋成，真是」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000053◇「起きてみると一人っきりで、さびしいのが我慢できなくて、お屋敷の中駆けずり回ってたんだぁ……」<br>◆00000053◆「醒来时发现自己一个人，忍受不了寂寞，到处在大宅子里跑来跑去……」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000054◇「……ぐ」<br>◆00000054◆「……呜」</p><p>◇00000055◇余計な弱みを見せてしまったと後悔したところでもう遅い。<br>◆00000055◆已经为露出了不必要的弱点而感到后悔，但已经为时已晚。</p><p>◇00000056◇麻子はらんらんと目を輝かせ、それは楽しそうに工月をからかおうと唇を吊り上げて笑みを浮かべ―――<br>◆00000056◆麻子眼中闪耀着光芒，嘴角上扬，准备开心地逗弄工月——</p><p>◇00000057◇しかし、ふっとすぐに真顔に戻る。<br>◆00000057◆但她很快就恢复了严肃的表情。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000058◇「……ごめんね」<br>◆00000058◆「……对不起」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000059◇「え……あ……？」<br>◆00000059◆「嗯……啊……？」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000060◇「秋成、よく眠ってたみたいだったし、起こすのも悪いかなって思ったんだ」<br>◆00000060◆「秋成，你似乎睡得很香，我觉得叫醒你可能不好」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000061◇「だから声も掛けなかったんだけど……」<br>◆00000061◆「所以我没有叫你……」</p><p>◇00000062◇眼差しに浮かべていたのは、まぎれもなく懸念と申し訳なさ。<br>◆00000062◆她眼中浮现的毫无疑问是关切和歉意。</p><p>◇00000063◇それで工月の中の強ばっていた気持ちがいっぺんに溶けた。<br>◆00000063◆这使得工月心中僵硬的情感瞬间融化。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000064◇「いや……別にいいんだ。考えてみれば俺の方も、そんなに焦るほどの事ではなかったわけだし」<br>◆00000064◆「不……没关系。仔细想想，我也不必那么焦虑」</p><p>◇00000065◇考えてみれば捜していた相手に会えたと言うことには変わりない。<br>◆00000065◆毕竟，能见到一直在寻找的人也没错。</p><p>◇00000066◇ただ―――今のやりとり一つをとっても、自分がこの麻子と近しい間だったというのは判るのだが、なにかそれ以上のことがあったような。<br>◆00000066◆只是——从现在的对话中，我能感受到自己与麻子的关系是如此亲近，但似乎还有更深层次的东西存在。</p><p>◇00000067◇物足りなさが、古い傷のように疼いた。<br>◆00000067◆这种不满足感像旧伤一样隐隐作痛。。</p><h2 id="竜胆01c"><a href="#竜胆01c" class="headerlink" title="竜胆01c"></a>竜胆01c</h2><p>◇00000001◇縁側に腰かけ、ぽぉんぽぉんと宙に舞う{袱:ふく}{紗:さ}の玉を眺めるともなしに眺める。<br>◆00000001◆坐在走廊边，漫不经心地看着袱纱的球在空中轻轻飘舞。</p><p>◇00000002◇麻子に連れられて差しかかった通り土間には、二つの小柄な影。<br>◆00000002◆麻子带着（某人）走到的通道土间上，有两个小小的影子。</p><p>◇00000003◇麻子と再会した時ほどの衝撃はなかったけれど、それでも工月は深い安堵に、肩のあたりにわだかまっていた{靄:もや}が薄れるのを感じた。<br>◆00000003◆虽不及再逢麻子时的冲击，但工月却深感安慰，肩边郁积的雾霭也随之雾散。</p><p>◇00000004◇もっとも双子の方は、工月がいることがさも当たり前のように、ちょっと頭を下げただけ。<br>◆00000004◆对于双胞胎，工月的存在本来就仿若理所当然，她俩略微颔首。</p><p>◇00000005◇―――親しげな笑みを口元にたまらせてはいたけれど。<br>◆00000005◆―――虽然在嘴角挤出了亲切的笑容。</p><p>☆AAAAAAAA★ 伊美</p><p>◇00000006◇「じゅうごやのよるに」<br>◆00000006◆「仿若十五夜一般」</p><p>◇00000007◇伊美の手から綺麗に縫われたお手玉が、二つ、三つと宙に投げられる様子が軽やかだった。<br>◆00000007◆伊美亲手缝制的手玉，两枚、三枚地向空中投掷的模样略显轻巧。</p><p>☆AAAAAAAA★ 斎</p><p>◇00000008◇「つきみぬやつは」<br>◆00000008◆「未赏月的家伙」</p><p>◇00000009◇かたわれの歌の端を継いで、斎もお手玉を投げ上げる。<br>◆00000009◆支离的歌曲继续，斋也将手玉投掷。</p><p>◇00000010◇その手さばきは余りにも巧みで、お手玉は宙にある間だけ生命を得ているようだ。<br>◆00000010◆那副动作游刃有余地精巧，手玉只有在空中的时刻，才像获得了生命一般。</p><p>☆AAAAAAAA★ 伊美</p><p>◇00000011◇「じごくのおにめが」<br>◆00000011◆「地狱的鬼眼在」</p><p>☆AAAAAAAA★ 斎</p><p>◇00000012◇「きねでつく」<br>◆00000012◆「杵打」</p><p>☆AAAAAAAA★ 伊美</p><p>◇00000013◇「あ、しょっぱいな」<br>◆00000013◆「啊，咸」</p><p>☆AAAAAAAA★ 斎</p><p>◇00000014◇「しょっぱいな」<br>◆00000014◆「苦咸」</p><p>◇00000015◇二人の戯れ歌は糸車から繰り出すように{澱:よど}みなく、それに誘われたように工月の記憶も解けていく。<br>◆00000015◆两人的戏曲像从纺车编织出来一般沉降，如同被它们引诱了一般，工月的记忆也解放了。</p><p>◇00000016◇ただその記憶も、麻子の時と同じようにとぎれとぎれで、本当はこの双子とも、もっともっと深い時間を経てきた筈なのに、どうしても届かない。<br>◆00000016◆只是那份记忆也，和麻子那时一样短短续续，事实上双胞胎，明明应当历经了愈加长久的时间，但无论如何也传达不到。</p><p>◇00000017◇その記憶は多分に凄惨なものであるのに、どこか艶めかしく官能的な―――<br>◆00000017◆明明那份记忆大部分是凄惨的，但是哪里缺娇艳诱人―――</p><p>◇00000018◇伊美は掌で操っていたお手玉を、宙にあるうちに手を返して今度は甲で受け、跳ね上げる。<br>◆00000018◆伊美将手里掌握的手玉悬空之时，将手收回，这次用甲来接受，跳跃而起。</p><p>◇00000019◇斎は負けじと右手と左手を交差させ、それでなにも差し支えなくお手玉を舞わせているのだからさすがだ。<br>◆00000019◆斋将左右手交错负背，就这样不用任何事物接来舞动手玉，不愧是她啊。</p><p>◇00000020◇この域に達するまで、二人はよほど同じ遊びを繰り返したことだろう。<br>◆00000020◆抵达这个领域前，两人如此这般，重复一样的游戏。</p><p>◇00000021◇対して麻子の方はといえば。<br>◆00000021◆对于麻子这边的话。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000022◇「……むっ。……よっ。……はっ！」<br>◆00000022◆「……唔。……喲。……哈！」</p><p>◇00000023◇掛け声ばかりは勇ましいが、お手玉二つを回すのにも苦戦している様子、双子の{袂:たもと}が小鳥のように軽く舞うのに比べて麻子の{袂:たもと}はまだまだ雛の手習い。<br>◆00000023◆但是念咒就算勇敢了，但是将手玉来回抛掷也算苦战，与仿若小鸟一般轻盈飞舞的双胞胎的裙摆相比，麻子的裙摆还只是雏鸟的练习。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000024◇「……って、ああもう、もどかしいっ」<br>◆00000024◆「……真是的，啊，太令人着急了」</p><p>◇00000025◇ちょっと拍子を早くしただけで、あっさり爪の先で弾いて土間にころころと、工月は足元に跳ねてきたそれを麻子に放ってやる。<br>◆00000025◆虽然时机还尚早，果断地将指尖在土间弹来弹去，工月将其从脚尖向麻子发射。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000026◇「苦戦してるようだな。慣れないことはあんまりするものじゃないぞ」<br>◆00000026◆「貌似是一场苦战呢。做了太多不熟悉的事情了。」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000027◇「そりゃあ、あたしにこういうのは向いてないってわかるけど」<br>◆00000027◆「那个，虽然我也知道不应该参与进来的」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000028◇「でもこの子たちがこんなに上手にしてるのを見ると、ついあたしもって気になって」<br>◆00000028◆「但是看到她们如此得熟练，就此我也变得在意起来了。」</p><p>◇00000029◇めげずに再びお手玉に挑む麻子を、双子は敢えて手も出さずに見守っている。<br>◆00000029◆不认输的麻子再次将手玉挑起，双胞胎故意不出手只是守望着她。</p><p>◇00000030◇こういうのは自分の手で自分に覚えさせるのが一番とよく判っているのだろう。<br>◆00000030◆这种事情最好自己上手才能熟悉。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000031◇（穏やかな情景だ……）<br>◆00000031◆（安稳的情景……）</p><p>◇00000032◇工月もまた、娘達の手遊びにはそれ以上の差し出口を挟まずに、眺めさせてもらうだけで良しとする。<br>◆00000032◆工月仍然，不能对女孩们的游戏过多地插嘴，只好眺望着她们。</p><p>◇00000033◇古い時代の正月の過ごし方を見るような、しみじみとした郷愁を覚えているのは、娘たちが皆それぞれに色とりどりの振り袖姿だからだろう。<br>◆00000033◆仿若在见识古老时代正月的度过方式一般，深情地忆起乡愁，大概是因为女孩们各自袖姿五彩缤纷的舞动吧。</p><p>◇00000034◇双子や麻子が手遊びに耽る様子は、工月の心を穏やかに鎮め、もうずっと昔からこうしてこの屋敷で過ごしているような気持ちになってくる。<br>◆00000034◆双胞胎与麻子沉浸在手的游戏的样子，使得工月的心镇定，就像很久以前就住在这座宅邸一般。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000035◇「てや……っ。……うう、やっぱりあたし、こういうの苦手～～」<br>◆00000035◆「唉……。……呜呜，果然我，不擅长这些」</p><p>◇00000036◇今度は二ついっぺんに取り落とし、さすがに麻子も飽きてきたのか、それ以上は続けようとせずに立ちあがって腰の埃と一緒に手遊びへの執着も払う。<br>◆00000036◆现在两枚手玉突然坠落，果然连麻子也厌倦了吗，不继续游戏转而站起，将腰间的尘土与一起游戏的执着拂去。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000037◇「もうおしまいか？」<br>◆00000037◆「已经结束了吗？」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000038◇「すぐに上達するもんじゃないしね」<br>◆00000038◆「这不是马上就提升了吗」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000039◇「それにもうすぐ晩御飯だから、紫織さんの手伝いもしないと」<br>◆00000039◆「话说回来，马上就要吃晚饭了，紫织小姐也不传达消息」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000040◇「紫織さん―――」<br>◆00000040◆「紫织小姐―――」</p><p>◇00000041◇麻子から聴かされれば意外な響きのその名も、工月自身が口にしてみれば優しい姉に抱くような信頼を伴って据わりがいい。<br>◆00000041◆从麻子那里听闻的一个意外有响度的名字，从工月自己嘴里说出来的话，会有仿若被温柔的姐姐拥抱一般的信赖陪伴，坐立心安。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000042◇（そうだ―――彼女だっているんだ）<br>◆00000042◆（对啊―――她也在）</p><p>◇00000043◇伊美と斎、麻子が戯れる様子を間近にしながら、どこかしら足りない姿があるように思えて目で捜していたのは彼女なのだった。<br>◆00000043◆伊美、斋还有麻子的嬉戏的样子在眼前时，不知何处有着不满足的身姿一般，神思片刻，凝目巡查，正是在寻找她。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000044◇「秋成は座敷で待ってて」<br>◆00000044◆「秋成在宅邸等候着」</p><p>◇00000045◇土間に続きの台所に下がっていく麻子の後ろ姿に、何百年もこの屋敷にこうして住んでいたような安定感を見て、工月はほっと溜息をつく。<br>◆00000045◆延续到了土间的厨房，麻子的背影向下，目睹仿若居于此屋数百年之安定，工月深叹一息。</p><p>◇00000046◇きっと自分はこうして{那:な}{越:ごし}の女達と、ずっと一緒に暮らしてきたのではないか。<br>◆00000046◆自己定然将同女孩们，就如此，一直一起生活吧。</p><p>◇00000047◇そう思うのが、一番収まりが良さそうなのに。<br>◆00000047◆虽是如此思索，但还是最为收敛为妙。</p><p>◇00000048◇どうしてか工月は、座りこんだ縁側が軟泥と化して自分が呑みこまれていくような、そんな{儚:はかな}さを感じていた―――<br>◆00000048◆为什么呢，工月感受到了如此的梦幻，坐卧的走廊，化为软泥，仿佛要将自我裹挟―――</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;竜胆01a&quot;&gt;&lt;a href=&quot;#竜胆01a&quot; class=&quot;headerlink&quot; title=&quot;竜胆01a&quot;&gt;&lt;/a&gt;竜胆01a&lt;/h2&gt;&lt;p&gt;◇00000001◇―――時という言葉は―――&lt;br&gt;◆00000001◆―――所谓时间―――&lt;/p&gt;
&lt;p&gt;◇00</summary>
      
    
    
    
    
    <category term="汉化" scheme="http://example.com/tags/%E6%B1%89%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>算法：双指针</title>
    <link href="http://example.com/2024/08/15/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>http://example.com/2024/08/15/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2024-08-15T06:57:01.000Z</published>
    <updated>2024-08-19T06:05:15.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>数组其实是一个连续的内存空间，删除元素的基本原理是</p><ul><li>空间不变</li><li>计数方法会进行包装</li></ul><h3 id="erase函数"><a href="#erase函数" class="headerlink" title="erase函数"></a>erase函数</h3><p>在vector这个模板里面，就算使用了erase函数，原本申请的数组所占有的内存也是不发生变化的。</p><table><thead><tr><th>a[0]</th><th>a[1]</th><th>a[2]</th><th>a[3]</th><th>a[4]</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>1</td><td>2</td><td>3</td><td>5</td><td>5</td></tr></tbody></table><blockquote><p>删除4元素的原理，就是删除将下一位的元素那进来补位，然后通过某些手段，屏蔽接下来的元素，这样就可以形成一个新的数组</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void erase(&amp;a,int b)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]==b)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[j-1]=a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">复杂度O(i+(n-i))=O(n)</span><br></pre></td></tr></table></figure><h3 id="库函数的使用"><a href="#库函数的使用" class="headerlink" title="库函数的使用"></a>库函数的使用</h3><p>过于简单的题目（能用库函数一次解决的），就不要用库函数</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><blockquote><p>其实就是牺牲空间，获取时间，原理是这样的，我们采用额外的空间，比如再声明一个数组，这样一个数组有了之后，我们就可以采用快慢指针的方法，快指针的作用很简单，就是用于遍历数组中的所有元素，而慢指针的作用在于标度待删除元素的存在，确认数组在最后拥有的数组大小。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delete element(&amp;a,int b)</span><br><span class="line">&#123;</span><br><span class="line">int slow=0;</span><br><span class="line">vector&lt;int&gt;a_1;</span><br><span class="line">for(int fast=0;fast&lt;a.size();fast++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[fast]!=b) slow++;</span><br><span class="line">&#125;</span><br><span class="line">return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是快慢指针"><a href="#什么是快慢指针" class="headerlink" title="什么是快慢指针"></a>什么是快慢指针</h4><p>快慢指针是双指针算法中的一种。不同于左右对撞指针，快慢指针中的两个指针是从同一侧但以不同的策略移动的指针。因此，两个指针中会有一个移动较快的快指针（fast）和一个较慢的慢指针（slow）。当快指针移动到数组的顶端时，停止遍历或进行新一轮遍历。</p><h4 id="为什么要用快慢指针"><a href="#为什么要用快慢指针" class="headerlink" title="为什么要用快慢指针"></a>为什么要用快慢指针</h4><p>使用双指针最实在的好处在于，我们的快指针相当于一个探路侠，它每走一步就会给予慢指针一个信息，让慢指针完成它的一部分工作，这样尽量让两个指针分工操作。</p><p>快指针的工作在前面进行，而快指针完成工作之后，对于它本身信息的传递，其实是不消耗空间，也不消耗时间的。我们可以利用信息的充分化利用，使得两个指针能干更多有意义的事情。</p><h4 id="快慢指针是怎么用的"><a href="#快慢指针是怎么用的" class="headerlink" title="快慢指针是怎么用的"></a>快慢指针是怎么用的</h4><ul><li>链表：在链表中，链表往往是单向链表，这个时候使用快慢指针，让它们朝着同一个方向进行迭代。</li><li>数组：数组利用的是索引的只是，在return值里面使用索引，便可以返回对应长度数组的值。</li></ul><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul><p><strong>用户评测：</strong></p><p>评测机将使用以下代码测试您的解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int val = ...; // 要移除的值</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的预期答案。</span><br><span class="line">                            // 它以不等于 val 的值排序。</span><br><span class="line"></span><br><span class="line">int k = removeElement(nums, val); // 调用你的实现</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">sort(nums, 0, k); // 排序 nums 的前 k 个元素</span><br><span class="line">for (int i = 0; i &lt; actualLength; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有的断言都通过，你的解决方案将会 <strong>通过</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2,_,_]</span><br><span class="line">解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。</span><br><span class="line">注意这五个元素可以任意顺序返回。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h3 id="题解（双指针）"><a href="#题解（双指针）" class="headerlink" title="题解（双指针）"></a>题解（双指针）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val)</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以联想为两排数组，快指针的那排数组具有元素，当快指针找到不是val的值的时候，就把这个值丢给慢指针，反之则不丢，最后慢指针在的那个数组中，去除了所有的目标元素。</p><p><img src="https://p.sda1.dev/18/496fb1149023399a4fb0163b1520cb4b/B7EC9CA94D6DF2BEB4E92654E268692E.png"></p><h4 id="硬解"><a href="#硬解" class="headerlink" title="硬解"></a>硬解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 相向双指针⽅法，基于元素顺序可以改变的题⽬描述改变了元素相对位置，确保了移动最少元素</span></span><br><span class="line"><span class="comment">* 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">* 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> leftIndex = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> rightIndex = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (leftIndex &lt;= rightIndex) &#123;</span><br><span class="line"><span class="comment">// 找左边等于val的元素</span></span><br><span class="line"><span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[leftIndex] != val)&#123;</span><br><span class="line">++leftIndex;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 找右边不等于val的元素</span></span><br><span class="line"><span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[rightIndex] == val) &#123;</span><br><span class="line">-- rightIndex;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 将右边不等于val的元素覆盖左边等于val的元素</span></span><br><span class="line"><span class="keyword">if</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">nums[leftIndex++] = nums[rightIndex--];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">return</span> leftIndex; <span class="comment">// leftIndex⼀定指向了最终数组末尾的下⼀个元素</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><p><strong>判题标准:</strong></p><p>系统会用下面的代码来测试你的题解:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2,_]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li></ul><p>​我们来分析删除元素这个算法的原理，首先我们给定的一个数组它是严格递增的，在这里我们需要把重复的元素都删掉，然后返回整个数组的长度，可以看到我们这边是使用了一个快慢指针的方法，一个慢指针，一个快指针。</p><p>​这里基本的思路是，如果说就是快指针和慢指针所指的两个数它相同的话。那么就只有快指针向前走一步，慢指针不动。在这里我们可以举一个例子，假如说嗯，这时候有三个相同的元素卖指针已经指向了第1个元素，而会计证指向的是第2个元素，这时候进行一步操作。因为这两个指针指向的元素的值是相同的，所以说慢指针不动，然后快指针向前走一步。</p><p>​接下来继续操作，这个时候慢指针指向了第1个元素，然后快指针指向了第3个元素。因为这个时候会计证和慢指针的值还是相同的，所以说慢指针不动，快指针继续前进。这个时候快指针已经指向了和慢指针不同的元素。这个时候循环继续，因为快指针和慢指针它指向的元素已经不同了，所以说慢指针和快指针都向前走一步。而我们的操作中，当慢指针和快指针它们的值不同的时候，我们会将快指针的值赋给慢指针。</p><p>​所以说慢指针，它最后会走的步数是。数组中不同元素的个数，而慢指针它本身的一个值是索引，所以说我们在计算数组长度的时候需要返回就是慢指针它的值，加上一个1。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">1</span>; fast &lt; nums.<span class="built_in">size</span>(); fast = fast + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] != nums[fast])</span><br><span class="line">                nums[++slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://p.sda1.dev/18/0310a04d7db7eb8d955b8c89eca22e95/0DEE598ED87C4D5522F12F9FD0F44B2C.png"></p><ul><li><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li></ul><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[l],s[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="双指针底层"><a href="#双指针底层" class="headerlink" title="双指针底层"></a>双指针底层</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=s[l];</span><br><span class="line">            s[l]=s[r];</span><br><span class="line">            s[r]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="LCR-122-路径加密"><a href="#LCR-122-路径加密" class="headerlink" title="LCR 122. 路径加密"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">LCR 122. 路径加密</a></h3><p>假定一段路径记作字符串 <code>path</code>，其中以 “<code>.</code>“ 作为分隔符。现需将路径加密，加密方法为将 <code>path</code> 中的分隔符替换为空格 “<code> </code>“，请返回加密后的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;a.aef.qerf.bb&quot;</span><br><span class="line"></span><br><span class="line">输出：&quot;a aef qerf bb&quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= path.length &lt;= 10000</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">pathEncryption</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fast=<span class="number">0</span>,slow=<span class="number">0</span>;fast&lt;path.<span class="built_in">size</span>();fast++,slow++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(path[fast]==<span class="string">&#x27;.&#x27;</span>) path[slow]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原地修改</p><h3 id="剑指Offer-05-替换空格"><a href="#剑指Offer-05-替换空格" class="headerlink" title="剑指Offer 05.替换空格"></a>剑指Offer 05.替换空格</h3><p>请实现⼀个函数，把字符串 s 中的每个空格替换成”%20”。 </p><p>示例 1： </p><p>输⼊：s &#x3D; “We are happy.” </p><p>输出：”We**%20<strong>are</strong>%20**happy.” </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计空格的个数</span></span><br><span class="line"><span class="type">int</span> sOldSize = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 扩充字符串s的⼤⼩，也就是每个空格替换成&quot;%20&quot;之后的⼤⼩</span></span><br><span class="line">s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> sNewSize = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 从后先前将空格替换为&quot;%20&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = sNewSize - <span class="number">1</span>, j = sOldSize - <span class="number">1</span>; j &lt; i; i--, j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">s[i] = s[j];</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">s[i - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">s[i - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">i -= <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="拓展：字符串和数组的区别"><a href="#拓展：字符串和数组的区别" class="headerlink" title="拓展：字符串和数组的区别"></a>拓展：字符串和数组的区别</h3><p>C&#x2F;C++中的字符串以’\0’作为结束的标志</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">5</span>] = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; a[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++中，string类中会给我们提供size接口，这可以用来判断string类字符串是否结束，可以避免’\0’的使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string a = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector<char>和vector<string>的区别是string类中重载了一些运算符，在处理字符串的时候会显得更加方便。</string></char></p><h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p><h4 id="自己的思路"><a href="#自己的思路" class="headerlink" title="自己的思路"></a>自己的思路</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; s1;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        a.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//左边隔板的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;a.<span class="built_in">push_back</span>(i);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录中间隔板的位置</span></span><br><span class="line">        a.<span class="built_in">push_back</span>(s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">//右边界隔板的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!a.<span class="built_in">size</span>()) <span class="keyword">return</span> s;</span><br><span class="line">            <span class="comment">//单个单词直接返回</span></span><br><span class="line">            s1.<span class="built_in">push_back</span>(s.<span class="built_in">begin</span>()+a[i]+<span class="number">1</span>,s.<span class="built_in">begin</span>()+a[i+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//左隔板前移动一位，右隔板后移一位，切出一个单词</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s1.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;r;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s1[l],s1[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        string s2=s1[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//左右指针将单词反转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s1.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s2+=<span class="string">&#x27; &#x27;</span>+s1[i];</span><br><span class="line">        &#125;<span class="comment">//利用占头部的方式消除前置零</span></span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123; <span class="comment">//翻转，区间写法：左闭又闭 []</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;<span class="comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;   <span class="comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//遇到非空格就处理，即删除所有空格。</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//补上该单词，遇到空格说明单词结束。</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow); <span class="comment">//slow的大小即为去除多余空格后的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s); <span class="comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i - <span class="number">1</span>); <span class="comment">//翻转，注意是左闭右闭 []的翻转。</span></span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">//更新下一个单词的开始下标start</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Split库-分隔单词"><a href="#Split库-分隔单词" class="headerlink" title="Split库+分隔单词"></a>Split库+分隔单词</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">istringstream <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">        string str;</span><br><span class="line">        stack&lt;string&gt; zhan;</span><br><span class="line">        <span class="keyword">while</span>(is&gt;&gt;str)&#123;</span><br><span class="line">            zhan.<span class="built_in">push</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用输入流，将单词分别输入</span></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!zhan.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res += zhan.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(zhan.<span class="built_in">size</span>() != <span class="number">1</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            zhan.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//利用栈原理，逆向接受单词空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="栈原理"><a href="#栈原理" class="headerlink" title="栈原理"></a>栈原理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">// self solution! yeah!!</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack &lt;string&gt; stk;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;<span class="comment">//先遍历字符串，提前单词，word入栈</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                word += s[i];</span><br><span class="line">                <span class="keyword">if</span> (i ==  n<span class="number">-1</span> || s[i+<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//关键判断条件：什么时候入栈，当字母后有空格或已是最后一个则判断为word，入栈</span></span><br><span class="line">                    stk.<span class="built_in">push</span>(word);</span><br><span class="line">                    word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>())&#123;<span class="comment">//释放栈中元素，加入空格组成反转后结果</span></span><br><span class="line">            ans += stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>())  ans += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><p>通常我们会在大厂里的第一道比较简单的面试题里面，见到反转链表这样的题目，这是对单链表数据结构的基本操作，是需要掌握的知识点。</p><p>众所周知，链表中一个基础结构叫做节点，节点之中有<strong>数据域和指针域</strong>两个部分，一个链表由<strong>头节点决定链表整体的地址信息</strong>，头接点可以遍历整个链表，而要把链表反转，就是让每个节点的<strong>指针域进行反向操作</strong>，这是比较高级的做法，下面从最开始接触到反转链表的问题的想法。</p><p>最容易想到的是，利用双指针的方法，进一步说明就是利用左右指针的算法，从链表两侧往中间遍历。对于整个链表，基本操作方式就是，左指针从链表的左侧一直往右侧移动，右测的指针往左测移动，当左右指针都能移动一步过后，我们把这两个指针所在的节点的数据域进行交换。但是，这里交换数据域出现问题，我们不能直接像数组一样，利用索引就调出某个元素的值，这边我们要调用单列表的某个元素是，只能从头节点开始遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;target;i++)</span><br><span class="line">&#123;</span><br><span class="line">    currPtr=currPtr-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果像这样去调用每个对象的数据域，会出现currPtr的指向一直在变化，我们要调用两个镜像的节点的数据域需要考虑预设中间节点，但是我们没有回退的指针运算，不管如何，都得从头节点出发。如果是能够从中间开始，这里就需要考虑元素的奇偶性，必然会导致“数数”的过程，增加运算的步骤，出现这样的情况。</p><blockquote><p>注意：如果出现奇偶的情况，最先考虑二者最后的执行情况是否能一致。</p></blockquote><p>很显然，反转链表是一道简单题，如果是选择数据域进行操作，可以计算一下操作的自由度：这里存在链表给予的空间自由度，还有链表本身的一维遍历自由度.</p><p>单链表有一个特点:每一个节点之间以一个next指针连接,要遍历整个链表只需找头接点,头接点规定为链表的末尾节点,接着将所有的指针域反转,就可以实现链表反转的目标.</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>空</th></tr></thead><tbody><tr><td>head</td><td>head-&gt;next</td><td>~</td><td>~</td><td>~</td><td>~</td><td>nullptr</td></tr><tr><td>currPtr</td><td>currPtr-&gt;next</td><td></td><td></td><td></td><td></td><td>prevPtr</td></tr><tr><td></td><td>temPtr</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://pic.leetcode-cn.com/1631933586-mEtOBg-008eGmZEly1gnrf1oboupg30gy0c44qp.gif" alt="img"></p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>空</th></tr></thead><tbody><tr><td>head</td><td>head-&gt;next</td><td>~</td><td>~</td><td>~</td><td>~</td><td>nullptr</td></tr><tr><td>currPtr</td><td>currPtr-&gt;next</td><td></td><td></td><td></td><td></td><td>prevPtr</td></tr><tr><td></td><td>temPtr</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>存c下一位,转向切换</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* currPtr=head;</span><br><span class="line">        ListNode* prevPtr=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(currPtr!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode*temPtr=currPtr-&gt;next;</span><br><span class="line">            <span class="comment">//①</span></span><br><span class="line">            currPtr-&gt;next=prevPtr;</span><br><span class="line">            <span class="comment">//其实是调转方向的指令②</span></span><br><span class="line">            prevPtr=currPtr;</span><br><span class="line">            <span class="comment">//③</span></span><br><span class="line">            currPtr=temPtr;</span><br><span class="line">            <span class="comment">//④</span></span><br><span class="line">            <span class="comment">//①④是完成操作后,使c前进一位</span></span><br><span class="line">            <span class="comment">//③是完成调转方向后,使p前进一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prevPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链表的操作可以微元化单个步骤的重复.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(currPtr!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode*temPtr=currPtr-&gt;next;</span><br><span class="line">            <span class="comment">//①</span></span><br><span class="line">            currPtr-&gt;next=prevPtr;</span><br><span class="line">            <span class="comment">//其实是调转方向的指令②</span></span><br><span class="line">            prevPtr=currPtr;</span><br><span class="line">            <span class="comment">//③</span></span><br><span class="line">            currPtr=temPtr;</span><br><span class="line">            <span class="comment">//④</span></span><br><span class="line">            <span class="comment">//①④是完成操作后,使c前进一位</span></span><br><span class="line">            <span class="comment">//③是完成调转方向后,使p前进一位</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre,ListNode* cur)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">ListNode* temp = cur-&gt;next;</span><br><span class="line">cur-&gt;next = pre;</span><br><span class="line"><span class="comment">// 可以和双指针法的代码进⾏对⽐，如下递归的写法，其实就是做了这两步</span></span><br><span class="line"><span class="comment">// pre = cur;</span></span><br><span class="line"><span class="comment">// cur = temp;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse</span>(cur,temp);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 和双指针法初始化是⼀样的逻辑</span></span><br><span class="line"><span class="comment">// ListNode* cur = head;</span></span><br><span class="line"><span class="comment">// ListNode* pre = NULL;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">NULL</span>, head);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><ul><li><h4 id="虚拟头结点"><a href="#虚拟头结点" class="headerlink" title="虚拟头结点"></a>虚拟头结点</h4></li></ul><p>我们在处理链表问题时,通常会用到虚拟头结点这个工具,虚拟头结点本身不储存任何数据,它的存在只是为了更方便我们去对链表中的元素进行操作.</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>g</th></tr></thead><tbody><tr><td>dummyhead</td><td>head</td><td>head-&gt;next</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>如果我们要删除头结点,那么就只需要将dummyhead的指针指向head-&gt;next所在的节点,清理掉头结点的内存,然后head节点指向dummyhead.</p><p>这里我们要删除链表的倒数第二个元素，首先我们要知道链表，我们是<strong>无法直接指定他到某个索引找出它的节点</strong>，我们需要用到一些方法就是<strong>快慢指针</strong>的那一种方式。</p><p>快慢指针的方式：快指针先走n步，慢指针后走，这样能在两个指针之间形成n个节点的间隔，当快指针走到空指针的位置的时候，慢指针刚好在倒数第n个节点的前一个节点的位置，之后对倒数第n个元素进行删除就好了，这里我们还需要使用到虚拟头接点的方式，有了虚拟头节点我们就方便地进行链表节点的删除。</p><p>关于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyhead= <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next=head;</span><br><span class="line">        ListNode* fast=dummyhead;</span><br><span class="line">        ListNode* slow=dummyhead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next=slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://i.postimg.cc/WzGdvtRY/A0-A70-DA070-ECE89284-F06-FC7-C8-FBC855.png" alt="删除链表的倒数第n个元素"></p><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><h4 id="逻辑环-双指针"><a href="#逻辑环-双指针" class="headerlink" title="逻辑环+双指针"></a>逻辑环+双指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *A=headA,*B=headB;</span><br><span class="line">        <span class="keyword">while</span>(A!=B)</span><br><span class="line">        &#123;</span><br><span class="line">            A=A!=<span class="literal">nullptr</span>?A-&gt;next:headB;</span><br><span class="line">            B=B!=<span class="literal">nullptr</span>?B-&gt;next:headA;</span><br><span class="line">            <span class="comment">//相当于将两个链表结成一个环，当两个指针完全一致的时候，就返回对应的指针</span></span><br><span class="line">            <span class="comment">//这里的环只是逻辑上的环，实际上并没有改变链表的任何数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂双指针"><a href="#复杂双指针" class="headerlink" title="复杂双指针"></a>复杂双指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表A的长度</span></span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表B的长度</span></span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">// 让curA为最长链表的头，lenA为其长度</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求长度差</span></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">        <span class="comment">// 让curA和curB在同一起点上（末尾位置对齐）</span></span><br><span class="line">        <span class="keyword">while</span> (gap--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历curA 和 curB，遇到相同则直接返回</span></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>层次分析</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//外层为具体条件,while语句对链表进行扫描</span></span><br><span class="line"><span class="comment">//slow一次移动一个节点,fast则移动两个</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span>(slow==fast)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode*index1=fast;</span><br><span class="line">    ListNode*index2=head;</span><br><span class="line">    <span class="comment">//用index1和index2标记头结点和fast节点</span></span><br><span class="line">    <span class="comment">//标记slow也可以</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span>(index1!=index2)</span><br><span class="line">            &#123;</span><br><span class="line">                index1=index1-&gt;next;</span><br><span class="line">                index2=index2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> index2;</span><br><span class="line"><span class="comment">//用快指针定位,已知x=(n-1)(y+z)+z</span></span><br><span class="line"><span class="comment">//就是当index1(fast)指针到达相交点后,index2(head)指针也在这里</span></span><br></pre></td></tr></table></figure><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h4 id="哈希法"><a href="#哈希法" class="headerlink" title="哈希法"></a>哈希法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="双指针法-2"><a href="#双指针法-2" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    <span class="comment">//如果不进行收缩,那么一会儿还会重复计算一次算过的数据</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h3><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h4 id="双指针法-3"><a href="#双指针法-3" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝处理</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 这里使用break，统一通过最后的return返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对nums[k]去重</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="comment">// 2级剪枝处理</span></span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对nums[i]去重</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;数组其实是一个连续的内存空间，删除元素的基本原理是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间不变&lt;/li&gt;
&lt;li&gt;计数方法会进行包装&lt;/li&gt;
&lt;/</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SPOC（12）:异常处理</title>
    <link href="http://example.com/2024/08/15/SPOC-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2024/08/15/SPOC-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2024-08-15T01:19:59.000Z</published>
    <updated>2024-08-15T01:33:41.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第-12-章-异常处理"><a href="#第-12-章-异常处理" class="headerlink" title="第 12 章 异常处理"></a>第 12 章 异常处理</h2><h3 id="本章主要内容"><a href="#本章主要内容" class="headerlink" title="本章主要内容"></a>本章主要内容</h3><ul><li><p>异常处理的基本思想与程序实现 </p></li><li><p>异常处理中的构造与析构 </p></li><li><p>标准程序库异常处理 </p></li><li><p>小结</p></li></ul><h3 id="异常处理的思想与程序实现"><a href="#异常处理的思想与程序实现" class="headerlink" title="异常处理的思想与程序实现"></a>异常处理的思想与程序实现</h3><h4 id="异常处理的基本思想"><a href="#异常处理的基本思想" class="headerlink" title="异常处理的基本思想"></a>异常处理的基本思想</h4><p><img src="https://i.postimg.cc/wvpSVg4J/QQ20240815-092055.png"></p><h4 id="异常处理的语法"><a href="#异常处理的语法" class="headerlink" title="异常处理的语法"></a>异常处理的语法</h4><p><img src="https://i.postimg.cc/BbZkrN0n/QQ20240815-092109.png"></p><h4 id="例12-1处理除零异常"><a href="#例12-1处理除零异常" class="headerlink" title="例12-1处理除零异常"></a>例12-1处理除零异常</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//12_1.cpp #include &lt;iostream&gt; </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (y == <span class="number">0</span>) </span><br><span class="line"> <span class="keyword">throw</span> x; </span><br><span class="line"> <span class="keyword">return</span> x / y; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;5 / 2 = &quot;</span> &lt;&lt; <span class="built_in">divide</span>(<span class="number">5</span>, <span class="number">2</span>) &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;8 / 0 = &quot;</span> &lt;&lt; <span class="built_in">divide</span>(<span class="number">8</span>, <span class="number">0</span>) &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;7 / 1 = &quot;</span> &lt;&lt; <span class="built_in">divide</span>(<span class="number">7</span>, <span class="number">1</span>) &lt;&lt; endl; </span><br><span class="line"> &#125; <span class="built_in">catch</span> (<span class="type">int</span> e) &#123; </span><br><span class="line"> cout &lt;&lt; e &lt;&lt; <span class="string">&quot; is divided by zero!&quot;</span> &lt;&lt; endl; </span><br><span class="line"> &#125; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;That is ok.&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="异常接口声明"><a href="#异常接口声明" class="headerlink" title="异常接口声明"></a>异常接口声明</h4><ul><li><p>一个函数显式声明可能抛出的异常，有利于函数的调用者为异常处理做好准备 </p></li><li><p>可以在函数的声明中列出这个函数可能抛掷的所有异常类型。</p></li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(A，B，C，D)</span></span>; </span><br></pre></td></tr></table></figure><ul><li><p>若无异常接口声明，则此函数可以抛掷任何类型的异常。 </p></li><li><p>不抛掷任何类型异常的函数声明如下：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; </span><br></pre></td></tr></table></figure><h4 id="异常处理中的构造与析构"><a href="#异常处理中的构造与析构" class="headerlink" title="异常处理中的构造与析构"></a>异常处理中的构造与析构</h4><p>自动的析构,找到一个匹配的catch异常处理后初始化异常参数。 将从对应的try块开始到异常被抛掷处之间构造（且尚未析构）的所有自动对象进行析构。 从最后一个catch处理之后开始恢复执行。 </p><h4 id="例-12-2-带析构语义的类的-C-异常处理"><a href="#例-12-2-带析构语义的类的-C-异常处理" class="headerlink" title="例 12-2 带析构语义的类的 C++异常处理"></a>例 12-2 带析构语义的类的 C++异常处理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//12_2.cpp </span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">MyException</span>(<span class="type">const</span> string &amp;message) : <span class="built_in">message</span>(message) &#123;&#125; </span><br><span class="line"> ~<span class="built_in">MyException</span>() &#123;&#125; </span><br><span class="line"> <span class="function"><span class="type">const</span> string &amp;<span class="title">getMessage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> message; &#125; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> string message; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">Demo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Constructor of Demo&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"> ~<span class="built_in">Demo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destructor of Demo&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span> <span class="params">(MyException)</span> </span>&#123; </span><br><span class="line"> Demo d; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Throw MyException in func()&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;exception thrown by func()&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;In main function&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="built_in">func</span>(); </span><br><span class="line"> &#125; <span class="built_in">catch</span> (MyException&amp; e) &#123; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Caught an exception: &quot;</span> &lt;&lt; e.<span class="built_in">getMessage</span>() &lt;&lt; endl; </span><br><span class="line"> &#125; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Resume the execution of main()&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure><h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">In main function </span></span><br><span class="line"><span class="function">Constructor of Demo </span></span><br><span class="line"><span class="function">Throw MyException in <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Destructor of Demo </span></span><br><span class="line"><span class="function">Caught an exception: exception thrown by func() </span></span><br><span class="line"><span class="function">Resume the execution of main() </span></span><br></pre></td></tr></table></figure><h3 id="标准程序库异常处理"><a href="#标准程序库异常处理" class="headerlink" title="标准程序库异常处理"></a>标准程序库异常处理</h3><h4 id="标准异常类的继承关系"><a href="#标准异常类的继承关系" class="headerlink" title="标准异常类的继承关系"></a>标准异常类的继承关系</h4><p><img src="https://i.postimg.cc/KzDCpwCW/QQ20240815-092119.png"></p><h4 id="C-标准库各种异常类所代表的异常"><a href="#C-标准库各种异常类所代表的异常" class="headerlink" title="C++标准库各种异常类所代表的异常"></a>C++标准库各种异常类所代表的异常</h4><p><img src="https://i.postimg.cc/gjMQmRzq/QQ20240815-092129.png"> </p><h4 id="标准异常类的基础"><a href="#标准异常类的基础" class="headerlink" title="标准异常类的基础"></a>标准异常类的基础</h4><ul><li><p>exception：标准程序库异常类的公共基类 </p></li><li><p>logic_error表示可以在程序中被预先检测到的异常 </p></li><li><p>如果小心地编写程序，这类异常能够避免 </p></li><li><p>runtime_error表示难以被预先检测的异常</p></li></ul><h3 id="例-12-3-三角形面积计算"><a href="#例-12-3-三角形面积计算" class="headerlink" title="例 12-3 三角形面积计算"></a>例 12-3 三角形面积计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//12_3.cpp </span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> </span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="comment">//给出三角形三边长，计算三角形面积 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> <span class="title">throw</span> <span class="params">(invalid_argument)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//判断三角形边长是否为正 </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (a &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || c &lt;= <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;the side length should be positive&quot;</span>); </span><br><span class="line"></span><br><span class="line"> <span class="comment">//判断三边长是否满足三角不等式 </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (a + b &lt;= c || b + c &lt;= a || c + a &lt;= b) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;the side length should fit the triangle </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inequation&quot;</span>); </span><br><span class="line"></span><br><span class="line"> <span class="comment">//由Heron公式计算三角形面积 </span></span><br><span class="line"></span><br><span class="line"> <span class="type">double</span> s = (a + b + c) / <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">sqrt</span>(s * (s - a) * (s - b) * (s - c)); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="type">double</span> a, b, c; <span class="comment">//三角形三边长 </span></span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Please input the side lengths of a triangle: &quot;</span>; </span><br><span class="line"></span><br><span class="line"> cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="type">double</span> s = <span class="built_in">area</span>(a, b, c); <span class="comment">//尝试计算三角形面积 </span></span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; s &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"> &#125; <span class="built_in">catch</span> (exception &amp;e) &#123; </span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>• 运行结果1： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please input the side lengths of a triangle: <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line">Area: <span class="number">6</span> </span><br></pre></td></tr></table></figure><p>• 运行结果2： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please input the side lengths of a triangle: <span class="number">0</span> <span class="number">5</span> <span class="number">5</span> </span><br><span class="line">Error: the side length should be positive </span><br></pre></td></tr></table></figure><p>• 运行结果2： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please input the side lengths of a triangle: <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line">Error: the side length should fit the triangle inequation 小结 </span><br></pre></td></tr></table></figure><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li><p>异常处理的基本思想</p></li><li><p>C++异常处理的实现</p></li><li><p>异常处理中的构造与析构</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第-12-章-异常处理&quot;&gt;&lt;a href=&quot;#第-12-章-异常处理&quot; class=&quot;headerlink&quot; title=&quot;第 12 章 异常处理&quot;&gt;&lt;/a&gt;第 12 章 异常处理&lt;/h2&gt;&lt;h3 id=&quot;本章主要内容&quot;&gt;&lt;a href=&quot;#本章主要内容&quot; cla</summary>
      
    
    
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>SPOC(11)：流类库与输入输出</title>
    <link href="http://example.com/2024/08/14/SPOC%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%B5%81%E7%B1%BB%E5%BA%93%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://example.com/2024/08/14/SPOC%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%B5%81%E7%B1%BB%E5%BA%93%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2024-08-14T02:11:36.000Z</published>
    <updated>2024-08-14T02:19:02.929Z</updated>
    
    <content type="html"><![CDATA[<p>第十一章 流类库与输入&#x2F;输出</p><p>主要内容</p><p> I&#x2F;O流的概念</p><p> 流类库结构</p><p> 输出流</p><p> 输入流</p><p> 输入&#x2F;输出流</p><p> 读写文本文件的格式控制</p><p>I&#x2F;O 流的概念及流类库结构</p><p>程序与外界环境的信息交换</p><p> 当程序与外界环境进行信息交换时，存在着两个对象：程序中的对象、文件对象。</p><p>流</p><p> 一种抽象，负责在数据的生产者和数据的消费者之间建立联系，并管理数据的流动。</p><p>流对象与文件操作</p><p> 程序建立一个流对象</p><p> 指定这个流对象与某个文件对象建立连接</p><p> 程序操作流对象</p><p> 流对象通过文件系统对所连接的文件对象产生作用。</p><p>提取与插入</p><p> 读操作在流数据抽象中被称为（从流中）提取</p><p> 写操作被称为（向流中）插入。</p><p>流类库结构流类列表</p><p>输出流概述</p><p>最重要的三个输出流</p><p> ostream</p><p> ofstream</p><p> ostringstream</p><p>预先定义的输出流对象</p><p> cout 标准输出</p><p> cerr 标准错误输出，没有缓冲，发送给它的内容立即被输出。 clog 类似于cerr，但是有缓冲，缓冲区满时被输出。</p><p>标准输出换向</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;b.out&quot;</span>)</span></span>;</span><br><span class="line">streambuf* pOld =cout.<span class="built_in">rdbuf</span>(fout.<span class="built_in">rdbuf</span>()); </span><br><span class="line"><span class="comment">//…</span></span><br><span class="line">cout.<span class="built_in">rdbuf</span>(pOld); </span><br></pre></td></tr></table></figure><p>构造输出流对象</p><p> ofstream类支持磁盘文件输出</p><p> 如果在构造函数中指定一个文件名，当构造这个对象时该文件是自动打开的</p><p>ofstream myFile(“filename”);</p><p> 可以在调用默认构造函数之后使用open成员函数打开文件</p><p>ofstream myFile; &#x2F;&#x2F;声明一个静态文件输出流对象</p><p>myFile.open(“filename”); &#x2F;&#x2F;打开文件，使流对象与文件建立联系</p><p> 在构造对象或用open打开文件时可以指定模式</p><p>ofstream myFile(“filename”, ios_base::out | ios_base::binary);</p><p>文件输出流成员函数的三种类型</p><p> 与操纵符等价的成员函数。</p><p> 执行非格式化写操作的成员函数。</p><p> 其它修改流状态且不同于操纵符或插入运算符的成员函数。</p><p>文件输出流成员函数</p><p> open函数</p><p>把流与一个特定的磁盘文件关联起来。</p><p>需要指定打开模式。</p><p> put函数</p><p>把一个字符写到输出流中。</p><p> write函数</p><p>把内存中的一块内容写到一个文件输出流中</p><p> seekp和tellp函数</p><p>操作文件流的内部指针</p><p> close函数</p><p>关闭与一个文件输出流关联的磁盘文件</p><p> 错误处理函数在写到一个流时进行错误处理</p><p>向文本文件输出</p><p>标准输出设备显示器被系统看作文本文件，所以我们以向标准设备输出为例，介绍文本</p><p>文件输出格式控制</p><p>插入运算符</p><p> 插入(&lt;&lt;)运算符</p><p> </p><p>为所有标准C++数据类型预先设计的，用于传送字节到一个输出流对象。</p><p>操纵符（manipulator）</p><p> 插入运算符与操纵符一起工作</p><p> </p><p>控制输出格式。</p><p> 很多操纵符都定义在</p><p> </p><p>ios_base类中（如hex()）、<iomanip>头文件（如setprecision()）。</iomanip></p><p> 控制输出宽度</p><p> </p><p>在流中放入setw操纵符或调用width成员函数为每个项指定输出宽度。</p><p> setw和width仅影响紧随其后的输出项，但其它流格式操纵符保持有效直到发生改</p><p>变。</p><p> dec、oct和hex操纵符设置输入和输出的默认进制。</p><p>例 11-1 使用 width 控制输出宽度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.23</span> <span class="number">35.36</span></span><br><span class="line"><span class="number">653.7</span></span><br><span class="line"><span class="number">4358.24</span></span><br></pre></td></tr></table></figure><p>例 11-2 使用 <strong>setw</strong> 操纵符指定宽度</p><p>&#x2F;&#x2F;11_2.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i] </span><br><span class="line"> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Zoot <span class="number">1.23</span></span><br><span class="line">Jimmy <span class="number">35.36</span></span><br><span class="line"> Al <span class="number">653.7</span></span><br><span class="line"> Stan <span class="number">4358.24</span></span><br></pre></td></tr></table></figure><p>例 11-3 设置对齐方式</p><p>&#x2F;&#x2F;11_3.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)<span class="comment">//左对齐 &lt;&lt; setw(6) &lt;&lt; names[i]</span></span><br><span class="line"> &lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)</span><br><span class="line"> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1.23</span></span><br><span class="line">Jimmy <span class="number">35.36</span></span><br><span class="line">Al <span class="number">653.7</span></span><br><span class="line">Stan <span class="number">4358.24</span></span><br></pre></td></tr></table></figure><p>setiosflags 操纵符</p><p> 这个程序中，通过使用带参数的setiosflags操纵符来设置左对齐，setiosflags定</p><p>义在头文件iomanip中。</p><p> 参数ios_base::left是ios_base的静态常量，因此引用时必须包括ios_base::前缀。</p><p> 这里需要用resetiosflags操纵符关闭左对齐标志。setiosflags不同于width和setw，</p><p>它的影响是持久的，直到用resetiosflags重新恢复默认值时为止 。</p><p> setiosflags的参数是该流的格式标志值，可用按位或（|）运算符进行组合</p><p>setiosflags 的参数（流的格式标识）</p><p> ios_base::skipws 在输入中跳过空白 。</p><p> ios_base::left 左对齐值，用填充字符填充右边。</p><p> ios_base::right 右对齐值，用填充字符填充左边（默认对齐方式）。</p><p> ios_base::internal 在规定的宽度内，指定前缀符号之后，数值之前，插入指定的</p><p>填充字符。</p><p> ios_base::dec 以十进制形式格式化数值（默认进制）。</p><p> ios_base::oct 以八进制形式格式化数值 。</p><p> ios_base::hex 以十六进制形式格式化数值。</p><p> ios_base::showbase 插入前缀符号以表明整数的数制。</p><p> ios_base::showpoint 对浮点数值显示小数点和尾部的0 。</p><p> ios_base::uppercase 对于十六进制数值显示大写字母A到F，对于科学格式显示大</p><p>写字母E 。</p><p> ios_base::showpos 对于非负数显示正号（“+”）。</p><p> ios_base::scientific 以科学格式显示浮点数值。</p><p> ios_base::fixed 以定点格式显示浮点数值（没有指数部分） 。</p><p> ios_base::unitbuf 在每次插入之后转储并清除缓冲区内容。精度</p><p> 浮点数输出精度的默认值是6，例如：3466.98。</p><p> 要改变精度：setprecision操纵符（定义在头文件iomanip中）。</p><p> 如果不指定fixed或scientific，精度值表示有效数字位数。</p><p> 如果设置了ios_base::fixed或ios_base::scientific精度值表示小数点之后的位数。</p><p>例 11-4 控制输出精度——未指定 fixed 或 scientific</p><p>&#x2F;&#x2F;11_4_1.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1</span></span><br><span class="line">Jimmy <span class="number">4e+001</span></span><br><span class="line">Al <span class="number">7e+002</span></span><br><span class="line">Stan <span class="number">4e+003</span></span><br></pre></td></tr></table></figure><p>例 11-4 控制输出精度——指定 fixed</p><p>&#x2F;&#x2F;11_4_2.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::fixed);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1.2</span></span><br><span class="line">Jimmy <span class="number">35.4</span></span><br><span class="line">Al <span class="number">653.7</span></span><br><span class="line">Stan <span class="number">4358.2</span></span><br></pre></td></tr></table></figure><p>例 11-4 控制输出精度——指定 scientific</p><p>&#x2F;&#x2F;11_4_3.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::scientific);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1.2e+000</span>Jimmy <span class="number">3.5e+001</span></span><br><span class="line">Al <span class="number">6.5e+002</span></span><br><span class="line">Stan <span class="number">4.4e+003</span></span><br></pre></td></tr></table></figure><p>向二进制文件输出</p><p>二进制文件流</p><p> 使用ofstream构造函数中的模式参量指定二进制输出模式；</p><p> 以通常方式构造一个流，然后使用setmode成员函数，在文件打开后改变模式；</p><p> 通过二进制文件输出流对象完成输出。</p><p>例 11-5 向二进制文件输出</p><p>&#x2F;&#x2F;11_5.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span> &#123; </span><br><span class="line"><span class="type">int</span> mon, day, year; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Date dt = &#123; <span class="number">6</span>, <span class="number">10</span>, <span class="number">92</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;date.dat&quot;</span>, ios_base::binary)</span></span>;</span><br><span class="line">file.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;dt),<span class="built_in">sizeof</span>(dt));</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向字符串输出</p><p>将字符串作为输出流的目标，可以实现将其他数据类型转换为字符串的功能</p><p>字符串输出流（ ostringstream ）</p><p> 用于构造字符串</p><p> 功能</p><p> </p><p>支持ofstream类的除open、close外的所有操作</p><p> </p><p>str函数可以返回当前已构造的字符串 典型应用</p><p> </p><p>将数值转换为字符串</p><p>例 11-6 用 ostringstream 将数值转换为字符串</p><p>&#x2F;&#x2F;11_6.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">toString</span><span class="params">(<span class="type">const</span> T &amp;v)</span> </span>&#123;</span><br><span class="line">ostringstream os; <span class="comment">//创建字符串输出流</span></span><br><span class="line">os &lt;&lt; v; </span><br><span class="line"><span class="comment">//将变量v的值写入字符串流</span></span><br><span class="line"><span class="keyword">return</span> os.<span class="built_in">str</span>(); </span><br><span class="line"><span class="comment">//返回输出流生成的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str1 = <span class="built_in">toString</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2 = <span class="built_in">toString</span>(<span class="number">1.2</span>);</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure><p>输入流概述</p><p>重要的输入流类</p><p> istream类最适合用于顺序文本模式输入。cin是其实例<strong>。</strong></p><p> ifstream类支持磁盘文件输入。</p><p> istringstream</p><p>函数模板 toString 可以将各种支持</p><p>“&lt;&lt;“插入符的类型的对象转换为字符串。构造输入流对象</p><p> 如果在构造函数中指定一个文件名，在构造该对象时该文件便自动打开。</p><p><strong>ifstream myFile(“filename”);</strong></p><p> 在调用默认构造函数之后使用open函数来打开文件。</p><p>ifstream myFile; &#x2F;&#x2F;建立一个文件流对象</p><p><strong>myFile.open(“filename”); &#x2F;&#x2F;<strong><strong>打开文件</strong></strong>“filename****”</strong></p><p> 打开文件时可以指定模式</p><p><strong>ifstream myFile(“filename”, ios_base::in | ios_base::binary);</strong></p><p>使用提取运算符从文本文件输入</p><p> 提取运算符(&gt;&gt;)对于所有标准C++数据类型都是预先设计好的。</p><p> 是从一个输入流对象获取字节最容易的方法。</p><p> ios类中的很多操纵符都可以应用于输入流。但是只有少数几个对输入流对象具有</p><p>实际影响，其中最重要的是进制操纵符dec、oct和hex。</p><p>输入流相关函数</p><p> open 把该流与一个特定磁盘文件相关联。</p><p> get 功能与提取运算符（&gt;&gt;）很相像，主要的不同点是get函数在读入数据时包</p><p>括空白字符。</p><p> getline 功能是从输入流中读取多个字符，并且允许指定输入终止字符，读取完成</p><p>后，从读取的内容中删除终止字符。</p><p> read 从一个文件读字节到一个指定的内存区域，由长度参数确定要读的字节数。</p><p>当遇到文件结束或者在文本模式文件中遇到文件结束标记字符时结束读取。</p><p> seekg 用来设置文件输入流中读取数据位置的指针。</p><p> tellg 返回当前文件读指针的位置。</p><p> close 关闭与一个文件输入流关联的磁盘文件。</p><p>输入流应用举例</p><p>例 11-7 <strong>get</strong> 函数应用举例</p><p>&#x2F;&#x2F;11_7.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> ch;<span class="keyword">while</span> ((ch = cin.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">cout.<span class="built_in">put</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例 11-8 为输入流指定一个终止字符：</p><p>&#x2F;&#x2F;11_8.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> string line;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Type a line terminated by &#x27;t&#x27; &quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="built_in">getline</span>(cin, line, <span class="string">&#x27;t&#x27;</span>);</span><br><span class="line"> cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例 11-9 从文件读一个二进制记录到一个结构中</p><p>&#x2F;&#x2F;11_9.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SalaryInfo</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> id;</span><br><span class="line"><span class="type">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SalaryInfo employee1 = &#123; <span class="number">600001</span>, <span class="number">8000</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">os</span><span class="params">(<span class="string">&quot;payroll&quot;</span>, ios_base::out | ios_base::binary)</span></span>;</span><br><span class="line">os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;employee1), <span class="built_in">sizeof</span>(employee1));</span><br><span class="line">os.<span class="built_in">close</span>();<span class="function">ifstream <span class="title">is</span><span class="params">(<span class="string">&quot;payroll&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (is) &#123;</span><br><span class="line">SalaryInfo employee2;</span><br><span class="line">is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;employee2), <span class="built_in">sizeof</span>(employee2));</span><br><span class="line">cout &lt;&lt; employee2.id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; employee2.salary &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;payroll&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">is.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例 11-10 用 <strong>seekg</strong> 函数设置位置指针</p><p>&#x2F;&#x2F;11_10.cpp, 头部分省略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> values[] = &#123; <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">os</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::out | ios_base::binary)</span></span>;</span><br><span class="line">os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(values), <span class="built_in">sizeof</span>(values));</span><br><span class="line">os.<span class="built_in">close</span>();</span><br><span class="line"><span class="function">ifstream <span class="title">is</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (is) &#123;</span><br><span class="line">is.<span class="built_in">seekg</span>(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;v), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The 4th integer in the file &#x27;integers&#x27; is &quot;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;integers&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例 11-11 读一个文件并显示出其中 0 元素的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_11.cpp, 头部分省略int main() &#123;</span></span><br><span class="line"><span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line"><span class="keyword">while</span> (file) &#123;<span class="comment">//读到文件尾file为0</span></span><br><span class="line"> streampos here = file.<span class="built_in">tellg</span>();</span><br><span class="line"> <span class="type">int</span> v;</span><br><span class="line"> file.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;v), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">if</span> (file &amp;&amp; v == <span class="number">0</span>) </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Position &quot;</span> &lt;&lt; here &lt;&lt; <span class="string">&quot; is 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;integers&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从字符串输入</p><p>将字符串作为文本输入流的源，可以将字符串转换为其他数据类型</p><p>字符串输入流（ istringstream）</p><p> 用于从字符串读取数据</p><p> 在构造函数中设置要读取的字符串</p><p> 功能</p><p> </p><p>支持ifstream类的除open、close外的所有操作</p><p> 典型应用</p><p> </p><p>将字符串转换为数值</p><p>例 11-12 用 istringstream 将字符串转换为数值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_12.cpp, 头部分省略</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">fromString</span><span class="params">(<span class="type">const</span> string &amp;str)</span> </span>&#123;</span><br><span class="line"><span class="function">istringstream <span class="title">is</span><span class="params">(str)</span></span>; <span class="comment">//创建字符串输入流</span></span><br><span class="line">T v;is &gt;&gt; v;<span class="comment">//从字符串输入流中读取变量v</span></span><br><span class="line"><span class="keyword">return</span> v; </span><br><span class="line"><span class="comment">//返回变量v</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> v1 = <span class="built_in">fromString</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">cout &lt;&lt; v1 &lt;&lt; endl;</span><br><span class="line"><span class="type">double</span> v2 = <span class="built_in">fromString</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;1.2&quot;</span>);</span><br><span class="line">cout &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure><p>输入&#x2F;输出流</p><p>两个重要的输入&#x2F;输出流</p><p> 一个iostream对象可以是数据的源或目的。</p><p> 两个重要的I&#x2F;O流类都是从iostream派生的，它们是fstream和stringstream。这</p><p>些类继承了前面描述的istream和ostream类的功能。</p><p>fstream 类</p><p> fstream类支持磁盘文件输入和输出。</p><p> 如果需要在同一个程序中从一个特定磁盘文件读并写到该磁盘文件，可以构造一个</p><p>fstream对象。</p><p> 一个fstream对象是有两个逻辑子流的单个流，两个子流一个用于输入，另一个用</p><p>于输出。</p><p>stringstream 类</p><p> stringstream类支持面向字符串的输入和输出</p><p> 可以用于对同一个字符串的内容交替读写，同样是由两个逻辑子流构成。</p><p>小结 主要内容</p><p> </p><p>I&#x2F;O流的概念、流类库结构、输出流、输入流、输入&#x2F;输出流、读写文本文件</p><p>的格式控制。</p><p> 达到的目标</p><p>能够将数据持久化。</p><p>能够处理文本文件和二进制文件。</p><p>能够利用字符串流进行字符串与其他类型之间的转换</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第十一章 流类库与输入&amp;#x2F;输出&lt;/p&gt;
&lt;p&gt;主要内容&lt;/p&gt;
&lt;p&gt; I&amp;#x2F;O流的概念&lt;/p&gt;
&lt;p&gt; 流类库结构&lt;/p&gt;
&lt;p&gt; 输出流&lt;/p&gt;
&lt;p&gt; 输入流&lt;/p&gt;
&lt;p&gt; 输入&amp;#x2F;输出流&lt;/p&gt;
&lt;p&gt; 读写文本文件的格式控制&lt;</summary>
      
    
    
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>SPOC(11)：流类库与输入输出</title>
    <link href="http://example.com/2024/08/14/SPOC%EF%BC%9A%E6%B5%81%E7%B1%BB%E5%BA%93%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://example.com/2024/08/14/SPOC%EF%BC%9A%E6%B5%81%E7%B1%BB%E5%BA%93%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2024-08-14T02:11:36.000Z</published>
    <updated>2024-08-15T01:45:38.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十一章-流类库与输入-输出"><a href="#第十一章-流类库与输入-输出" class="headerlink" title="第十一章 流类库与输入&#x2F;输出"></a>第十一章 流类库与输入&#x2F;输出</h2><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ul><li><p>I&#x2F;O流的概念</p></li><li><p>流类库结构</p></li><li><p>输出流</p></li><li><p>输入流</p></li><li><p>输入&#x2F;输出流</p></li><li><p>读写文本文件的格式控制</p></li></ul><h3 id="I-O-流的概念及流类库结构"><a href="#I-O-流的概念及流类库结构" class="headerlink" title="I&#x2F;O 流的概念及流类库结构"></a>I&#x2F;O 流的概念及流类库结构</h3><h4 id="程序与外界环境的信息交换"><a href="#程序与外界环境的信息交换" class="headerlink" title="程序与外界环境的信息交换"></a>程序与外界环境的信息交换</h4><p>当程序与外界环境进行信息交换时，存在着两个对象：程序中的对象、文件对象。</p><h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>一种抽象，负责在数据的生产者和数据的消费者之间建立联系，并管理数据的流动。流对象与文件操作</p><ul><li><p>程序建立一个流对象</p></li><li><p>指定这个流对象与某个文件对象建立连接</p></li><li><p>程序操作流对象</p></li><li><p>流对象通过文件系统对所连接的文件对象产生作用。</p></li></ul><h4 id="提取与插入"><a href="#提取与插入" class="headerlink" title="提取与插入"></a>提取与插入</h4><ul><li><p>读操作在流数据抽象中被称为（从流中）提取</p></li><li><p>写操作被称为（向流中）插入。</p></li></ul><p>流类库结构流类列表</p><p>输出流概述</p><h4 id="最重要的三个输出流"><a href="#最重要的三个输出流" class="headerlink" title="最重要的三个输出流"></a>最重要的三个输出流</h4><ul><li><p>ostream</p></li><li><p>ofstream</p></li><li><p>ostringstream</p></li></ul><h4 id="预先定义的输出流对象"><a href="#预先定义的输出流对象" class="headerlink" title="预先定义的输出流对象"></a>预先定义的输出流对象</h4><ul><li><p>cout 标准输出</p></li><li><p>cerr 标准错误输出，没有缓冲，发送给它的内容立即被输出。 clog 类似于cerr，但是有缓冲，缓冲区满时被输出。</p></li></ul><h4 id="标准输出换向"><a href="#标准输出换向" class="headerlink" title="标准输出换向"></a>标准输出换向</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;b.out&quot;</span>)</span></span>;</span><br><span class="line">streambuf* pOld =cout.<span class="built_in">rdbuf</span>(fout.<span class="built_in">rdbuf</span>()); </span><br><span class="line"><span class="comment">//…</span></span><br><span class="line">cout.<span class="built_in">rdbuf</span>(pOld); </span><br></pre></td></tr></table></figure><h4 id="构造输出流对象"><a href="#构造输出流对象" class="headerlink" title="构造输出流对象"></a>构造输出流对象</h4><ul><li><p>ofstream类支持磁盘文件输出</p></li><li><p>如果在构造函数中指定一个文件名，当构造这个对象时该文件是自动打开的ofstream myFile(“filename”);</p></li><li><p>可以在调用默认构造函数之后使用open成员函数打开文件ofstream myFile; &#x2F;&#x2F;声明一个静态文件输出流对象myFile.open(“filename”); &#x2F;&#x2F;打开文件，使流对象与文件建立联系</p></li><li><p>在构造对象或用open打开文件时可以指定模式ofstream myFile(“filename”, ios_base::out | ios_base::binary);</p></li></ul><h4 id="文件输出流成员函数的三种类型"><a href="#文件输出流成员函数的三种类型" class="headerlink" title="文件输出流成员函数的三种类型"></a>文件输出流成员函数的三种类型</h4><ul><li><p>与操纵符等价的成员函数。</p></li><li><p>执行非格式化写操作的成员函数。</p></li><li><p>其它修改流状态且不同于操纵符或插入运算符的成员函数。</p></li></ul><h4 id="文件输出流成员函数"><a href="#文件输出流成员函数" class="headerlink" title="文件输出流成员函数"></a>文件输出流成员函数</h4><ul><li>open函数</li></ul><p>把流与一个特定的磁盘文件关联起来。</p><p>需要指定打开模式。</p><ul><li>put函数</li></ul><p>把一个字符写到输出流中。</p><ul><li>write函数</li></ul><p>把内存中的一块内容写到一个文件输出流中</p><ul><li>seekp和tellp函数</li></ul><p>操作文件流的内部指针</p><ul><li>close函数</li></ul><p>关闭与一个文件输出流关联的磁盘文件</p><ul><li>错误处理函数在写到一个流时进行错误处理</li></ul><h4 id="向文本文件输出"><a href="#向文本文件输出" class="headerlink" title="向文本文件输出"></a>向文本文件输出</h4><p>标准输出设备显示器被系统看作文本文件，所以我们以向标准设备输出为例，介绍文本</p><p>文件输出格式控制</p><h4 id="插入运算符"><a href="#插入运算符" class="headerlink" title="插入运算符"></a>插入运算符</h4><ul><li><p>插入(&lt;&lt;)运算符</p></li><li><p>为所有标准C++数据类型预先设计的，用于传送字节到一个输出流对象。</p></li></ul><h4 id="操纵符（manipulator）"><a href="#操纵符（manipulator）" class="headerlink" title="操纵符（manipulator）"></a>操纵符（manipulator）</h4><ul><li><p>插入运算符与操纵符一起工作</p></li><li><p>控制输出格式。</p></li><li><p>很多操纵符都定义在ios_base类中（如hex()）、<iomanip>头文件（如setprecision()）。</iomanip></p></li><li><p>控制输出宽度</p><ol><li><p>在流中放入setw操纵符或调用width成员函数为每个项指定输出宽度。</p></li><li><p>setw和width仅影响紧随其后的输出项，但其它流格式操纵符保持有效直到发生改</p></li></ol></li></ul><p>变。</p><ul><li>dec、oct和hex操纵符设置输入和输出的默认进制。</li></ul><h4 id="例-11-1-使用-width-控制输出宽度"><a href="#例-11-1-使用-width-控制输出宽度" class="headerlink" title="例 11-1 使用 width 控制输出宽度"></a>例 11-1 使用 width 控制输出宽度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果:"></a>输出结果:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.23</span> <span class="number">35.36</span></span><br><span class="line"><span class="number">653.7</span></span><br><span class="line"><span class="number">4358.24</span></span><br></pre></td></tr></table></figure><h4 id="例-11-2-使用-setw-操纵符指定宽度"><a href="#例-11-2-使用-setw-操纵符指定宽度" class="headerlink" title="例 11-2 使用 setw 操纵符指定宽度"></a>例 11-2 使用 <strong>setw</strong> 操纵符指定宽度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i] </span><br><span class="line"> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果:"></a>输出结果:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Zoot <span class="number">1.23</span></span><br><span class="line">Jimmy <span class="number">35.36</span></span><br><span class="line"> Al <span class="number">653.7</span></span><br><span class="line"> Stan <span class="number">4358.24</span></span><br></pre></td></tr></table></figure><h4 id="例-11-3-设置对齐方式"><a href="#例-11-3-设置对齐方式" class="headerlink" title="例 11-3 设置对齐方式"></a>例 11-3 设置对齐方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_3.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)<span class="comment">//左对齐 &lt;&lt; setw(6) &lt;&lt; names[i]</span></span><br><span class="line"> &lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)</span><br><span class="line"> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果-2"><a href="#输出结果-2" class="headerlink" title="输出结果:"></a>输出结果:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1.23</span></span><br><span class="line">Jimmy <span class="number">35.36</span></span><br><span class="line">Al <span class="number">653.7</span></span><br><span class="line">Stan <span class="number">4358.24</span></span><br></pre></td></tr></table></figure><h4 id="setiosflags-操纵符"><a href="#setiosflags-操纵符" class="headerlink" title="setiosflags 操纵符"></a>setiosflags 操纵符</h4><ul><li><p>这个程序中，通过使用带参数的setiosflags操纵符来设置左对齐，setiosflags定义在头文件iomanip中。</p></li><li><p>参数ios_base::left是ios_base的静态常量，因此引用时必须包括ios_base::前缀。</p></li><li><p>这里需要用resetiosflags操纵符关闭左对齐标志。setiosflags不同于width和setw，它的影响是持久的，直到用resetiosflags重新恢复默认值时为止 。</p></li><li><p>setiosflags的参数是该流的格式标志值，可用按位或（|）运算符进行组合setiosflags 的参数（流的格式标识）</p></li><li><p>ios_base::skipws 在输入中跳过空白 。</p></li><li><p>ios_base::left 左对齐值，用填充字符填充右边。</p></li><li><p>ios_base::right 右对齐值，用填充字符填充左边（默认对齐方式）。</p></li><li><p>ios_base::internal 在规定的宽度内，指定前缀符号之后，数值之前，插入指定的填充字符。</p></li><li><p>ios_base::dec 以十进制形式格式化数值（默认进制）。</p></li><li><p>ios_base::oct 以八进制形式格式化数值 。</p></li><li><p>ios_base::hex 以十六进制形式格式化数值。</p></li><li><p>ios_base::showbase 插入前缀符号以表明整数的数制。</p></li><li><p>ios_base::showpoint 对浮点数值显示小数点和尾部的0 。</p></li><li><p>ios_base::uppercase 对于十六进制数值显示大写字母A到F，对于科学格式显示大写字母E 。</p></li><li><p>ios_base::showpos 对于非负数显示正号（“+”）。</p></li><li><p>ios_base::scientific 以科学格式显示浮点数值。</p></li><li><p>ios_base::fixed 以定点格式显示浮点数值（没有指数部分） 。</p></li><li><p>ios_base::unitbuf 在每次插入之后转储并清除缓冲区内容。精度</p></li><li><p>浮点数输出精度的默认值是6，例如：3466.98。</p></li><li><p>要改变精度：setprecision操纵符（定义在头文件iomanip中）。</p></li><li><p>如果不指定fixed或scientific，精度值表示有效数字位数。</p></li><li><p>如果设置了ios_base::fixed或ios_base::scientific精度值表示小数点之后的位数。</p></li></ul><h4 id="例-11-4-控制输出精度——未指定-fixed-或-scientific"><a href="#例-11-4-控制输出精度——未指定-fixed-或-scientific" class="headerlink" title="例 11-4 控制输出精度——未指定 fixed 或 scientific"></a>例 11-4 控制输出精度——未指定 fixed 或 scientific</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_4_1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1</span></span><br><span class="line">Jimmy <span class="number">4e+001</span></span><br><span class="line">Al <span class="number">7e+002</span></span><br><span class="line">Stan <span class="number">4e+003</span></span><br></pre></td></tr></table></figure><h4 id="例-11-4-控制输出精度——指定-fixed"><a href="#例-11-4-控制输出精度——指定-fixed" class="headerlink" title="例 11-4 控制输出精度——指定 fixed"></a>例 11-4 控制输出精度——指定 fixed</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_4_2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::fixed);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果：-1"><a href="#输出结果：-1" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1.2</span></span><br><span class="line">Jimmy <span class="number">35.4</span></span><br><span class="line">Al <span class="number">653.7</span></span><br><span class="line">Stan <span class="number">4358.2</span></span><br></pre></td></tr></table></figure><h4 id="例-11-4-控制输出精度——指定-scientific"><a href="#例-11-4-控制输出精度——指定-scientific" class="headerlink" title="例 11-4 控制输出精度——指定 scientific"></a>例 11-4 控制输出精度——指定 scientific</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_4_3.cpp</span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::scientific);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果：-2"><a href="#输出结果：-2" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1.2e+000</span>Jimmy <span class="number">3.5e+001</span></span><br><span class="line">Al <span class="number">6.5e+002</span></span><br><span class="line">Stan <span class="number">4.4e+003</span></span><br></pre></td></tr></table></figure><h3 id="向二进制文件输出"><a href="#向二进制文件输出" class="headerlink" title="向二进制文件输出"></a>向二进制文件输出</h3><h4 id="二进制文件流"><a href="#二进制文件流" class="headerlink" title="二进制文件流"></a>二进制文件流</h4><ul><li><p>使用ofstream构造函数中的模式参量指定二进制输出模式；</p></li><li><p>以通常方式构造一个流，然后使用setmode成员函数，在文件打开后改变模式；</p></li><li><p>通过二进制文件输出流对象完成输出。</p></li></ul><h4 id="例-11-5-向二进制文件输出"><a href="#例-11-5-向二进制文件输出" class="headerlink" title="例 11-5 向二进制文件输出"></a>例 11-5 向二进制文件输出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_5.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span> &#123; </span><br><span class="line"><span class="type">int</span> mon, day, year; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Date dt = &#123; <span class="number">6</span>, <span class="number">10</span>, <span class="number">92</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;date.dat&quot;</span>, ios_base::binary)</span></span>;</span><br><span class="line">file.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;dt),<span class="built_in">sizeof</span>(dt));</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向字符串输出"><a href="#向字符串输出" class="headerlink" title="向字符串输出"></a>向字符串输出</h4><p>将字符串作为输出流的目标，可以实现将其他数据类型转换为字符串的功能</p><h4 id="字符串输出流（-ostringstream-）"><a href="#字符串输出流（-ostringstream-）" class="headerlink" title="字符串输出流（ ostringstream ）"></a>字符串输出流（ ostringstream ）</h4><ul><li><p>用于构造字符串</p></li><li><p>功能</p><ol><li>支持ofstream类的除open、close外的所有操作</li><li>str函数可以返回当前已构造的字符串 典型应用</li><li>将数值转换为字符串</li></ol></li></ul><h4 id="例-11-6-用-ostringstream-将数值转换为字符串"><a href="#例-11-6-用-ostringstream-将数值转换为字符串" class="headerlink" title="例 11-6 用 ostringstream 将数值转换为字符串"></a>例 11-6 用 ostringstream 将数值转换为字符串</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_6.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">toString</span><span class="params">(<span class="type">const</span> T &amp;v)</span> </span>&#123;</span><br><span class="line">ostringstream os; <span class="comment">//创建字符串输出流</span></span><br><span class="line">os &lt;&lt; v; </span><br><span class="line"><span class="comment">//将变量v的值写入字符串流</span></span><br><span class="line"><span class="keyword">return</span> os.<span class="built_in">str</span>(); </span><br><span class="line"><span class="comment">//返回输出流生成的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str1 = <span class="built_in">toString</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2 = <span class="built_in">toString</span>(<span class="number">1.2</span>);</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果：-3"><a href="#输出结果：-3" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure><h3 id="输入流概述"><a href="#输入流概述" class="headerlink" title="输入流概述"></a>输入流概述</h3><h4 id="重要的输入流类"><a href="#重要的输入流类" class="headerlink" title="重要的输入流类"></a>重要的输入流类</h4><ul><li><p>istream类最适合用于顺序文本模式输入。cin是其实例<strong>。</strong></p></li><li><p>ifstream类支持磁盘文件输入。</p></li><li><p>istringstream</p></li></ul><p>函数模板 toString 可以将各种支持“&lt;&lt;“插入符的类型的对象转换为字符串。构造输入流对象</p><ul><li>如果在构造函数中指定一个文件名，在构造该对象时该文件便自动打开。</li></ul><h4 id="ifstream-myFile-“filename”"><a href="#ifstream-myFile-“filename”" class="headerlink" title="ifstream myFile(“filename”);"></a><strong>ifstream myFile(“filename”);</strong></h4><ul><li>在调用默认构造函数之后使用open函数来打开文件。</li></ul><p>ifstream myFile; &#x2F;&#x2F;建立一个文件流对象</p><h4 id="myFile-open-“filename”-打开文件“filename-”"><a href="#myFile-open-“filename”-打开文件“filename-”" class="headerlink" title="myFile.open(“filename”); &#x2F;&#x2F;打开文件“filename****”"></a><strong>myFile.open(“filename”); &#x2F;&#x2F;<strong><strong>打开文件</strong></strong>“filename****”</strong></h4><p> 打开文件时可以指定模式</p><h4 id="ifstream-myFile-“filename”-ios-base-in-ios-base-binary"><a href="#ifstream-myFile-“filename”-ios-base-in-ios-base-binary" class="headerlink" title="ifstream myFile(“filename”, ios_base::in | ios_base::binary);"></a><strong>ifstream myFile(“filename”, ios_base::in | ios_base::binary);</strong></h4><p>使用提取运算符从文本文件输入</p><ul><li><p>提取运算符(&gt;&gt;)对于所有标准C++数据类型都是预先设计好的。</p></li><li><p>是从一个输入流对象获取字节最容易的方法。</p></li><li><p>ios类中的很多操纵符都可以应用于输入流。但是只有少数几个对输入流对象具有</p></li></ul><p>实际影响，其中最重要的是进制操纵符dec、oct和hex。</p><h4 id="输入流相关函数"><a href="#输入流相关函数" class="headerlink" title="输入流相关函数"></a>输入流相关函数</h4><ul><li><p>open 把该流与一个特定磁盘文件相关联。</p></li><li><p>get 功能与提取运算符（&gt;&gt;）很相像，主要的不同点是get函数在读入数据时包括空白字符。</p></li><li><p>getline 功能是从输入流中读取多个字符，并且允许指定输入终止字符，读取完成后，从读取的内容中删除终止字符。</p></li><li><p>read 从一个文件读字节到一个指定的内存区域，由长度参数确定要读的字节数。当遇到文件结束或者在文本模式文件中遇到文件结束标记字符时结束读取。</p></li><li><p>seekg 用来设置文件输入流中读取数据位置的指针。</p></li><li><p>tellg 返回当前文件读指针的位置。</p></li><li><p>close 关闭与一个文件输入流关联的磁盘文件。</p></li></ul><h4 id="输入流应用举例"><a href="#输入流应用举例" class="headerlink" title="输入流应用举例"></a>输入流应用举例</h4><h4 id="例-11-7-get-函数应用举例"><a href="#例-11-7-get-函数应用举例" class="headerlink" title="例 11-7 get 函数应用举例"></a>例 11-7 <strong>get</strong> 函数应用举例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_7.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> ch;<span class="keyword">while</span> ((ch = cin.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">cout.<span class="built_in">put</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例-11-8-为输入流指定一个终止字符："><a href="#例-11-8-为输入流指定一个终止字符：" class="headerlink" title="例 11-8 为输入流指定一个终止字符："></a>例 11-8 为输入流指定一个终止字符：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_8.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> string line;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Type a line terminated by &#x27;t&#x27; &quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="built_in">getline</span>(cin, line, <span class="string">&#x27;t&#x27;</span>);</span><br><span class="line"> cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例-11-9-从文件读一个二进制记录到一个结构中"><a href="#例-11-9-从文件读一个二进制记录到一个结构中" class="headerlink" title="例 11-9 从文件读一个二进制记录到一个结构中"></a>例 11-9 从文件读一个二进制记录到一个结构中</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_9.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SalaryInfo</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> id;</span><br><span class="line"><span class="type">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SalaryInfo employee1 = &#123; <span class="number">600001</span>, <span class="number">8000</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">os</span><span class="params">(<span class="string">&quot;payroll&quot;</span>, ios_base::out | ios_base::binary)</span></span>;</span><br><span class="line">os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;employee1), <span class="built_in">sizeof</span>(employee1));</span><br><span class="line">os.<span class="built_in">close</span>();<span class="function">ifstream <span class="title">is</span><span class="params">(<span class="string">&quot;payroll&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (is) &#123;</span><br><span class="line">SalaryInfo employee2;</span><br><span class="line">is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;employee2), <span class="built_in">sizeof</span>(employee2));</span><br><span class="line">cout &lt;&lt; employee2.id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; employee2.salary &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;payroll&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">is.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例-11-10-用-seekg-函数设置位置指针"><a href="#例-11-10-用-seekg-函数设置位置指针" class="headerlink" title="例 11-10 用 seekg 函数设置位置指针"></a>例 11-10 用 <strong>seekg</strong> 函数设置位置指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_10.cpp, 头部分省略</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> values[] = &#123; <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">os</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::out | ios_base::binary)</span></span>;</span><br><span class="line">os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(values), <span class="built_in">sizeof</span>(values));</span><br><span class="line">os.<span class="built_in">close</span>();</span><br><span class="line"><span class="function">ifstream <span class="title">is</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (is) &#123;</span><br><span class="line">is.<span class="built_in">seekg</span>(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;v), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The 4th integer in the file &#x27;integers&#x27; is &quot;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;integers&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例-11-11-读一个文件并显示出其中-0-元素的位置"><a href="#例-11-11-读一个文件并显示出其中-0-元素的位置" class="headerlink" title="例 11-11 读一个文件并显示出其中 0 元素的位置"></a>例 11-11 读一个文件并显示出其中 0 元素的位置</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_11.cpp, 头部分省略int main() &#123;</span></span><br><span class="line"><span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line"><span class="keyword">while</span> (file) &#123;<span class="comment">//读到文件尾file为0</span></span><br><span class="line"> streampos here = file.<span class="built_in">tellg</span>();</span><br><span class="line"> <span class="type">int</span> v;</span><br><span class="line"> file.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;v), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">if</span> (file &amp;&amp; v == <span class="number">0</span>) </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Position &quot;</span> &lt;&lt; here &lt;&lt; <span class="string">&quot; is 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;integers&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从字符串输入"><a href="#从字符串输入" class="headerlink" title="从字符串输入"></a>从字符串输入</h3><p>将字符串作为文本输入流的源，可以将字符串转换为其他数据类型</p><h4 id="字符串输入流（-istringstream）"><a href="#字符串输入流（-istringstream）" class="headerlink" title="字符串输入流（ istringstream）"></a>字符串输入流（ istringstream）</h4><ul><li><p>用于从字符串读取数据</p></li><li><p>在构造函数中设置要读取的字符串</p></li><li><p>功能</p><ol><li>支持ifstream类的除open、close外的所有操作</li></ol></li><li><p>典型应用</p><ol><li>将字符串转换为数值</li></ol></li></ul><h4 id="例-11-12-用-istringstream-将字符串转换为数值"><a href="#例-11-12-用-istringstream-将字符串转换为数值" class="headerlink" title="例 11-12 用 istringstream 将字符串转换为数值"></a>例 11-12 用 istringstream 将字符串转换为数值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_12.cpp, 头部分省略</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">fromString</span><span class="params">(<span class="type">const</span> string &amp;str)</span> </span>&#123;</span><br><span class="line"><span class="function">istringstream <span class="title">is</span><span class="params">(str)</span></span>; <span class="comment">//创建字符串输入流</span></span><br><span class="line">T v;is &gt;&gt; v;<span class="comment">//从字符串输入流中读取变量v</span></span><br><span class="line"><span class="keyword">return</span> v; </span><br><span class="line"><span class="comment">//返回变量v</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> v1 = <span class="built_in">fromString</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">cout &lt;&lt; v1 &lt;&lt; endl;</span><br><span class="line"><span class="type">double</span> v2 = <span class="built_in">fromString</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;1.2&quot;</span>);</span><br><span class="line">cout &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果：-4"><a href="#输出结果：-4" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure><h3 id="输入-输出流"><a href="#输入-输出流" class="headerlink" title="输入&#x2F;输出流"></a>输入&#x2F;输出流</h3><h4 id="两个重要的输入-输出流"><a href="#两个重要的输入-输出流" class="headerlink" title="两个重要的输入&#x2F;输出流"></a>两个重要的输入&#x2F;输出流</h4><ul><li><p>一个iostream对象可以是数据的源或目的。</p></li><li><p>两个重要的I&#x2F;O流类都是从iostream派生的，它们是fstream和stringstream。这些类继承了前面描述的istream和ostream类的功能。</p></li></ul><h4 id="fstream-类"><a href="#fstream-类" class="headerlink" title="fstream 类"></a>fstream 类</h4><ul><li><p>fstream类支持磁盘文件输入和输出。</p></li><li><p>如果需要在同一个程序中从一个特定磁盘文件读并写到该磁盘文件，可以构造一个</p></li></ul><h4 id="fstream对象。"><a href="#fstream对象。" class="headerlink" title="fstream对象。"></a>fstream对象。</h4><ul><li>一个fstream对象是有两个逻辑子流的单个流，两个子流一个用于输入，另一个用于输出。</li></ul><p>stringstream 类</p><ul><li><p>stringstream类支持面向字符串的输入和输出</p></li><li><p>可以用于对同一个字符串的内容交替读写，同样是由两个逻辑子流构成。</p></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="主要内容-1"><a href="#主要内容-1" class="headerlink" title="主要内容"></a>主要内容</h4><ul><li><p>I&#x2F;O流的概念</p></li><li><p>流类库结构</p></li><li><p>输出流</p></li><li><p>输入流</p></li><li><p>输入&#x2F;输出流</p></li><li><p>读写文本文件的格式控制</p></li></ul><h4 id="达到的目标"><a href="#达到的目标" class="headerlink" title="达到的目标"></a>达到的目标</h4><ol><li><p>能够将数据持久化。</p></li><li><p>能够处理文本文件和二进制文件。</p></li><li><p>能够利用字符串流进行字符串与其他类型之间的转换</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第十一章-流类库与输入-输出&quot;&gt;&lt;a href=&quot;#第十一章-流类库与输入-输出&quot; class=&quot;headerlink&quot; title=&quot;第十一章 流类库与输入&amp;#x2F;输出&quot;&gt;&lt;/a&gt;第十一章 流类库与输入&amp;#x2F;输出&lt;/h2&gt;&lt;h3 id=&quot;主要内容&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>SPOC（10）：泛型程序设计与C++标准模板库</title>
    <link href="http://example.com/2024/08/13/SPOC(10)%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EC-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    <id>http://example.com/2024/08/13/SPOC(10)%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EC-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</id>
    <published>2024-08-12T22:20:17.000Z</published>
    <updated>2024-08-14T02:09:49.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型程序设计的基本概念"><a href="#泛型程序设计的基本概念" class="headerlink" title="泛型程序设计的基本概念"></a>泛型程序设计的基本概念</h2><ul><li>编写不依赖于<strong>具体数据类型</strong>的程序</li><li>将算法从特定的<strong>数据结构</strong>中抽象出来，成为了<strong>通用</strong>的</li><li>C++的模板为<strong>泛型程序设计</strong>奠定了关键的基础</li></ul><h3 id="术语：概念"><a href="#术语：概念" class="headerlink" title="术语：概念"></a>术语：概念</h3><ul><li>用来界定具备一定功能的数<strong>据类型</strong></li></ul><ol><li><p>将 “ <strong>可 以 比 大 小</strong> 的 所 有 数 据 类 型 （ 有 比 较 运 算 符 ）” 这 一 概 念 记 为<strong>Comparable</strong></p></li><li><p>将“具有<strong>公有的复制构造函数</strong>并可以<strong>用‘&#x3D;’赋值</strong>的数据类型”这一概念记为Assignable</p></li><li><p>将“可以<strong>比大小</strong>、具有<strong>公有的复制构造函数</strong>并可以<strong>用‘&#x3D;’赋值</strong>的所有数据类型”这个概念记作Sortable。</p></li></ol><ul><li>对于两个不同的概念A和B，如果概念A所需要的<strong>所有功能</strong>也是概念B<strong>所需求的功能</strong>，那么就说概念B是概念A的子概念。例如：</li></ul><p>Sortable既是Comparable的子概念，也是Assignable的子概念</p><h3 id="术语：模型"><a href="#术语：模型" class="headerlink" title="术语：模型"></a>术语：模型</h3><ul><li>模型（model）：<strong>符合一个概念的数据类型</strong>称为该概念的模型，例如：</li></ul><ol><li><p>int型是Comparable概念的模型。</p></li><li><p>静态数组类型不是Assignable概念的模型（无法用“&#x3D;”给整个静态数组赋值）</p></li></ol><h3 id="用概念做模板参数名"><a href="#用概念做模板参数名" class="headerlink" title="用概念做模板参数名"></a>用概念做模板参数名</h3><ul><li><p>很多STL的实现代码就是使用<strong>概念来命名模板参数</strong>的。</p></li><li><p>为概念赋予一个名称，并使用该名称作为<strong>模板参数名</strong>。</p></li><li><p>例如</p></li></ul><ol><li><p>表示insertionSort这样一个函数模板的原型：</p></li><li><p>template <class sortable></class></p></li><li><p>void insertionSort(Sortable a[], int n);</p></li></ol><h2 id="STL-简介"><a href="#STL-简介" class="headerlink" title="STL 简介"></a>STL 简介</h2><p>标准模板库（Standard Template Library，简称STL）提供了一些非常常用的数据结构和算法</p><h3 id="STL-简介-1"><a href="#STL-简介-1" class="headerlink" title="STL 简介"></a>STL 简介</h3><ul><li><p>标准模板库（Standard Template Library，简称STL）定义了一套概念体系，为泛型程序设计提供了逻辑基础</p></li><li><p>STL中的各个类模板、函数模板的参数都是用这个体系中的概念来规定的。</p></li><li><p>使用STL的模板时，类型参数既可以是C++标准库中已有的类型，也可以是自定义的类型——只要这些类型是所要求概念的模型。</p></li></ul><h3 id="STL-的基本组件"><a href="#STL-的基本组件" class="headerlink" title="STL 的基本组件"></a>STL 的基本组件</h3><ul><li><p>容器（container）</p></li><li><p>迭代器（iterator）</p></li><li><p>函数对象（function object）</p></li><li><p>算法（algorithms）</p></li></ul><h3 id="STL-的基本组件间的关系"><a href="#STL-的基本组件间的关系" class="headerlink" title="STL 的基本组件间的关系"></a>STL 的基本组件间的关系</h3><ul><li>Iterators（迭代器）是<strong>算法和容器的桥梁</strong>。</li></ul><ol><li>将迭代器作为<strong>算法的参数</strong>、通过迭代器<strong>来访问容器</strong>而不是把容器直接作为<strong>算法的参数</strong>。</li></ol><ul><li><p>将<strong>函数对象</strong>作为<strong>算法的参数</strong>而不是将函数所执行的运算作为算法的一部分。</p></li><li><p>使用STL中提供的或自定义的迭代器和函数对象，配合STL的算法，可以组合出各种各样的功能。</p></li></ul><p><img src="https://i.postimg.cc/DfjktKxc/33b0c9e6efcf36164beda0525394a156.png" alt="STL"></p><h3 id="STL-的基本组件——容器（container）"><a href="#STL-的基本组件——容器（container）" class="headerlink" title="STL 的基本组件——容器（container）"></a>STL 的基本组件——容器（container）</h3><ul><li><p>容纳、包含一组元素的<strong>对象</strong>。</p></li><li><p>基本容器类模板</p></li></ul><ol><li><p><strong>顺序容器</strong></p></li><li><p>array（数组）、vector（向量）、deque（双端队列）、forward_list（单链表）、list（列表）</p></li><li><p>(<strong>有序)关联容器</strong></p></li><li><p>set（集合）、multiset（多重集合）、map（映射）、multimap（多重映射）</p></li><li><p><strong>无序关联容器</strong></p></li><li><p>unordered_set （无序集合）、unordered_multiset（无序多重集合）</p></li><li><p>unordered_map（无序映射）、unorder_multimap（无序多重映射）</p></li></ol><ul><li><strong>容器适配器</strong></li></ul><ol><li>stack（栈）、queue（队列）、priority_queue（优先队列）</li></ol><ul><li>使用容器，需要包含对应的头文件</li></ul><h3 id="STL-的基本组件——迭代器（iterator）"><a href="#STL-的基本组件——迭代器（iterator）" class="headerlink" title="STL 的基本组件——迭代器（iterator）"></a>STL 的基本组件——迭代器（iterator）</h3><ul><li><p>迭代器是<strong>泛化的指针</strong>，提供了<strong>顺序访问容器</strong>中每个元素的方法</p></li><li><p>提供了顺序访问容器中每个元素的方法；</p></li><li><p>可以使用“++”运算符来<strong>获得指向下一个元素的迭代器</strong>；</p></li><li><p>可以<strong>使用“*”运算符访问一个迭代器所指向的元素</strong>，如果元素类型是<strong>类或结构体</strong>，还可以使用“-&gt;”运算符直接访问该元素的一个成员；</p></li><li><p>有些迭代器还支持通过“–”运算符获得指向上一个元素的迭代器；</p></li><li><p>迭代器是泛化的指针：指针也具有同样的特性，因此指针本身就是一种迭代器；</p></li><li><p>使用独立于<strong>STL容器的迭代器</strong>，需要包含头文件<iterator>。</iterator></p></li></ul><h3 id="STL-的基本组件——函数对象（function-object）"><a href="#STL-的基本组件——函数对象（function-object）" class="headerlink" title="STL 的基本组件——函数对象（function object）"></a>STL 的基本组件——函数对象（function object）</h3><ul><li><p>一个<strong>行为类似函数</strong>的对象，对它可以像调用函数一样调用。</p></li><li><p>函数对象是<strong>泛化的函数</strong>：任何普通的函数和任何重载了“()” 运算符的类的对象都可以作为函数对象使用</p></li><li><p>使用STL的函数对象，需要包含头文件<functional></functional></p></li></ul><h3 id="STL-的基本组件——算法（algorithms）"><a href="#STL-的基本组件——算法（algorithms）" class="headerlink" title="STL 的基本组件——算法（algorithms）"></a>STL 的基本组件——算法（algorithms）</h3><ul><li>STL包括70多个算法</li></ul><ol><li>例如：排序算法，消除算法，计数算法，比较算法，变换算法，置换算法和</li></ol><p>容器管理等</p><ul><li><p>可以广泛用于<strong>不同的对象</strong>和<strong>内置的数据类型</strong>。</p></li><li><p>使用STL的算法，需要包含头文件<algorithm>。</algorithm></p></li><li><p>例10-1从标准输入读入几个整数，存入向量容器，输出它们的相反数</p></li></ul><h3 id="例-10-1：STL-程序实例"><a href="#例-10-1：STL-程序实例" class="headerlink" title="例 10-1：STL 程序实例"></a>例 10-1：STL 程序实例</h3><ul><li>transform算法</li></ul><ol><li>transform算法的一种实现：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">UnaryFunction</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">transform</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;first != last; ++first, ++result)</span><br><span class="line">*result = <span class="built_in">op</span>(*first);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>transform算法<strong>顺序遍历first和last两个迭代器所指向</strong>的元素；</p></li><li><p>将每个元素的值作为<strong>函数对象op</strong>的参数；</p></li><li><p>将op的返回值通过<strong>迭代器result</strong>顺序输出；</p></li><li><p>遍历完成后result迭代器指向的是输出的最后一个元素的下一个位置，transform会将该迭代器返回</p></li></ol><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul><li>迭代器是算法和容器的桥梁</li></ul><ol><li>迭代器用作访问容器中的元素</li><li>算法不直接操作容器中的数据，而是通<strong>过迭代器间接操作</strong></li></ol><ul><li>算法和容器独立</li></ul><ol><li><p>增加新的算法，无需影响容器的实现</p></li><li><p>增加新的容器，原有的算法也能适用</p></li></ol><h3 id="输入流迭代器和输出流迭代器"><a href="#输入流迭代器和输出流迭代器" class="headerlink" title="输入流迭代器和输出流迭代器"></a>输入流迭代器和输出流迭代器</h3><ul><li>输入流迭代器</li></ul><p>istream_iterator<T></T></p><ol><li><p>以<strong>输入流（如cin）</strong>为参数构造</p></li><li><p>*<em>可用</em>(p++)**获得下一个输入的元素</p></li></ol><ul><li>输出流迭代器</li></ul><p>ostream_iterator<T></T></p><ol><li><p>构造时需要提供输出流（如cout）</p></li><li><p>可用(*p++) &#x3D; x将x输出到输出流</p></li></ol><ul><li>二者都属于适配器</li></ul><ol><li><p>适配器是用来为已有<strong>对象提供新的接口的对象</strong></p></li><li><p>输入流适配器和输出流适配器为<strong>流对象</strong>提供了迭代器的接口</p></li></ol><h3 id="例-10-2-从标准输入读入几个实数，分别将它们的平方输出"><a href="#例-10-2-从标准输入读入几个实数，分别将它们的平方输出" class="headerlink" title="例 10-2 从标准输入读入几个实数，分别将它们的平方输出"></a>例 10-2 从标准输入读入几个实数，分别将它们的平方输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//求平方的函数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//从标准输入读入若干个实数，分别将它们的平方输出</span></span><br><span class="line"> <span class="built_in">transform</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">double</span>&gt;(cin), <span class="built_in">istream_iterator</span>&lt;<span class="type">double</span>&gt;(),</span><br><span class="line"><span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout, <span class="string">&quot;\t&quot;</span>), square);</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h3><p><img src="https://i.postimg.cc/0Nz1kXrw/60ee0dff11d1d4065b50330cd32adcd7.png"></p><h3 id="迭代器支持的操作"><a href="#迭代器支持的操作" class="headerlink" title="迭代器支持的操作"></a>迭代器支持的操作</h3><ul><li>迭代器是<strong>泛化的指针</strong>，提供了类似指针的操作（诸如++、*、-&gt;运算符）</li></ul><ol><li><p>输入迭代器</p><p>可以用来从序列中<strong>读取数据</strong>，如<strong>输入流迭代器</strong></p></li><li><p>输出迭代器</p><p>允许向序列中<strong>写入数据</strong>，如<strong>输出流迭代器</strong></p></li><li><p>前向迭代器</p><p>既是输入迭代器又是输出迭代器，并且可以<strong>对序列进行单向的遍历</strong></p></li><li><p>双向迭代器</p><p>与前向迭代器相似，但是在<strong>两个方向上</strong>都可以对数据遍历</p></li><li><p>随机访问迭代器</p><p>也是双向迭代器，但能够在序列中的<strong>任意两个位置</strong>之间进行跳转，如指针、使用vector的begin()、end()函数得到的迭代器</p></li></ol><h3 id="迭代器的区间"><a href="#迭代器的区间" class="headerlink" title="迭代器的区间"></a>迭代器的区间</h3><ul><li><p>两个<strong>迭代器</strong>表示一个区间：[p1, p2)</p></li><li><p>STL算法常以迭代器的区间作为<strong>输入，传递输入数据</strong></p></li><li><p><strong>合法的区间</strong></p></li><li><p>p1经过n次(n &gt; 0)自增(++)操作后<strong>满足p1 &#x3D;&#x3D; p2</strong></p></li><li><p>区间<strong>包含p1</strong>，但<strong>不包含p2</strong></p></li></ul><h3 id="例-10-3-综合运用几种迭代器的示例"><a href="#例-10-3-综合运用几种迭代器的示例" class="headerlink" title="例 10-3 综合运用几种迭代器的示例"></a>例 10-3 综合运用几种迭代器的示例</h3><p>程序涉及到<strong>输入迭代器、输出迭代器、随机访问迭代器</strong>这三个迭代器概念，并且以前两个概念为基础编写了一个通用算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_3.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//将来自输入迭代器的n个T类型的数值排序，将结果通过输出迭代器result输出</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过输入迭代器将输入数据存入向量容器s中</span></span><br><span class="line">vector&lt;T&gt; s;</span><br><span class="line"><span class="keyword">for</span> (;first != last; ++first)</span><br><span class="line">s.<span class="built_in">push_back</span>(*first);</span><br><span class="line"><span class="comment">//对s进行排序，sort函数的参数必须是随机访问迭代器</span></span><br><span class="line"> <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); </span><br><span class="line"><span class="built_in">copy</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), result); <span class="comment">//将s序列通过输出迭代器输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//将s数组的内容排序后输出</span></span><br><span class="line"><span class="type">double</span> a[<span class="number">5</span>] = &#123; <span class="number">1.2</span>, <span class="number">2.4</span>, <span class="number">0.8</span>, <span class="number">3.3</span>, <span class="number">3.2</span> &#125;;</span><br><span class="line"><span class="built_in">mySort</span>&lt;<span class="type">double</span>&gt;(a, a + <span class="number">5</span>, <span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//从标准输入读入若干个整数，将排序后的结果输出</span></span><br><span class="line"><span class="built_in">mySort</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(cin), <span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(), </span><br><span class="line"><span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.8</span> <span class="number">1.2</span> <span class="number">2.4</span> <span class="number">3.2</span> <span class="number">3.3</span></span><br><span class="line"><span class="number">2</span> <span class="number">-4</span> <span class="number">5</span> <span class="number">8</span> <span class="number">-1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">-5</span></span><br><span class="line"><span class="number">-5</span> <span class="number">-4</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="迭代器的辅助函数"><a href="#迭代器的辅助函数" class="headerlink" title="迭代器的辅助函数"></a>迭代器的辅助函数</h3><ul><li>advance(p, n)</li></ul><p>对p执行<strong>n次自增操作</strong></p><ul><li>distance(first, last)</li></ul><p>计算两个迭代器<strong>first和last的距离</strong>，即对first执行多少次“++”操作后能够使得first &#x3D;&#x3D; last</p><h2 id="容器的基本功能与分类"><a href="#容器的基本功能与分类" class="headerlink" title="容器的基本功能与分类"></a>容器的基本功能与分类</h2><ul><li><p>容器类是<strong>容纳、包含一组元素或元素集合</strong>的对象。</p></li><li><p>基于容器中元素的组织方式：<strong>顺序容器、关联容器</strong></p></li><li><p>按照与容器所关联的迭代器类型划分：<strong>可逆容器</strong> <strong>随机访问容器</strong></p></li></ul><h3 id="容器的基本功能与分类-1"><a href="#容器的基本功能与分类-1" class="headerlink" title="容器的基本功能与分类"></a>容器的基本功能与分类</h3><ul><li>容器</li></ul><ol><li><strong>顺序</strong>容器</li></ol><p>array（数组）、vector（向量）、deque（双端队列）、forward_list（单链表）、list（列表）</p><ol start="2"><li><strong>(有序)关联</strong>容器</li></ol><p>set（集合）、multiset（多重集合）、map（映射）、multimap（多重映射）</p><ol start="3"><li><strong>无序关联</strong>容器</li></ol><p>unordered_set （无序集合）、unordered_multiset（无序多重集合）</p><p>unordered_map（无序映射）、unorder_multimap（无序多重映射）</p><h3 id="容器的分类"><a href="#容器的分类" class="headerlink" title="容器的分类"></a>容器的分类</h3><p><img src="https://i.postimg.cc/Ss808X6Q/abdc044a9a2dc26fc478d24d8ce1db1f.png"></p><p><img src="https://i.postimg.cc/8cV2b14R/049c148163a903ba980087b8738a3323.png"></p><h3 id="容器的通用功能"><a href="#容器的通用功能" class="headerlink" title="容器的通用功能"></a>容器的通用功能</h3><ul><li>容器的<strong>通用</strong>功能</li></ul><ol><li><p>用默认构造函数构造空容器</p></li><li><p>支持关系运算符：&#x3D;&#x3D;、!&#x3D;、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</p></li><li><p>begin()、end()：获得容器首、尾迭代器</p></li><li><p>clear()：将容器清空</p></li><li><p>empty()：判断容器是否为空</p></li><li><p>size()：得到容器元素个数</p></li><li><p>s1.swap(s2)：将s1和s2两容器内容交换</p></li><li><p>相关数据类型（S表示容器类型）</p></li><li><p>S::iterator：指向容器元素的迭代器类型</p></li><li><p>S::const_iterator：常迭代器类型</p></li></ol><h4 id="对可逆容器的访问"><a href="#对可逆容器的访问" class="headerlink" title="对可逆容器的访问"></a>对可逆容器的访问</h4><ul><li><p>STL为每个可逆容器都提供了逆向迭代器，逆向迭代器可以通过下面的成员函数得到：</p><ol><li>rbegin() ：指向容器尾的逆向迭代器</li><li>rend()：指向容器首的逆向迭代器</li></ol></li><li><p>逆向迭代器的类型名的表示方式如下：</p></li><li><ol><li>S::reverse_iterator：逆向迭代器类型</li><li>S::const_reverse_iterator：逆向常迭代器类型</li></ol></li></ul><h3 id="随机访问容器"><a href="#随机访问容器" class="headerlink" title="随机访问容器"></a>随机访问容器</h3><ul><li><p>随机访问容器支持对容器的元素进行随机访问</p></li><li><p>s[n]：获得容器s的第n个元素</p></li></ul><h2 id="顺序容器的基本功能"><a href="#顺序容器的基本功能" class="headerlink" title="顺序容器的基本功能"></a>顺序容器的基本功能</h2><h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><ol><li><p>向量（vector）</p></li><li><p>双端队列（deque）</p></li><li><p>列表（list）</p></li><li><p>单向链表（forward_list）</p></li><li><p>数组（array）</p></li><li><p>元素线性排列，可以随时在指定位置插入元素和删除元素。</p></li></ol><p> 必须符合<strong>Assignable</strong>这一概念（即具有公有的拷贝构造函数并可以用“&#x3D;”赋值）。</p><p>array对象的<strong>大小固定</strong>，forward_list有<strong>特殊的添加和删除操作</strong></p><h3 id="顺序容器的接口（不包含单向链表（forward-list）和数组（array））"><a href="#顺序容器的接口（不包含单向链表（forward-list）和数组（array））" class="headerlink" title="顺序容器的接口（不包含单向链表（forward_list）和数组（array））"></a>顺序容器的接口（不包含单向链表（forward_list）和数组（array））</h3><ol><li><p>构造函数</p></li><li><p>赋值函数</p></li><li><p>assign</p></li></ol><ul><li>插入函数</li></ul><p>insert， push_front（只对list和deque）， push_back，emplace，</p><p>emplace_front</p><ul><li>删除函数</li></ul><p>erase ， clear ， pop_front （只对 list 和 deque ） ， pop_back ，</p><p>emplace_back</p><ul><li>首尾元素的直接访问</li></ul><p>front，back</p><p>在逻辑上可看作是一个长度可扩展的数组</p><p>改变大小</p><p>resize</p><h3 id="例-10-4-顺序容器的基本操作"><a href="#例-10-4-顺序容器的基本操作" class="headerlink" title="例 10-4 顺序容器的基本操作"></a>例 10-4 顺序容器的基本操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_4.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="comment">//输出指定的顺序容器的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printContainer</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">const</span> T&amp; s)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; msg &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line"><span class="built_in">copy</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//从标准输入读入10个整数，将它们分别从s的头部加入</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">s.<span class="built_in">push_front</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printContainer</span>(<span class="string">&quot;deque at first&quot;</span>, s);</span><br><span class="line"><span class="comment">//用s容器的内容的逆序构造列表容器l</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(s.rbegin(), s.rend())</span></span>;</span><br><span class="line"><span class="built_in">printContainer</span>(<span class="string">&quot;list at first&quot;</span>, l);</span><br><span class="line">例<span class="number">10</span><span class="number">-4</span> 顺序容器的基本操作</span><br><span class="line"><span class="comment">//将列表容器l的每相邻两个元素顺序颠倒</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator iter = l.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (iter != l.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="type">int</span> v = *iter;</span><br><span class="line">iter = l.<span class="built_in">erase</span>(iter);</span><br><span class="line">l.<span class="built_in">insert</span>(++iter, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printContainer</span>(<span class="string">&quot;list at last&quot;</span>, l);</span><br><span class="line"><span class="comment">//用列表容器l的内容给s赋值，将s输出</span></span><br><span class="line">s.<span class="built_in">assign</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printContainer</span>(<span class="string">&quot;deque at last&quot;</span>, s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">9</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line">deque at first: <span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span></span><br><span class="line">list at first: <span class="number">0</span> <span class="number">9</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line">list at last: <span class="number">9</span> <span class="number">0</span> <span class="number">6</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">deque at last: <span class="number">9</span> <span class="number">0</span> <span class="number">6</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="顺序容器的特性"><a href="#顺序容器的特性" class="headerlink" title="顺序容器的特性"></a>顺序容器的特性</h2><p>顺序容器：向量、双端队列、列表、单向链表、数组</p><h3 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h3><ul><li>特点</li></ul><ol><li><p>一个可以扩展的动态数组</p></li><li><p>随机访问、在尾部插入或删除元素快</p></li><li><p>在中间或头部插入或删除元素慢</p></li></ol><ul><li>向量的容量</li></ul><ol><li><p>容量(capacity)：实际分配空间的大小</p></li><li><p>s.capacity() ：返回当前容量</p></li><li><p>s.reserve(n)：若容量小于n，则对s进行扩展，使其容量至少为n</p></li></ol><h3 id="双端队列（deque）"><a href="#双端队列（deque）" class="headerlink" title="双端队列（deque）"></a>双端队列（deque）</h3><ul><li>特点</li></ul><ol><li><p>在两端插入或删除元素快</p></li><li><p>在中间插入或删除元素慢</p></li><li><p>随机访问较快，但比向量容器慢</p></li></ol><h3 id="例-10-5-奇偶排序"><a href="#例-10-5-奇偶排序" class="headerlink" title="例 10-5 奇偶排序"></a>例 10-5 奇偶排序</h3><p>先按照从大到小顺序输出奇数，再按照从小到大顺序输出偶数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部分省略</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">i1</span><span class="params">(cin)</span>, i2</span>; <span class="comment">//建立一对输入流迭代器</span></span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s1</span><span class="params">(i1, i2)</span></span>; <span class="comment">//通过输入流迭代器从标准输入流中输入数据</span></span><br><span class="line"> <span class="built_in">sort</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>()); <span class="comment">//将输入的整数排序</span></span><br><span class="line"> deque&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"> <span class="comment">//以下循环遍历s1</span></span><br><span class="line"> <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = s1.<span class="built_in">begin</span>(); iter != s1.<span class="built_in">end</span>(); ++iter) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (*iter % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">//偶数放到s2尾部</span></span><br><span class="line"> s2.<span class="built_in">push_back</span>(*iter);</span><br><span class="line"> <span class="keyword">else</span> <span class="comment">//奇数放到s2首部</span></span><br><span class="line"> s2.<span class="built_in">push_front</span>(*iter);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//将s2的结果输出</span></span><br><span class="line"> <span class="built_in">copy</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h3><ul><li>特点</li></ul><ol><li><p>在<strong>任意位置插入和删除元素</strong>都很快</p></li><li><p>不支持<strong>随机</strong>访问</p></li><li><p>接合(splice)操作</p></li><li><p>s1.splice(p, s2, q1, q2)：将s2中[q1, q2)移动到<strong>s1中p所指向元素之前</strong></p></li></ol><p>&#x2F;&#x2F; 头部分省略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string names1[] = &#123; <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Helen&quot;</span>, <span class="string">&quot;Lucy&quot;</span>, <span class="string">&quot;Susan&quot;</span> &#125;;</span><br><span class="line">string names2[] = &#123; <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Levin&quot;</span>, <span class="string">&quot;Mike&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//用names1数组的内容构造列表s1</span></span><br><span class="line"> <span class="function">list&lt;string&gt; <span class="title">s1</span><span class="params">(names1, names1 + <span class="number">4</span>)</span></span>; </span><br><span class="line"><span class="comment">//用names2数组的内容构造列表s2</span></span><br><span class="line"> <span class="function">list&lt;string&gt; <span class="title">s2</span><span class="params">(names2, names2 + <span class="number">4</span>)</span></span>; </span><br><span class="line"><span class="comment">//将s1的第一个元素放到s2的最后</span></span><br><span class="line"> s2.<span class="built_in">splice</span>(s2.<span class="built_in">end</span>(), s1, s1.<span class="built_in">begin</span>());</span><br><span class="line"> list&lt;string&gt;::iterator iter1 = s1.<span class="built_in">begin</span>(); <span class="comment">//iter1指向s1首</span></span><br><span class="line"> <span class="built_in">advance</span>(iter1, <span class="number">2</span>); <span class="comment">//iter1前进2个元素，它将指向s1第3个元素</span></span><br><span class="line"> list&lt;string&gt;::iterator iter2 = s2.<span class="built_in">begin</span>(); <span class="comment">//iter2指向s2首</span></span><br><span class="line"> ++iter2; <span class="comment">//iter2前进1个元素，它将指向s2第2个元素</span></span><br><span class="line"> list&lt;string&gt;::iterator iter3 = iter2; <span class="comment">//用iter2初始化iter3</span></span><br><span class="line"> <span class="built_in">advance</span>(iter3, <span class="number">2</span>); <span class="comment">//iter3前进2个元素，它将指向s2第4个元素</span></span><br><span class="line"> <span class="comment">//将[iter2, iter3)范围内的结点接到s1中iter1指向的结点前</span></span><br><span class="line"> s1.<span class="built_in">splice</span>(iter1, s2, iter2, iter3); </span><br><span class="line"> <span class="comment">//分别将s1和s2输出</span></span><br><span class="line"> <span class="built_in">copy</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">copy</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单向链表（forward-list）"><a href="#单向链表（forward-list）" class="headerlink" title="单向链表（forward_list）"></a>单向链表（forward_list）</h3><ol><li><p>单向链表每个结点只有指向下个结点的指针，没有简单的方法来获取一个结点的前驱；</p></li><li><p>未定义insert、emplace和erase操作，而定义了insert_after、emplace_after和erase_after操作，其参数与list的insert、emplace和erase相同，但并不是插入或删除迭代器p1所指的元素，而是对p1所指元素之后的结点进行操作；</p></li><li><p>不支持size操作。</p></li></ol><h3 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h3><ol><li><p>array是对内置数组的封装，提供了更安全，更方便的使用数组的方式</p></li><li><p>array的对象的大小是固定的，定义时除了需要指定元素类型，还需要指定容器大</p></li></ol><p>小。</p><ol start="3"><li>不能动态地改变容器大小</li></ol><h3 id="顺序容器的比较"><a href="#顺序容器的比较" class="headerlink" title="顺序容器的比较"></a>顺序容器的比较</h3><ol><li>STL所提供的顺序容器各有所长也各有所短，我们在编写程序时应当根据我们对容</li></ol><p>器所需要执行的操作来决定选择哪一种容器。</p><ol start="2"><li>如果需要执行<strong>大量的随机访问操作</strong>，而且当<strong>扩展容器</strong>时只需要向容器尾部加</li></ol><p>入新的元素，就应当选择向量容器vector；</p><ol start="3"><li>如果需要<strong>少量的随机访问</strong>操作，需要在<strong>容器两端插入或删除元素</strong>，则应当选</li></ol><p>择<strong>双端队列容器deque</strong>；</p><ol start="4"><li>如果<strong>不需要</strong>对容器<strong>进行随机访问</strong>，但是需要在中<strong>间位置插入或者删除元素</strong>，</li></ol><p>就应当选择列表容器list或forward_list；</p><ol start="5"><li>如果需要数组，array相对于<strong>内置数组</strong>类型而言，是一种更安全、更容易使</li></ol><p>用的数组类型</p><h2 id="顺序容器的插入迭代器与适配器"><a href="#顺序容器的插入迭代器与适配器" class="headerlink" title="顺序容器的插入迭代器与适配器"></a>顺序容器的插入迭代器与适配器</h2><h3 id="顺序容器的插入迭代器"><a href="#顺序容器的插入迭代器" class="headerlink" title="顺序容器的插入迭代器"></a>顺序容器的插入迭代器</h3><ol><li><p>用于向容器头部、尾部或中间指定位置插入元素的迭代器</p></li><li><p>包括前插迭代器（front_inserter）、后插迭代器（back_insrter）和任意位置插入</p></li></ol><p>迭代器（inserter）</p><p>例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function">back_inserter <span class="title">iter</span><span class="params">(s)</span></span>;</span><br><span class="line">*(iter++) = <span class="number">5</span>; <span class="comment">//通过iter把5插入s末尾</span></span><br></pre></td></tr></table></figure><h3 id="顺序容器的适配器"><a href="#顺序容器的适配器" class="headerlink" title="顺序容器的适配器"></a>顺序容器的适配器</h3><ul><li><p>以顺序容器为基础构建一些常用数据结构，是对<strong>顺序容器的封装</strong></p></li><li><p>栈(stack)：最先压入的元素<strong>最后被弹出</strong></p></li><li><p>队列(queue)：<strong>最先压入</strong>的元素最<strong>先被弹出</strong></p></li><li><p>优先级队列(priority_queue)：<strong>最“大”的元素</strong>最先被弹出</p></li></ul><h3 id="栈和队列模板"><a href="#栈和队列模板" class="headerlink" title="栈和队列模板"></a>栈和队列模板</h3><ul><li>栈模板</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt; <span class="keyword">class</span> stack;</span><br></pre></td></tr></table></figure><ul><li>队列模板</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">FrontInsertionSequence</span> = deque&lt;T&gt; &gt; <span class="keyword">class</span> queue;</span><br></pre></td></tr></table></figure><ul><li>栈可以用任何一种顺序容器作为基础容器，而队列只允许用前插顺序容器（双端队列或列表）</li></ul><h3 id="栈和队列共同支持的操作"><a href="#栈和队列共同支持的操作" class="headerlink" title="栈和队列共同支持的操作"></a>栈和队列共同支持的操作</h3><ul><li><p>s1 op s2 op可以是&#x3D;&#x3D;、!&#x3D;、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;之一，它会对两个容器适配器之间的元素按字典序进行比较</p></li><li><p>s.size()  </p><p>返回s的元素个数</p></li><li><p>s.empty() 返回s是否为空</p></li><li><p>s.push(t)</p><p>   将元素t压入到s中</p></li><li><p>s.pop() 将一个元素从s中弹出，对于栈来说，每次弹出的是最后被压入的元素，而对于队列，每次被弹出的是最先被压入的元素</p></li><li><p>不支持迭代器，因为它们不允许对任意元素进行访问</p></li></ul><h3 id="栈和队列不同的操作"><a href="#栈和队列不同的操作" class="headerlink" title="栈和队列不同的操作"></a>栈和队列不同的操作</h3><ul><li>栈的操作</li></ul><p>s.top() </p><p>返回栈顶元素的引用</p><ul><li>队列操作</li></ul><p>s.front() </p><p>获得队头元素的引用</p><ul><li>s.back()</li></ul><p>获得队尾元素的引用</p><h3 id="例-10-7-利用栈反向输出单词"><a href="#例-10-7-利用栈反向输出单词" class="headerlink" title="例 10-7 利用栈反向输出单词"></a>例 10-7 利用栈反向输出单词</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_7.cpp， 省略头部分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str; <span class="comment">//从键盘输入一个字符串</span></span><br><span class="line"><span class="comment">//将字符串的每个元素顺序压入栈中</span></span><br><span class="line"><span class="keyword">for</span> (string::iterator iter = str.<span class="built_in">begin</span>(); iter != str.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">s.<span class="built_in">push</span>(*iter);</span><br><span class="line"><span class="comment">//将栈中的元素顺序弹出并输出</span></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果如下："><a href="#运行结果如下：" class="headerlink" title="运行结果如下："></a>运行结果如下：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">congratulations</span><br><span class="line">snoitalutargnoc</span><br></pre></td></tr></table></figure><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><ul><li>优先级队列也像栈和队列一样支持元素的压入和弹出，但元素弹出的顺序与元素的大小有关，每次弹出的总是容器中最“大”的一个元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt; &gt; <span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure><ul><li><p>优先级队列的<strong>基础容器</strong>必须是支持<strong>随机访问的顺序容器</strong>。</p></li><li><p>支持栈和<strong>队列的size、empty、push、pop</strong>几个成员函数，用法与栈和队列相同。</p></li><li><p>优先级队列并<strong>不支</strong>持<strong>比较</strong>操作。</p></li><li><p>与栈类似，优先级队列提供<strong>一个top函数</strong>，可以获得下一个即将被<strong>弹出元素（即最“大”的元素）的引用</strong>。</p></li></ul><h3 id="例-10-8-细胞分裂模拟"><a href="#例-10-8-细胞分裂模拟" class="headerlink" title="例 10-8 细胞分裂模拟"></a>例 10-8 细胞分裂模拟</h3><p>一种细胞在诞生（即上次分裂）后会在500到2000秒内分裂为两个细胞，每个细胞又按照同样的规律继续分裂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10.8.cpp, 头部分省略</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SPLIT_TIME_MIN = <span class="number">500</span>; <span class="comment">//细胞分裂最短时间</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SPLIT_TIME_MAX = <span class="number">2000</span>; <span class="comment">//细胞分裂最长时间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span>;</span><br><span class="line">priority_queue&lt;Cell&gt; cellQueue;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span> &#123; <span class="comment">//细胞类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count; <span class="comment">//细胞总数</span></span><br><span class="line"><span class="type">int</span> id; <span class="comment">//当前细胞编号</span></span><br><span class="line"><span class="type">int</span> time; <span class="comment">//细胞分裂时间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cell</span>(<span class="type">int</span> birth) : <span class="built_in">id</span>(count++) &#123; <span class="comment">//birth为细胞诞生时间</span></span><br><span class="line"><span class="comment">//初始化，确定细胞分裂时间</span></span><br><span class="line">time = birth + (<span class="built_in">rand</span>() % (SPLIT_TIME_MAX - SPLIT_TIME_MIN))+ </span><br><span class="line">SPLIT_TIME_MIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> id; &#125; <span class="comment">//得到细胞编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSplitTime</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> time; &#125; <span class="comment">//得到细胞分裂时间</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Cell&amp; s) <span class="type">const</span> <span class="comment">//定义“&lt;”</span></span><br><span class="line"> &#123; <span class="keyword">return</span> time &gt; s.time; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span> </span>&#123; <span class="comment">//细胞分裂</span></span><br><span class="line"> <span class="function">Cell <span class="title">child1</span><span class="params">(time)</span>, <span class="title">child2</span><span class="params">(time)</span></span>; <span class="comment">//建立两个子细胞</span></span><br><span class="line"> cout &lt;&lt; time &lt;&lt; <span class="string">&quot;s: Cell #&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; splits to #&quot;</span></span><br><span class="line">&lt;&lt; child1.<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; and #&quot;</span> &lt;&lt; child2.<span class="built_in">getId</span>() &lt;&lt; endl;</span><br><span class="line"> cellQueue.<span class="built_in">push</span>(child1); <span class="comment">//将第一个子细胞压入优先级队列</span></span><br><span class="line"> cellQueue.<span class="built_in">push</span>(child2); <span class="comment">//将第二个子细胞压入优先级队列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Cell::count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span>&gt;(<span class="built_in">time</span>(<span class="number">0</span>)));</span><br><span class="line"><span class="type">int</span> t; <span class="comment">//模拟时间长度</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Simulation time: &quot;</span>;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">cellQueue.<span class="built_in">push</span>(<span class="built_in">Cell</span>(<span class="number">0</span>)); <span class="comment">//将第一个细胞压入优先级队列</span></span><br><span class="line"><span class="keyword">while</span> (cellQueue.<span class="built_in">top</span>().<span class="built_in">getSplitTime</span>() &lt;= t) &#123;</span><br><span class="line">cellQueue.<span class="built_in">top</span>().<span class="built_in">split</span>(); <span class="comment">//模拟下一个细胞的分裂</span></span><br><span class="line">cellQueue.<span class="built_in">pop</span>(); <span class="comment">//将刚刚分裂的细胞弹出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Simulation time: <span class="number">5000</span></span><br><span class="line"><span class="number">971</span>s: Cell #<span class="number">0</span> splits to #<span class="number">1</span> <span class="keyword">and</span> #<span class="number">2</span></span><br><span class="line"><span class="number">1719</span>s: Cell #<span class="number">1</span> splits to #<span class="number">3</span> <span class="keyword">and</span> #<span class="number">4</span></span><br><span class="line"><span class="number">1956</span>s: Cell #<span class="number">2</span> splits to #<span class="number">5</span> <span class="keyword">and</span> #<span class="number">6</span></span><br><span class="line"><span class="number">2845</span>s: Cell #<span class="number">6</span> splits to #<span class="number">7</span> <span class="keyword">and</span> #<span class="number">8</span></span><br><span class="line"><span class="number">3551</span>s: Cell #<span class="number">3</span> splits to #<span class="number">9</span> <span class="keyword">and</span> #<span class="number">10</span></span><br><span class="line"><span class="number">3640</span>s: Cell #<span class="number">4</span> splits to #<span class="number">11</span> <span class="keyword">and</span> #<span class="number">12</span></span><br><span class="line"><span class="number">3919</span>s: Cell #<span class="number">5</span> splits to #<span class="number">13</span> <span class="keyword">and</span> #<span class="number">14</span></span><br><span class="line"><span class="number">4162</span>s: Cell #<span class="number">10</span> splits to #<span class="number">15</span> <span class="keyword">and</span> #<span class="number">16</span></span><br><span class="line"><span class="number">4197</span>s: Cell #<span class="number">8</span> splits to #<span class="number">17</span> <span class="keyword">and</span> #<span class="number">18</span></span><br><span class="line"><span class="number">4317</span>s: Cell #<span class="number">7</span> splits to #<span class="number">19</span> <span class="keyword">and</span> #<span class="number">20</span></span><br><span class="line"><span class="number">4686</span>s: Cell #<span class="number">13</span> splits to #<span class="number">21</span> <span class="keyword">and</span> #<span class="number">22</span></span><br><span class="line"><span class="number">4809</span>s: Cell #<span class="number">12</span> splits to #<span class="number">23</span> <span class="keyword">and</span> #<span class="number">24</span></span><br><span class="line"><span class="number">4818</span>s: Cell #<span class="number">17</span> splits to #<span class="number">25</span> <span class="keyword">and</span> #<span class="number">26</span></span><br></pre></td></tr></table></figure><h2 id="关联容器分类和的基本功能"><a href="#关联容器分类和的基本功能" class="headerlink" title="关联容器分类和的基本功能"></a>关联容器分类和的基本功能</h2><h3 id="关联容器的特点和接口"><a href="#关联容器的特点和接口" class="headerlink" title="关联容器的特点和接口"></a>关联容器的特点和接口</h3><ul><li>关联容器的特点</li></ul><p>每个关联容器都有一个键(key)</p><p>可以根据键高效地查找元素</p><ul><li>接口</li></ul><ol><li><p>插入：insert</p></li><li><p>删除：erase</p></li><li><p>查找：find</p></li><li><p>定界：lower_bound、upper_bound、equal_range</p></li><li><p>计数：count</p></li></ol><h3 id="关联容器概念图"><a href="#关联容器概念图" class="headerlink" title="关联容器概念图"></a>关联容器概念图</h3><p><img src="https://i.postimg.cc/6q0mLCyK/cce8c0eb52bb35bba409d63dc64ebfb8.png"></p><h3 id="四种关联容器"><a href="#四种关联容器" class="headerlink" title="四种关联容器"></a>四种关联容器</h3><ul><li>单重关联容器(set和map)</li></ul><ol><li>键值是唯一的，一个键值只能对应一个元素</li></ol><ul><li>多重关联容器(multiset和multimap)</li></ul><ol><li>键值是不唯一的，一个键值可以对应多个元素</li></ol><ul><li>简单关联容器(set和multiset)</li></ul><ol><li><p>容器只有一个类型参数，如set<K>、multiset<K>，表示键类型</K></K></p></li><li><p>容器的元素就是键本身</p></li></ol><ul><li>二元关联容器(map和multimap)</li></ul><ol><li><p>容器有两个类型参数，如map&lt;K,V&gt;、multimap&lt;K,V&gt;，分别表示键和附加数据的类型</p></li><li><p>容器的元素类型是pair&lt;K,V&gt;，即由键类型和元素类型复合而成的二元组</p></li></ol><h3 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h3><ul><li>C++11新标准中定义了4个无序关联容器</li></ul><ol><li>unordered_set 、 unordered_map 、 unordered_multiset 、unordered_multimap</li></ol><p> 不是使用比较运算符来组织元素的，而是通过一个哈希函数和键类型的&#x3D;&#x3D;运算符。</p><p> 提供了与有序容器相同的操作 可以直接定义关键字是内置类型的无序容器。</p><p> 不能直接定义关键字类型为自定义类的无序容器，如果需要，必须提供我们自己的hash模板。</p><h2 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h2><p>集合用来存储一组无重复的元素。由于集合的元素本身是有序的，可以高效地查找指</p><p>定元素，也可以方便地得到指定大小范围的元素在容器中所处的区间。</p><h3 id="例-10-9"><a href="#例-10-9" class="headerlink" title="例 10-9"></a>例 10-9</h3><p>输入一串实数，将重复的去掉，取最大和最小者的中值，分别输出小于等于此中值和</p><p>大于等于此中值的实数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_9.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">set&lt;<span class="type">double</span>&gt; s;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="type">double</span> v;</span><br><span class="line"> cin &gt;&gt; v;</span><br><span class="line"> <span class="keyword">if</span> (v == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//输入0表示结束</span></span><br><span class="line"> <span class="comment">//尝试将v插入</span></span><br><span class="line"> pair&lt;set&lt;<span class="type">double</span>&gt;::iterator,<span class="type">bool</span>&gt; r=s.<span class="built_in">insert</span>(v); </span><br><span class="line"> <span class="keyword">if</span> (!r.second) <span class="comment">//如果v已存在，输出提示信息</span></span><br><span class="line"> cout &lt;&lt; v &lt;&lt; <span class="string">&quot; is duplicated&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//得到第一个元素的迭代器</span></span><br><span class="line">set&lt;<span class="type">double</span>&gt;::iterator iter1=s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//得到末尾的迭代器</span></span><br><span class="line">set&lt;<span class="type">double</span>&gt;::iterator iter2=s.<span class="built_in">end</span>();</span><br><span class="line"> <span class="comment">//得到最小和最大元素的中值</span></span><br><span class="line"><span class="type">double</span> medium=(*iter1 + *(--iter2)) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//输出小于或等于中值的元素</span></span><br><span class="line">cout&lt;&lt; <span class="string">&quot;&lt;= medium: &quot;</span></span><br><span class="line"><span class="built_in">copy</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">upper_bound</span>(medium), <span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout, <span class="string">&quot; </span></span><br><span class="line"><span class="string">&quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出大于或等于中值的元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&gt;= medium: &quot;</span>;</span><br><span class="line"><span class="built_in">copy</span>(s.<span class="built_in">lower_bound</span>(medium), s.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2.5</span> <span class="number">5</span> <span class="number">3.5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">2.5</span> <span class="number">0</span></span><br><span class="line"><span class="number">5</span> is duplicated</span><br><span class="line"><span class="number">2.5</span> is duplicated</span><br><span class="line">&lt;= medium: <span class="number">1</span> <span class="number">2.5</span> <span class="number">3.5</span> <span class="number">5</span></span><br><span class="line">&gt;= medium: <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="映射（map）"><a href="#映射（map）" class="headerlink" title="映射（map）"></a>映射（map）</h2><ol><li>映射与集合同属于单重关联容器，它们的主要区别在于，集合的元素类型是键本身，</li></ol><p>而映射的元素类型是由键和附加数据所构成的二元组。</p><ol start="2"><li>在集合中按照键查找一个元素时，一般只是用来确定这个元素是否存在，而在映射</li></ol><p>中按照键查找一个元素时，除了能确定它的存在性外，还可以得到相应的附加数据。</p><h3 id="例-10-10"><a href="#例-10-10" class="headerlink" title="例 10-10"></a>例 10-10</h3><p>有五门课程，每门都有相应学分，从中选择三门，输出学分总和</p><p>&#x2F;&#x2F;10_10.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; courses;</span><br><span class="line"><span class="comment">//将课程信息插入courses映射中</span></span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;CSAPP&quot;</span>, <span class="number">3</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++&quot;</span>, <span class="number">2</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;CSARCH&quot;</span>, <span class="number">4</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;COMPILER&quot;</span>, <span class="number">4</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;OS&quot;</span>, <span class="number">5</span>));</span><br><span class="line"><span class="type">int</span> n = <span class="number">3</span>; <span class="comment">//剩下的可选次数</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//学分总和</span></span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name; <span class="comment">//输入课程名称</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::iterator iter = courses.<span class="built_in">find</span>(name);<span class="comment">//查找课程</span></span><br><span class="line"><span class="keyword">if</span> (iter == courses.<span class="built_in">end</span>()) &#123; <span class="comment">//判断是否找到</span></span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is not available&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum += iter-&gt;second; <span class="comment">//累加学分</span></span><br><span class="line">courses.<span class="built_in">erase</span>(iter); <span class="comment">//将刚选过的课程从映射中删除</span></span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Total credit: &quot;</span> &lt;&lt; sum &lt;&lt; endl; <span class="comment">//输出总学分</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C++</span><br><span class="line">COMPILER</span><br><span class="line">C++</span><br><span class="line">C++ is <span class="keyword">not</span> available</span><br><span class="line">CSAPP</span><br><span class="line">Total credit: <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="例-10-11"><a href="#例-10-11" class="headerlink" title="例 10-11"></a>例 10-11</h3><p>统计一句话中每个字母出现的次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10_11.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; s; <span class="comment">//用来存储字母出现次数的映射</span></span><br><span class="line"><span class="type">char</span> c; <span class="comment">//存储输入字符</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"> cin &gt;&gt; c; <span class="comment">//输入下一个字符</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c))&#123; <span class="comment">//判断是否是字母</span></span><br><span class="line"> c = <span class="built_in">tolower</span>(c); <span class="comment">//将字母转换为小写</span></span><br><span class="line"> s[c]++; <span class="comment">//将该字母的出现频率加1</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (c != <span class="string">&#x27;.&#x27;</span>); <span class="comment">//碰到“.”则结束输入</span></span><br><span class="line"><span class="comment">//输出每个字母出现次数</span></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;::iterator iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多重集合（multiset）与多重映射（multimap）"><a href="#多重集合（multiset）与多重映射（multimap）" class="headerlink" title="多重集合（multiset）与多重映射（multimap）"></a>多重集合（multiset）与多重映射（multimap）</h2><ul><li><p>多重集合是允许有重复元素的集合，多重映射是允许一个键对应多个附加数据的映射。</p></li><li><p>多重集合与集合、多重映射与映射的用法差不多，只在几个成员函数上有细微差异，其差异主要表现在去除了键必须唯一的限制。</p></li></ul><h3 id="例-10-12-上课时间查询"><a href="#例-10-12-上课时间查询" class="headerlink" title="例 10-12 上课时间查询"></a>例 10-12 上课时间查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_12.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">multimap&lt;string, string&gt; courses;</span><br><span class="line"><span class="keyword">typedef</span> multimap&lt;string, string&gt;::iterator CourseIter;</span><br><span class="line"><span class="comment">//将课程上课时间插入courses映射中</span></span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;2-6&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;COMPILER&quot;</span>, <span class="string">&quot;3-1&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;COMPILER&quot;</span>, <span class="string">&quot;5-2&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;OS&quot;</span>, <span class="string">&quot;1-2&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;OS&quot;</span>, <span class="string">&quot;4-1&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;OS&quot;</span>, <span class="string">&quot;5-5&quot;</span>));</span><br><span class="line"><span class="comment">//输入一个课程名，直到找到该课程为止，记下每周上课次数</span></span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">count = courses.<span class="built_in">count</span>(name);</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Cannot find this course!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">while</span> (count == <span class="number">0</span>);</span><br><span class="line"><span class="comment">//输出每周上课次数和上课时间</span></span><br><span class="line">cout &lt;&lt; count &lt;&lt; <span class="string">&quot; lesson(s) per week: &quot;</span>;</span><br><span class="line">pair&lt;CourseIter, CourseIter&gt; range = courses.<span class="built_in">equal_range</span>(name);</span><br><span class="line"><span class="keyword">for</span> (CourseIter iter = range.first; iter != range.second; ++iter)</span><br><span class="line">cout &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">Cannot find <span class="keyword">this</span> course!</span><br><span class="line">OS</span><br><span class="line"><span class="number">3</span> <span class="built_in">lesson</span>(s) per week: <span class="number">1</span><span class="number">-2</span> <span class="number">4</span><span class="number">-1</span> <span class="number">5</span><span class="number">-5</span></span><br></pre></td></tr></table></figure><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><ul><li><p>一个行为类似函数的对象</p></li><li><p>可以没有参数，也可以带有若干参数</p></li><li><p>其功能是获取一个值，或者改变操作的状态。</p></li><li><p>例</p></li></ul><ol><li><p>普通函数就是函数对象</p></li><li><p>重载了“()”运算符的类的实例是函数对象</p></li></ol><h3 id="函数对象概念图"><a href="#函数对象概念图" class="headerlink" title="函数对象概念图"></a>函数对象概念图</h3><p><img src="https://i.postimg.cc/63xjkMZw/79fc9c5da64631a30a7b023715e142a7.png"></p><h3 id="例-10-13、例-10-14："><a href="#例-10-13、例-10-14：" class="headerlink" title="例 10-13、例 10-14："></a>例 10-13、例 10-14：</h3><ol><li><p>使用两种方式定义表示乘法的函数对象</p></li><li><p>通过定义普通函数（例10-13）</p></li><li><p>通过重载类的“()”运算符（例10-14）</p></li></ol><p>• 用到以下算法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> Type, <span class="keyword">class</span> BinaryFunction&gt;</span></span><br><span class="line"><span class="function">Type <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, Type val, </span></span></span><br><span class="line"><span class="params"><span class="function">BinaryFunction binaryOp)</span></span>;</span><br></pre></td></tr></table></figure><p> 对[first, last)区间内的数据进行累“加”，binaryOp为用二元函数对象表示的“加”运算符，val为累“加”的初值</p><h3 id="例-10-13"><a href="#例-10-13" class="headerlink" title="例 10-13"></a>例 10-13</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">//包含数值算法头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义一个普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mult</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The result by multipling all elements in a is &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">accumulate</span>(a, a + N, <span class="number">1</span>, mult)</span><br><span class="line">&lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例-10-14"><a href="#例-10-14" class="headerlink" title="例 10-14"></a>例 10-14</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_14.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">//包含数值算法头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultClass</span>&#123; <span class="comment">//定义MultClass类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">//重载操作符operator()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The result by multipling all elements in a is &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">accumulate</span>(a, a + N, <span class="number">1</span>, <span class="built_in">MultClass</span>()) <span class="comment">//将类multclass传递给通用算法</span></span><br><span class="line">&lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL-提供的函数对象"><a href="#STL-提供的函数对象" class="headerlink" title="STL 提供的函数对象"></a>STL 提供的函数对象</h3><ul><li>用于算术运算的函数对象：</li></ul><ol><li><p>一元函数对象(一个参数) ：negate</p></li><li><p>二元函数对象(两个参数) ：plus、minus、multiplies、divides、modulus</p></li><li><p>用于关系运算、逻辑运算的函数对象(要求返回值为bool)</p></li><li><p>一元谓词(一个参数)：logical_not</p></li><li><p>二 元 谓 词 ( 两 个 参 数 ) ： equal_to 、 not_equal_to 、 greater 、 less 、greater_equal、less_equal、logical_and、logical_or</p></li></ol><h3 id="例-10-15-利用-STL-标准函数对象"><a href="#例-10-15-利用-STL-标准函数对象" class="headerlink" title="例 10-15 利用 STL 标准函数对象"></a>例 10-15 利用 STL 标准函数对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_15.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">//包含数值算法头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">//包含标准函数对象头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The result by multipling all elements in A is “</span></span><br><span class="line"><span class="string"> &lt;&lt; accumulate(a, a + N, 1, multiplies&lt;int&gt;())</span></span><br><span class="line"><span class="string">&lt;&lt; endl; //将标准函数对象传递给通用算法</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="例-10-16-利用-STL-中的二元谓词函数对象"><a href="#例-10-16-利用-STL-中的二元谓词函数对象" class="headerlink" title="例 10-16 利用 STL 中的二元谓词函数对象"></a>例 10-16 利用 STL 中的二元谓词函数对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10_16.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> intArr[] = &#123; <span class="number">30</span>, <span class="number">90</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(intArr, intArr + N)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;before sorting:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;after sorting:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h2><ul><li>绑定适配器：bind1st、bind2nd</li></ul><ol><li><p>将n元函数对象的指定参数绑定为一个常数，得到n-1元函数对象</p></li><li><p>组合适配器：not1、not2</p></li><li><p>将指定谓词的结果取反</p></li><li><p>函数指针适配器：ptr_fun</p></li><li><p>将一般函数指针转换为函数对象，使之能够作为其它函数适配器的输入。</p></li><li><p>在进行参数绑定或其他转换的时候，通常需要函数对象的类型信息，例如bind1st和bind2nd要求函数对象必须继承于binary_function类型。但如果传入的是函数指针形式的函数对象，则无法获得函数对象的类型信息。</p></li><li><p>成员函数适配器：ptr_fun、ptr_fun_ref</p></li><li><p>对成员函数指针使用，把n元成员函数适配为n + 1元函数对象，该函数对象的第一个参数为调用该成员函数时的目的对象</p></li><li><p>也就是需要将“object-&gt;method()”转为“method(object)”形式。将“object-&gt;method(arg1)”转为二元函数“method(object, arg1)”。</p></li></ol><h3 id="绑定适配器"><a href="#绑定适配器" class="headerlink" title="绑定适配器"></a>绑定适配器</h3><ol><li><p>binder2nd的实例构造通常比较冗长，bind2nd函数用于辅助构造binder2nd，产生它的一个实例。</p></li><li><p>binder1st和bind1st，将一个具体值绑定到二元函数的第一个参数。</p></li></ol><h3 id="例-10-17：函数适配器实例——找到数组中第一个大于-40-的元素"><a href="#例-10-17：函数适配器实例——找到数组中第一个大于-40-的元素" class="headerlink" title="例 10-17：函数适配器实例——找到数组中第一个大于 40 的元素"></a>例 10-17：函数适配器实例——找到数组中第一个大于 40 的元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_17.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> intArr[] = &#123; <span class="number">30</span>, <span class="number">90</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(intArr, intArr + N)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator p = <span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), </span><br><span class="line"><span class="number">40</span>));</span><br><span class="line"><span class="keyword">if</span> (p == a.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;no element greater than 40&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;first element greater than 40 is: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><p>find_if算法在STL中的原型声明为：</p><p>template&lt;class InputIterator, class UnaryPredicate&gt;</p><p>InputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate pred);它的功能是查找数组[first, last)区间中第一个pred(x)为真的元素。</p><h3 id="组合适配器"><a href="#组合适配器" class="headerlink" title="组合适配器"></a>组合适配器</h3><ol><li><p>对于一般的逻辑运算，有时可能还需要对结果求一次逻辑反。</p></li><li><p>unary_negate和binary_negate实现了这一适配功能。STL还提供了not1和not2辅助生成相应的函数对象实例，分别用于一元谓词和二元谓词的逻辑取反。</p></li></ol><h3 id="例-10-18-ptr-fun、not1-和-not2-产生函数适配器实例"><a href="#例-10-18-ptr-fun、not1-和-not2-产生函数适配器实例" class="headerlink" title="例 10-18 ptr_fun、not1 和 not2 产生函数适配器实例"></a>例 10-18 ptr_fun、not1 和 not2 产生函数适配器实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10_18.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> intArr[] = &#123; <span class="number">30</span>, <span class="number">90</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(intArr, intArr + N)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator p;</span><br><span class="line">p = <span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(g), <span class="number">40</span>));</span><br><span class="line"><span class="keyword">if</span> (p == a.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;no element greater than 40&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;first element greater than 40 is: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">p = <span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">15</span>)));</span><br><span class="line"><span class="keyword">if</span> (p == a.<span class="built_in">end</span>())</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;no element is not greater than 15&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;first element that is not greater than 15 is: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">p = <span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">not2</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()), <span class="number">15</span>));</span><br><span class="line"><span class="keyword">if</span> (p == a.<span class="built_in">end</span>())</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;no element is not greater than 15&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;first element that is not greater than 15 is: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例-10-19-成员函数适配器实例"><a href="#例-10-19-成员函数适配器实例" class="headerlink" title="例 10-19 成员函数适配器实例"></a>例 10-19 成员函数适配器实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_19.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="built_in">Car</span>(<span class="type">int</span> id) &#123; <span class="keyword">this</span>-&gt;id = id; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;car &quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;Car *&gt; pcars;</span><br><span class="line">vector&lt;Car&gt; cars;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">pcars.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Car</span>(i));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">cars.<span class="built_in">push_back</span>(<span class="built_in">Car</span>(i));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;elements in pcars: &quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(pcars.<span class="built_in">begin</span>(), pcars.<span class="built_in">end</span>(), std::<span class="built_in">mem_fun</span>(&amp;Car::display));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;elements in cars: &quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(cars.<span class="built_in">begin</span>(), cars.<span class="built_in">end</span>(), std::<span class="built_in">mem_fun_ref</span>(&amp;Car::display));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pcars.<span class="built_in">size</span>(); ++i)</span><br><span class="line"><span class="keyword">delete</span> pcars[i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法</p><p>STL 算法特点</p><ol><li><p>STL算法本身是一种函数模版</p></li><li><p>通过迭代器获得输入数据</p></li><li><p>通过函数对象对数据进行处理</p></li><li><p>通过迭代器将结果输出</p></li><li><p>STL算法是通用的，独立于具体的数据类型、容器类型</p></li></ol><p>STL 算法分类</p><ol><li><p>不可变序列算法</p></li><li><p>可变序列算法</p></li><li><p>排序和搜索算法</p></li><li><p>数值算法</p></li></ol><p>不可变序列算法</p><ol><li><p>不直接修改所操作的容器内容的算法</p></li><li><p>用于查找指定元素、比较两个序列是否相等、对元素进行计数等</p></li></ol><ul><li>例：</li></ul><p>template&lt;class InputIterator, class UnaryPredicate&gt;</p><p>InputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate pred);</p><p>查找[first, last)区间内pred(x)为真的首个元素</p><p>可变序列算法</p><ol><li><p>可以修改它们所操作的容器对象</p></li><li><p>包括对序列进行复制、删除、替换、倒序、旋转、交换、分割、去重、填充、洗牌</p></li></ol><p>的算法及生成一个序列的算法</p><ul><li>例：</li></ul><p>template&lt;class ForwardIterator, class T&gt;</p><p>void fill (ForwardIterator first, ForwardIterator last, const T&amp; x);</p><p>将[first, last)区间内的元素全部改写为x。</p><p>排序和搜索算法</p><ol><li><p>对序列进行排序</p></li><li><p>对两有序序列进行合并</p></li><li><p>对有序序列进行搜索</p></li><li><p>有序序列的集合操作</p></li></ol><ul><li>堆算法</li></ul><p> 例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span> , <span class="keyword">class</span> <span class="title class_">UnaryPredicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last, UnaryPredicate comp)</span></span>;</span><br></pre></td></tr></table></figure><p>以函数对象comp为“&lt;”，对 [first, last)区间内的数据进行排序</p><h3 id="数值算法"><a href="#数值算法" class="headerlink" title="数值算法"></a>数值算法</h3><ol><li><p>求序列中元素的“和”、部分“和”、相邻元素的“差”或两序列的内积</p></li><li><p>求“和”的“+”、求“差”的“-”以及求内积的“+”和“·”都可由函数对象</p></li></ol><p>指定</p><p>例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator, <span class="keyword">class</span> </span></span><br><span class="line"><span class="function">BinaryFunction&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">partial_sum</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result, BinaryFunction op)</span></span>;</span><br></pre></td></tr></table></figure><p>对[first, last)内的元素求部分“和”（所谓部分“和”，是一个长度与输入序</p><p>列相同的序列，其第n项为输入序列前n个元素的“和”），以函数对象op为“+”</p><p>运算符，结果通过result输出，返回的迭代器指向输出序列最后一个元素的下</p><p>一个元素</p><h3 id="算法应用举例"><a href="#算法应用举例" class="headerlink" title="算法应用举例"></a>算法应用举例</h3><ol><li><p>例10-20——例10-23演示了几类算法的应用。</p></li><li><p>详见教材第10章</p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>本章主要内容</p></li><li><p>泛型程序设计的概念</p></li><li><p>与标准模板库有关的概念和术语</p></li><li><p>迭代器</p></li><li><p>容器</p></li><li><p>函数对象</p></li><li><p>算法</p></li><li><p>本章学习目标</p></li></ul><ol><li><p>初步了解泛型程序设计的概念</p></li><li><p>学会C++标准模板库（STL）的使用方法</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;泛型程序设计的基本概念&quot;&gt;&lt;a href=&quot;#泛型程序设计的基本概念&quot; class=&quot;headerlink&quot; title=&quot;泛型程序设计的基本概念&quot;&gt;&lt;/a&gt;泛型程序设计的基本概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;编写不依赖于&lt;strong&gt;具体数据类型&lt;/strong</summary>
      
    
    
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>电影批评：阿凡达</title>
    <link href="http://example.com/2024/08/11/%E7%94%B5%E5%BD%B1%E6%89%B9%E8%AF%84%EF%BC%9A%E9%98%BF%E5%87%A1%E8%BE%BE/"/>
    <id>http://example.com/2024/08/11/%E7%94%B5%E5%BD%B1%E6%89%B9%E8%AF%84%EF%BC%9A%E9%98%BF%E5%87%A1%E8%BE%BE/</id>
    <published>2024-08-10T22:12:20.000Z</published>
    <updated>2024-08-10T22:12:20.403Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>算法：字符串</title>
    <link href="http://example.com/2024/08/10/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://example.com/2024/08/10/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2024-08-10T04:27:20.000Z</published>
    <updated>2024-08-16T01:13:36.225Z</updated>
    
    <content type="html"><![CDATA[<h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li></ul><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[l],s[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="双指针底层"><a href="#双指针底层" class="headerlink" title="双指针底层"></a>双指针底层</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=s[l];</span><br><span class="line">            s[l]=s[r];</span><br><span class="line">            s[r]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, k = 2</span><br><span class="line">输出：&quot;bacd&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由小写英文组成</li><li><code>1 &lt;= k &lt;= 104</code></li></ul><h4 id="分类讨论-库函数"><a href="#分类讨论-库函数" class="headerlink" title="分类讨论+库函数"></a>分类讨论+库函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i=i+<span class="number">2</span>*k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+k&lt;=s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">2</span>*k<span class="number">-1</span>;l&lt;k;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=s[l];</span><br><span class="line">            s[l]=s[r];</span><br><span class="line">            s[r]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=i+k,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;(s.<span class="built_in">size</span>()+i+k)/<span class="number">2</span>;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=s[l];</span><br><span class="line">            s[l]=s[r];</span><br><span class="line">            s[r]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="分类讨论"><a href="#分类讨论" class="headerlink" title="分类讨论"></a>分类讨论</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp;s,<span class="type">int</span> start,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=start,r=end;l&lt;r;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=s[l];</span><br><span class="line">            s[l]=s[r];</span><br><span class="line">            s[r]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i = i + <span class="number">2</span> * k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s,i,i+k<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverse</span>(s,i,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p><h4 id="自己的思路"><a href="#自己的思路" class="headerlink" title="自己的思路"></a>自己的思路</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; s1;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        a.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//左边隔板的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;a.<span class="built_in">push_back</span>(i);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录中间隔板的位置</span></span><br><span class="line">        a.<span class="built_in">push_back</span>(s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">//右边界隔板的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!a.<span class="built_in">size</span>()) <span class="keyword">return</span> s;</span><br><span class="line">            <span class="comment">//单个单词直接返回</span></span><br><span class="line">            s1.<span class="built_in">push_back</span>(s.<span class="built_in">begin</span>()+a[i]+<span class="number">1</span>,s.<span class="built_in">begin</span>()+a[i+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//左隔板前移动一位，右隔板后移一位，切出一个单词</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s1.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;r;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s1[l],s1[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        string s2=s1[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//左右指针将单词反转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s1.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s2+=<span class="string">&#x27; &#x27;</span>+s1[i];</span><br><span class="line">        &#125;<span class="comment">//利用占头部的方式消除前置零</span></span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Split库-分隔单词"><a href="#Split库-分隔单词" class="headerlink" title="Split库+分隔单词"></a>Split库+分隔单词</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">istringstream <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">        string str;</span><br><span class="line">        stack&lt;string&gt; zhan;</span><br><span class="line">        <span class="keyword">while</span>(is&gt;&gt;str)&#123;</span><br><span class="line">            zhan.<span class="built_in">push</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用输入流，将单词分别输入</span></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!zhan.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res += zhan.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(zhan.<span class="built_in">size</span>() != <span class="number">1</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            zhan.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//利用栈原理，逆向接受单词空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="栈原理"><a href="#栈原理" class="headerlink" title="栈原理"></a>栈原理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">// self solution! yeah!!</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack &lt;string&gt; stk;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;<span class="comment">//先遍历字符串，提前单词，word入栈</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                word += s[i];</span><br><span class="line">                <span class="keyword">if</span> (i ==  n<span class="number">-1</span> || s[i+<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//关键判断条件：什么时候入栈，当字母后有空格或已是最后一个则判断为word，入栈</span></span><br><span class="line">                    stk.<span class="built_in">push</span>(word);</span><br><span class="line">                    word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>())&#123;<span class="comment">//释放栈中元素，加入空格组成反转后结果</span></span><br><span class="line">            ans += stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>())  ans += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123; <span class="comment">//翻转，区间写法：左闭又闭 []</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;<span class="comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;   <span class="comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//遇到非空格就处理，即删除所有空格。</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//补上该单词，遇到空格说明单词结束。</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow); <span class="comment">//slow的大小即为去除多余空格后的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s); <span class="comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i - <span class="number">1</span>); <span class="comment">//翻转，注意是左闭右闭 []的翻转。</span></span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">//更新下一个单词的开始下标start</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>文本串 （m）<br>$$<br>aabaabaaf<br>$$<br>模式串（n）<br>$$<br>aabaaf<br>$$<br>暴力算法的时间复杂度O（m*n）</p><h4 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h4><p>前缀：</p><p>必须包含第一个字母但不包含最后一个字母的连续子串</p><p>后缀：</p><p>必须包含最后一个字母但不包含第一个字母的连续子串</p><p>前缀表：</p><p>最长相等前后缀（即这个字符串的前缀和后缀相等，还是最长的那个）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cebda048620efc235b1cdd19de36b6fa.png" alt="前缀表"></p><p>设置一个next数组，来记录前缀表的值。</p><h4 id="前缀函数的实现"><a href="#前缀函数的实现" class="headerlink" title="前缀函数的实现"></a>前缀函数的实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix_function</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="type">int</span>)s.<span class="built_in">length</span>();</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">substr</span>(<span class="number">0</span>, j) == s.<span class="built_in">substr</span>(i - j + <span class="number">1</span>, j)) &#123;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/08/10/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240814132219332.png" alt="image-20240814132219332"></p><h4 id="KMP算法的示例"><a href="#KMP算法的示例" class="headerlink" title="KMP算法的示例"></a>KMP算法的示例</h4><p>为了展示这个算法的细节，以及这个算法的运行，给出两个字符串：<br>$$<br>W&#x3D;”ABCDABD” andS&#x3D;”ABC ABCDAB ABCDABCDABDE”<br>$$<br>在某个特定的时间点，这个处于被两个整数类型的变量决定的状态</p><ul><li>m，显示W串在S串中的起始位置</li><li>i，显示当前被考虑的字符在W串中的索引</li></ul><p>在算法的每一步中。都将比较S[m+i]与W[i]，如果这两者相等，就递增变量i。</p><p>下面是对过程的呈现，在运行的最开始。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W: ABCDABD</span><br><span class="line">i: <span class="number">0123456</span></span><br></pre></td></tr></table></figure><p>这个算法比较W中的连续字符串与S中的平行字符串，如果两者的字符能够匹配，i发生递增，将从现在的字符移动到另一个字符。然而在第四步中，S[3]&#x3D;’ ‘与W[3]&#x3D;’D’不匹配。我们不会从S[1]重新开始搜索，我们注意到在S串的位置1到位置2中，’A’都没有出现，因此，在预先检查过S串中对饮的所有字符之后（以及已知它们能够匹配上W串中对应的字符），得知从S串的最开始去寻找没有机会达成目标，因此，根据算法，设置m&#x3D;3以及i&#x3D;0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:    ABCDABD</span><br><span class="line">i:    <span class="number">0123456</span></span><br></pre></td></tr></table></figure><p>这次匹配在初始字符处失败了，因此根据算法，设置m&#x3D;4以及i&#x3D;0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:     ABCDABD</span><br><span class="line">i:     <span class="number">0123456</span></span><br></pre></td></tr></table></figure><p>此处，i随着一次几乎完全的匹配递增，直到i&#x3D;6的时候，在W[6]和S[10]出现了一次不匹配。然而就在这次部分匹配之前，存在子串”AB”，它可以作为新一次匹配的起始，所以根据算法必须考虑这一点。因为能够匹配两个字符的这个字串处于当前位置之前，这些字符没有被再次核验的必要；根据算法，设置m&#x3D;9（初始化词头的起始点）以及i&#x3D;2（表示有两个字符匹配），然后继续匹配。因此根据算法不仅省略了提前匹配S串的字符（’AB’），而且提前匹配了W串的字符（词头”AB”）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:         ABCDABD</span><br><span class="line">i:         <span class="number">0123456</span></span><br></pre></td></tr></table></figure><p>在新位置的搜索立刻由于W[2]和S[10]不匹配而失败。由于在首次尝试，根据算法，不匹配使得运算退回W串的起始点，以及从S串的不匹配字符位置（m&#x3D;10）开始匹配，设置i&#x3D;0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:           ABCDABD</span><br><span class="line">i:           <span class="number">0123456</span></span><br></pre></td></tr></table></figure><p>在m&#x3D;10处的匹配立即失败，因此根据算法，开始尝试m&#x3D;11和i&#x3D;0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:            ABCDABD</span><br><span class="line">i:            <span class="number">0123456</span></span><br></pre></td></tr></table></figure><p>再一次，根据算法，能够匹配”ABCDAB“字符，但是其下一个字符‘C’不能匹配W串的最后一个字符‘D’。和之前同样的原因，根据算法，设置m&#x3D;15，从双字符字符串”AB“开始，连接到当前位置，设置i&#x3D;2，然后继续从当前位置开始匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:                ABCDABD</span><br><span class="line">i:                <span class="number">0123456</span></span><br></pre></td></tr></table></figure><p>此时匹配已经完成，W串的第一个字符是从S[15]开始匹配的。</p><h4 id="KMP搜索算法的伪代码描述"><a href="#KMP搜索算法的伪代码描述" class="headerlink" title="KMP搜索算法的伪代码描述"></a>KMP搜索算法的伪代码描述</h4><p>以上的样例包含了KMP搜索算法的所有要素。此时，我们假定”部分匹配“表T的存在，描述如下，其表示当一次不匹配被发现时，我们需要从哪里开始我们新一次的匹配。创建T的目录是为了当我们以S[m]为匹配起始点，比较S[m+i]到W[i]失败时，下一个可能的匹配起始点可以为S串索引为m+i-T[i]的位置（T[i]是在发生一次不匹配后我们需要回溯的数量）。这具有两个影响：首先，T[0]&#x3D;-1，表明W[0]会发生一次不匹配，我们不能回溯还必须简单检查下面一个字符；以及第二个，尽管接下来可能的匹配会从索引m+i-T[i]开始，因为以上的例子，我们没有必要镇店确定T[i]之后的任何字符，因此我们继续从W[T[i]]开始搜索。下面是KMP搜索算法的一个简单伪代码执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">algorithm kmp_search:</span><br><span class="line">    input:</span><br><span class="line">        an array of characters, <span class="built_in">S</span> (the text to be searched)</span><br><span class="line">        an array of characters, <span class="built_in">W</span> (the word sought)</span><br><span class="line">    output:</span><br><span class="line">        an array of integers, <span class="built_in">P</span> (positions in S at which W is found)</span><br><span class="line">        an integer, <span class="built_in">nP</span> (number of positions)</span><br><span class="line"></span><br><span class="line">    define variables:</span><br><span class="line">        an integer, j ← <span class="number">0</span> (the position of the current character in S)</span><br><span class="line">        an integer, k ← <span class="number">0</span> (the position of the current character in W)</span><br><span class="line">        an array of integers, <span class="built_in">T</span> (the table, computed elsewhere)</span><br><span class="line"></span><br><span class="line">    let nP ← <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="built_in">length</span>(S) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> W[k] = S[j] then</span><br><span class="line">            let j ← j + <span class="number">1</span></span><br><span class="line">            let k ← k + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k = <span class="built_in">length</span>(W) <span class="built_in">then</span></span><br><span class="line">                (occurrence found, <span class="keyword">if</span> only first occurrence is needed, m ← j - k  may be returned here)</span><br><span class="line">                let P[nP] ← j - k, nP ← nP + <span class="number">1</span></span><br><span class="line">                let k ← T[k] (T[<span class="built_in">length</span>(W)] can<span class="number">&#x27;</span>t be <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            let k ← T[k]</span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span> then</span><br><span class="line">                let j ← j + <span class="number">1</span></span><br><span class="line">                let k ← k + <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">j++;</span><br><span class="line"> &#125;</span><br><span class="line">next[i] = j; <span class="comment">// 将j（前缀的⻓度）赋给next[i]</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">j++;</span><br><span class="line"> &#125;</span><br><span class="line">next[i] = j; <span class="comment">// 将j（前缀的⻓度）赋给next[i]</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">int</span> next[needle.<span class="built_in">size</span>()];</span><br><span class="line"><span class="built_in">getNext</span>(next, needle);</span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组⾥记录的起始位置为-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i就从0开始</span></span><br><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">j++; <span class="comment">// i的增加在for循环⾥</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span> (j == (needle.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// ⽂本串s⾥出现了模式串t</span></span><br><span class="line"><span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;344-反转字符串&quot;&gt;&lt;a href=&quot;#344-反转字符串&quot; class=&quot;headerlink&quot; title=&quot;344. 反转字符串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.cn/problems/reverse-string/&quot;&gt;344</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
