<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>柳瀬しおこうの夢</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-01T18:06:07.769Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>SHIOKOU</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>古事記</title>
    <link href="http://example.com/2024/11/02/%E5%8F%A4%E4%BA%8B%E8%A8%98/"/>
    <id>http://example.com/2024/11/02/%E5%8F%A4%E4%BA%8B%E8%A8%98/</id>
    <published>2024-11-01T18:05:09.000Z</published>
    <updated>2024-11-01T18:06:07.769Z</updated>
    
    <content type="html"><![CDATA[<p><strong>序、古事記序</strong>　臣やつこ安萬侶やすまろ言まをす：夫それ，混元ひたたけたるもの既凝こり，氣象けはひかたち未效いまだあらはれず。無名なもなく無為しわざもなく，誰知其形そのかたち。然しかれども乾坤あめつち初分，參神みはしらのかみ作造化之首よろづもののはじめ。陰陽めを斯開ここにひらけ，二靈ふたはしらのかみ為群品之祖もろもろのもののおや。所以そこゆゑ，出入幽よもつくに顯うつしくに，日ひのかみ月つきのかみ彰あらはれ於洗あらふ目。浮沉うきしづみ海水うしほ，神あまつかみ祇くにつかみ呈あらはれ於滌すすぐ身。故かれ太素もと杳冥くらけ，因本教もとつをしへ而識しれり孕土くにをはらみ產島しまをうみ之時，元始はじめ綿邈とほく，賴より先聖さきのひじり而察さとれり生神かみをうみ立人ひとをたて之世。寔知まことにしりぬ，懸かけ鏡吐はき珠，而百王もものきみ相續あひづき。喫かみ劍切きり蛇へみ，以萬神よろづのかみ蕃息うまはりし與。議はかり安河やすのかは而平たひらげ天下あめのした，論あげつらひ小濱をはま而淸きよめ國土くに。　是以ここをもちて，番仁岐命ほのににぎのみこと，初降くだり于高千嶺たかちほのみね。<em>【○瓊瓊杵尊。】</em>神倭天皇かむやまとのすめらみこと，經歷へましき于秋津島あきづしま。化なれるもの熊くま出いだし爪つめ，天劍あめのつるぎ獲えたまひき於高倉たかくら。生尾をおひたるひと遮さへ徑みち，大烏おほきからす導みちびき於吉野よしの。列儛まひをつらね攘賊あたをはらひ，聞歌伏仇あた。<em>【○神武。】</em>即すなはち覺夢いめをさとり而敬いやまひ神あまつかみ祇くにつかみ，所以そこゆゑ稱たたへ賢后さかしききみ。<em>【○崇神。】</em>望烟けぶり而撫なで黎元おほみたから，於今傳つたへ聖帝ひじりのみかど。<em>【○仁德。】</em>定境さかひ開邦くに，制をさめ于近淡海ちかつあふみ。<em>【○成務。】</em>正ただし姓かばね撰えらひ氏うぢ，勒をさめ于遠飛鳥とほつあすか。<em>【○允恭。】</em>雖步驟あゆむとうぐつく各異おのおのこと，文かざれる質すなほ不同。莫なし不稽古いにしへをかむがへ以繩ただし風猷をしへ於既頽すでにおとろへたる，照今いまをてらし以補おきぬひ典教のり於欲絕たえむとする。　曁いたり飛鳥清原大宮あすかのきよみはらのおほみや御をさめ大八洲おほやしま天皇天武御世みよ，潛龍かづけるたつ體元のりにかなひ，洊雷しきれるいかづち應期ときにこたへき。聞夢歌いめのうた而相うらなひ纂業わざをつがむ，投いたり夜水よるのかは而知承基もとゐをうけむ。然天時あめのとき未臻いまだいたらず，蟬蛻せみのごとくもぬけましき於南山みなみのやま，人事ひとのわざ共洽そなはり，虎步とらのごとくあゆみ於東國ひむかしのくに。皇輿すめらみことのこし忽駕たちまちいでまし，凌渡こえわたりき山川やまかは，六師すめらみいくさ雷震いかづちのごとくふるひ，三軍おほきいくさ電逝いなづまのごとくゆきき。杖矛ほこをつゑつき擧威いきほひをふるひ，猛士たけしきをのこ烟起けぶりのごとくおこりき，絳旗はたをあかく耀兵つはものをかかやかし，凶徒あしきともがら瓦解かはらのごとくとけき。未移浹辰いくばくのとき，氣沴わざはひ自清おのづからしづまりぬ。乃放はなち牛息いこへ馬，愷悌よろこびやすまり歸於華夏みやこ。卷旌はたをまき戢戈ほこををさめ，儛詠まひうたひ停とどまり於都邑みやこ。歳ほし次やどり大梁とり，月つき踵あたり俠鍾きさらぎ，清原大宮飛鳥淨御原宮，昇のぼり即天位あまつくらゐ。道みち軼すぎ軒后黃帝，德うつくしび跨あふづくみ周王周文王。握とり乾符あまつしるし而摠すべ六合あめのした，得天統あまつひつぎ而包かねたまひ八荒やものきはみ。乘二氣ふたつのけはひ之正ただしき，齊ととのへ五行いつつのめぐり之序つぎて。設神理あやしきことわり以奬俗よにすすめ，敷しき英風すぐれたるをしへ以弘國くににひろめたまひき。重加しかのみにあらず，智海さとりのうみ浩瀚おぎろ，潭探ふかくさぐり上古いにしへ。心鏡こころのかがみ煒煌あきらけく，明覩あきらけくみ先代さきつよ。　於是ここに，天皇天武詔之のりたまひし：「朕あれ聞諸家もろもろのいへ之所齎もてる帝紀すめろきのふみ及本辭さきつよのことば，既違たがひ正實まこと，多加虛偽いつはり。當今之時いまのときにあたり，不改其失そのあやまり，未經たたず幾年いくばくのとし，其旨そのむね欲滅ほろびなむとす。斯乃これすなはち，邦家みかど之經緯たてぬき，王化おもぶけ之鴻基おほきもとゐ焉。故惟かれおもひ，撰錄えらひしるし帝紀，討覈たづねきはめ舊辭ふること，削偽いつはりをけずり定實まことをさだめ，欲流つたへむ後葉のちのよ。」時有舍人とねり，姓うぢ稗田ひえだ名な阿禮あれ，年よはひ是廿八はたちあまりやつ。為人ひととなり聰明とくさとく，度目めをわたれば誦口くちによみ，拂耳みみにふれば勒心こころにしるす。即勅語みことのり阿禮，令誦習よみならはしめ帝皇日繼すめろきのひつぎ，及先代舊辭さきつよのふること。然運移ときうつり世異よかはり，未行其事矣いまだそのことをおこなひはまはず。　伏惟ふしておもひ皇帝すめらみこと陛下元明，得一ひとつをえ光宅みちをり，通三みつにわたり亭育やしなひ。御紫宸おほみや而德うつくしび被おほひ馬蹄うまのつめ之所極きはまる，坐いまし玄扈みあらか而化おもぶけ照船頭ふなのへ之所逮およぶ。日浮うかび重暉ひかりをかさね，雲散くもちり非烟けぶりにあらず。連柯えだをつらね并穗ほをあはす之瑞しるし，史ふみひと不絕たたず書しるす。列烽とびひをつらね重譯をさをかさぬ之貢みつき，府みくら無空月むなしきつき。可謂いひつべし名高文命夏禹，德冠まされり天乙商湯矣。　於焉ここに，惜をしみ舊辭ふること之誤忤あやまりたがへる，正先紀さきつよのふみ之謬錯あやまりたがへる。以和銅わどう四年しねに九月なかつき十八日とほあまりやのか，詔臣安萬侶やすまろ：「撰錄えらひしるし稗田阿禮ひえたのあれ所誦よめる之勅語みことのり舊辭ふること，以獻上たてまつれ。」者。謹つつしみ隨まにまに詔旨みことのり，子細こまやかに採摭とりひりしつ。然上古之時いにしへのとき，言意こととこころ並朴ともにすなほ，敷文ふみをしき構句ことばをかまふる，於字もじ即難がたし。已すでに因訓よみにより述のべる者，詞ことば不逮およばず心。全またく以音こゑ連者つらねたるは，事趣ことのおもぶき更長さらにながし。是以今，或あるは一句ひとことば之中うち，交用まじへもちゐつ音訓こゑとよみ。或一事ひとこと之内，全以訓錄しるしつ。即辭理ことばのすぢ叵見みえがたき以注しるべ明あかし，意況こころのかたち易解さとりやすき更非注しるべせず。亦於姓うぢ日下くさか謂くさか玖沙訶，於名な帶たらす字もじ謂たらす多羅斯，如此之類かくあるたぐひ，隨本もとのまにまに不改あらためず。<br>　大抵おほかた所記しるせつところ者，自天地開闢あめつちのひらけし始はじめ，以訖をはる于小治田をはりだ御世推古。故かれ天御中主神あめのみなかぬしのかみ以下よりしも，日子ひこ波限建鵜草葺不合尊なぎさたけうかやふきあへずのみこと以前さき，為上卷かみつまき。神倭伊波禮毘古かむやまといはれびこ天皇神武以下，品陀ほむだ御世應神以前，為中卷なかつまき。大雀おほさざき皇帝仁德以下，小治田大宮をはりだのおほみや以前，為下卷しもつまき。并あはせて錄三卷みまき，謹つつしみ以獻上たてまつる。臣やつこ安萬侶，誠惶まことにおそり誠恐かしこみ，頓首頓首ぬかつきまをす。和銅わどう五年正月むつき廿八日　正五位上おほきいつのかみのくらゐ勲いさを五等いつのしな　太朝臣おほのあそみ安萬侶やすまろ<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kamitachi01.gif" alt="上立神岩○兵庫縣南淡道市沼島"><br>天御柱　上立神岩<br>伊邪那岐、伊邪那美聖婚淤能碁呂島，生國、生神，以為群品之祖。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yomotuhirasaka01.gif" alt="黃泉平坂○島根縣松江市東出雲町揖屋　伊賦夜坂"><br>黃泉平坂　伊賦夜坂　千引之石<br>伊邪那岐入黃泉，歸顯國，禊祓而生諸神與三貴子。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/takachiho01.gif" alt="高千穗峽　真名井瀧○宮崎県西臼杵郡高千穗町大字向山"><br>高千穗峽　真名井之瀧<br>須佐之男、天照誓於真名井，喫劍吐珠而續皇胤。後斬大蛇於出雲。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ama_yasukahara01.gif" alt="天安河原○宮崎県西臼杵郡高千穗町大字岩戶"><br>高千穗　天安之河原<br>天照大神幽居，天下常闇。眾神神議於天安河原，計可禱之方。<img src="https://miko.org/~uraki/kuon/furu/text/fuudo/izumo/01/inasa_hama03.gif" alt="出雲市大社町杵築北稻佐　辨天島"><br>稻佐濱　辨天島<br>天神地祇，論出雲讓國於稻佐濱。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kamikura01.gif" alt="神倉神社○和歌山縣新宮市神倉"><br>熊野　天磐楯　神倉神社<br>神武東征，皇軍遇毒氣於熊野，幸獲神劍於高倉下，遂得救。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/tennmu01.gif" alt="天武天皇畫像"><br>天武天皇　天渟中原瀛真人天皇<br>大海人皇子，坐飛鳥淨御原宮，治天下。是為天武天皇。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/genmei01.gif" alt="元明天皇畫像○日本歷代天皇大鑑、御歷代百廿一天皇御尊影"><br>日本根子天津御代豐國成姬天皇<br>元明天皇，即阿閇皇女，天智帝皇女，而草壁皇子正妃。生文武、元正帝。詔敕撰風土記、古事記。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yasumaro_haka.gif" alt="太安萬侶墓○奈良縣奈良市此瀨町"><br>太安萬侶墓<br><strong>天地創造</strong></p><p><img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/takamanohara01.gif" alt="高天原遙拜所○宮崎縣西臼杵郡高千穗町大字三田井"><br>高天原　高天原遙拜所<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/hajime01.gif" alt="img"><br>天地初闢洲壤浮漂<br>五別天神者，天御之中主神、高御產巢日神、神產巢日神、宇摩志訶備比古遲神、天之常立神。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kuninokototachi01.gif" alt="德川家康於關ヶ原之戰歸後所奉國之常立神御面，號「天下一統之面」。○品川神社藏">國之常立神御面<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kunitoko01.gif" alt="出口王仁三郎繪　國之常立神、豐雲野神"><br>國之常立神、豐雲野神<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/tukuyomi01.gif" alt="伊勢神宮別宮　伊佐奈岐宮（後），祀伊邪那岐命。伊佐奈彌宮（中），祀伊邪那美命。○三重縣伊勢市中村町　月讀宮境內"><br>伊佐奈岐宮、伊佐奈彌宮<br>月讀宮境內。伊勢皇大神宮別宮，祀伊邪那岐神、伊邪那美神。<strong>一、天地開闢</strong>　方天地あめつち初發之時はじめてあらはれしとき，於高天原たかあまのはら成一神。其名，天之御中主神あめのみなかぬしのかみ。【高下天，訓あま阿麻。下效ならふ此。】<br>　次，高御產巢日神たかみむすひのかみ。<br>　次，神產巢日神かむむすひのかみ。此三柱みはらし神者，皆獨神ひとりがみ成坐なりまし而隱身也みをかくしき。<em>【○並ともに稱，造化三神。】</em>　次，國稚くにわかく如浮脂うけるあぶら，而譬猶水母くらげ之浮水上ただよへる者。于時成神，狀如葦芽あしかひ而萌騰もえあがれる。其名，可美葦芽宇摩志阿斯訶備彥遲神比古遲のかみ。【可美葦芽彥遲うましあしかびひこぢ原文うましあしかびひこぢ宇摩志阿斯訶備比古遲以音。】<br>　次，天之常立神あめのとこたちのかみ。<br>　此二柱ふたはしら神，亦ともに獨神成坐而隱身也。又，上件かみのくだり五柱いつはしら神，所謂別天神ことあまつかみ是也。<br>　次成神なりしかみ，名，國之常立神くにのとこたちのかみ。【訓よみ常立亦如上。】<br>　次，豐雲野神とよくもののかみ。此二神，亦獨神成坐而隱身也。　次，男神，埿土煮神宇比地邇のかみ。<em>【○埿土煮うひぢに原文うひぢに宇比地邇以音。】</em><br>　次，妹いも，沙土煮神須比智邇のかみ。<em>【○沙土煮すひぢに原文すひぢに須比智邇以音。與兄神埿土煮尊並為一世，下傚此。】</em><br>　次，男神，角杙神つのぐいのかみ.<br>　次，妹，活杙神いくぐいのかみ。【兄妹二柱。】<br>　次，男神，大戶道神意富斗能地のかみ。<em>【○大戶道おほとのぢ原文おほとのぢ意富斗能地以音。】</em><br>　次，妹，大戶邊神大斗乃辨のかみ。【<em>○大戶邊おおとのべ原文おおとのべ大斗乃辨以音。</em>兄妹二柱。】<br>　次，男神，面足神淤母陀流のかみ。<em>【○面足おもだる原文おもだる淤母陀流以音。】</em><br>　次，妹，惶根神阿夜訶志古泥のかみ。【<em>○惶根あやかしこね原文あやかしこね阿夜訶志古泥以音。</em>兄妹二柱。】<br>　次，男神，伊邪那岐神いざなきのかみ。<br>　次，妹，伊邪那美神いざなみのかみ。【此兄妹二神之名以音。<em>○別為男誘神、女誘神，書紀作伊弉諾尊いざなぎのみこと、伊弉冉尊いざなみのみこと。</em>】上自國之常立神くにのとこたちのかみ以下よりしも，伊邪那美神いざなみのかみ以前よりさき，并稱神世七代かみよななよ。【所以為七代者，二柱獨神ひとりがみ各云一代，次雙ならべる十神とはしらのかみ各併あはせ二柱計為一代ひとよ也。】<strong>二、二靈聖婚與生國生神</strong>　於是，天神あまつかみ諸命もろもろのみこと，詔伊邪那岐いざなぎ、伊邪那美いざなみ二柱神曰：「是飄流多陀用弊流之國者，汝等宜修理固成つくろひかためなせ。」遂依言ことよし而賜たまひ天沼矛あめのぬほこ。故かれ二柱神，立たたし天浮橋あめのうきはし，【立，訓たたし多多志。】指下さしおろし沼矛ぬほこ攪之かきし，則滄溟しほ汩汩こをろこをろ畫鳴かきなし。【訓鳴云なし那志也。】復引上ひきあげ沼矛時，矛末ほこのすゑ垂落しただりおちし之潮しほ，<em>【○滄溟しほ、潮しほ，底本作鹽しほ。】</em>凝こり而累積かさなりつもり成島，是淤能碁呂島おのごろしま。【島名以音。<em>○自凝島おのごろしま是也。</em>】<br>　二神天降あまくだり其島，覓得みたて天之御柱あめのみはしら、復八尋殿やひろどの。於是ここに，陽神問其妹そのいも伊邪那美命曰：「汝身なむぢがみ者，如何いかにか成也なれる？」答申こたへてまをす：「吾身あがみ者層層鑄成なりてなりて，然有一成闕處なりあはぬところ。」爾伊邪那岐詔のりたまひ：「吾身者亦層層鑄而，有一成餘處なりあまれるところ。故かれ，以もち此吾身成餘處，刺塞さしふさぎ汝身所闕處，以為おもふ生成うみなさむ國土くに而奈何いかに？【訓生云うむ宇牟，下效此。】」伊邪那美答曰：「然しか，善よし。」爾しかく伊邪那岐命詔：「然者しからば，吾あれ與汝行迴逢ゆきめぐりあひ茲天之御柱あめのみはしら，而為洞房之媾合美斗能麻具波比。<em>【○洞房原文みと美斗，寢所也。媾合原文まぐはひ麻具波比，男女交合之意，或引申作結婚。】</em>」<br>　如此之期かくちぎり，乃すなはち詔：「汝者，自より右迴逢めぐりあへ。我者，自左ひだり迴逢。」約竟ちぎりをはり以迴時，伊邪那美命先言まづいはく：「妍哉阿那邇夜志，俊俏壯士焉え袁登古を！」後のちに伊邪那岐命言：「妍哉阿那邇夜志，可愛美少女焉え袁登賣を！<em>【○妍哉，感動詞，此云あなにやし阿那邇夜志。】</em>」各おのおの言盡之後いひをはりしのち，陽神告のらし其妹曰：「女人をみな先言まづいひつる，不良よくあらず。」雖然しかれども，仍興おこし夫婦之道於組所久美度。<em>【○組所原文くみど久美度，夫婦之閨房也。】</em><br>　　生子，水蛭子ひるこ。此子者，入葦船あしぶね而流去ながしさりき。<br>　　次つぎ生，淡島あはしま。是亦不入いれず子之列このつら。　於是，二柱神議はかり云：「今吾所生之子あがうめるこ，不良。猶なほ宜白まをすべし天神之御所みもと。」即共參上まゐのぼり，請こひき天神之命。爾天神之命あまつかみのみこと以太占布斗麻邇卜相うらなひ而詔之のりたまひし：「因よりて女先言而不良。亦また當還降かへりくだり改言あらためいへ！」<em>【○太占原文ふとまに布斗麻邇，燒鹿之肩胛骨，觀其裂痕之狀以卜占也。】</em>故爾かれしかく返降かへりくだり，更往迴ゆきめぐる其天之御柱如先さきのごとく。<br>　於是，伊邪那岐命先言まづいはく：「妍哉あなにやし，可愛美少女焉えをとめを！」後妹伊邪那美命言：「妍哉あなにやし，俊俏壯士焉えをとこを！」如此かく言竟いひをはり而御合みあひ。　　生子，淡道之穗之狹別島あはぢのほのさわけのしま。<br>　　次生，伊豫之二名島いよのふたなのしま。此島者，身一ひとつ而有面おもて四，每面おもてごと有名な。故かれ，伊豫國いよのくに謂愛媛え比賣，讚岐國さぬきのくに謂飯依彥いひより比古，粟國あはのくに謂大宜都姬おほげつ比賣，土左國とさのくに謂建依別たけよりわけ。<br>　　次生，隱伎之三子島おきのみづごのしま。亦名天之忍許呂別あめのおしことわけ。<br>　　次生，筑紫島つくしのしま。此島亦身み一而有面四よつ，每面有名。故筑紫國つくしのくに謂白日別しらひわけ，豐國とよくに謂豐日別とよひわけ，肥國ひのくに謂建日向日豐久士比泥別たけひむかひとよくじひねわけ，【自至泥以音。<em>○意未詳。</em>】熊曾國くまそのくに謂建日別たけひわけ。【曾字以音。】<br>　　次生，伊岐島いきのしま。亦名謂天一柱あま比登都はしら。【自比至都以音。訓川天如天。】<br>　　次生，津島つしま。亦名またのな謂天之狹手依姬あめのさでよりひめ。<br>　　次生，佐度島さどのしま。<br>　　次生，大倭豐秋津島おほやまととよあきしまづ。亦名謂天御虛空豐秋津根別あめのみそらとよあきづねわけ。故，因此八島やつのしま先所生まづうめる，故謂大八島國おほやしまくに。　然後，二神還坐之時かへりまししとき，復生子。<br>　　先生，吉備兒島きびのこしま。亦名謂建日方別たけひかたわけ。<br>　　次生，小豆島あづきしま。亦名謂大野手姬おほのて比賣。<br>　　次生，大島おほしま。亦名謂大溜別おほ多麻流わけ。【多麻流たまる以音。】&lt;<br>　　次生，女島をみなしま。亦名謂天一根あまひとつね。【訓天如天あま。】<br>　　次生，知訶島ちかのしま。亦名謂天之忍男あめのおしを。<br>　　次生，兩兒島ふたごのしま。亦名謂天兩屋あめのふたや。【自より吉備兒島，至いたるまで天兩屋島，并六島むつのしま。<em>○二神於茲產竟日本諸島。</em>】<img src="https://miko.org/~uraki/kuon/furu/text/syoki/01/amanonuboko01.gif" alt="小林永濯「以天瓊探滄海圖」"><br>以天瓊探滄海圖<br>伊邪那岐、伊邪那美坐天浮橋，以天瓊矛探獲滄溟。矛鋒垂落之潮，凝而成島，即淤能碁呂島。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kamitachi01.gif" alt="上立神岩○兵庫縣南淡道市沼島"><br>天御柱　上立神岩<br>伊邪那岐、伊邪那美於淤能碁呂島尋得天御柱、八尋殿，於茲迴柱誓言，婚合產子。然以婦女先言不善，遂返降改璇而得生國、生神。<a href="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yashima01.gif"><img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yashima01.gif" alt="大八島國"></a><br>大八島國　令制國地圖<br>淡道穗狹別島，淡路島。伊豫二名島，四國。隱伎三子島，隱岐島。筑紫島，九州。伊岐島，壹岐島。津島，對馬。佐度島，佐渡島。大倭豐秋津島，本州。日本書紀則以大日本豐秋津洲、伊豫二名洲、筑紫洲、億岐洲、佐度洲、越洲、大洲、吉備子洲為大八州國。<a href="https://miko.org/~uraki/kuon/furu/text/kojiki/01/shima02.gif"><img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/sima02.gif" alt="生國諸島"></a><br>生國諸島　令制國地圖<br>吉備兒島，兒島半島。小豆島，小豆島。大島，周防大島。女島，大分姬島。知訶島，五島列島。兩兒島，男女群島。亦有他說。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/izanami01.gif" alt="伊邪那美命 ©FOG『久遠の絆』"><br>伊邪那美命　伊奘冉尊<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/watatumi01.gif" alt="青島神社　日向神話館　綿津見神像○宮崎縣宮崎市青島"><br>海神　大綿津見神<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/uda_mikumari01.gif" alt="宇太水分神社○奈良縣宇陀市菟田野古市場"><br>宇太水分神社<br>祭速秋津日子神、天之水分神、國水分神。即陰神所生水戶神，及水戶二神分治河海而生水分神矣。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ohoyamatumi01.gif" alt="大山祇神社○三重縣伊勢市宇治館町"><br>皇大神宮所管社　大山祇神社<br>亦名山神社。祭大山津見神。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kiyonoiba01.gif" alt="大山祇神社○三重縣伊勢市常磐"><br>豐受大神宮攝社　清野井庭神社<br>祭神草野姬，即鹿屋野姬神是也。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kotohiraohotori01.gif" alt="金刀比羅大鷲神社○神奈川縣橫濱市南區真金町"><br>金刀比羅大鷲神社<br>祭鳥之石楠船神，亦名天鳥船命。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/hananoihaya02.gif" alt="花窟神社○三重縣熊野市有馬町上地"><br>花窟神社　軻遇突智尊神籬<br>祭神，火之迦具土神。花窟神社神體為巨大磐座，稱女陰穴。自古以為伊邪那美陵墓候補地。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ougon01.gif" alt="黃金神社○台灣新北市瑞芳區金瓜石"><br>黃金神社　金瓜石神社遺跡<br>祭金山彥、大國主、猿田彥。本為神明造，現僅存拜殿社柱爾。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kume01.gif" alt="久米神社○島根縣安來市伯太町　比婆山"><br>比婆山　久米神社<br>伊邪那美命，葬出雲、伯耆國堺比婆山。有伊邪那美大神御神陵柱。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ama_yasukahara02.gif" alt="天安河原○宮崎県西臼杵郡高千穗町大字岩戶"><br>天安河原　湯津石村<br>湯津石村，神聖之石群。按日本書紀云，天安河邊所在五百箇磐石。是知，齋石叢者，蓋在天安河原。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kashima01.gif" alt="鹿島神宮○茨城縣鹿嶋市宮中"><br>鹿島神宮　奧宮<br>祭神武御雷之男神，亦名武甕槌。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kifune_oku01.gif" alt="貴船神社　奧宮○京都府京都市左京區鞍馬貴船"><br>貴船神社　奧宮<br>祭神闇龗神，或云與高龗同神。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kakuru01.gif" alt="賀久留神社○静岡縣濱松市西區神谷町"><br>賀久留神社<br>祭神闇罔象、闇龗、玉依姬等。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/isobe01.gif" alt="磯部神社○三重縣志摩市磯部町惠利原"><br>磯部神社<br>祭神天之尾羽張神、天忍穗耳尊、天穗日命、天津彥根等并卌九柱。<strong>三、伊邪那美殞命</strong>　二神既生國竟をはり，復更さらに生神。<br>　　故生神，名大事忍男神おほことおしをのかみ。<br>　　次生，石土彥神いはつち毘古のかみ。<br>　　次生，石巢姬神いはす比賣のかみ。<br>　　次生，大戶日別神おほとひわけのかみ。<br>　　次生，天之吹男神あめのふきをのかみ。<br>　　次生，大屋彥神おほや毘古のかみ。<br>　　次生，風木津別之忍男神かざもくつわけのおしをのかみ。<br>　　次生，海神わたのかみ，名大綿津見神おほわたつみのかみ。<br>　　次生，水戶神みなとのかみ，名速秋津日子神はやあきつひこのかみ。<br>　　次生，妹いも，速秋津姬神はやあきつ比賣のかみ。【自大事忍男神，至秋津姬神，并十神とはしらのかみ。】　　此速秋津日子はやあきつひこ、速秋津姬はやあきつひめ二神，因分治もちわけ河海かはわた，而生神。<br>　　　名，沫那藝神あわなぎのかみ。【那藝以音，下效此。<em>○男沫神あわなぎのかみ。或云沫凪神あわなぎのかみ。</em>】<br>　　　次，沫那美神あわなみのかみ。【那美以音，下效此。<em>○女沫神あわなみのかみ。或云沫波神あわなみのかみ。</em>】<br>　　　次，頰那藝神つらなぎのかみ。<em>【○男頰神つらなぎのかみ。頰つら字表水面。或云頰凪神つらなぎのかみ。】</em><br>　　　次，頰那美神つらなみのかみ。<em>【○女頰神つらなみのかみ。或云頰浪神つらなみのかみ。】</em><br>　　　次，天之水分神あめのみくまりのかみ。【訓分云くまり久麻理，下效此。】<br>　　　次，國之水分神くにのみくまりのかみ。<br>　　　次，天之汲瓢持神あめの久比奢母智のかみ。【汲瓢持くひざもち，原文云くひざもち久比奢母智，下效此。】<br>　　　次，國之汲瓢持神くにの久比奢母智のかみ。【自沫那藝神，至國之汲瓢神くにのくひざもちのかみ，并八神やはしらのかみ。】　　次生，風神かぜのかみ，名志那都彥神しなつ比古のかみ。【此神名以音。<em>○書紀作級長津彥しなつひこ。</em>】<br>　　次生，木神きのかみ，名久久能智神くくのちのかみ。【此神名以音。<em>○書紀作句句迺馳くくのち。</em>】<br>　　次生，山神やまのかみ，名大山津見神おほやまつみのかみ。<br>　　次生，野神ののかみ，名鹿屋野姬神かやの比賣のかみ，亦名謂野椎神のづちのかみ。【自志那都彥神しなつひこのかみ，至野椎，并あはせ四神。】　　此大山津見神おほやまつみのかみ、野椎神のづちのかみ二神，因分治もちわけ山野やまの而生神。<br>　　　名，天之狹土神あめのさづちのかみ。【訓土云づち豆知，下效此。】<br>　　　次，國之狹土神くにのさづちのかみ。<br>　　　次，天之狹霧神あめのさぎりのかみ。<br>　　　次，國之狹霧神くにのさぎりのかみ。<br>　　　次，天之闇戶神あめのくらとのかみ。<br>　　　次，國之闇戶神くにのくらとのかみ。<br>　　　次，大戶惑子神おほとまとひこのかみ。【訓惑云まとひ麻刀比，下效此。】<br>　　　次，大戶惑女神おほとまとひめのかみ。【自天之狹土神，至いたる大戶惑女神，并八神やはしらのかみ也。】　　次生神，名鳥之石楠船神とりのいはくすふねのかみ，亦名謂天鳥船あめのとりふね。<br>　　次生，大饌津姬神おほ宜都比賣のかみ。【此神名おほげつひめ以音。】<br>　　次生，火之夜藝速男神ひのやぎはやをのかみ，亦名謂火之炫彥神ひのかか毘古のかみ，亦名火之迦具土神ひのかぐつちのかみ。【夜藝、迦具以音。<em>○夜藝やぎ，燒やぎ也。迦具かぐ與陽炎かぎろひ之かぎ相通，書紀作軻遇突智かぐつち。</em>】　　因生此子火神，伊邪那美命女陰美蕃登見炙やかえ而病臥やみふし。<em>【○女陰みほと訓みほと美蕃登。】</em><br>　　　嘔吐多具理成神，金山彥神かなやま毘古のかみ、金山姬神かなやま毘賣のかみ。【嘔吐たぐり訓たぐり多具理。訓金かな云かな加那，下效此。】<br>　　　於屎くそ成神。名埴安彥神波邇夜須毘古のかみ、埴安姬神波邇夜須毘賣のかみ。<br>　　　於尿ゆまり成神。名水波女神彌都波能賣のかみ、稚產巢日神和久むすひのかみ。<br>　　　　此神稚產巢日之子，謂豐受姬神とよ宇氣毘賣のかみ。　故，伊邪那美神いざなみのかみ者，因生火神ひのかみ，遂神避坐かむさりましき也。【自天鳥船至豐受姬神，并八神也。<em>○神避坐かむさりましき，謂死也。</em>】<br>　凡おほよそ伊邪那岐、伊邪那美二神所共生ともにうめる島，壹拾肆島とをあまりよつのしま。又神，參拾伍神みそはしらあまりいつはしらのかみ。【是伊邪那美，未死神避以前さき所生。唯ただ淤能碁呂島意のごろしま者，非所生うめるにあらず。亦蛭子ひるこ與淡島あはしま，不入子之例このつら也。】　故爾かれしか，伊邪那岐命詔之のりたまはく：「愛也うつくしき我汝妹あが那邇も命みこと乎，謂いふ易かはらむ子之一木このひとつき乎？<em>【○汝妹なにも，訓なに那邇も，夫婦親暱之乎稱。可愛吾妹，豈以汝命以易一子乎？】</em>」乃すなはち匍匐はらばひ於亡妻御枕方みまくらへ，匍匐御足方みあとへ而哭なき。<br>　　時於御淚みなみた所成神，坐います香山かぐやま之畝尾うねを木本このもと。名，泣澤女神なきさはめのかみ。<br>　故其所神避之かむされる伊邪那美命者，葬はぶりき出雲國いつものくに與伯耆國ははきのくに堺さかひ之比婆之山ひばのやま也。　於是，伊邪那岐命いざなぎのみこと悲愴忿恨，拔ぬき所御佩みはかしせる之十拳劍とつかのつるぎ，斬きりき其子迦具土神かぐつちのかみ之頸くび。爾しかくし，著つける其劍鋒御刀前之血噴濺，走就はしりつき齋石叢湯津石村。<em>【○劍鋒さき，原文御刀前みはかしのさき，配劍先鋒。齋石叢ゆついはむら，原文湯津石村ゆついはむら，神聖之石群。湯ゆ與齋ゆ同。】</em><br>　　所成神，名石析神いはさくのかみ。<br>　　次，根析神ねさくのかみ。<br>　　次，石箇之男神。【三神。】<br>　次，著劍鍔御刀本之血ち亦噴濺，走就はしりつき齋石叢湯津石村。<em>【○劍鍔つるぎのつば，原文書御刀本みはかしのもと，配劍之鍔。】</em><br>　　所成神，名甕速日神みかはやひのかみ。<br>　　次，樋速日神ひはやひのかみ。<br>　　次，武御雷之男神建みかづちのをのかみ。亦名武韴神建布都のかみ，亦名豐韴神とよ布都のかみ。【三神。<em>○武たけ，原文書建たけ，勇猛之意。韴ふつ，刀劍斷物之音，原文書布都ふつ以音。下效此。</em>】<br>　次，集あつまれる劍柄御刀之手上血垂落，自手俣たなまた漏出くきいで。【訓漏くき云くき久伎。<em>○劍柄つるぎのつか，原文御刀之手上みはかしのたかみ，配劍之握把。</em>】<br>　　所成神，名闇靇神くら淤加美のかみ。<em>【○原文淤加美おかみ以音，龍神，書紀作靇おかみ。】</em><br>　　次，闇水波神やみ御津羽のかみ。<em>【○書紀作闇罔象くらみつは。】</em><br>　　上件かみのくだり，自石析神以下しも，闇水波神やみ御津羽のかみ以前，并あはせ八神者，因御刀みはかし所生之神也。　　所殺ころさえし迦具土神かぐつちのかみ之頭かしら成神，名正鹿山津見神まさかやまつみのかみ。<br>　　次，於胸むね所成神，名淤滕山津見神おどやまつみのかみ。<br>　　次，於腹はら所成神，名奧山津見神おくやまつみのかみ。<br>　　次，於陰はぜ所成神，名闇山津見神くらやまつみのかみ。<br>　　次，於左手ひだりのて所成神，名志藝山津見神しぎやまつみのかみ。<br>　　次，於右手みぎのて所成神，名羽山津見神はやまつみのかみ。<br>　　次，於左足ひだりのあし所成神，名原山津見神はらやまつみのかみ。<br>　　次，於右足みぎのあし所成神，名戶山津見神とやまつみのかみ。【自正鹿山津見神，至戶山津見神，并八神。<em>○正鹿まさか、淤滕おど，意未詳。奧おく乃深山處，闇くら指峽谷。志藝しぎ與繁しげ通，繁茂之狀。羽は與端は通，山麓。原はら乃山裾遼闊之狀。戶と與奧おく相反，近於人里之處。</em>】　故かれ，所斬きれる火神迦具土之刀十拳劍，名天之尾羽張あめのをはばり，亦名嚴之尾羽張伊都のをはばり。<em>【○嚴いつ原文伊都いつ以音，稜威いつ。】</em><strong>陰陽永隔</strong></p><p><strong>一、黃泉神話</strong>　於是ここに，陽神伊邪那岐欲おもひ見其妹そのいも伊邪那美命いざなみのみこと，遂追往おひゆきき黃泉國よもつくに。爾陰神伊邪那美自殿との騰とぢ戶出向之時いでむかへしとき，伊邪那岐命いざなぎのみこと語詔之かたりてのりたまひし：「愛也うつくしき我汝妹命那邇ものみこと，吾あれ與汝なむぢ所作之國つくれるくに，未作竟いまだつくりをはらず。故かれ，可還かへるべし！」爾伊邪那美命答白こたへまをさく：「悔哉くやしきかも，君不速來はやくこねば！吾既為しつ黃泉戶喫よもつへぐひ。然しかれども以，愛也うつくしき我汝兄命那勢のみこと，入來坐之事いりきませること，欣喜惶恐かしこき。故ゆゑ，欲還かへらむとおもふ。且しまらく與黃泉神よもつかみ相論あひあげつらはむ。冀莫視我あれをみることなかれ。【汝兄なせ，原文那勢なせ以音，下效此。<em>○女性對親暱男性之呼稱，夫君。</em>】」如此白かくまをし而，還入かへりいる其殿內とののうち。　陰神伊邪那美還入相談之間あひだ，甚久いとひさしく，難待まつことかたし。故かれ陽神伊邪那岐取插刺其左御髻ひだりのみ美豆良之齋爪櫛湯津津間くし，攀折取闕其齒男柱而燭ともし一火ひとつひ以入見いりまし。【髻みづら，原文美豆良みづら以音，下效此。<em>○或書角髮みづら、總角みづら。</em>】時蛆虫宇士群集多加禮攢動許呂呂岐弖。<em>【○蛆虫うじ群集たかれ攢動ころろき，原文以音，訓うじたかれころろきて宇士多加禮許呂呂岐弖。】</em><br>　　居於頭かしら者，大雷おほいかづち。<br>　　居於胸むね者，火雷ほのいかづち。<br>　　居於腹はら者，黑雷くろいかづち。<br>　　居於陰ほと者，析雷さくいかづち。<br>　　居左手ひだりのて者，若雷わかいかづち。<br>　　居右手みぎのて者，土雷つちいかづち。<br>　　居左足ひだりのあし者，鳴雷なるいかづち。<br>　　居右足みぎのあし者，伏雷ふすいかづち。併八雷神やくさのいかづち，成居なりをりき。　於是，伊邪那岐命いざなぎのみこと見畏みかしこみ而逃還にげかへり。時其妹そのいも伊邪那美命いざなみのみこと怒言：「令見辱吾！」即遣黃泉醜女予母都志許賣令追おはしめき。<em>【○黃泉醜女よもつしこめ，よもつしこめ予母都志許賣，原文以音。】</em><br>　爾しかくし伊邪那岐命，取黑御縵くろきみかづら投棄なげうつる，乃生蒲子山葡萄。是醜女摭食之間ひりはむあひだ，逃行にげゆきき。<br>　醜女猶追なほおひき。陽神伊邪那岐亦取刺させる其右御髻みぎのみ美豆良之齋爪櫛湯津津間くし攀折取闕而投棄なげうつる，乃生笋筍。是醜女拔食之間ぬきはむあひだ，逃行。　且後またのち者， 陰神伊邪那美於其八雷神やくさのいかづち，副そへ千五百ちいほ之黃泉軍よもついくさ令追おはしめき。爾陽神伊邪那岐拔所御配之みはかしせる十拳劍とつかのつるぎ，而於後手しりへで振舞布伎都都逃來にげきつ。<em>【○振舞ふきつつ，原文ふきつつ布伎都都以音，振ふきつつ。】</em>醜女猶追なほおひき，到黃泉平坂よもつ比良さか之坂本さかもと時，陽神伊邪那岐取在其坂本桃子もものみ三箇みつ待擊まちうち者，悉ことごとく去坂而返也かへりき。爾しかくし伊邪那岐命告のらさく桃子：「汝なむぢ如助たすけしがごとく吾，於葦原中國あしはらのなかつくに所有あらゆる現世宇都志伎青人草あをひとくさ之落おち苦瀨くるしきせ而患惚うれへなやむ時，可助たすくべし！<em>【○現世宇都志伎，原文うつしき宇都志伎以音，現うつしき。青人草あをひとくさ，日本書紀書蒼生あをひとくさ。】</em>」告のらし賜名なをたまひ，號なづけき大神祇命意富加牟豆美のみこと。<em>【○原文意富加牟豆美おほかむつみ以音。】</em><br>　最後もとものち，其妹そのいも伊邪那美命躬自みづから追來焉おひきつ。爾陽神伊邪那岐舉千引之石ちびきのいは，封塞ひきふさぎ黃泉平坂よもつのひらさか。其石置中，各おのおの對立むきたち而為絕緣之誓度事戶。<em>【○原文度わたる事戶ことど，未詳。或云離別之語。】</em>　時伊邪那美命いざなみのみこと言：「愛也うつくしき我汝兄那勢命，為如此者かくせば，汝國なむぢがくに之人草ひとくさ，一日ひとひ絞殺くびりころさむ千頭ちかしら！」爾伊邪那岐命詔：「愛也うつくしき我汝妹那邇も命，汝為然者しかせば，吾一日立たてむ千五百ちいほ產屋うぶや！」是以ここをもち葦原中國一日必かならず千人ちたり死，一日必千五百人生うまるる也。<br>　故かれ，號なづけ其伊邪那美神命いざなみのかみのみこと，謂黃泉津大神よもつおほかみ。亦云またいはく，以其陰神追及おひ斯伎斯，而號道敷大神ちしきのおほかみ。<em>【○追及おひしきし，原文追しきしおひ斯伎斯以音，追及おひしきし。】</em>亦所塞ふさげる其黃泉坂よもつさか之石いは者，號道反之大神ちがへしのおほかみ，亦謂塞坐黃泉戶大神ふさがりますよもつのおほかみ。故其所謂いはゆる之黃泉平坂よもつの比良さか者，今謂出雲國いづものくに之伊賦夜坂いふやさか是也。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yomotuhe01.gif" alt="黃泉穴○島根現出雲市豬目町　豬目洞窟"><br>黃泉戶　黃泉之穴<br>按出雲國風土記，夢至此窟者必死。土俗謂黃泉之坂、黃泉之穴。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yomi_kuni01.gif" alt="(C)FOG 久遠の絆"><br>黃泉國之伊邪那美命<br>陰神肢體腐爛，蛆蟲爬滿全身，身纏八雷神。陽神見之，恐荒而逃。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yakusanoikaduchi01.gif" alt="(C)FOG 久遠の絆"><br>伊邪那美命與所纏身之八雷神<br>頭、胸、腹、陰、雙手、雙腳，有大雷、火雷、黑雷、拆雷、稚雷、土雷、鳴雷、伏雷等雷神纏身。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yomotusikome01.gif" alt="江戶里神樂　間宮和磨社中○東京都城南地區各神社神樂殿"><br>黃泉醜女與伊邪那岐命<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yomotuhirasaka01.gif" alt="黃泉平坂○島根縣松江市東出雲町揖屋　伊賦夜坂"><br>神蹟黃泉平坂伊賦夜坂傳說地<br>夫婦於茲絕緣，自後日日各有千人死、千五百人生。青人草即蒼生。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/chibikinoiwa01.gif" alt="黃泉平坂　千引之石　道反之大神　塞坐黃泉戶大神○島根縣松江市東出雲町揖屋　伊賦夜坂"><br>黃泉平坂　千引之石<br>陽神以千引之石塞黃泉戶，陰陽兩界自是不復相通。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ifuya01.gif" alt="揖夜神社○島根縣松江市東出雲町揖屋"><br>揖夜神社<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ahagihara01.gif" alt="江田神社　禊池○宮崎縣宮崎市阿波岐原町產母"><br>橘小戶檍原　江田神社禊池<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ikisu01.gif" alt="息栖神社○茨城縣神栖市息栖"><br>息栖神社　祀岐神<br>衝立船戶神，日本書紀作岐神。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/misogiharai01.gif" alt="山邊神宮藏　堀江友聲『古事記繪詞』○島根縣江津市江津町"><br>古事記繪詞　陽神禊祓生子<img src="https://miko.org/~uraki/kuon/furu/text/fuudo/itubun/01/sumie01.gif" alt="住吉大社○大阪府大阪市住吉區住吉"><br>攝津國一宮　住吉大社<br>底筒男、中筒男、上筒男，並稱墨江三座大神，祀於住吉大社。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/hotaka01.gif" alt="穗高神社　奧宮　上高地　明神池○長野縣松本市安曇上高地"><br>穗高神社奧宮　明神池<br>祭神穗高見命，綿津見神之子顯日金拆命，而安曇連等遠祖。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/naiguu01.gif" alt="伊勢神宮　內宮　皇大神宮○三重縣伊勢市宇治館町"><br>伊勢神宮　內宮<br>皇大神宮正宮，祀天照大神。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kumano_honguu01.gif" alt="熊野本宮大社　大齋原○和歌山縣田邊市本宮町本宮"><br>熊野本宮大社　大齋原<br>家津美御子大神，即須佐之男。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/tagataisya01.gif" alt="多賀大社○滋賀縣犬上郡多賀町大字多賀"><br>多賀大社　伊弉諾尊幽宮<strong>二、小戶檍原之禊祓生神</strong>　是ここ以，伊邪那岐大神詔のりたまはく：「吾あれ者，到いたり於不須伊那凶目志許米醜陋志許米岐污穢之國きたなきくに而在矣あり祁理。故，吾者，當為御身之禊みみのみそぎ！」而到筑紫つくし日向ひむか橘小門たちばなのをど之檍原阿波岐はら而禊祓みそぎしき也。<em>【○不須凶目醜陋いなしこめしこめき，原文いなしこめしこめき伊那志許米志許米岐以音。檍あはき，原文あはき阿波岐以音。】</em><br>　　故かれ，所投棄なげうつる御杖みつゑ成神。其名，衝立船戶神つきたつふなとのかみ。<br>　　次，所投棄御帶みおび成神。其名，道之長乳齒神みちのながちはのかみ。<br>　　次，所投棄御囊みふくろ成神。其名，時量師神ときはからしのかみ。<br>　　次，所投棄御衣みけし成神。其名，災主神和豆良比能宇斯能かみ<em>【○原文わづらひのうしの和豆良比能宇斯能神以音。】</em>。<br>　　次，所投棄御褌みはかま成神。其名，道岐神ちまたのかみ。<br>　　次，所投棄御冠みかがふり成神。其名，飽咋之主神あきぐひの宇斯能かみ。<br>　　次，所投棄左御手ひだりのみて之手纏たまき成三神。奧疏神おきざかるのかみ、奧津波限彥神おきつ那藝佐毘古のかみ、奧津甲裴弁羅神おきつかひべらのかみ。<br>　　次，所投棄右みぎ御手之手纏たまき成三神。邊疏神へざかるのかみ、邊津波限彥神へつ那藝佐毘古のかみ、邊津甲裴弁羅神へつかひべらのかみ。【右件みぎのくだり，自船戶神以下しも，邊津甲裴弁羅神以前さき，十二神とはしらあまりふたはしらのかみ者，因脫ぬきし著身之物みにつけたるもの所生うめる神也。】　於是，陽神伊邪那岐詔之：「上瀨かみつせ者瀨速せはやし，下瀨しもつせ者瀨弱せよわし。」而初はじめ於中瀨なかつせ墮潛おち迦豆伎而滌之すすぎ。<br>　　所成神，名八十禍津日神やそまがつひのかみ。【潛かづき，訓かづき迦豆伎。】<br>　　次，大禍津日神おほまがつひのかみ。此二神ふたはしらのかみ者，所到其穢繁國けがれしげきくに時，因污垢けがれし所成禍神まがつかみ也。<br>　　次，為直なほさむ其禍而成神，神直毘神かむなほびのかみ。<br>　　次，大直毘神おほなほびのかみ。<br>　　次，嚴女伊豆能賣。【并三神也。<em>○直，治也。嚴女いづのめ，蓋巫女之神格化。</em>】<br>　　次，滌すすぎ水底みなそこ時成神。底津綿津見神そこつわたつみのかみ、底筒之男命そこつつのをのみこと。<br>　　次，滌於中なか時成神。中津綿津見神なかつわたつみのかみ、中筒之男命なかつつのをのみこと。<br>　　次，滌水上みづのうへ時成神。上津綿津見神かみつわたつみのかみ、上筒之男命うはつつのをのみこと。【訓上云うへ宇閉。】此三柱みはしら綿津見神者，阿曇連あづみのむらじ等所齋祭伊都久之祖神おやがみ也。故かれ阿曇連等者，綿津見神之子顯日金拆命宇都志ひかなさくのみこと之子孫あなすゑ也。其底筒之男命、中筒之男命、上筒之男命三柱神者，墨江之三前大神すみのえのみまへのかみ也。【顯うつし，原文うつし宇都志以音。<em>○墨江即住吉すみのえ。顯日金拆命，亦名穗高見命ほだかみのみこと。</em>】　　於是，陽神伊邪那岐洗左御目ひだりのみめ時成神。天照大御神あまてらすのおほみかみ。<br>　　次，洗あらひし右御目みぎのみめ時成神。月讀命つくよみのみこと。<br>　　次，洗御鼻みはな之時成神。建速須佐之男命たけはやすさのみこと。【右件みぎのくだり八十禍津日神以下しも，建速須佐之男命以前さき十柱とはしら神者，因滌御身みみ所生うめる者也。<em>○須佐すさ二字以音，荒すさ。武勇狂暴之神。</em>】　此時，伊邪那岐命いざなぎのみこと大歡喜おほきによろこび詔：「吾生子眾こをうみうみ，而遂うみをへ得此三貴子みはしらのうづのみこ。」即取其御頸珠みくびのたま之玉緒たまのを，玲瓏玉響母由良邇，振之搖曳由良迦志而賜たまひ天照大御神あまてらすのおほみかみ。詔之のりたまひし：「汝命ながみこと者，所治しらせ高天原たかあまのはら矣。」依言事而賜也。故，其御頸珠名な，謂御倉板舉之神みくらたなのかみ。【訓板舉たな云たな多那，棚たな也。<em>○玲瓏玉響もゆら、振之搖曳ゆらかし，原文もゆらに母由良邇、ゆらかし由良迦志以音，下效此。治し，原文書以知し字。</em>】次，詔月讀命つくよみのみこと：「汝命者，所治夜之食國よるのをすくに矣。」依言也ことよしき。【訓食をす云をす袁須。】次，詔建速須佐之男命たけはやすさのをのみこと：「汝命者，所治海原うなはら矣。」依言也。<br>　故，天照、月讀各おのおの隨まにまに依賜之命よしたまひしみこと，治看しらしめせる所任之國。唯速須佐之男命，不治をさめず所命之國おほせらえしくに，終日哭啼なき伊佐知伎，令八拳鬚やつかひげ垂至胸前こころさき也。其泣狀なくかたち者，令青山あをやま如枯山からやま泣枯なきからし，河海かはうみ者亦悉ことごとく泣乾なきほしき。是以惡神之音あしきかみのこゑ，如狹蠅さばへ皆滿みなみち，萬物之妖よろづのもののわざはひ悉發おこりき。<br>　故伊邪那岐大御神詔のりたまひしく問速須佐之男命：「汝以何由なにのゆゑ，不治所託事依之國，而終日哭泣哭伊佐知流？」爾しかくして，答白こたへまをし：「僕やつかれ者欲おもふ罷まからむ妣國ははがくに根之堅洲國ねのかたすくに。故ゆゑ哭。」爾伊邪那岐大御神，大忿怒おほきにいかり詔：「然者しからば，汝なむぢ不可住すむべくあらず此國葦原中國！」乃神逐而逐賜かみ夜良比爾夜良比はまひ也。【逐而逐やらひにやらひ，原文やらひにやらひ夜良比爾夜良比以音。<em>○須佐之男遭父神放逐。</em>】故其伊邪那岐大神者，坐います淡海あふみ之多賀たが也。<strong>高天原</strong></p><p><strong>一、誓約生神與天津罪</strong>　故於是かれここに，速須佐之男命はやすさのをのみこと言：「然者しからば，先請まをし天照大御神，而將罷まからむ根堅洲國。」乃參上まゐのぼる高天原。時山川やまかは悉動ことごとくとよみ，國土くにつち皆震みなふるひき。爾天照大御神あまてらすおほみかみ，聞驚ききおどろき而詔のりたまはく：「我汝弟命那勢命之上來由のぼりくるゆゑ者，必かならず不存善心よきこころならじ。欲おもへ奪うばはむ我國高天原爾！」即すなはち解とき御髮みかみ纏まき髻御美豆羅，乃すなはち於左右ひだりみぎ髻みづら上又飾御蔓みかづら。亦また於左右御手みて，各おのおの纏持まきもち八尺勾璁やさかのまがたま之五百箇御統いほ津の美須麻流。負おひ千入之靫ちのりのゆき於背鎧之平曾毗良，附つけ五百入之靫いほのりのゆき於鎧平毗良。亦所取佩とりはかし稜威之竹鞆伊都のたかとも，振起ふりたて弓腹ゆばら， 踐踏堅庭かたには。向股むかもも蹈潦ふみ那豆美，如沫雪あわゆき以蹶散くゑちちし。奮稜威伊都之雄誥男建，【訓誥建云たけぶ多祁夫。】蹈嘖ふみたけぶ而待問まちとひ：「何故なにのゆゑ上來のぼりきたる？」<br>　爾しかくし速須佐之男命答白こたへまをす：「僕やつかれ者無邪心あしきこころ。唯以大御神伊弉諾尊之命みこと，問とひたまふ僕終日哭泣哭伊佐知流之事。故ゆゑ白狀まをし都良久：『僕欲往ゆかむ妣國ははがくに以哭なく。』大御神伊弉諾尊詔：『汝なむち者，不可在あるべからず此國葦原中國！』乃神逐而逐賜かむ夜良比夜良比たまふ。故以為おもひ請まをさむ將罷往之狀まかりゆかむかたち而參上爾まゐのぼれらくのみ。必無異心けしきこころ。」爾，天照大御神詔：「然者，吾何以いかに知汝心之清明きよくあかき？」於是ここに，速須佐之男命答曰：「各おのおの誓約宇氣比而生子こをうまむ可驗。」【誓約うけひ，此云うけひ宇氣比。】　故爾かれしかく，二神各中置なかにおき天安河あめのやすのかは而誓約宇氣比。時天照大御神，先まづ乞度こひわたし建速須佐之男命所佩はける十拳劍とつかのつるぎ，打折うちをり三段みきだ，令瓊音玉響而奴那登母母由良邇振滌ふりすすぎ天之真名井あめのまなゐ，𪗾然咀嚼佐賀美邇迦美，於吹棄ふきうつる氣吹之狹霧いふきのさぎり所成神。<br>　　御名みな，田霧姬命多紀理毘賣のみこと。<em>【○原文多紀理毘賣たきりびめ以音。】</em>亦名またのみな謂奧津島姬命おきつしま比賣のみこと<br>　　次，市寸島姬命いちきしま比賣のみこと。亦名狹依姬命さより毘賣のみこと。<br>　　次，湍津姬命多岐都比賣のみこと。【三柱。<em>○原文多岐都比賣たきつひめ以音。令瓊音玉響而ぬなとももゆらに，原文瓊音も玉響に奴那登母母由良邇。</em>】　速須佐男命はやすさのをのみこと，乞度こひわたる天照大御神所纏まける左御髻ひだりのみ美豆良八尺勾璁やさかのまがたま之五百箇御統珠いほ津の美須麻流たま，令瓊音玉響而奴那登母母由良邇，振滌ふりすすぎ天之真名井あめのまなゐ，𪗾然咀嚼佐賀美邇迦美，於吹棄ふきうつる氣吹之狹霧いふきのさぎり所成神。<em>【○八尺勾璁やさかのまがたま，即八尺瓊勾玉やさかにのまがたま。】</em><br>　　御名，正勝吾勝勝速日天之忍穗耳命まさかつあかつかちはやひあめのおしほみみのみこと。<br>　　亦，乞度こひわたる所纏右御髻みぎのみ美豆良之珠，𪗾然咀嚼佐賀美邇迦美，於吹棄ふきうつる氣吹之狹霧いふきのさぎり所成神。御名，天之菩卑能命あめのほひのみこと。【自菩ほ下三字以音。<em>○菩ほ與穗ほ通，卑ひ蓋靈力之意。</em>】<br>　　亦，乞度こひわたる所纏御蔓みかづら之珠たま而𪗾然咀嚼さがみにかみ，於吹棄ふきうつる氣吹之狹霧いふきのさぎり所成神。御名，天津彥根命あまつ日子ねのみこと。<br>　　又，乞度こひわたる所纏左御手ひだりのみて之珠而𪗾然咀嚼さがみにかみ，於吹棄ふきうつる氣吹之狹霧いふきのさぎり所成神。御名，活津彥根命いくつ日子ねのみこと。<br>　　亦，乞度こひわたる所纏右御手之珠而𪗾然咀嚼さがみにかみ，於吹棄ふきうつる氣吹之狹霧いふきのさぎり所成神。御名，熊野奇靈命くまの久須毘のみこと。<em>【○熊野奇靈命くまのくすびのみこと，原文久須毘くすび以音。】</em>并あはせ五柱いつはしら。　於是，天照大御神告のらし速須佐之男命：「是後こののち所生うまめる五柱いつはしら男子をのこ者，物實ものざね因我物所成，故ゆゑ自おのづから吾子あがこ也。先まづ所生之三柱みはしら女子めのこ者，物實ものざね因汝物なむちがもの所成，故乃すなはち汝子也。」如此詔別也かくのりわきき。<br>　　故かれ其先所生之神，田霧姬命多紀理毘賣のみこと者，坐胸形宗像之奧津宮おきつみや。<em>【○宗像大社むなかたのおほやしろ沖津宮。】</em><br>　　次，市寸島姬命いちきしま比賣のみこと者，坐胸形むなかた之中津宮なかつみや。<em>【○宗像大社中津宮。】</em><br>　　次，湍津姬命田寸津比賣のみこと者，胸形宗像之邊津宮へつみや。<em>【○宗像大社邊津宮。】</em>此三柱神者，胸形君むなかたのきみ等之以齋伊都久三前大神みまへのおほかみ者也。<em>【○宗像三神，亦為安藝國あぎのくに嚴島神社いつくしまのかむやしろ所祀。】</em><br>　　故此後こののち所生五柱子之中，天之菩比命あめのほひのみこと。其子，建比良鳥命たけひらとりのみこと。【此，出雲國造いづものくにのみやつこ、武藏無耶志國造、上菟上かみつうなかみ國造、下菟上しもつうなかみ國造、伊甚伊自牟國造、津嶋對馬縣直あがたのあたひ、遠江とほつあふみ國造等之祖おや也。<em>○武藏むざし訓むざし無耶志。上菟上かみつうなかみ、下菟上しもつうなかみ各為上總かづさ、下總しもふさ之一部。伊甚いじむ訓いじむ伊自牟。津嶋つしま則對馬つしま。</em>】<br>　　天津彥根命あまつ日子ねのみこと。【凡河內凡川內國造、額田部湯座連ぬかたべのゆゑのむらじ、茨城茨木國造、倭田中直やまとのたなかのあたひ、山城山代國造、馬來田うまぐた國造、陸奧岐閉道尻きへ國造、諏訪周方國造、倭淹知造やまとのあむちのみやつこ、高市縣祖たけちのあがたぬし、蒲生かまふ稻置稻寸、三枝部造さきくさべのみやつこ等之祖也。<em>○凡川內おほしかふち即河內かふち。茨城うばらき在常陸ひたち，田中たなか在大和。山代やましろ或云山背やましろ，今京都。馬來田うまぐた在上總かづさ，道尻岐閉みちのしりきへ在陸奧而岐閉未詳。周方すは即諏訪すは，淹知あむち、高市たけち在大和やまと。蒲生かまふ在近江あふみ，稻寸いなき即稻置いなき。</em>】　爾速須佐之男命，白まをさく於天照大御神：「我心清明故きよくあかきがゆゑ，所生之子，得手弱女たわやめ。因此これにより言者いはば，自おのづから我勝あれかちぬ！」云而，乘勝勝佐備毀はなち天照大御神營田つくりた之畔阿，埋うみ其溝みぞ。亦放屎屎麻理於其聞看きこしめす大嘗おほにへ之殿との。<em>【○乘勝，原文勝さびかち佐備。毀はなち，原文離はなち。畔あ，原文阿あ。放屎くそまり，原文屎まりくそ麻理。 】</em>故雖然為かれしかすれども，天照大御神未咎登賀米受而告： 「如屎くそのごとき，醉ゑひ而吐散之矣はきちらすとこそ。故我汝弟那勢命，為如此かくしつらめ。又，毀離田之畔阿、埋溝渠みぞ者，憐阿多良斯地之故矣とこそ。我汝弟なせ命，為如此。」詔雖直なほせども，猶なほ其惡態あしきわざ，不止やまず而轉うたたあり。天照大御神，坐いまし忌服屋いみはたや，而令織おらしめし神御衣かむみそ之時，弟神須佐之男穿うかち其服屋はたや之頂いただき，逆剝さかはぎ天斑馬あめのふちうま皮，而投棄墮入おとしいれ。天服織女あめのはとりめ見驚みおどろき，以梭ひ衝つき陰ほと而死しにき。<em>【○ 憐あたらし，訓あたらし阿多良斯，可惜土地未善盡利用。直なほせ，此云辯護。轉うたたあり，此云變本加厲。陰ほと，原文陰上ほと。凡畔放あはなち、溝埋みぞうめ、樋放ひはなち、頻播しきまき、串刺くしさし、生剝いきはぎ、逆剝さかはぎ、糞戶くそへ者，所謂天津罪あまつつみ是也。】</em><img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ukehi01.gif" alt="廣島縣立美術館藏　松本楓湖『天照大御神與須佐之男命』○廣島縣廣島市中區上幟町"><br>天照大神、須佐之男　誓約之圖<br>天照大神見須佐之男參上，以為有奪國之志，遂著男裝詰問之。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/takachiho01.gif" alt="高千穗峽　真名井瀧○宮崎県西臼杵郡高千穗町大字向山"><br>天真名井之瀧<br>天照大神、須佐之男隔天安河而誓約，取天真名井之水，互濯彼此所持劍、勾玉，吐霧成神。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ama_manawi01.gif" alt="高千穗　天真名井○宮崎県西臼杵郡高千穗町大字三田井"><br>天之真名井<br>於茲，須佐之男生三女神：田霧姬命、市寸嶋姬命、湍津姬命。天照大神產五男神：正勝吾勝勝速日天忍穗耳命、天菩比命、天津彥根命、活津彥根命、熊野奇靈命。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/munakata_hentu01.gif" alt="宗像大社　邊津宮○福岡縣宗像市田島"><br>宗像大社　邊津宮<br>湍津姬命，坐宗像大社邊津宮。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/munakata_nakatu01.gif" alt="宗像大社　中津宮○福岡縣宗像市大島"><br>宗像大社　中津宮<br>市寸島姬命，坐宗像大社中津宮。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/amaterasu01.gif" alt="天岩戶神社　天照大神像○宮崎縣西臼杵郡高千穗町大字岩戶"><br>天岩戶神社　天照大御神像<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kouma01.gif" alt="山邊神宮藏　堀江友聲『古事記繪詞』○島根縣江津市江津町"> 須佐之男之暴行、天津罪<br>須佐之男鑿忌服屋頂，逆剝天斑馬投墬，機織女驚惶，以梭撞陰死。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ama_iwato01.gif" alt="天岩戶示意圖　實地禁止攝影○宮崎県西臼杵郡高千穗町大字岩戶"><br>天岩戶神社　天岩戶合成示意圖<br>天照大神驚動，入天石窟而幽居。遂六合常闇，不知晝夜相代。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ama_yasukahara01.gif" alt="天安河原○宮崎県西臼杵郡高千穗町大字岩戶"><br>天岩戶神社　天安河原<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/gyoubo_iwaya01.gif" alt="天安河原○宮崎県西臼杵郡高千穗町大字岩戶"><br>天安河原　仰慕窟　天安河原宮<br>天安河原宮，祀思兼命。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/gyoubo_iwaya02.gif" alt="天安河原○宮崎県西臼杵郡高千穗町大字岩戶"><br>天安河原　仰慕窟　天安河原宮<br>八百萬神聚天安河原仰慕窟。思兼命有叡智，獻計令日神出天岩戶。<img src="https://miko.org/~uraki/kuon/furu/text/syoki/01/ama_uzume01.gif" alt="高千穗道之驛　天鈿女命像○宮崎県西臼杵郡高千穗町大字三田井"><br>高千穗道之驛　天鈿女命像<br>天鈿女命飾以蘿、鬘、篠，舞蹈神懸。露出胸乳，褪裳於陰。高天原動而八百萬神共咲。天照大神恠之，遂細開天石屋戶。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/tadikarawo01.gif" alt="天安河原○宮崎県西臼杵郡高千穗町大字岩戶"><br>天岩戶神社　天手力男命像<br>天手力男侍磐戶側，引日神而奉出。所擲岩戶，化信洲戶隱山也。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/iwato_kagura01.gif" alt="春齋年昌『岩戶神樂之起顯』○春齋年昌"><br>岩戶神樂之起顯<br>天照大御神，自岩戶出而臨坐。時高天原及葦原中國，自得照明。<strong>二、日蝕常闇與五穀起源</strong>　故かれ於是，天照大御神あまてらすのおほみかみ見畏みかしこみ，開ひらき天石屋戶あめのいはやのと而幽居刺許母理也。<em>【○幽居さしこもり，原文云刺籠坐さしこもりましき。】</em>爾高天原たかあまのはら皆暗みなくらく，葦原中國あしはらのなかつくに悉闇ことごとくくらし，因此これにより而常夜とこよ往ゆきき，無復晝夜之殊。於是，萬神よろのづかみ之聲こゑ者，猶那須蠅聲さばへ盈滿みち，萬妖よろづのはざはひ悉發おこりき。<em>【○猶蠅聲さばへ盈滿，原文云狹蠅なす滿さばへ那須みち。】</em>　是以ここをもちて，八百萬神やほよろづのかみがみ神集集かむつどひつどひ於天安之河原あめのやすのかはら而計可禱之方。【○訓集つどひ云つどひ都度比。】令高御產巢日神たかみむすひのかみ子思金神おもひかねのかみ慮之。遂集常世とこよ長啼鳥ながきどり，令鳴なかしめ。揀取天安河あめのやすのかは河上かはかみ之天堅石あめのかたしは，採取天金山あめのかなやま之鐵くろかね而，求もとめ鍛人かぬち天津麻羅あまつまら，科おほせ石凝姥命伊斯許理度賣のみこと，令作鏡八咫鏡。【石凝姥命いしこりどめ，原文いしこりどめ伊斯許理度賣以音。】科玉祖命たまのおやのみこと者，令作八尺勾璁八尺瓊勾玉之五百箇御統珠いほ津御須麻流のたま。召めし天兒屋命あめのこやのみこと、太玉命布刀たまのみこと，內拔うつぬき天香山あめのかぐやま之真男鹿まをしか肩かた骨，摘取天香山之天朱櫻あめの波波迦燔之，以為太占占合之備麻迦那波矣。<em>【○太玉命ふとたまのみこと，原文太ふと作布刀ふと以音。朱櫻ははか，原文ははか波波迦以音。以為太占占合之備麻迦那波，原文令占合うらなひまかなは麻迦那波，賄まかなひ乃準備之意。】</em><br>　復根掘ね許士爾許士天香山之五百箇津真賢木まさかき而，於上枝かみつえ懸取著八尺勾璁八尺瓊勾玉之五百箇御統之玉いほつみすまるのたま，於中枝なかつえ懸繫とりかけ八咫鏡やあたのかがみ，於下枝しもつえ懸垂とりしで白幣帛しら丹寸手、青幣帛あを丹寸手。【訓八咫やあた云八阿多やあた，訓垂しで云しで志殿。<em>○根掘原文根こじにこじね許士爾許士以音。幣帛にきて原文にきて丹寸手以音。</em>】太玉命布刀たまのみこと奉持とりもちて此種種くさぐさ物，以為大御幣布刀みでくら。天兒屋命あめのこやのみこと言禱ごとほき祝詞詔戶，奏上白。天手力男神あめのたぢからをのかみ，隱立かくりたち天岩戶掖とのわき。天鈿女命あめの宇受賣のみこと，繫かけ天香山あめのかぐやま蘿日影於襷手次，以天真折蔓あめのまさき為鬘縵，結ゆひ天香山篠小竹於手手草，置覆槽伏汙氣於天石屋戶而蹈轟ふみ登杼呂許志以為神懸かむがかり，<em>【○蘿ひかげ，原文日影ひかげ。襷たすき，原文手次たすき，或云手繦たすき。鬘かづら，原文縵かづら。訓小竹ささ云ささ佐佐。覆槽ふせうけ原文伏うけふせ汙氣以音。轟，原文とどろこし登杼呂許志以音。】</em>其姿，露出掛いだし胸乳むなち，裳緒ものを褪垂忍たれき於陰番登也。<em>【○露出，原文掛出かけいだし。褪垂おしたれき，原文忍垂おしたれき。陰陰，原文番登ほと以音。】</em>爾しかくして高天原動とよみ而八百萬神共咲ともにわらひき。　於是，天照大御神以為おもひ怪あやし，細開ほそくひらき天石屋戶あめのいはやのと，居內うち而告のらし：「朕以為おもふに，因吾隱坐こもります，而天原あまのはら自闇おのづからくらく，亦葦原中國あしはらのなかつくに皆闇みなくらけむ矣。何由なにのゆゑ以天鈿女あめの宇受賣者為樂あそび，亦八百萬神やほよろづのかみかみ諸咲もろもろわらふ？」<br>　爾，天鈿女あめの宇受賣白言まをしていはく：「以益まし汝命ながみこと貴神たふときかみ坐故いますがゆゑ，歡喜よろこび咲樂わらひあそぶ。」如此言之間かくいふあひだ，天兒屋命、太玉命布刀たまのみこと，指出さしいだし其鏡八咫鏡，示奉しめしまつる天照大御神。天照大御神あまてらすおほみかみ，逾いよよ思奇之あやし，稍やをやく自戶出而臨坐のぞみます。時其所隱立かくりたてる戶掖之天手力男神あめのたぢからをのかみ，取其天照御手みて引出ひきいだす。即太玉命ふとたまのみこと，以端出之繩尻久米なは，控度ひきわたし其天照御後方みしりへ，白言：「從此これより以內うち，不得えじ還入かへりいる。」<em>【○樂あそび，此即神遊かむあそび。端出之繩しりくめなは，原文しりくめ繩尻久米なは，注連繩しめなは是也。】</em>故，天照大御神出坐之時いでまししとき，高天原及と葦原中國，自得おのづからえたり照明てりあかること。　於是ここに，八百萬神やほよろづのかみかみ共議ともにはかり，科負速須佐之男命はやすさのをのみこと以千位置戶ちくらのおきと，<em>【○科おほせ，原文作負おほせ。千位置戶ちくらのおきと，科以眾多祓物，位くら乃置臺，書紀作千座置戶ちくらのおきと。】</em>亦切きり鬢ひげ及手足爪てあしのつめ贖之，令祓はらへしめ而神逐而逐矣かむ夜良比夜良比岐。　又，須佐之男乞こひき食物くらひもの於大饌津姬神おほ氣都比賣のかみ。爾大饌津姬，自鼻はな、口くち及尻しり，取出とりいだし種種くさぐさ味物うましもの，作具つくりそなへ種種珍饈而進之たてまつる。時速須佐之男命，立伺たちうかかひ其態そのわざ者，以為おもひ穢污けがし而奉進たてまつる。乃すなはち殺ころしき其大饌津姬神おほ宜つ比賣のかみ。<br>　故，所殺之ころさえし神大饌津姬於屍身生物なりしもの。<br>　　於頭かしら，生なり蠶こ。<br>　　於二目ふたつのめ，生稻種いなだね。<br>　　於二耳ふたつのみみ，生粟あは。<br>　　於鼻はな，生小豆あづき。<br>　　於陰ほと，生麥むぎ。<br>　　於尻しり，生大豆まめ。<br>　故是かれここに，神產巢日御祖命かむむすひのみおやのみこと，令取とらしめき茲成種このなれるたね。<strong>八岐大蛇</strong></p><p><strong>一、驅除大蛇與八重垣神詠</strong>　故かれ須佐之男為高天原所避逐さりおはえ，遂降くだりき出雲國いづものくに肥河上ひのかはかみ鳥髮とりかみ之地ところ。此時このとき，箸はし從其河流下ながれくだりき。於是ここに須佐之男命以為おもひ：「人在有其河上かはかみ。」而尋覓たづねもとめ溯往者のぼりゆけば，有老夫おきな、老女おみな二人ふたり，以童女をとめ置中なかにおき而泣なけり。爾しかくし須佐之男問賜之とひたまひし：「汝等なむちら者誰たれぞ？」其老夫答言こたへていひし：「僕やつかれ者國神くにつかみ，大山津見神おほやまつみのかみ之子焉。僕名謂足名椎あしなづち，妻名謂めがな手名椎てなづち，女むすめ名謂いふ櫛名田姬くしなだ比賣。」亦問またとひし：「汝哭由なくゆゑ者何なにぞ？」答白こたへまをし言：「我之女あがむすめ者，本もとより有八稚女やたりのをとめ。是高志こし之八岐大蛇八俣遠呂知，每年としごと來喫きてくひき。<em>【○八岐大蛇やまたをろち，原文八俣のをろちやまた遠呂知。】</em>今逢其當來時矣くべきときぞ。故かれ泣なく。」爾問：「其形そのかたち如何いかに？」答白：「彼目そのめ如赤酸醬あか加賀智，身一而有八頭やつのかしら、八尾やつのを。亦其身生おひ蘿ひかけ及檜ひ、椙すぎ。其長渡わたり谿八谷たにやたに、峽八尾をやを而，見其腹はら者，悉ことごとく常つねに血爛也ちあえただれたり。」【此謂赤かがちあか加賀智者，今酸醬ほほづき者也。】　爾，速須佐之男命はやすさのをのみこと詔其老夫おきな：「是この汝之女なむちがむすめ者，奉於吾哉あれにまつらむや？」答白：「恐かしこし。亦また，不覺さとらず御名みな。」爾須佐之男答詔のりたまひし：「吾者，天照大御神あまてらすおほみかみ之胞弟伊呂せ者也。故，今自天降坐也あめよりくだりましぬ。」爾足名椎あしなづち、手名椎てなづち白：「然者しかいまさば，惶恐かしこし。立奉たてまつらむ。」<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/amanomurakumo01.gif" alt="天叢雲劍○©F.O.G　久遠の絆">爾，速須佐之男命，乃すなはち化取成其童女をとめ為齋爪櫛湯津つまくし而插さし於御髻み美豆良。告のらし其足名椎、手名椎神：「汝等なむちら當釀かみ八鹽折之酒やしほをりのさけ，亦作迴つくりめぐらし垣かき。於其垣作八門やつのかど，每門かどごと結ゆひ八假庪やつの佐受岐。每其假庪やずき置酒船さかぶね，各盛もり八鹽折酒やしほをりのさけ以待まて。」<em>【○假庪さずき，訓さずき佐受岐以音。權設之棚，棧敷さぢき之疇也。酒船さかぶね，酒槽さかふね之謂也。八鹽折酒やしほをりのさけ，書紀作八醞酒やしほをりのさけ。】</em>故隨告のらししまにまに而如此設備かくまうけそなへ相待之間まつとき，八岐大蛇八俣遠呂知信まこと如言ことのごとく來きぬ。　八岐大蛇乃すなはち每船ふなごと垂入たれいれ己頭おのがかしら，飲のみき其酒。於是，飲醉のみゑひ，留とどまり而伏寢ふしいねき。爾速須佐之男命，拔ぬき其所御佩みはかしせる十拳劍とつかのつるぎ，斬散きりちらし其蛇。肥河ひのかは之水，變血ちにかはり而流ながれき。故，斫きり其中尾なかつを時，御刀之刃みはかしのは毀こほれき。爾須佐之男思怪あやし，以御刀みはかし之鋒前，刺割さしさき而見者，有都牟羽之大刀つむはのたち。故取此大刀，思其異物あやしきもの，不可私有，而白上まをしあげき於天照大神あまてらすおほみかみ也。是これ者，草薙之大刀くさ那藝のたち也。<em>【○草薙劍くさなぎのつるぎ，或謂天叢雲劍あまのむらくものつるぎ，傳大蛇をろち頭上常有雲氣くものけ，故云。都牟羽大刀つむはのたち，或本書都牟刈大刀つむがりのたち，今隨真福寺本。其所以斷蛇之十握劍とつかのつるぎ，或云蛇之麤正をろちのあらまさ、蛇韓鋤劍をろちのからさひのつるぎ、天蠅斫劍あまのははきりのつるぎ、天羽羽斬あめのはばきり、布都斯魂劍ふつしみたまのつるぎ也。】</em>　 故是以ここをもち，其速須佐之男命，求もとめき可造宮之地みやをつくるべきところ於出雲國いづものくに。爾到清地須賀而詔之のりたまはく：「吾あれ來此地ここ，我御心あがみこころ清清之須賀須賀斯。」遂營作宮其地そこ以鎮座いましき。故かれ其地者，於今云須賀すが也。【清清之すがすがし，原文すがすがし須賀須賀斯以音。】<br>　玆この大神須佐之男，初はじめ作須賀宮すがのみや之時，八雲自其地立騰たちのぼりき。爾作御歌みうた。其歌曰：　八雲立やくもたつ　出雲八重垣いづもやへがき　妻籠つまごみに　八重垣作やへがきつくる　其八重垣そのやへがきを　於是，喚めし其足名鈇神あしなづちのかみ，告言：「汝者，任まけむ我宮之首おびと。」且負名なをおほせ，號なづけき稻田宮主いなだのみやぬし須賀之八耳神すがのやつみみのかみ。<em>【○足名鈇神あしなづちのかみ，即足名椎あしなづち。鈇づち乃斧をの、鉞まさかり之意，『名義抄』訓以つち。】</em>　故かれ須佐之男與其櫛名田姬くしなだ比賣興組所久美度。<em>【○組所くみと即閨房，此云婚合。】</em><br>　　所生神，名謂八島士奴美神やしまじぬみのかみ。【じぬみ士奴美以音。或云八島治主靈神やしま士奴美のかみ。】<br>　又娶めとり大山津見神おほやまつみのかみ之女神大市姬かむおほいち比賣。<br>　　生子，大年神おほとしのかみ。<br>　　次，宇迦之御魂神うかのみたまのかみ。<em>【○宇迦うか與受うけ同源，食物之古形而特指稻靈。】</em><br>　　兄え八島士奴美神，娶大山津見神之女木花知流姬このはなちる比賣。<br>　　　生子，莟貴國栖主神布波能母遲久奴須奴のかみ。【○原文ふはのもぢくぬすぬのかみ布波能母遲久奴須奴神以音。】<br>　　　此莟貴國栖主神ふはのもぢくぬすぬのかみ，娶靇神淤迦美のかみ之女日河姬ひかは比賣。<br>　　　　生子，深淵之水夜禮花神ふかふちのみづやれはなのかみ。<br>　　　　此水夜禮花神みづやれはなのかみ，娶天之集道泥神あめの都度閉知ねのかみ。<em>【○按原文天之あめの或云水源，つどへち都度閉知以音，ね泥為親稱。】</em><br>　　　　　生子，大水主神淤美豆奴のかみ。【原文おみづぬ淤美豆奴以音。】<br>　　　　　此大水主神おみづぬのかみ，娶布怒豆怒神ふのづののかみ之女布帝耳神ふてみみのかみ。<br>　　　　　　生子，天之冬衣神あめのふゆきぬのかみ。<br>　　　　　　此天之冬衣神，娶刺國大神さしくにおほかみ之女刺國若姬さしくにわか比賣。<br>　　　　　　　生子，大國主神おほくにぬしのかみ。亦名またのな謂大穴牟遲神おほあなむぢのかみ，亦名謂いひ葦原醜男神あしはら色許をのかみ，亦名謂八千矛神やちほこのかみ，亦名謂顯國玉神宇都志くにたまのかみ。并あはせ有五名いつつのな。<em>【○醜しか，強壯之意，原文しこ色許以音，下效此。顯うつし，原文うつし宇都志以音。】</em><img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/hiikawa01.gif" alt="斐伊川○島根縣出雲市"><br>肥河　斐伊川<br>八岐大蛇傳說，在裴伊川流域。<a href="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kusinada01.gif"><img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kusinada01.gif" alt="八重垣神社　復原奇稻田姬命障壁畫○島根縣松江市佐草町"></a><br>八重垣神社　櫛名田姬復原障壁畫<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/amagafuchi01.gif" alt="天が淵○島根縣雲南市木次町湯村"><br>天之淵<br>斐伊川上游，傳八岐大蛇居所。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yamata_orochi01.gif" alt="八岐大蛇　©F.O.G　久遠の絆 再臨詔"><br>八岐大蛇<br>出雲之舊支配者，不順鬼神代表。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yasugi01.gif" alt="八本杉○雲南市木次町里方"><br>傳八岐大蛇首塚　八本杉<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/suga01.gif" alt="日本初之宮　須我神社　神詠歌碑○島根縣雲南市大東町須賀"><br>日本初之宮　須我神社　神詠歌碑<br><a href="https://miko.org/~uraki/kuon/furu/text/waka/kikirouei/krk01.htm#k0001">八重垣神詠</a>：「八雲層湧立　出雲清地八重垣　欲籠妻在此　遂造出雲八重垣　其八重垣可怜矣」<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yahegaki01.gif" alt="八重垣神社○島根縣松江市佐草町"><br>意宇六社　八重垣神社<br>須佐之男築宮須賀，【須我神社。】後移佐草【八重垣神社。】。奧院佐久佐女森鏡池，傳稻田姬隱居梳妝處。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yahegaki02.gif" alt="八重垣神社攝社　腳摩乳神社、手摩乳神社○島根縣松江市佐草町"><br>腳摩乳神社、手摩乳神社<br>八重垣神社攝社。須佐之男命稻田姬父神足名椎神，為稻田宮主。<a href="https://miko.org/~uraki/kuon/furu/text/kojiki/01/susanowo01.gif"><img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/susanowo01.gif" alt="八重垣神社　復原素戔嗚尊障壁畫○島根縣松江市佐草町"></a><br>八重垣神社　素戔嗚尊復原障壁畫<br>須佐之男築須賀宮，籠妻八重垣，始作卅一字之詠，短歌之肇也。<strong>出雲神話</strong></p><p><img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yakamihime01.gif" alt="八上神社　八上姬像○島根縣出雲市斐川町學頭　旅館湯元湯川構內"><br>八上神社　八上姬像<br>稻羽國國色八上姬，眾神欲婚之。<a href="https://www.instagram.com/p/BwBN0uEAW-G/"><img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/hakuto01.gif" alt="白兔海岸　白兔神社○鳥取縣鳥取市白兔©Miro ~Qiu Jing-Wen"></a><br>氣多崎　白兔海岸　白兔神社<br>大穴牟遲等遇稻羽素菟於氣多崎。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ookuninusi02.gif" alt="出雲大社　大國主命　御慈愛之御神像○島根縣出雲市大社町杵築東"><br>出雲大社　御慈愛之御神像<br>大穴牟遲神以善心救因幡白兔，遂得八上姬之青睞。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yakamihime02.gif" alt="道之驛神話之里白兔　大國主命與八上姬○鳥取縣鳥取市白兔"><br>沙像　大國主命與八上姬<br>大穴牟持神、八上姬以白兔結緣。<img src="https://miko.org/~uraki/kuon/furu/text/fuudo/izumo/01/inochinusi01.gif" alt="神魂伊能知奴志神社・命主社・御魂社○島根縣出雲市大社町杵築東"><br>神魂伊能知奴志神社　命主社<br>出雲大社攝社，祀神產巢日命。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ohonamuchi01.gif" alt="青木繁『大穴牟知命』○1905年 油畫"><br>大穴牟遲神與𧏛貝姬、蛤貝姬<br>大穴牟遲陷八十神計為石燒著死。神產靈遣𧏛貝姬、蛤貝姬令活之。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/amazaki01.gif" alt="出雲大社攝社　天前社　神魂伊能知比賣神社○島根縣出雲市大社町杵築東"><br>神魂伊能知比賣神社【右】<br>俗稱天前社。祭𧏛貝姬、蛤貝姬。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/soga_yasiro01.gif" alt="出雲神社　素鵞社○島根縣出雲市大社町杵築東"><br>出雲大社攝社　素鵞社<br>祭須佐之男命。須佐之男往妣國，為根堅洲國之主。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/suseribime01.gif" alt="武州里神樂　須勢理姬命○埼玉縣新座市野火止"><br>武州里神樂　須勢理姬命<br>須佐之男之女，而與大國主一見鍾情，助其通過父神所予之試練。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ookuninusi04.gif" alt="古事記繪詞　遙封大國主命○©山邊神社　古事記繪詞"><br>建速須佐之男遙封大國主命<br>大穴牟遲、須勢理姬竊生大刀、生弓矢、天沼琴而逃。須佐之男於黃泉平坂遙封大穴牟遲為大國主命。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/mimukahi01.gif" alt="出雲大社攝社　御向社　大神大后神社○島根縣出雲市大社町杵築東"><br>大神大后神社　御向社【中】<br>祭神，大國主命正妻須勢理姬命。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/nunakawa01.gif" alt="絲魚川驛北口　沼河姬像○新潟縣糸魚川市大町"><br>高志國　沼河姬<br>大國主與沼河姬應答歌三首，併與須勢理姬相問歌二首，是為神語。<a href="https://miko.org/~uraki/kuon/furu/text/waka/kikirouei/krk01.htm#k0002">神語，其一</a>：「顯國八千矛　大國主神大汝命　大八島國中　欲娶妻兮卻難尋　遙遙而遠赴　聽聞高智越國間　有賢女在兮　窈窕淑女麗孃子　君子自好逑　聽聞佳人在此故　故今來求婚　蟻立居於此　故今來求婚　蟻通訪於此　大刀飾緒者　至今未解佇於茲　襲裳衣著者　至今未解佇於茲　窈窕孃子之　所寢香閨板戶矣　今押搖振之　吾立於此求婚者　引晃喚娘子　吾居於此求婚者　巍峨青山間　鵺鳥發聲鳴　小野間鳥者　雉鳥啼聲響野中　庭院間鳥者　長鳴雞宏唳　鳥鳴聲忌忌　鳴鳥啼聲亂心緒　願將此鳥等　打叩止鳴致寂靜　慕訟神語兮　天際傳詠天馳使　冀將此事矣　願將吾述言語者　流傳延末世」<a href="https://miko.org/~uraki/kuon/furu/text/waka/kikirouei/krk01.htm#k0003">其二</a>：「顯國八千矛　大國主神大汝命　陰柔弱萎草　手弱女人吾是者　我心甚游移　其若浦渚沙濱鳥　雖在今日時　彼為我鳥屬吾身　但在此後者　當作汝鳥為汝物　還冀聞我願　莫殺彼鳥勿害命　慕訟神語兮　天際傳詠天馳使　冀將此事矣　願將吾述言語者　流傳延末世　蒼鬱青山中　大陽日隱其間者　濡烏射干玉　闇夜至矣世黑漆　滿面猶朝日　笑顏綻兮榮來而　栲綱皎如月　白皙細腕為汝執　沫雪猶泡沫　稚嫩酥胸為汝撫　輕悄微叩兮　輕叩愛翫幸吾身　高貴真玉手　相交玉手為手枕　股腳伸而長　纏綿交寢渡春宵　無由方寸焦　戀慕如此情亂麻　顯國八千矛　大國主神大汝命　冀將此事矣　願將吾述言語者　流傳延末世 」<a href="https://miko.org/~uraki/kuon/furu/text/waka/kikirouei/krk01.htm#k0004">其三</a>：「烏黑射干玉　漆黑真闇尊御衣　恭謹具呈之　取兮慎裝冶容儀　若猶沖鳥鴨　露胸展膛時搏羽　茲不適合宜　故如邊津波　悄悄褪棄黑御衣　墨綠鴗鳥之　蒼翠碧青尊御衣　恭謹具呈之　取兮慎裝冶容儀　若猶沖鳥鴨　露胸展膛時搏羽　茲不適合宜　故如邊津波　悄悄褪棄青御衣　今以山方所蒔茜　舂彼茜兮而　以彼染草染木汁　所染也御衣　恭謹具呈之　取兮慎裝冶容儀　若猶沖鳥鴨　露胸展膛時搏羽　是也甚合宜　親親愛子矣　愛也吾妻妹命者　翩翩群鳥之　我倆成伴同去者　退引群鳥之　若吾如鳥退去者　汝蓋啜泣乎　雖汝強言不泣啼　蜻蛉大和國　孤零一本丁薄芒　猶彼項垂傾　吾度汝當闇泣歟　歎猶朝方天　朝霧起兮情陰鬱　若草稚卉之　所愛親親吾妻命　冀將此事矣　願將吾述言語者　流傳延末世」<a href="https://miko.org/~uraki/kuon/furu/text/waka/kikirouei/krk01.htm#k0005">其四</a>：「顯國八千矛　大己貴大汝命耶　我妾身之大國主　汝以男神者　巡迴遍國中　諸島諸岬御崎崎　探迴遍國中　所巡礒邊崎無落　若草稚卉之　可憐少妻汝娶歟　然顧妾身者　妾身為女心不安　除汝命之外　莫無他男可倚恃　除汝命之外　莫無他夫可倚恃　綾織帳垣兮　輕柔飄盪垂敷下　絹絲蠶衾兮　和柔輕軟彼襖下　楮絲栲衾兮　衣擦騷聲彼襖下　沫雪猶泡沫　稚嫩酥胸為汝撫　栲綱皎如月　白皙細腕為汝執　輕悄微叩兮　輕叩愛翫幸吾身　高貴真玉手　相交玉手為手枕　股腳伸而長　纏綿交寢渡春宵　今舉豐御酒　貢獻美酒敬吾夫」<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/suseribime02.gif" alt="出雲大社　大國主命、須勢理姬命結納圖○島根縣出雲市大社町杵築東"><br>大國主命、須勢理姬命結納圖<br>神語既迄，結盞交頸鎮坐至今。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/tukusi_yasiro01.gif" alt="出雲大社攝社　筑紫社　神魂御子神社○島根縣出雲市大社町杵築東"><br>神魂御子神社　筑紫社【左】<br>祭神宗像大社奧津宮田霧姬命。大國主命與之結婚，生下光姬命。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/katano01.gif" alt="片埜神社○大阪府枚方市牧野阪"><br>一宮牛頭天王　片埜神社<br>配祀八嶋士奴美神者，非大國主命之子。須佐之男、櫛名田姬所生。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/mihojinnjya01.gif" alt="美保神社○島根縣松江市美保關町美保關"><br>惠比壽總本宮　美保神社<br>神屋楯姬命，生事代主神。祀於美保神社本殿內末社大后社。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kuehikojinjya01.gif" alt="久延彥神社○奈良縣櫻井市三輪大御輪寺"><br>大神神社末社　久延彥神社<br>久延彥，足不能行而能知天下事。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/sukunahikona01.gif" alt="常陸國出雲大社　大國主神像　少彥名神○茨城縣笠間市福原"><br>少彥名神像<br>少彥名神，侏儒神，乘天羅摩船來而與大國主命共造葦原中國。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/musubi_mikata01.gif" alt="出雲大社　大國主命　結緣之御神像○島根縣出雲市大社町杵築東"><br>出雲大社　幸魂奇魂結緣御神像<br>少彥名神渡常世國。大國主神愁無神與之建國。時大物主神光海依來，是為大國主之幸魂奇魂也。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/miwajinjya01.gif" alt="大和國一宮　大神神社○奈良縣櫻井市大字三輪"><br>大和國一宮　大神神社　三輪山<br>大物主神，坐大和國御諸三輪山。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/miwajinjya02.gif" alt="大和國一宮　大神神社○奈良縣櫻井市大字三輪"><br>大和國一宮　大神神社　拜殿<br>大神神社以神奈備之三輪山為神體，僅有三輪鳥居，無本殿。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yamato_jinjya01.gif" alt="大和神社　右殿○奈良縣天理市新泉町星山"><br>大和神社　右殿<br>祀御年大神者，須佐之男、大山津見神之女大市姬之子。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yamato_jinjya02.gif" alt="大和神社　拜殿○奈良縣天理市新泉町星山"><br>大和神社　拜殿<br>大國御魂神或云與倭大國魂神同神，則大和神社主祭神。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/matuwo01.gif" alt="松尾大社○京都府京都市西京區嵐山宮町"><br>松尾大社<br>大山咋神，亦名山末之大主神。坐近江日枝山、葛野松尾。<strong>一、大國主命之歷練與出雲建國</strong>　 伏惟大國主神おほくにぬしのかみ之兄弟はらから，有八十神やそかみ。然しかれども皆みな以其國，讓避於大國主神。<em>【○讓さりき，原文避さりき。離於己身，拱手他人。下效此。】</em>所以ゆゑ讓さりし者何？八十眾神，各おのおの懷欲婚あはむとおもふ稻羽いなば之八上姬やかみ比賣之心こころ，遂共徃いきし稻羽。時命大穴牟遲神おほなむぢのかみ為從者ともびと，負おほせ袋ふくろ而率往ゐてゆきき。<em>【○袋ふくろ，行囊。】</em><br>　於是ここに，到いたりし氣多之崎けたの前時，有一裸兔あかはだのうさぎ伏也ふせりき。爾しかくし八十神謂いひ其菟云：「汝なむち將為せまく癒者，宜浴あみ此海潮海鹽，當あたり風吹かぜのふく而伏ふせれ高山たかきやま峰上尾のへ。<em>【○崎さき原文前さき，海潮このうしほ原文海鹽このうしほ，峰上をのへ原文尾上をのへ，下效此。】</em>」故其菟，從したがひ八十神之教をしへ而伏ふせりき。爾其身皮，悉ことごとく隨まにまに潮乾しほのかはく而為風吹裂ふき析。<em>【○吹裂ふきさかりき原文吹析ふきさかりき。】</em>故愈痛苦いたみくるしび，泣伏不已。時大穴牟遲神最後もっとものち之來こし，見其菟うさぎ言：「汝以何由なにのゆゑ，泣伏なきふせる於茲？」　白菟答こたへ言：「僕やつかれ在隱岐嶋淤岐のしま，雖欲おもひしかども渡わたらむ此地ここ，苦無なかりき渡由わたむよし。<em>【○隱岐おき原文淤岐おき，當非沖嶋おきつしま矣。渡由わたむよし，渡海之方。】</em>故欺あざむき海鰐わたの和邇言：『吾與汝あれとなむち競くらべ，欲計はからむ族之多少うがらのおほさすくなさ。故かれ汝當悉率ことごとくゐて族來き，自より此島起，皆列伏渡なみふしわたれ，至於いたるまで氣多崎けたの前矣。爾吾蹈ふみ其上そのうへ，走乍はしりつつ數渡讀みわたらむ。於是ここに可知しらむ，汝與吾族孰いづれか多。』<em>【○鰐わに，鰐鮫わにさめ，原文和邇わに以音。數よみ原文讀よみ，計數。】</em>如此言者かくいひしかば，鰐為吾欺あざむかえ，舉族列伏なみふす。時吾蹈其上，讀數渡來わたりき。然將接岸下地時，失言語之：『汝等，為我所欺あれにあざむかえぬ！』言畢いひ竟，即すなはち伏最端もともはし鰐鮫和邇，倏然捕とらへ吾，悉剝はぎき毛皮衣服。因此これにより泣患なきうれへ。<em>【○接岸つちにおりむ原文下地つちにおりむ，降至地面。言畢いひをはるに原文言竟いひをはるに，毛皮こもろ原文衣服こもろ。】</em>時先行まづゆき八十神等，誨告をしへてのらし：『宜浴 海潮うしほ，當あたり風而伏。』故かれ隨其教者，我身あがみ悉傷ことごとくやぶれぬ。」<br>　於是大穴牟遲神おほなむぢのかみ，教告をしえてのらし其菟うさぎ：「今急すむやけく往此水門みなと，以水滌洗身。復取其水門之蒲黃かまのはな，敷散しきちらし而輾轉こいまろば其上者，汝身なむちがみ必かならず癒，差いえむ如本膚もとのはだ。」<em>【○差いえむ，痊癒。】</em>故菟隨まにまに其教，而其身そのみ如本もとのごとし也。此者，稻羽之素菟いなばのしろうさぎ，於今所謂菟神うさぎがみ是也。故其菟白まをし大穴牟遲神：「此八十神やそがみ，必かならず不得えじ八上姬やかみ比賣。汝雖負おへども袋ふくろ，終將獲之えむ。」　於是，八上姬やかみ比賣答八十神而言：「吾あれ者，不聞きかじ汝等之言いましたちのこと，將嫁あはむ大穴牟遲神。」故爾かれしかく，八十神忿いかり，欲殺ころさむ大穴牟遲神。乃共議ともにはかり而，至伯岐國ははきのくに之手間山てまのやま麓本，謂大穴牟遲云：「赤豬あかきゐ在此山，我等和禮共ともに追下おひくだり而，汝命待取まちとれ！若不待取まちとらず者，必將殺ころさむ汝！」<em>【○伯岐ははき即伯耆ははき。麓ふもと原文本もと。我等われ，原文われ和禮以音。】</em>八十神云而，以火ひをもち燒やき似にたる豬大石おほきいし而轉落まろばしおとしき。爾八十神追下おひくだり，大穴牟遲將取之時とるとき，即すなはち於其石そのいし所燒著やきつけらえ而死しにき。　爾其御祖命みおやのみこと刺國若姬さしくにわか比賣，哭患なきうれへ而參上まゐのぼり于天あめ，請まをし神產巢日之命かむむすひのみこと時。<em>【御祖命みおやのみこと，此云母神。】</em>神產巢日命乃すなはち遣つかはし𧏛貝姬さきかひ比賣與蛤貝姬うむかひ比賣，令作活つくりいけしめき。爾𧏛貝姬さきかひ比賣刮削岐佐宜集あつめ而，蛤貝姬うむかひ比賣待承まちうけ且塗ぬり母乳汁ははのち者，大穴牟遲忽然復生，成なり麗壯夫うるはしきをとこ而出遊行いであそびあるきき。【刮削きさげ，原文きさげ岐佐宜以音。訓壯夫をとこ云をとこ袁等古。】<br>　於是，八十神 見みて，且また欺あざむき率入ゐていり山，切伏きりふせ大樹おほきき，復以茹はめ矢や打立うちたて其木そのき，令大穴牟遲入いらしめ其中そのうち，即打離うちはなち其楔冰目矢而拷殺也うちころしき。<em>【○楔ひめや，原文冰目矢ひめや。罅ひ即空隙，目め乃裂痕，矢や則弓矢矣。】</em>爾亦みた其御祖命刺國若姬，哭乍求なきつつもとめ者，得見みることをえて，即拆さき其木而取出とりいだし活いけ。<br>　刺國若姬さしくにわか比賣遂告其子大穴牟遲言：「汝なむち命，若留あり此間ここ者，必終つひに為ならむ八十神やそがみ所滅ほろぼすところ！」乃避人目，違遣たかへやりき於紀國木のくに之大屋彥神おほや毘古のかみ御所みもと。爾，八十神覓もとめ而追臻おひいたり，矢射乞や刺こふ時，大屋彥神おほや毘古のかみ令大穴牟遲自木岐きのたま漏逃くけにがし而云：「可參向まゐむかふべし須佐之男命すさのをのみこと所坐いませる根堅洲國ねのかたすくに。必與其大神須佐之男議也はからむ！」<em>【○矢射乞やさしてこふ原文矢刺乞やさしてこふ，構弓指之，威脅要求大屋彥神交出大穴牟遲之狀。木岐きのたま原文木俣きのたま。】</em>　故かれ大穴牟遲隨まにまに詔命みことのり參到まゐいたり根堅洲國須佐之男命すさのをのみこと御所みもと。其女むすめ須勢理姬すせり毘賣出見いでみ，遂一見傾心為目合而相婚あひあひき。<em>【○一見傾心，原文為目合めくはせし。】</em>須勢理姬すせりびめ還入かへりいり，白まをし其父須佐之男言：「甚麗神いとうるはしきかみ來きたり。」爾しかくし其大神須佐之男出見而告のらし：「此者これは，謂之いふぞ葦原醜男命あしはら色許をのみこと。」即喚入めしいれ而令寢いねしめき其蛇室へみのむろ。於是ここに，其妻そのめ須勢理姬すせり毘賣以蛇領巾へみの比禮授さづけ其夫そのを云：「若其蛇將咋くはむ，以此領巾比禮三舉みたびふり打撥うちはらへ。」故如教をしへのごとく者，蛇自靜おのづからしづまりき。故平寢たひらけくいね出之いでき。亦また來日夜こしひのよ者，入蜈蚣吳公與蜂はち室。亦其妻授蜈蚣むかで、蜂之領巾比禮，教如先さきのごとし。故かれ亦安然平出之。<em>【○領巾ひれ，原文ひれ比禮以音。安然ひらけく，原文平ひらけく也。】</em>　亦また，須佐之男執鳴鏑かぶち射入いい大野之中おほきののなか，令採とらしめき其矢や。故大穴牟遲入いりし其野時，大神須佐之男即すなはち以火ひ迴燒めぐりやきき其野。於是，大穴牟遲不知しらず所出いでむどころ之間ありしあひだ，鼠ねずみ來云：「內うち者空洞富良富良，外者狹隘須夫須夫！【空洞ほらほら、狹隘すぶすぶ，原文ほらほら富良富良、ほらほら須夫須夫以音。<em>○空ほら與洞ほら同源。狹隘すぶすぶ或云洞口狹窄，其內仍有洞天。或云地上路窄，無處可去。</em>】」如此言かくいひき故，蹈ふみ其處そこ者，落おち洞隱入之間こもりいりしあひだ，火者燒過もえすぎにき。爾しかくし其鼠，咋持くひもち其鳴鏑，出來いでき而奉也まつりき。其矢羽やのは者，皆みな為鼠子等ねずみのこら盡喫也くへり。<br>　於是，其妻そのめ須勢理姬すせり毘賣者，持喪具ものそなへ而哭來なきくる。其父大神須佐之男者思大穴牟遲已死訖すでにしにをはりぬ，出立いでたて其野そのの。<br>　爾，大穴牟遲持もち其矢以奉之時まつりしとき，率入ゐていり家いへ，而喚入めしいれ八田間大室やたまのおほむろ，令取其頭そのかしら之虱しらみ。故爾かれしかくし，見其頭者，蜈蚣吳公多在あまたあり。於是，其妻須勢理姬取椋木實牟久のこのみ與赤土あかきつち，授さづけき其夫大穴牟遲。<em>【○椋むく，原文むく牟久以音。】</em>故咋破くひやぶり其木實このみ，含ふふみ赤土而唾出はきいだし。其大神須佐之男以為おもひ大穴牟遲咋破蜈蚣むかで唾吐，故於心こころに思おもひ愛うつくし而寢矣いねき。　爾大穴牟遲握其神須佐之男之髮かみ，結著ゆひつけ其室之每椽たりきごと，亦取五百引石いほぼきのいは塞ふさぎ其室戶むろのと。負おひ其妻須勢理姬すせり毘賣，即すなはち取持とりもち其神須佐之男之生大刀いくたち與生弓矢いくゆみや，及其天沼琴あめのぬこと而逃出にげいでし。時其天沼琴，不慎拂ふれ樹，而地つち動鳴とよみなりき。<br>　故其所寢いねたる大神須佐之男，聞驚ききおどろき而引仆ひきたふしき其室，然大神須佐之男解とく結椽たりきにゆへる髮かみ之間，大穴牟遲等既遠逃とほくにげき。<br>　故爾，大神須佐之男追至おひいたり黃泉平坂よもつの比良さか，遙望はるかにのぞみ，呼さけび謂大穴牟遲神おほあなむぢのかみ曰：「其その當以もちて汝なむち所持之もてる生大刀いくたち、生弓矢いくゆみや，放逐汝庶兄弟ままはらから，追伏おひふせ坂之稜さかの御尾，追撥おひはらひ河之瀨かはのせ矣。如此為而己意禮為大國主神おほくにぬしのかみ，亦為顯國玉神宇都志くにたまのかみ。其後，當以我之女あがむすめ須勢理姬すせり毘賣為嫡妻適妻，構宮宇迦山うかのやま之山麓山本，太豎布刀斯理宮柱みやばしら於底津石根そこついはね，高築多迦斯理冰椽ひぎ於高天之原たかあまのはら而居をれ！是奴也このやつこや！」<em>【○稜みを原文御尾みを，山、坡之稜線。坂稜、河瀨，指地之端，水之盡。己おれ原文おれ意禮以音，懷有親愛之情的第二人稱代名詞。嫡妻むかひめ，原文適妻むかひめ。山麓ふもと原文山本やまもと。太豎ふとしり原文ふとしり布刀斯理以音，知しり本意治理而此引申為豎立。底津石根そこついはね乃地底之磐石。高築たかしり原文たかしり多迦斯理以音。冰椽ひぎ與千木ちぎ同，神社屋頂之裝飾。】</em><br>　故大穴牟遲持其大刀、弓矢，追避おひさりし其兄八十神やそがみ。追伏おひふせ每坂さかごと之稜御尾，追撥おひはらひ每河かはごと之瀨せ。如是放逐，而始はじめて作國也くにつくりき。　故其八上姬やかみ比賣者，大國主八千矛如先期さきのちぎり迎娶美刀阿多波志都。【迎娶みとあたはしつ，原文みとあたはしつ美刀阿多波志都以音。<em>○寢所與みとあたはしつ也。</em>】故其八上姬やかみ比賣者，雖率來ゐてきつれども出雲，然畏かしこみ其嫡妻むかひめ須勢理姬すせり毘賣，遂將其所生子うめるこ者刺挾さしはさみ木岐木俣而返かへりき。<br>　　故名なづけ其子云，木俣神きまたのかみ。亦名またのな，謂御井神みゐのかみ也。　此八千矛神やちほこのかみ，將婚あはむ高志國こしのくに沼河姬ぬなかは比賣而幸行之時いでまししとき。到其沼河姬ぬなかは比賣之家いへ，歌曰うたひていはく：　八千矛やちほこの　神命かみのみことは　八島國やしまくに　妻娶難つままきかねて　遠遠とほどほし　越國こしのくにに　賢女さかしめを　有ありと聞きかして　麗女くはしめを　有ありと聞きこして　さ求婚よばひに　蟻立ありたたし　求婚よばひに　蟻通ありかよはせ　太刀たちが緒をも　未解いまだとかずて　襲衣おすひをも　未解いまだとかねば　孃子をとめの　寢なすや板戶いたとを　押振おそぶらひ　我わが立たたせれば　引連ひこづらひ　我わが立たたせれば　青山あをやまに　鵼ぬえは鳴なきぬ　小野鳥さのつとり　雉きぎしは響とよむ　庭鳥にはつとり　雞かけは鳴なく　心痛うれたくも　鳴なくなる鳥とりか　此鳥このとりも　打止遣うちやめこせね　い慕したふや　天馳使あまはせづかひ　事ことの　語言かたりごとも　此こをば　爾，其沼河姬ぬなかは比賣，未開戶いまだとをひらかず，自內うちより歌曰：　八千矛やちほこの　神命かみのみこと　萎草ぬえくさの　女めにしあれば　我わが心こころ　浦渚鳥うらすのとりぞ　今いまこそは　我鳥わどりにあらめ　後のちは　汝鳥などりにあらむを　命いのちは　勿殺賜なしせたまひそ　い慕したふや　天馳使あまはせづかひ　事ことの　語言かたりごとも　此こをば<br>　青山あをやまに　日ひが隱かくらば　烏玉ぬばたまの　夜よは出いでなむ　朝日あさひの　笑榮來ゑみさかえきて　栲綱たくづのの　白腕しろきただむき　沫雪あわゆきの　稚わかやる胸むねを　そ叩だたき　叩愛ただきまながり　真玉手またまで　玉手差枕たまでさしまき　股長ももながに　寢いは寢なさむを　恠あやに　な戀聞こひきこし　八千矛やちほこの　神命かみのみこと　事ことの　語言かたりごとも　此こをば　故，其夜者未合あはず，而明日夜あくるひのよ為御合也みあひしき。<em>【○御合みあひ，結婚也。八千矛神、大穴牟遲神，並大國主異名也。】</em>　又，其神大國主之嫡后適后須勢理姬命すせり毘賣のみこと，性甚はなはだ嫉妒うはなりねたみ。故其彥遲神大國主侘而和備弖，自出雲いづも將往上坐倭國やまとのくに。束裝發向立之時，一手片御手繫かけ御馬みうま之鞍桉，一足片御足蹈入ふみいれ其御鐙みあぶみ而歌曰：<em>【○彥遲神ひこぢのかみ，原文日子遲神ひこぢのかみ。彥ひこ、遲ぢ皆男性敬稱。侘而わびて原文わびて和備弖以音。往ゆき原文上坐のぼりまさむ，意為上京，乃以大和やまと為中心之用詞。發向たちむかひ原文立たちし。一手かたつみて、一足かたつみあし原文片御手かたつみて、片御足かたつみあし。】</em>　烏玉ぬばたまの　黑御衣くろきみけしを　真具まつぶさに　取裝とりよそひ　沖鳥おきつとり　胸見むなみる時とき　羽搏はたたぎも　是これは適ふさはず　邊波へつなみ　そに脫棄ぬきうて　鴗鳥そにどりの　青御衣あをきみけしを　真具まつぶさに　取裝とりよそひ　沖鳥おきつとり　胸見むなみる時とき　羽搏はたたぎも　是こも適ふさはず　邊波へつなみ　そに脫棄ぬきうて　山方やまがたに蒔まきし　茜舂あたねつき　染木そめきが汁しるに　染衣しめころもを　真具まつぶさに　取裝とりよそひ　沖鳥おきつとり　胸見むなみる時とき　羽搏はたたぎも　是こし宜よろし　愛子哉いとこやの　妹命いものみこと　群鳥むらとりの　我わが群去むれいなば　引鳥ひけとりの　我わが引去ひけいなば　泣なかじとは　汝なは言いふとも　大和やまとの　一本薄ひともとすすき　項傾うなかぶし　汝なが泣なかさまく　朝天あさあめの　霧きりに立たたむぞ　若草わかくさの　妻命つまのみこと　事ことの　語言かたりごとも　此こをば　爾其后須勢理姬取大御酒坏おほみさかづき，依偎立依奉觴指舉而歌：<em>【○依偎たちより原文立依たちより。奉觴さかづきあげ原文指舉さしあげ。】</em>　八千矛やちほこの　神命かみのみことや　我あが大國主おほくにぬし　汝なこそは　男をに坐いませば　打迴うちみる　島崎崎しまのさきざき　搔迴かきみる　礒崎落いそのさきおちず　若草わかくさの　妻持つまもたせらめ　我あはもよ　女めにしあれば　汝なを除きて　男をは無なし　汝なを除きて　夫つまは無なし　綾垣あやかきの　ふはやが下したに　蠶衾むしぶすま　和にこやが下したに　栲衾たくぶすま　騷さやぐが下したに　沫雪あわゆきの　稚わかやる胸むねを　栲綱たくづのの　白腕しろきただむき　そ叩だたき　叩愛ただきまながり　真玉手またまで　真玉手差枕たまでさしまき　股長ももながに　寢いをし寢なせ　豐御酒とよみき　奉たてまつらせ　二神如此歌かくうたひ，即すなはち為結盞宇伎由比而交頸宇那賀氣理弖，鎮坐しづまります至今いまにいたるまで也。此謂之神語かむがたり也。<em>【○結盞うきゆひ原文うきゆひ宇伎由比以音，可書盞結うきゆひ，則交杯酒也。交頸うながけりて原文うながけりて宇那賀氣理弖以音，可書項掛うながけりて，鴛鴦交頸之狀也。以上神語かむがたり，計五首。】</em>　故，此大國主神おほくにぬしのかみ，娶もとり坐胸形宗像奧津宮おくつみや神田霧姬命多紀理毘賣のみこと。<br>　　生子うみしこ，阿遲鉏高彥根神あぢすきたか日子ねのかみ。【あぢ阿遲二字以音。】<br>　　次妹いも，高姬命たか比賣のみこと。亦名下光姬命したでる比賣のみこと。此阿遲鉏高彥根神あぢすきたか日子ねのかみ者，今謂賀茂大御神迦毛のおほみかみ也。<em>【○賀茂かも訓かも迦毛。】</em><br>　大國主命亦娶神屋楯姬命かむやたて比賣のみこと。<br>　　生子，事代主神ことしろぬしのかみ。<br>　大國主亦娶八嶋牟遲能神やしまむぢのかみ之女鳥取神ととりのかみ。<br>　　生子，鳥鳴海神とりなるみのかみ。【訓鳴なる云なる那留。】　　此鳥鳴海神とりなるみのかみ，娶日名照額田毘道男伊許知邇神ひなてりぬかたびちをいこちにのかみ。<em>【○名義不詳。或云男字以前乃父神之名。】</em><br>　　　生子，國忍富神くにおしとみのかみ。<br>　　　此國忍富神，娶葦那陀迦神あしなだかのかみ，亦名八河江姬やがはえ比賣。<br>　　　　生子，速甕之多氣佐波夜遲奴美神はやみかのたけさはやぢぬみのかみ。<br>　　　　此速甕之多氣佐波夜遲奴美神，娶天之甕主神あめのみかぬしのかみ之女前玉姬さきたま比賣。<br>　　　　　生子，甕主彥神みかぬし日子のかみ。<br>　　　　　此甕主日子神，娶靇神淤加美のかみ之女靈平志姬比那良し毘賣。<em>【○靈平志姬ひならしひめ原文比那良志毘賣ひならしひめ以音。藉靈力使海面平和之女神。】</em><br>　　　　　　生子，多比理岐志麻流美神たひりきしまるみのかみ。【此神名以音。】<br>　　　　　　此多比理岐志麻流美神，娶柊之其花待靈神比比羅木のそのはな麻豆美のかみ之女活玉前玉姬神いくたまさきたま比賣のかみ。<em>【○柊之其花ひひらぎのそのはな待靈神まづみのかみ，義未詳。或云づみ豆美者祇つみ也，或云まづ麻豆者待まつ也。】</em><br>　　　　　　　生子，美呂浪神みろなみのかみ。【みろ美呂二字以音。】<br>　　　　　　　此美呂浪神，娶敷山主神しきやまぬしのかみ之女青沼馬沼押姬あをぬうまぬおし比賣。<br>　　　　　　　　生子，布忍富鳥鳴海神ぬのおしとみとりなるみのかみ。<br>　　　　　　　　此布忍富鳥鳴海神，娶若盡女神わかつくしめのかみ。<br>　　　　　　　　　生子，天日腹大風處靈神あめのひはらおほ科度美のかみ。【しなど科度以音。】<br>　　　　　　　　　此天日腹大風處靈神あめのひはらおほしなどのかみ，娶天狹霧神あめのさぎりのかみ之女遠津待根神とほつまちねのかみ。<em>【○或云待まち乃真靈まち之意。。】</em><br>　　　　　　　　　　生子，遠津山岬足神とほつやまさき多良斯のかみ<em>【○足たらし原文たらし多良斯以音。】</em>。　右件みぎのくだり，自八島士奴美神やしまじぬみのかみ以下よりしも，遠津山岬足神とほつやまさき帶のかみ以前よりさき，稱十七世神とをよあまりななよのかみ。　故，大國主神おほくにぬしのかみ坐出雲いづも美保埼御大之御前時，有歸來神よりくるかみ，內剝うつはぎ鵝皮かりのかは剝はぎ為衣服ころも，自波穗なみのほ乘天之羅摩船あめのかがみのふね，汎海而至。爾大國主雖問とへども其名，不答こたへず。且また雖問所從したがへる之諸神もろもろのかみ，皆白まをしき：「不知しらず。」爾，蟾蜍多邇具久白言：「此者これは，久延彥くえ毘古必かならず知之しりたらむ。」<em>【○美保埼みほのみさき原文御大之御前みほのみさき。鵝かり蓋家畜化之雁かり。或云蛾ひむし之訛，然與皮かは字矛盾，不採。羅摩かがみ，鏡芋ががいも古名，形似舟船。蟾蜍たにぐく原文たにぐく多邇具久以音，谷潛たにぐく也。】</em>即召久延彥くえ毘古以問。答白：「此者，神產巢日神かむむすひのかみ之御子みこ，少彥名神すく名毘古那のかみ也。」<br>　故爾かれしかくし，大國主白上まをしあげ於神產巢日御祖命みおやのみこと者，答告こたへてのらし：「此者，實まことに我子也あがこぞ。於子之中このなか，自吾指間手俣漏出久岐斯子也。故與汝なむち葦原醜男命あしはらの色許をのみこと為兄弟はらから也。汝等當戮力一心，作堅つくりかためむ其國そのくに。」<br>　故自爾かれそれより，大穴牟遲おほあなむぢ與少彥名すく名毘古那二柱神ふたはしらのかみ，相並あひとも作堅つくりかためき此國。然しかし後のち者，其少彥名神すく名毘古那のかみ者，渡わたりき于常世國とこよのくに也。故，顯白あらはしまをし其少彥名神すく名毘古那のかみ所謂いはゆる久延彥くえ毘古者，於今いまに山田やまだ之芻人曾富騰者也。此神者，足あし雖不行いかねども，盡ことごとく知しれる天下之事あめのしたのこと也。<em>【○芻人そほど原文そほど曾富騰，則濡人そほど也。案山子かかし、稻草人之古語也。】</em>　於是，大國主神愁うれへ而告：「吾獨あれひとり何能いかにかよく得作つくれる此國？孰神いづれのかみか與吾能よく相作あひつくらむ此國耶？」是時このとき，有光海うみをてらし依來よりくる之神。其神曰：「能治よくをさめ我前あがまへ者，吾あれ能共與ともに相作成。若不然もししからず者，國難成なることかたけむ。」爾しかくし大國主曰：「然者しからば，治奉之狀をさめまつるかたち，奈何いかに？」答言：「吾者，齋奉伊都岐まつれ于倭やまと之青垣あをかき東山上ひむかしのやまのうへ！」此者，坐います御諸山みもろのやま上大物主神おほものぬしのかみ也。<em>【○治をさめ者鎮しづめ矣，祭祀安撫也。前まへ乃指稱神祇之避忌表現。齋いつき原文いつき伊都岐，祭祀。御諸山みもろのやま，三輪山みわのやま也。】</em>　故，其大年神おほとしのかみ，娶めとり神活須毘神かむいくすびのかみ之女伊怒姬いの比賣。<br>　　生子，大國御魂神おほくにみたまのかみ。<br>　　次，韓神からのかみ。<br>　　次，王都神曾富理のかみ。<em>【○王都そほり原文そほり曾富理以音。古朝鮮語以黃金そ村落ほり為王都そほり。】</em><br>　　次，白日神しらひのかみ。<br>　　次，聖神ひじりのかみ。【五神。<em>○聖ひじり者語源日知ひじり。能識農事曆法之神哉。</em>】<br>　大年神又娶香用姬かぐよ比賣。【此神名以音。<em>○香かぐ乃光輝，用よ當齋ゆ之轉矣。</em>】<br>　　生子，大香山戶臣神おほかぐやまとおみのかみ。<br>　　次子，御年神みとしのかみ。【二柱。】<br>　大年神又娶天近瑞姬あま知迦流美豆比賣。【訓天如天，ちかるみづひめ知迦流美豆比賣以音。】<br>　　生子，奧津彥神おくつ日子のかみ。<br>　　次，奧津姬命おくつ比賣のみこと。亦名，大戶姬神おほへ比賣のかみ。此者，諸人もろひと以拜をろがむ竈神かまのかみ者也。<br>　　次，大山咋神おほやまくひのかみ，亦名山末之大主神やますゑのおほぬしのかみ。此神者，坐近淡海國ちかつあふみのくに之日枝山ひえのやま，亦坐葛野かづの之松尾まづを，用もちゐる鳴鏑かぶら神者也。<em>【○近淡海ちかつあふみ，近江あふみ也。】</em><br>　　次，庭津日神にはつひのかみ。<br>　　次，阿須波神あすはのかみ。【此神名以音。】<br>　　次，波比岐神はひきのかみ。【此神名以音。】<br>　　次，香山戶臣神かぐやまとおみのかみ。<br>　　次，羽山戶神はやまとのかみ。<br>　　次，庭高津日神にはたかつひのかみ。<br>　　次，大土神おほつちのかみ，亦名土之御祖神つちのみおやのかみ。【九神ここのはしらのかみ。】　上件かみのくだり大年神おほとしのかみ之子，自大國御魂神おほくにみたまのかみ以下，大土神おほつちのかみ以前，併あはせ十六神とはしらあまりむはしらのかみ。<br>　　其中，羽山戶神はやまとのかみ，娶大饌津姬神おほ氣都比賣のかみ。<br>　　　生子，若山咋神わかやまくひのかみ。<br>　　　次，若年神わかとしのかみ。<br>　　　次妹いも，若實女神わか沙那賣のかみ。【實女さなめ原文さなめ沙那賣以音。】<br>　　　次，瑞蒔神彌豆麻岐のかみ。【瑞蒔みづまき原文みづまき彌豆麻岐以音。】<br>　　　次，夏高津日神なつたかつひのかみ。亦名，夏之女神なつの賣のかみ。<br>　　　次，秋姬神あき毘賣のかみ。<br>　　　次，久久年神くくとしのかみ。<em>【○久久くく乃莖くき之交替形，立莖。】</em><br>　　　次，久久紀若室葛根神くくきわかむろつなねのかみ。<em>【○久久紀くくき乃立莖之樹。】</em><br>　　　上件かみのくだり，羽山はやま之子以下よりしも，若室葛根わかむろつなね以前よりさき，併あはせ八神やはしらのかみ。<strong>二、出雲讓國</strong>　天照大御神あまてらすおほみかみ詔命みこと：「以豐葦原之千秋長五百秋之瑞穗國とよあしはらのちあきのながいほあきの水づほのくに者，<em>【○瑞穗みづほ，原文水穗みづほ，下效此。】</em>當為我御子あがみこ正勝吾勝勝速日まさかつあかつかちはやひ天忍穗耳命あめのおしほみみのみこと之所治國しらさむくに。」<em>【○治しる，原文知しる。】</em>天忍穗耳命，因よし其言こと賜而天降矣あまくだしき。於是ここに，天忍穗耳命立多多志於天浮橋あめのうきはし而詔之：「豐葦原之千秋長五百秋之瑞穗國者，甚伊多久喧騷佐夜藝弖也那理。」告斯而更還上さらにかへりのぼり天，請まをしき于天照大御神。<em>【○立たたし原文たたし多多志，甚喧騷いたくさやぎて原文いたくさやぎて伊多久佐夜藝弖，也なり原文なり那理，以音。】</em><br>　爾以もち高御產巢日神たかみむすひのかみ、天照大御神あまてらすおほみかみ之命，聚集八百萬神やほよろづのかみがみ，神集かむつどへ天安河之河原あめのやすのかはのかはら，令思金神おもひかねのかみ思而詔：「此葦原中國あしはらのなかつくに者，當為我御子所治しらさむ。依言ことよし所賜之國たまへるくに也。故，以為おもふに於此國千磐破道速振荒振あらぶる國神くにつかみ等多在あまたある。是當使つかはし何神いづれのかみ，而將言趣ことむけ？」<em>【○千磐破ちはやぶる，原文道速振ちはやぶる或云千早振ちはやぶる稜威之意。荒振あらぶる，荒暴。言趣ことむけ，令其宣示服屬之意。】</em>爾思金神及と八百萬神，議白之はかりまをし：「天菩比神あめのほひのかみ，是これ可遣つかはすべし。」<br>　然所遣天菩比神者，乃すなはち媚附こびつき大國主神おほくにぬしのかみ。至於いたるまで三年みとせ，不復奏かへりことまをさず。　是以ここをもちて，高御產巢日神、天照大御神，亦問諸神等もろもろのかみたち：「所遣つかはせる葦原中國あしはらのなかつくに之天菩比神あめのほひのかみ，久ひさしく不復奏かへりことまをさず。亦使何神いづれのかみ者為吉よけむ？」爾しかくし思金神おもひかねのかみ答白こたへてまをし：「可遣つかはすべき天津國玉神あまつくにたまのかみ之子，天若彥あめわか日子。」故爾，以天之真鹿兒弓あめの麻迦古ゆみ、天之羽羽矢あめの波波や，賜たまひ天若彥あめわか日子而遣つかはしき。<em>【○真鹿兒まかこ、羽羽はは，原文まかこ麻迦古、はは波波以音。】</em><br>　於是ここに，天若彥あめわか日子降到くだりいたり其國，即すなはち娶めとり大國主神おほくにぬしのかみ之女下照姬したでる比賣，亦慮おもひはかり獲えむ其國。至於八年やとせ，不復奏かへりことまをさず。　故爾かれしかくし，天照大御神あまてらすおほみかみ、高御產巢日神たかみむすひのかみ亦問とひ諸神もろもろのかみたち等：「天若彥あめわか日子，久不復奏。又遣曷神いづれのかみ以問天若彥あめわか日子之滯淹留とどまれる所由ゆゑ？<em>【○滯とどこほる，原文作淹ひさしく。】</em>」於是，諸神及思金神答白こたへてまをさく：「可遣雉きぎし，名鳴女なきめ。」時天照大神詔のりたまひ此雉曰：「汝行なむちいき，問天若彥あめわかひこ狀かたち者：『汝所以ゆゑ使つかはせる葦原中國あしはらのなかつくに者，言趣和ことむけやはせ其國之荒振神等あらぶるかみども之者也。何なにとかも至于八年，不復奏かへりことまをさぬ？』」<br>　故爾かれしかくし，鳴女なきめ自天あめより降到くだりいたり，居天若彥あめわか日子門かど前齋楓上湯津かつらのうへ，悉言委曲ことのつばひら，如ごとし天神あまつかみ之詔命みことのり。爾，天探女あめの佐具賣聞此鳥言こと而語かたり天若彥あめわか日子云：「此鳥者，其鳴音なくおと甚惡いとあし。故可射殺いころすべし！」<em>【○齋ゆ原文書湯ゆ。探女さぐめ，原文さぐめ佐具賣以音。】</em>如是進言云進，即天若彥あめわか日子持天神所賜たまへる天之梔弓あめの波士ゆみ與天之輝矢あめの加久や，射殺其雉きぎし。<em>【○進言原文云進いひすすむる。天之梔弓あめのはじゆみ、天之輝矢あめのかくや，蓋與天羽羽矢あめのはじや、天真鹿兒弓あめのまかこゆみ同而語型稍異。】</em>爾其矢，自雉胸むね貫通とほり而逆射さかしまにい直上あがり，逮いたりき於天安河原あまのやすかはら天照大御神あまてらすおほみかみ、高木神たかぎのかみ之御所みもと。是この高木神者，高御產巢日神たかみむすひのかみ之別名ことな。<br>　故かれ高木神，取其矢見者，血著つけり其矢羽やのは。於是ここに，高木神告之のらさく：「此矢者，所賜天若彥あめわか日子之矢。」即示しめし諸神等もろもろのかみたち詔者：「或もし天若彥あめわか日子不誤あやまたず所命みこと，為射いむとする惡神あしきかみ之矢之至者いたれらば，不中あたらず天若彥あめわか日子。或有邪心あしきこころ者，天若彥あめわか日子必禍麻賀禮於此矢！【禍まがれ，原文まがれ麻賀禮以音，斃也。】」云而取其矢，自其矢穴やのあな衝返下つきかへりくだし者，中天若彥あめわか日子寢いねたる朝床あさとこ之高胸前たかむなさか坂以死しにき。【此これ，「還矢かへりや可畏」之本もと也。<em>○前さか，原文借字書坂さか。</em>】亦其雉きぎし不還かへらず，故於今諺ことわざ曰「雉之頓使ひたつかひ」本是也これぞ。　故天若彥あめわか日子之妻め下照姬したでる比賣之哭聲なくこゑ，與と風響ひびき徹天際。於是，在天天若彥あめわか日子之父天津國玉神あまつくにたまのかみ及其妻子めこ，聞而降來くだりき，哭悲なきかなしび不已。乃於其處そこ設喪屋もや而殯之。即命河鴈かはかり為持傾頭者岐佐理もち，鷺さぎ為持掃者掃持，<em>【○持傾頭者きさりもち，原文きさり持岐佐理もち，蓋送葬時持死者食物者，未詳。掃持ははきもち，持掃帚者。】</em>翠鳥そにどり為御食人みけびと，雀すずめ為碓女うすめ，雉きぎし為哭女なきめ。如此かく行定おこなひさだめ而，日八日ひやうか、夜八夜よやよ，弔遊也あそびき。　此時このとき，味鉏高彥根神阿遲志貴たか日子ねのかみ來到弔とぶらひ天若彥あめわか日子之喪も，而自天降到くだりいたれる。天若彥あめわか日子之父ちち，亦其妻下照姬皆哭云なきていはく：「我子未死！我君未死！<em>【○原文我子あがこ者不死しなず有けりあり祁理！我君あがきみ者不死しなず有けりあり祁理！】</em>」取懸とりかかり手足てあし而哭悲也なきかなしびき。其誤過所以ゆゑ者，此二柱神ふたはしらのかみ之容姿かたち，甚能いとよく相似あひにたり。故是以ここをもち誤あやまち也。<br>　於是，味鉏高彥根神阿遲志貴たか日子ねのかみ大怒おほきにいかり曰：「我あれ以愛友うるはしきとも，故ゆゑ弔來耳とぶらひきつらくのみ。何なにとかも以穢きたなき死人しにびと比なそふる吾あれ？」遂拔ぬき所佩みはかしせる十掬劍とつかのつるぎ，切伏きりふせ其喪屋もや，以足あし蹶離遣くゑはなちやりき。此者，在美濃國みののくに藍見河あゐみのかは之川上かはかみ喪山もやま也。其味鉏高彥根あぢしたきたかひこね所持切もちてきれる大刀たち名謂いひ大量おほはかり，亦名神銳劍かむ度のつるぎ。<em>【○神銳劍かむどのつるぎ，原文神度劍かむどのつるぎ。】</em>　故味鉏高彥根神阿遲志貴たか日子ねのかみ忿いかり而飛去之時とびさりしとき，其胞妹伊呂も高姬命たか比賣のみこと思おもひき顯あらはさむ其兄御名みな，故歌曰うたひていはく：　天あめなるや　弟棚機おとたなばたの　項うながせる　玉御統たまのみすまる　御統みすまるに　足玉あなだまはや　御谷みたに　二渡ふたわたらす　味鉏高彥根あぢしきたかひこねの　神かみぞ　此歌このうた者，夷振ひなぶり也。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ammehohi01.gif" alt="稻付香取神社　夜神樂　菩比上使○東京都北區赤羽西"> 夜神樂　菩比上使<br>思金神、八百萬神議遣天菩比神為使。而其神媚附大國主，不復命。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/senge_kokusou01.gif" alt="出雲大社　千家國造館○島根縣出雲市大社町杵築東宮內"> 出雲大社　千家國造館<br>天菩比神或云天穗日命，其子孫代代祀大國主命為出雲國造。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/abiko01.gif" alt="安孫子神社○滋賀縣愛知郡秦莊町安孫子"><br>安孫子神社<br>祭神天稚彥，即天若彥矣。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/shitori01.gif" alt="伯耆國一宮　倭文神社　經塚○鳥取縣東伯郡湯梨濱町大字宮內"><br>伯耆國一宮　倭文神社　經塚<br>倭文神社經塚，傳為下照姬命墓。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/hirama01.gif" alt="平間神社○和歌山縣西牟婁郡白濱町十九淵"><br>平間神社<br>祭神天探女，或云天邪鬼。民間承傳，以好惡戲為性。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/amewakahiko01.gif" alt="地神五代記○勝川春亭"><br><a href="https://ehon.dh-jac.net/books/search?title=%5B%E5%9C%B0%E7%A5%9E%E4%BA%94%E4%BB%A3%E8%A8%98%5D">地神五代記</a>　天若彥射殺雉鳴女<br>天若彥聞天探女進言，持天之梔弓、天之輝矢，射殺其雉。<img src="https://miko.org/~uraki/kuon/furu/text/syoki/02/moyama01.gif" alt="喪山天神社○岐阜県美濃市大矢田"><br>喪山天神社　喪山跡<br>味鉏高彥根神怒人誤己為死人，拔劍切伏天若彥喪屋，蹴至美濃國藍見河上，是為喪山。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/takakamo01.gif" alt="高鴨神社○奈良縣御所市鴨神"><br>高鴨神社<br>鴨神社總本社，祭味鉏高彥根神。<a href="https://miko.org/~uraki/kuon/furu/text/waka/kikirouei/krk01.htm#k0006">夷振</a>：「其猶久方天　年稚棚機織機女　頸間所繫項　麗美連珠玉御統　其御統之間　妍矣穴玉足玉者　猶其連珠兮　輝煌似能渡二谷　阿治鋤高日子根　神命高名矣」　於是，天照大御神あまてらすおほみかみ詔之：「亦遣つかはし曷神いづれのかみ者吉よけむ？」爾思金神おもひかねのかみ及諸神白之まをし：「鎮坐います天安河あまのやすかは河上かはかみ天石屋あめのいはや，名嚴之尾羽張神伊都のをはばりのかみ，是可遣つかはすべし。若亦もしまた非此神者，其神之子武御雷之男神建みかづちのをのかみ，此これ應遣。且其天尾羽張神あめのをはばりのかみ者，逆さかしま塞上せきあげ天安河之水みづ而塞道みちをふさぎ居をる故ゆゑ，他神あたしかみ不得行ゆくことえず。故，別ことに遣天迦久神あめのかくのかみ可問とふべし。」故爾かれしかくし，使つかはし天迦久神問天尾羽張神。其神答こたへ白：「恐之かしこし，仕奉つかへまつらむ。然しかれども於此道このみち者，僕子やつかれがこ武御雷神建みかづちのかみ可遣。」乃貢進たてまつりき。爾天鳥船神あめのとりふねのかみ副そへ武御雷神建みかづちのかみ而遣。　是以，此二神降到くだりいたり出雲國いづものくに五十狹狹之小濱伊耶佐のをはま而拔十掬劍とつかのつるぎ，逆刺さかしまにさし於浪穗なみのほ，趺坐あぐみゐ其劍鋒つるぎの前，<em>【○五十狹狹いざさ，原文いざさ伊耶佐以音。書紀作稻佐濱いなさのはま。】</em>問其大國主神おほくにぬしのかみ言：「以天照大御神、高木神たかぎのかみ之命みこと，問使之つかはせり：『汝なむち之統領宇志波祁流葦原中國あしはらのなかつくに者，當為我御子あがみこ之所治國知らさむくに。<em>【○統領うしはける原文うしはける宇志波祁流，主著うしはける也。治し原文知し。】</em>』依其言賜ことよしたまひき。故かれ，汝心なむちがこころ奈何いかに？」爾大國主答白之：「僕やつかれ者不得白まをすことえず。我子あがこ八重言代主神やへことしろぬしのかみ，是これ可白まをすべし。然為ため鳥遊とりのあそび、取魚すなどり，而往美保埼御大之前而未還來いまだかへりこず。<em>【○鳥遊とりのあそび，獵鳥。遊あそび之字義甚廣，凡超脫日常之行為皆可稱之。取魚すなどり，漁獵。美保埼みほのさき原文御大之前みほのさき。】</em>」<br>　故爾，遣天鳥船神あめのとりふねのかみ，徵來めしき八重事代主神やへことしろぬしのかみ而問賜とひたまひ。時事代主神語かたり其父大神大國主言：「恐之かしこし。此國葦原中國者，立奉たてまつらむ天神あまつかみ之御子みこ。」即蹈傾ふみかたぶけ其船，以天逆手あめのさかて打成うちなし青柴垣あをふしかき而隱也かくりき。【訓柴ふし云ふし布斯。<em>○天逆手，別於一般以手掌拍手かしはで，而以手背為之之呪術用法。</em>】　故爾かれしかくし，武御雷神たけみかづちのかみ復問其大國主神：「今，汝子事代主神，如此白訖かくまをしをはりぬ。亦有可答白之子乎？」於是亦また白之：「亦我子尚有武御名方神建みなかたのかみ。除おき此者無也なし。」如此白之間まをすあひだ，其武御名方神建みなかたのかみ手末たなすゑ擎ささげ千引石ちびきのいは而來，言：「誰來我國而忍忍しのぶしのぶ如此物言ものいふ？然しからば，欲おもふ為せむ力競ちからくらべ。故我あれ且先まづ欲取とらむ其御手みて！」故令取とらしむ其武御雷御手者，即すなはち化とりなし立冰たつひ，<em>【○冰柱つらら也。】</em>又化劍刃つるぎのは。故爾，武御名方神たけみなかたのかみ懼をぢ而退居しりぞきをりき。<br>　爾武御雷神たけみかづちのかみ欲取其武御名方神建みなかたのかみ之手。乞歸こひよせ而取者，如取稚葦若あし，搤批とりひだき而投離なげはなち。武御名方神たけみなかたのかみ倏即逃去にげさりき。故武御雷神たけみかづちのかみ追往おひゆき而到科野國信濃のくに之洲羽海諏訪のうみ，將殺之ころさむ。<em>【○稚葦わかあし幼嫩之葦。搤批とりひだき，捉拿押潰。科野國しなののくに洲羽海すわのうみ，信濃國しなののくに諏訪湖すわのみづうみ。則武御名方神者，坐諏訪大社。】</em>時武御名方神建みなかたのかみ白：「恐かしこし。莫なかれ殺我あれをころすこと！除おき此地ここ者，吾不行ゆかじ他處あたしところ。亦不違たがはじ我父あがちち大國主神おほくにぬしのかみ之命みこと，不違八重事代主神やへことしろぬしのかみ之言こと。此葦原中國あしはらのなかつくに者，隨まにまに天神御子之命獻たてまつらむ！」　故武御雷神たけみかづちのかみ更さらに且還來またかへりき，問とひ其大國主神おほくにぬしのかみ：「汝子等なむちがこら事代主神ことしろぬしのかみ、武御名方神建みなかたのかみ二神ふたはしらのかみ者，皆白訖まをしをはりぬ：『隨まにまに天神あまつかみ御子みこ之命，勿違たがはじ。』故，汝心奈何いかに？」爾大國主答白之：「隨僕やつかれ子等こども二神之答まをす，僕亦不違。此葦原中國あしはらのなかつく者，隨命みことのまにまに既すでに獻也たてまつらむ。唯ただに僕住所すみか天日隅宮者，當如天神御子之天津日繼あまつひづき所營知之十足登陀流天之御巢あめのみす以奉造。太豎布斗斯理宮柱みやばしら於底津石根そこついはね，高築多迦斯理冰木ひぎ於高天之原たかあまのはら而治賜者をさめたまはば，僕者當於百不足ももたらず八十坰手やそくまで，將奉避隱侍矣かくりはべらむ。<em>【○十足とだる原文とだる登陀流以音，十分滿足之狀。八十坰手やそくまで，書紀作八十隈やそくま，僻地矣。隱侍かくりはべらむ，書紀作隱去かくりさりぬ，奉避矣。】</em>亦僕子等こら百八十神ももやそのかみ者，即八重事代主神やへことしろぬしのかみ，為神之御尾前みをさき而仕奉者つかへまつらば，誰敢不順，無復違神たがふかみ也。」如此之白かくまをし而，於出雲國いづものくに多藝志之小濱たぎしのをはま，造天之御舍あめのみあらか。<em>【○御尾前みをさき，立於天津諸神前鋒或尾端侍奉者。天之御舍あめのみあらか即出雲大社いづものおほやしろ。】</em>　水戶神みなとのかみ之孫うまご櫛八玉神くしやたまのかみ為膳夫かしはて，獻たてまつり天御饗あめのみあへ。時櫛八玉神禱白ほきまをし而化なり鵜う入いり海底わたのそこ，咋出くひいだｓ底埴そこ之波邇作天八十平瓮あめのやそ毘良迦，復鎌かり海布之柄めのから作燧臼ひきりうす，以海蓴之柄こものから作燧杵ひきりきね，攅出きりいだし火ひ云：　是この我所燧あがきれる火ひ，爨於高天之原たかまのはら者，所燒舉たきあげ之狀，神產巢日御祖命かむむすひのみおやのみこと，十足登陀流天之新巢あめのにひす之，令其凝烟すす垂たる八拳やつか。復爨地下つちのした根國者，所燒凝たきこらし之狀，底津石根そこついはね為燔固。打莚うちはへ栲繩たくなは兮，以為千尋綱繩ちへろなは長，漁釣つりする海人あま之，大口くちおほ大鰭尾翼鱸をはたすずき，騷騷而佐和佐和邇控依騰ひきよせあげ而，打竹うちたけ之曲撓復曲撓登遠遠登遠遠邇，所獻たてまつる天真魚咋あめのまなぐひ也！<em>【○凝烟すす，烟煤。此云燧火旺盛，令高天原之新居亦垂烟煤。騷騷而さわさわに，原文さわさわに佐和佐和邇以音。曲撓復曲撓とををとををに，原文とををとををに登遠遠登遠遠邇以音，竹棒打竹撓曲之狀。】</em>　故かれ，武御雷神建みかづちのかみ，返かへり高天原，參上まゐのぼり復奏かへりことまをしき降服言向和平やはしたひらげつる葦原中國あしはらのなかつくに之狀かたち。 <em>【○降服ことむけ原文言向ことむけ，前文作言趣ことむけ。】</em><img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ama_yasukahara03.gif" alt="天安河原　仰慕窟○宮崎県西臼杵郡高千穗町大字岩戶"><br>天安河河上<br>天尾羽張神，坐天安河河上天石屋，逆塞河水與道，諸神不得行。天迦久神者，迦久蓋水手之意。<img src="https://miko.org/~uraki/kuon/furu/text/fuudo/izumo/01/inasa_hama03.gif" alt="稻佐濱○出雲市大社町杵築北稻佐　辨天島"><br>五十狹狹之小濱　稻佐濱<br>武御雷神、天鳥船神，降到出雲國五十狹狹小濱，質問讓國之事。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/miho_saki01.gif" alt="美保關　美保神社○島根縣松江市美保關町美保關"><br>御大之御前　美保關<br>八重事代主神，則美保神社祭神。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/inasahama03.gif" alt="稻佐濱　因佐神社○出雲市大社町杵築北稻佐"><br>因佐神社　出雲讓國圖<br>武御雷神拔劍逆刺浪穗，趺劍鋒。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/suwa_hon01.gif" alt="諏訪大社　上社本宮○長野縣諏訪市中洲宮山"><br>諏訪大社上社本宮<br>武御名方神敗走信濃，自此不出。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/byoufu01.gif" alt="稻佐濱　屏風岩○出雲市大社町杵築北稻佐"><br>稻佐濱　屏風岩　讓國交涉之地<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/idumo_ohoyasiro01.gif" alt="古代出雲歷史博物館　古代出雲大社本殿復原模型○島根縣出雲市大社町杵築東"><br>古代出雲大社本殿復原模型<br>大國主命讓國於天神御子，但須築天之御舍祀之，出雲大社是也。造宮之制，柱則高大，板則廣厚，遂有雲太、和二、京三之諺。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kashima02.gif" alt="鹿島神宮○茨城縣鹿嶋市宮中"><br>常陸國一宮　鹿島神宮<br>武御雷之男神，遂平定葦原中國。<strong>天孫降臨</strong></p><p><img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/takachiho02.gif" alt="高千穗　國見丘○宮崎県西臼杵郡高千穗町大字押方"><br>高千穗　國見丘　雲海<br>天孫撥排天八重雲，擇稜威之正道，降高千穗以治葦原中國。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/masumita01.gif" alt="真清田神社○愛知縣一宮市真清田"><br>尾張國一宮　真清田神社<br>祭神天火明命，天忍穗耳命長子。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/sarutahiko_ameuzume02.gif" alt="椿大神社　猿田彥神立居天之八衢○三重縣鈴鹿市山本町"><br>猿田彥神立居天八衢圖<br>天孫降臨之際，猿田彥神居天之八衢，諸神不能進。以天鈿女能目勝神，遣之顯申其名。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/amaterasu02.gif" alt="神宮徵古館藏　今野可啟『齋庭稻穗』○三重縣伊勢市神田久志本町"><br>天照大神授三神器與齋庭之穗<br>大神賜八尺瓊勾玉、八咫鏡、草薙劍，詔以其鏡為天照大神御魂。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kourin01.gif" alt="神宮徵古館藏　狩野探道『天孫降臨』○三重縣伊勢市神田久志本町"><br>狩野探道繪　天孫降臨<br>五伴緒隨天孫降臨，各掌其職，而為古代諸氏族之祖。<img src="https://miko.org/~uraki/kuon/furu/text/syoki/02/sikufuru01.gif" alt="槵觸神社○宮崎縣西臼杵郡高千穗町大字三田井"><br>槵觸神社　參道<br>天孫降臨筑紫日向高千穗槵觸峰。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/kourin02.gif" alt="霧島神宮古宮址　天孫降臨神籬齋場○鹿兒島縣霧島市霧島田口"><br>霧島神宮古宮址<br>霧島神宮天孫降臨神籬齋場。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/sarutahiko_ameuzume01.gif" alt="葛飾北齋『猿田彥與天鈿女命』"><br>猿田彥與天鈿女命<br>天鈿女命之裔，為猿女君。<strong>一、天降穗峰與木花咲耶姬</strong>　葦原中國既平，爾しかくし以天照大御神あまてらすおほみかみ、高木神たかぎのかみ之命みこと，詔のりたまひし太子おほみこ正勝吾勝勝速日天忍穗耳命まさかつあかつかちはやひあめのおしほみみのみこと：「今いま平訖たひらげをはりぬ葦原中國あしはらのなかつくに之奏白。故隨まにまに言依賜ことよしたまひし，當降坐くだりまし而治之知らせ。」其太子正勝吾勝勝速日天忍穗耳命答白こたへてまをし：「僕やつかれ者將降くだらむ裝束之間よそへるあひだ，吾子生出うまれいでぬ。名な天饒國饒天津日高日子番能邇邇藝命あめ邇岐志くに邇岐志あまつひたかひこほのににぎのみこと。此子應降也くだすべし。<em>【○饒にぎし原文邇岐志にぎし以音。】</em>」<br>　此御子みこ者，天忍穗耳命婚與御合高木神之女萬幡豐秋津師姬命よろづはたとよあきつし比賣のみこと。<br>　　生子うみしこ，天火明命あめのほあかりのみこと。<br>　　次つぎ，日子番能邇邇藝命ひこほのににぎのみこと。二柱也ふたはしらぞ。<br>　是以ここをもち，天照大神隨白之まをししまにまに，科詔おほせのりたまひ日子番能邇邇藝命：「此豐葦原瑞穗國とよあしはらの水ほのくに者，汝なむち將治知らさむ國。隨言依賜ことよしたまひ。故汝隨命みことのまにまに可以天降あまくだるべし。」　爾日子番能邇邇藝命ひこほのににぎのみこと將天降あまくだらむ之時，於是ここに有神，立居ゐ天之八衢あめのちまた而，上かみ光てらし高天原たかあまのはら，下照光葦原中國あしはらのなかつくに。<br>　故爾かれしかくし，以天照大御神あまてらすおほみかみ、高木神たかぎのかみ之命，詔天鈿女神あめの宇受賣のかみ：「汝なむち者雖手弱女人たわやめ，與相向伊牟迦布神而可面勝神おもかつかみ也。<em>【○相向いむかふ原文伊牟迦布いむかふ以音，い向むかふ，對峙。】</em>故專もはら汝往將問ゆきてとはまく者：『此吾御子わがみこ為する天降之道みち，誰たれぞ如此かく而居をる？』」<br>　故天鈿女問賜之時とひたまひしとき，答白：「僕やつかれ者國神くにつかみ，名猿田彥神さるた毘古のかみ也。所以ゆゑ出居いでをる者，聞天神御子あまつかみみこ天降坐あまくだります，故欲仕奉つかへまつらむ御前みさき而為參向まゐむかへ之侍はべり。」<br>　爾天兒屋命あめのこやのみこと、太玉命布刀たまのみこと、天鈿女命あめの宇受賣のみこと、石凝姥命伊斯許理度賣のみこと、玉祖命たまのおやのみこと，并あはせ五伴緒いつりのとものを矣。各隨支加邇邇藝命而天降也あまくだりき。<em>【○各隨わかちくはへ原文支加わかちくはへ。】</em>　於是，天照大御神副賜そへたまひ其所召遠岐斯八尺勾璁やさかのまがたま、八咫之鏡やたのかがみ，及草薙劍くさ那藝のつるぎ於邇邇藝命，並遣思金神おもひかねのかみ、手力男神たぢからをのかみ、天石戶別神あめのいは門わけのかみ而詔のりたまひ者：「吾兒，此之鏡このかかみ者，專もはら為として我御魂あがみたま。視此寶鏡，如ごとく拜をろがむ吾前あがまへ，當齋奉矣伊都岐まつれ！」次：「思金神者，取持とりもち前事さきのこと，輔之為政まつりごとせよ！」此二柱神者，拜祭をろがみまつりき伊勢榮釧佐久久斯梠五十鈴宮伊須受能みや。<em>【○邇邇藝命、思金神，伊勢神宮內宮。○榮釧さくくしろ原文さくくしろ佐久久斯梠以音，五十之枕詞。】</em><br>　次，豐受姬神登由宇氣のかみ。此者，坐外宮とつみや之度會わた相神者也。<em>【○度會わたらひ，伊勢神宮外宮。】</em><br>　次，天石戶別神あめのいはとわけのかみ。亦名またのな謂櫛石窗神くしいはまとのかみ，亦名謂豐石窗神とよいはまとのかみ。此神者，御門之神みかどのかみ也。<br>　次，手力男神たぢからをのかみ者，坐佐那那縣さななあがた也。<em>【○佐那那縣，伊勢國多氣たけ一帶之古名。】</em><br>　故かれ其天兒屋命あめのこやのみこと者，中臣連なかとみのむらじ等之祖おや。太玉命布刀たまのみこと者，忌部首いみべのおびと等之祖。天鈿女命あめの宇受賣のみこと者，猿女君さるめのきみ等之祖。石凝姥命伊斯許理度賣のみこと者，作鏡連かがみつくりのむらじ等之祖。玉祖命たまのおやのみこと者，玉祖連たまのおやのむらじ等之祖。　故爾，詔天津日子番能邇邇藝命あまつひこほのににぎのみこと，離はなれ天之石位あめのいはくら，押分おしわけ天之八重棚雲あめのやへの多那ぐも，稜威之道別道別而伊都能知和岐知和岐弖，<em>【○押分おしわけ或云排分おしわけ，撥開。稜威いつ乃莊嚴之意。道別道別ちわきちわき意指慎重地選別行進之道路。】</em>於天浮橋あめのうきはし，經浮島漂壤宇岐士摩理，聳立發向而蘇理多多斯弖，<em>【○原文うきじまり宇岐士摩理、そりたたし蘇理多多斯弖以音，難解。本居宣長援引日本書紀，以為浮島うきじまり則州壤標浮之狀。聳立そりたたし蓋高聳身姿出發之狀。】</em>天降あまくだり於筑紫つくし日向ひむか之高千穗たかちほ之槵觸嶽久士布流多氣。<em>【○槵觸嶽くしふるたけ，原文くしふるたけ久士布流多氣以音。】</em><br>　故爾，天忍日命あめのおしひのみこと、天津久米命あまつくめのみこと二人ふたり，取負とりおひ天之石靫あめのいはゆき，取佩とりはき頭椎之大刀かぶつちのたち，取持とりもち天之梔弓あめの波士ゆみ，手挾たばさみ天之真鹿兒矢あめのまかこや，立たち邇邇藝命御前みさき而仕奉つかへまつりき。<br>　故，其天忍日命者，大伴連おほとものむらじ等之祖。天津久米命者，久米直くめのあたひ等之祖也。　於是ここに，邇邇藝命詔之のりたまはく：「此地ここ者，對向むかひ韓國からくに，真來通まきとほり笠沙岬かささ之御前，朝日あさひ之直射國ただ刺しくに、夕日ゆふひ之日照國ひでるくに也。故かれ，此地甚吉地いとよきところ也，」遂太豎布斗斯理宮柱みやばしら於底津石根そこついはね，高築多迦斯理冰椽ひぎ於高天之原たかあまのはら而坐也いましき。　故爾かれしかくし邇邇藝命詔天鈿女命あめの宇受賣のみこと：「此立御前みさき所仕奉猿田彥大神さるた毘古のおほかみ者，其名專もはら汝可所顯申あらはしまをせる。故遣汝なむち命奉送おくりまつれ。亦其神御名みな者，汝負おひ仕奉つかへまつれ。」是以猿女君さるめのきみ等，負其猿田彥さるた毘古之男神をのかみ名，而女をみな呼よぶ猿女君之事，是也これなり。<br>　故其猿田彥神さるた毘古のかみ坐阿邪訶あざか。【此三字以音，地名。】為漁すなとり之時，其手以比良夫貝ひらぶのかひ咋合くひあはさえ，而沉溺いづみおぼほれき海潮う鹽而斃去。<em>【○海潮うしほ，原文海鹽うしほ。】</em>故其沉居しづみゐる海底そこ之時名，謂底著御魂そこ度久みたま。【著どく原文どく度久以音。】其海水うしほ之冒泡都夫多都時名，謂粒立御魂都夫多都のみたま。【冒泡つぶたつ原文つぶたる都夫多都以音，粒立つぶたつ。】其泡裂阿合佐久時名，泡裂御魂阿合佐久のみたま。<br>　於是，天鈿女命あめのうずめのみこと送猿田彥神さるた毘古のかみ而還到かへりいたり，乃悉ことごとく追聚おひあつめ鰭廣物はたのひろもの、鰭狹物はたのさおの以問言：「汝者，仕奉つかへまつらむ天神あまつかみ御子みこ耶？」時諸魚もろもろのうを皆白：「仕奉。」其中なか唯海鼠こ不白まをさず。爾天鈿女命あめの宇受賣のみこと謂海鼠云：「此口乎このくちや，不答之口こたへぬくち！」而以紐小刀ひもかたな拆さきき其口。故於今海鼠口，拆也さけたるぞ。是以代代天皇御世みよ，志摩島獻速贄はやにへ之時，必給たまふ猿女君等さるめのきみら也。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ahisome01.gif" alt="平澤定治『逢初川』○宮崎縣宮崎市神宮　宮崎神宮"><br>邇邇藝命、木花咲耶姬相會初逢川<img src="https://miko.org/~uraki/kuon/furu/chara/senken/01/konohanasakuya01.jpg" alt="伊藤勝文藏　『木花之佐久夜毘賣像』"><br>木花咲耶姬像<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/tonakiyasiro01.gif" alt="木花開耶姬火中出產○木花開耶姬火中出產　日向神話館蠟人形○宮崎縣宮崎市青島　青島神社"><br>木花咲耶燔無戶八尋殿出產　於是，天津日高日子番能邇邇藝命あまつひたかひこほのににぎ能みこと，於笠沙岬かささの御前，遇あひき麗美人うるはしきをとめ。爾問：「誰女だがむすめ耶？」答白：「大山津見神おほやまつみのかみ之女むすめ，名神吾田津姬かむ阿多都比賣，亦名木花咲耶姬このはな之佐久夜毘賣。」天孫邇邇藝命又問：「汝有兄弟はらから乎？」答白：「有姉あね石長姬いはなが比賣也。」爾天孫詔のりたまひ：「吾欲婚目合汝。<em>【○婚あひあはむ，原文目合あひあはむ，或訓まぐはひ目合。】</em>奈何いかに？」答曰：「妾僕不得えず答白。妾僕父大山津見神，將白まをさむ。」故かれ天孫遣やり使乞こひ其父大山津見神。時父神大歡喜おほきによろこび，而副そへ其姉石長姬いはなが比賣，令持もたしめ百取机代之物ももとりのつくえしろのもの，<em>【○百取机代之物ももとりのつくえしろのもの，眾多嫁妝。】</em>奉出まつりいだしき。<br>　故爾かれしかくし，因より其姉石長姬者，貌甚凶醜いとみにくき故，天孫見畏みかしこみ而返送かへしおくり，唯ただ留とどめ其妹弟木花咲耶姬このはな之佐久夜毘賣，以一宿ひとよ為婚あひをしき。<em>【○妹おと原文弟おと，年幼之意。】</em><br>　爾，大山津見神おほやまつみのかみ因天孫返かへしし石長姬いはなが比賣而大恥おほきにはぢ，遣使送おくり言：「我以二女むすめふたり並ともに立奉之由たてまつりしゆゑ：『使つかはば石長姬いはなが比賣者，天神あまつかみ御子之命いのち，雖雪零ゆきふり風吹かぜふく，恒つねに如石いしのごとく而常堅ときはにかちはに不動うごかず。亦使木花咲耶姬このはな之佐久夜比賣者，如木花このはな之榮さかゆる榮さかえ。』誓約而宇氣比弖貢進たてまつりき。如此かく令返かへらしめ石長姬いはなが比賣而獨ひとり留木花咲耶姬このはな之佐久夜毘賣故ゆゑ，天神御子みこ之御壽みいのち， 將猶木花之須臾爾阿摩比能微。<em>【○須臾爾阿摩比能微，あまひ阿摩比義未詳，蓋短暫之間。爾のみ乃而已之意。】</em>」故かれ是以ここをもちて，時至于今いまにいたるまで，天皇命すめらみこと等之御命みいのち，皆不長ながくあらぬ也。　時頃，木花咲耶姬このはな之佐久夜毘賣參出まゐいで白天孫云：「妾あれ妊身はらみぬ，今臨のぞみ產時うむとき。是この天神之御子，不可べくあらぬ私わたくし產うむ，故ゆゑに請まをす。」爾天孫不信之，詔曰：「咲耶姬佐久夜毘賣，一宿哉ひとよにや妊はらみぬる？是非あらず我子あがこ，必かならず國神くにつかみ之子！」爾答白：「吾妊之子はらめるこ，若もし國神之子者，產時うむとき不幸さきくあらじ！若天神之御子者ならば，幸さきくあらむ產！」即すなはち作無戶八尋殿となきやしろどの，入其殿內とののうち，以土つち塗塞ぬりふさぎ。復方まさに產時，以火著つけ其殿而產也うみき。<br>　　故，其火盛燒さかりにもゆる時所生之子，名火照命ほでりのみこと。【此者こは，隼人はやと阿多君あたのきみ之祖おや。】<br>　　次生子，名火須勢理命ほすせりのみこと。<em>【○すせり須勢理三字以音，乘勢前進之狀。按書紀或云火進命ほのすすみのみこと。】</em><br>　　次生子，御名みな火遠理命ほをりのみこと，亦名天津日高日子穗穗手見命あまつひたかひこほほでみのみこと。【三柱みはしら。】<strong>日向三代</strong></p><p><strong>一、山海易幸</strong>　故かれ火照命ほでりのみこと者，為海幸彥うみ佐知毘古而取とり鰭廣物はたのひろもの、鰭狹物はたのさもの。【○此云，漁獲大小諸魚為業。幸彥さちびこ，原文さちびこ佐知毘古以音，下效此。幸さち則獲物之義，亦引伸為狩獵之具。】火遠理命ほをりのみこと者，為山幸彥やま佐知毘古而取毛麤物けのあらもの、毛柔物けのにこもの。【○此云，狩獵大小走獸為業。】爾しかくし火遠理命謂いはく其兄火照命：「欲おもふ各相易あひかへ幸佐知為用もちゐむ。」雖乞こへども三度みたび，不許ゆるさず。然しかれども遂つひに纔かづかに得えたり而相易あひかふる。<br>　爾火遠理命山幸彥，以海幸うみ佐知釣魚うををつる，都かつて不得一魚ひとつのうを，亦失うしなひき其鉤ち於海うみ。於是ここに，其兄そのえ火照命乞こひ其勾曰：「或狩山珍やまさち者，當以己幸おのがさち以獵之さち。或漁海味うみさち者，宜以己幸おのがさち以獲之さち。【○原文山幸やまさちも己之おのがさち幸幸さちさち，海幸うみさちも己之おのが幸幸さちさち。幸さち字依序為獵物、獵具、獲得。蓋意指無論山獵、海漁，不以己具則難獲之俗諺。】今各おのおの謂おもふ返かへさむ其幸佐知。」時其弟おと火遠理命答こたへ曰：「汝鉤なむちがち者，釣魚不得えず一魚，遂つひに失海。」然其兄海幸彥強あながち乞徵こひはたりき。故其弟山幸彥，搗破やぶり御佩之みはかしせる十拳劍とつかのつるぎ，作つくり五百鉤いほのち。雖償つくのへ，不取とらず。亦作一千鉤ちのち，雖償つくのへども不受うけず。海幸彥云：「猶なほ欲おもふ得えむ其正本鉤まさしきもとのち。」　於是ここに，其弟山幸彥居をり海邊うみへ泣患之時，鹽椎神しほつちのかみ來問曰：「虛空津日高そらつひたか之泣患なきうれへ所由ゆゑ者何なにぞ？」<em>【○日高ひたか意指如仰望高空中明日般高貴。】</em>答言：「我あれ與兄え易鉤ち而失うしなひき其鉤。是ここに兄乞こふ其鉤故ゆゑ，雖償つくのへども多鉤あまたのち，不受うけず。云いひつらく：『猶なほ欲得其本鉤もとのち！』故かれ泣患之。」<br>　爾，鹽椎神云：「我為汝命ながみこと作なさむ善議よきはかりこと。」即すなはち以竹編無間籠まなし勝間之小船をぶね，載のせ其船以教をしへ曰：「吾押流をしなが其船者，汝差暫往ややしまらくゆけ，將有可怜御路味みち。<em>【○籠かつま，原文勝間かつま。可怜うまし原文味うまし，美好之意。】</em>乃すなはち乘其道往者ゆかば，必有如ごとく鱗いろこ所造之宮室つくれるみや，則綿津見神わたつみのかみ之宮みっや也。到其神御門みかど者，傍かたはら之井上ゐのへ有齋香木湯津かつら。故坐其木上きのうへ，其海神うみのかみ之女むすめ，見汝而可與相議あひはからむ也。」<br>　故かれ，山幸彥隨教をしへのまにまに少行すこしゆく，備つぶさに如ごとし其言そのこと。即登のぼり其香木かつら以坐いまし。【訓香木云かつら加都良，下效此。<em>○齋香木ゆつかつら原文湯津香木ゆつかつら，齋桂ゆつかつら。</em>】　爾海神うみのかみ之女豐玉姬とよたま毘賣之從婢つかひめ，持玉器たまもひ而將酌くまむ水時，於井ゐ有光ひかり。仰見者あふぎみれば，有麗壯夫うるはしきをとこ。【訓壯夫云をとこ袁登古，下效此。】以為おもひき甚異奇いとあやし。火遠理命ほをりのみこと見其婢つかひめ，乞こひ：「欲おもふ得水みづ。」婢乃すなはち酌水みづをくみ，入いれ玉器たまもひ貢進たてまつりき。<br>　爾山幸彥火遠理命不飲のまず其水，解とき御頸みくび之璵たま含ふふみ口，唾入はきいれき其玉器たまもひ。於是其璵著つき器もひ，婢不得離はなつことをえず璵。故任ながら璵著つけ以進たてまつりき豐玉姬命とよたま毘賣のみこと。<br>　爾豐玉姬とよたまびめ見其璵たま，問婢つかひめ曰：「若もし有人居門外かどのと哉？」答曰：「有人，坐我井上わがゐのへ香木かつら之上。甚麗いとうるはしき壯夫をとこ也。益まし我王わがきみ而甚貴いとたふとし。其人乞水みづをこひつる，故奉まつれ水者，不飲水而唾入はきいれつ此璵たま。是不得離，故かれ任璵入，將來もちき而獻たてまつりき。」<br>　豐玉姬命とよたま毘賣のみこと，思奇あやしき出見いでみ，乃すなはち見感みめで。一目傾心目合而白まをし其父海神曰：「吾門わがかど有麗人うるはしきひと。」爾海神うみのかみ自みづから出見，云：「此人このひと者，天津日高あまつひたか之御子みこ，虛空津日高そらつひたか矣！」即率入ゐていり於內うち，先以海驢皮美知のかは之疊たたみ敷八重やへ，亦以絁疊きぬたたみ八重敷しき其上そのうへ，令坐いませ其上而具そなへ百取机代物ももとりのつくえしろのもの，為し御饗みあへ。即令婚あはしめき其女豐玉姬とよたま毘賣。<br>　故かれ，山幸彥至いたる於三年みとせ，住すみき其海神之國くに。　於是ここに，火遠理命ほ袁りのみこと思其初事はじめのこと而大一歎おほきにひとたびなげきき。故，豐玉姬命とよたま毘賣のみこと聞其歎以白其父海神言：「雖住すめども三年みとせ，恒つねに無所歎なげきことなき。今夜こよひ為大一歎ひとつのなげき，若もし有何由なにのゆゑ？」故其父大神おほかみ，問とひ其婿聟夫曰：「今旦けさ，聞きく我女あがむすめ之語かたる云：『雖坐いませども三年，恒無所歎。今夜為しつ大歎。』若有由哉や？亦また到いたれる此間ここ之由ゆゑ，奈何いかに？」爾山幸彥語其大神，備つぶさに如ごとし其兄そのえ罰はたり失鉤うせたるち之狀かたち。<em>【○婿むこ，原文聟夫むこ。】</em><br>　是ここ以，海神悉ことごとく召集めしあつめ海之大小魚おほきちひさきうを，問曰：「若有取とれる此鉤このち魚乎？」故諸もろもろ魚白之：「頃このころ者，赤海鯽魚たひ愁言うれへいへり：『鯁のぎたち於喉のみと故，物もの不得食くふ。』故，必かならず是これ魚所取とりつらむ。」於是探さぐる赤海鯽魚たひ之喉のみと者，有鉤。即取出とりだし而清洗きよめあらひ，奉まつり火遠理命。<br>　時其綿津見大神わたつみのおほかみ誨之をしへ曰：「以もち此鉤給其兄そのえ時，當言狀いはむかたち如此：『此鉤者，淤煩鉤おぼち、荒鉤須須ち、貧鉤まづち、愚鉤宇流ち。』如是云而いひて，於後手しりへで賜たまへ。<em>【○淤煩おぼ，恍惚之狀。荒すす，原文すす須須以音。愚うる與愚おろ同根，原文うる宇流以音。後手しりへで，反手，具呪詛之意。】</em>然而しかくして，其兄海幸彥作高田たかた者，汝命ながみこと營つくれ下田。其兄作下田ひきた者，汝命營高田。為然者しかせば，以吾掌つかさどる水みづ故ゆゑ，三年之間みとせのあひだ，其兄海幸彥必貧窮まづし。若汝兄海幸彥悵怨うらみ其為然之事しかすること而攻戰者せめたたかはば，出いだし潮盈珠鹽みちのたま而溺おぼほせよ。若其それ愁請者うれへこはば，出潮乾珠鹽ひのたま而活いけよ。如此かく令惚苦なやみくるしびしめよ。」即授さづけ潮盈珠しほみちのたま、潮乾珠しほひのたま并あはせ兩箇ふたつ。　復悉ことごとく召集鰐鮫和邇魚問曰：「今いま，天津日高あまつひたか之御子みこ，虛空津日高そらつひたか，將出幸いでまさむ上國うはつくに。誰者たれか幾日いくか送奉おくりまつり而覆奏かへりことまをす？」<em>【○鰐鮫わに原文わに和邇者鱷わに也。然日本無鱷，蓋鰐鮫之疇也。】</em><br>　故鮫各おのおの隨まにまに己身おのがみ之尋長ひろたけ，限日ひをかぎり而白まをす。其中なかに一尋鰐鮫ひとひろ和邇白：「僕やつかれ者，一日ひとひ送おくり即還來かへりこむ。」故爾，海神告のらさく其一尋鰐鮫和邇：「然者しからば，汝なむち送奉おくりまつれ。若もし渡わたらむ海中うみなか時，無令なかれ惶畏おそりかしこまらしむる。」即すなはち載其鰐鮫和邇之頸くび送出おくりいだしき。果如期ちぎりしがごとく，一日之內うち送奉也。其鰐鮫和邇將返かへらむ之時，山幸彥解とき所佩はける之紐小刀ひもかたな，著つけ其頸くび而返かへしき。故其一尋鰐鮫和邇者，今謂刀持神佐比もちのかみ也。<em>【○さひ佐比乃刀かたな之意，或云刀持神佐比もちのかみ即雙髻鯊撞木鮫。】</em>　是以ここをもちて山幸彥備つぶさに如海神うみのかみ之教言をしへしこと，歸與あたへき其鉤そのち。故自爾以後それよりのち，兄神稍俞やをやくいよよ貧まづし，更さらに起おこし荒心あらきこころ迫來せめきたり。兄神海幸彥將攻之時せめむとせしとき，弟神山幸彥出潮盈珠鹽みちのたま而令溺おぼほれしめき。其愁請者うれへこへば，出潮乾珠鹽ひのたま而救すくひ。如此かく令惚苦なやびくるしび之時，兄神稽首ぬかつき白：「僕やつかれ者，自今以後いまよりのち，為汝命ながみこと之晝夜ひるよる守護人まもりびと而仕奉つかへまつらむ。」故至今いまにいたるまで，隼人歌儛以其溺時おぼほれしとき種種之態くさぐさのわざ，不絕たえずして仕奉也つかへまつるぞ。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/aosima02.gif" alt="青島神社鳥居　鬼之洗濯板○宮崎縣宮崎市青島"><br>青島神社鳥居　鬼之洗濯板<br>傳山海易幸之地。其隆起海床與奇形波蝕痕被稱作鬼之洗濯板。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/sachikahe01.gif" alt="山幸彥與海幸彥　日向神話館蠟人形○宮崎縣宮崎市青島"><br>山海易幸　山幸彥與海幸彥<br>幸者本幸獲獵物之情，引申作獲物之具也。山幸為弓，海幸為鉤。則山幸彥則獵人，海幸彥即漁夫。<a href="https://miko.org/~uraki/kuon/furu/text/kojiki/01/sachi02.gif"><img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/sachi02.gif" alt="小林永濯『鮮齋永濯畫譜』鹽椎神贈議於山幸彥"></a><br><a href="https://dl.ndl.go.jp/info:ndljp/pid/851055/14">鮮齋畫譜</a>　鹽椎神議於山幸彥<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/yutukatuki01.gif" alt="湯津杜樹之上　日向神話館蠟人形○宮崎縣宮崎市青島"><br>豐玉姬從婢見井中有光<br>山幸彥居海神御門旁井齋香木上。<img src="https://miko.org/~uraki/kuon/furu/text/syoki/02/toyotamahime01.gif" alt="豐玉姬與山幸彥　日向神話館蠟人形○宮崎縣宮崎市青島"><br>豐玉姬、山幸彥一見鍾情<br>豐玉姬思奇出見，遂而見感。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/toyotamahime03.gif" alt="豐玉姬與山幸彥　日向神話館蠟人形○宮崎縣宮崎市青島"><br>山幸彥抱懷土之憂<br>火遠理命思其初事而大一歎。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/watatumi02.gif" alt="海神自赤海鯽魚喉中取鉤　日向神話館蠟人形○宮崎縣宮崎市青島"><br>綿津見神自赤海鯽魚取鉤<br>海神探赤海鯽魚之喉，取出其鉤。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/hitohirowani01.gif" alt="山幸彥揮別海神宮　日向神話館蠟人形○宮崎縣宮崎市青島"><br>山幸彥揮別海神宮<br>海神以一尋鰐鮫送奉山幸彥。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/hitohirowani02.gif" alt="香港海洋公園　鎚頭鯊○香港仔黃竹坑道"><br>刀持神　鎚頭鯊<br>山幸彥繫紐小刀於鮫頸，謂刀持神。亦傳為海神參伊雜宮之使。<img src="https://miko.org/~uraki/kuon/furu/text/syoki/02/hihomitu_furutama01.gif" alt="潮滿瓊、潮涸瓊　日向神話館蠟人形○宮崎縣宮崎市青島"><br>潮盈珠與潮乾珠<br>山幸彥以海神所贈潮盈珠、潮乾珠責其兄海幸彥，令之折服，後裔為俳優之民，吠狗奉事。　於是ここに，海神うみのかみ之女むすめ豐玉姬命とよたま毘賣のみこと，自みづから參出まゐいで白之：「妾あれ已すでに妊身はらみぬ，今臨のぞみ產時うむとき。此念これをおもふに，天神あまつかみ之御子みこ，不可生うむべくあらず海原うなはら。故參出到也いたれり。」<br>　爾，即すなはち於其海邊うみへ渚波限，以鵜羽うのは為葺草かや，造つくりき產殿うぶや。<em>【○渚なぎさ，原文波限なぎさ。】</em>於是，其產殿未葺合いまだふきあへぬ，不忍たへず御腹之急みはらのにはかなる。故入坐いりましき產殿。<br>　爾將方あたり產之時，豐玉姬命白まをし其日子ひこ火遠理命言：「凡おほよそ他國人あたしくにのひと者，臨產之時，以本國もとつくに之形かたち產生うむ。故妾あれ今いま以本身もとのみ為產。願ねがふ勿見みることなかれ妾。」<br>　然於是，火遠理命思奇あやし其言このこと，竊ひそかに伺うかかへ其方產うまむ者，則見其妻化八尋鰐鮫やしろ和邇而匍匐はらばひ委虵もごよひき。火遠理命即見驚畏おどろきかしこみ而遁退にげそきき。爾豐玉姬命とよたま毘賣のみこと知其夫伺見うかかひみる之事，以為おもひ心恥こころはづかし。乃生置うみおき其御子みこ而白：「妾あれ恒つねに通とほり海道うみつち欲往來かよはむ。然夫君伺見うかかひみつる吾形あがかたち，是これ甚怍之いとはづかし。」即塞ふさぎ堵海坂うなさか而返入かへりいりき。<br>　　是以ここをもち，名なづけ其所產之御子うめるみこ，謂天津日高日子あまつひたかひこ波限建鵜葺草葺不合命なぎさたけうかやあへずのみこと。【訓波限なぎさ云なぎさ那藝佐，渚なぎさ之意。訓葺草かや云かや加夜。<em>○鵜羽葺草殿之未葺合時所生故。</em>】　然後しかしくのち者，雖恨うらむれど其窺伺之情うかかひしこころ，不忍たへず戀心こふるこころ。因より治養ひたす其御子之緣よし，附つけ其妹弟玉依姬たまより毘賣而獻たてまつりき歌之。其歌うた曰：　赤玉あかだまは　緒をさへ光ひかれど　玉しらたまの　君きみが裝よそひし　貴たふとくありけり　爾，其夫比古遲火遠理命答歌こたふるうた曰：【夫ひこぢ原文ひこぢ比古遲以音。】　沖鳥おきつとり　鴨著島かもどくしまに　我わが率寢ゐねし　妹いもは忘わすれじ　世悉よのことごとに　故かれ日子穗穗手見命ひこほほでみのみこと者，<em>【○火遠理命。】</em>坐高千穗宮たかちほのみや伍佰捌拾歲いほとせあまりやそとせ。御陵みさざき者，在高千穗山たかちほのやま之西にし也。<em>【○高屋山上陵たかやのやまのへのみさざき。】</em>　是この天津日高日子あまつひたかひこ波限建鵜葺草葺不合命なぎさたけうかやあへずのみこと，娶めとり其姨をば玉依姬命たまより毘賣のみこと而生御子。<br>　　名，五瀨命いつせのみこと。<em>【○五瀨いつ與嚴苑いつそ通。】</em><br>　　次，稻冰命いなひのみこと。<em>【○稻冰いなひ即稻靈いなひ。】</em><br>　　次，御毛沼命みけぬのみこと。<em>【○御毛沼みけぬ與御饌野みけぬ通。】</em><br>　　次，若御毛沼命わかみけぬのみこと。。亦名またのな豐御毛沼命とよみけぬのみこと。，亦名神倭磐余彥命かむやまと伊波禮の毘古のみこと。【四柱。<em>○神倭磐余彥命かむやまといはれびこのみこと，日本書紀作神日本磐余彥尊かむやまといはれびこのみこと，是則神武天皇じんむてんわう。</em>】<br>　　故かれ，御毛沼命者。蹈跳浪穗なみのほ而渡わたり于常世國とこよのくに。稻冰命者，入坐いりましき其妣國ははがくに海原うなはら也。<em>【○蹈ふみ原文作跳ふみ。按日本書紀，稻飯命いなひのみこと隨神武帝東征至熊野，海中遇暴風，歎曰：「吾祖則天神，母則海神。何厄我於陸，復厄我於海？」乃拔劍入海，化為鋤持神。三毛入野命みけいりののみこと亦曰：「我母及姨並是海神。何起波瀾以灌溺乎？」則蹈浪秀なみのほ而往乎常世鄉とこよのくに矣。】</em><img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/aosima01.gif" alt="青島神社　元宮○宮崎縣宮崎市青島"><br>鴨就宮　青島神社　元宮<br>火遠理命歸自海原後，構宮青島。所以名鴨就宮者，依火遠理命與豐玉姬贈答之曲而然。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/toyotamahime02.gif" alt="豐玉姬與鵜葺草葺不合命　日向神話館蠟人形○宮崎縣宮崎市青島"><br>豐玉姬與鵜葺草葺不合命<br>豐玉姬托不合命於其妹玉依姬。<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/uto01.gif" alt="鵜戶神宮○宮崎縣日南市大字宮浦"><br>鵜戶神宮<br>祭日子波限瀲武鸕鶿草葺不合尊<a href="https://miko.org/~uraki/kuon/furu/text/waka/kikirouei/krk01.htm#k0007">豐玉姬命託子歌</a>：「琥珀明赤玉　其玉輝兮緒亦耀　真珠白玉矣　夫君汝命形姿貴　更勝赤玉耀麗美」<a href="https://miko.org/~uraki/kuon/furu/text/waka/kikirouei/krk01.htm#k0008">火遠理命答歌</a>：「譬猶沖津鳥　沖鳥群鴨所寄島　吾與汝率寢　相枕妹妻吾不忘　此生此世悉永銘」<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/ugayafukiaezu01.gif" alt="音川安親編　萬物雛形畫譜　日子波限建鵜葺草葺不合命"> 日子波限建鵜葺草葺不合命<img src="https://miko.org/~uraki/kuon/furu/text/kojiki/01/wakamikenu01.gif" alt="國史畫帖大和櫻　神武天皇御東征之圖"><br>若御毛沼命　神武天皇御東征之圖</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;序、古事記序&lt;/strong&gt;　臣やつこ安萬侶やすまろ言まをす：夫それ，混元ひたたけたるもの既凝こり，氣象けはひかたち未效いまだあらはれず。無名なもなく無為しわざもなく，誰知其形そのかたち。然しかれども乾坤あめつち初分，參神みはしらのかみ作造化之首よろづもの</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法：每日一题</title>
    <link href="http://example.com/2024/10/23/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    <id>http://example.com/2024/10/23/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</id>
    <published>2024-10-23T05:06:40.000Z</published>
    <updated>2024-10-24T05:40:16.355Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2024年10月23日</strong></p><p><img src="https://i.postimg.cc/DzNRDmP7/d939241e073b3bf46017619e08f5e9a1.png" alt="img"></p><p>今天这个题目就是两数之和的应用，使用的方法是哈希表法。</p><p><strong>语法回顾</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.<span class="built_in">count</span>(x);<span class="comment">//获得map中同种元素的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> hour:hours);<span class="comment">//顺序遍历hours中的所有元素，每次遍历都用hour指代对应元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> &amp;pair:map);<span class="comment">//顺序遍历map中的所有元素</span></span><br><span class="line">pair.first;<span class="comment">//key</span></span><br><span class="line">pair.second;<span class="comment">//value</span></span><br></pre></td></tr></table></figure><p>逻辑：</p><p>​取余数的过程相当于剥壳，取完余数之后，某些本来不相关的元素就同质化了。然后hours里面的一批人每个人拥有一把钥匙（可能相同），开完锁之后放一个东西在里面，后面通过特定的方式，给这些人重新分配一把钥匙，统计打开门之后，这些人能回收的物品个数。</p><p>2024年10月24日</p><p><a href="https://leetcode.cn/problems/find-the-first-player-to-win-k-games-in-a-row/">3175. 找到连续赢 K 场比赛的第一位玩家</a></p><p><img src="https://i.postimg.cc/Hkdm4JBK/image-20241024133340965.png" alt="image-20241024133340965"></p><p>今天这个题目是双指针问题，遍历加上辅助指针解决问题，问题的简化就是：遍历指针的元素与辅助指针的元素进行大小的比较，需要辅助指针的元素胜利k次，然后就能顺利返回，不然就只能移动辅助指针，重新计数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;2024年10月23日&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.postimg.cc/DzNRDmP7/d939241e073b3bf46017619e08f5e9a1.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天这个题</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>aegisub代码</title>
    <link href="http://example.com/2024/10/19/aegisub%E4%BB%A3%E7%A0%81/"/>
    <id>http://example.com/2024/10/19/aegisub%E4%BB%A3%E7%A0%81/</id>
    <published>2024-10-18T17:16:42.000Z</published>
    <updated>2024-10-18T17:16:42.391Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>日記</title>
    <link href="http://example.com/2024/10/18/%E6%97%A5%E8%A8%98/"/>
    <id>http://example.com/2024/10/18/%E6%97%A5%E8%A8%98/</id>
    <published>2024-10-18T12:24:37.000Z</published>
    <updated>2024-10-23T06:26:46.059Z</updated>
    
    <content type="html"><![CDATA[<p>​20241018:　</p><p>​<strong>月明かりが煌々と輝いていて、ぼんやりと陽だまりのように、世界をでらしていた。</strong>今日から日記を書くつもりです、その原因で、ここからこちらに私の文字を沢山積み上げたいです。とは言え、ここに集まていることは普通に他の人に言えないです、例えば日常の中に何気ない言葉、そして他の人に見せたくない妄想。それらを書く原因はいっぱいあって、自分の過ごしたことには記録されたいとか、過去の感情の再現することをやすくなるとか、余計なことはここまでだ、これからは日記そのものだ。</p><p>​今日の朝９時に、目が覚めた、今日は昼間の授業がない次第で、寮で一日のやりたいことを解決した。やたことの内容はMusicusのプレイーだけ、夜は難しい授業を受けた。日本語で風景を描くことについて、些細なことを心得る。</p><p>１.先ずは**<u>感覚的な表見</u>**：</p><p>「<strong>秋の風が肌を撫で、遠くから紅葉の葉がカサカサと音を立てて舞い落ちている。</strong>」</p><p>２.そして**<u>四季の変化</u>**：</p><p>「<strong>春の陽気に誘われ、桜の花びらがゆらゆらと川面に落ちていく</strong>」</p><p>３.**<u>比喩</u><strong>や</strong><u>擬音</u><strong>、</strong><u>擬態語</u>**の使用：</p><p>「<strong>川は太陽の光を受けてきらきらと耀き、そよ風が草むらをそっと撫でていく。</strong>」</p><p>４.**<u>文化的な背景</u><strong>や</strong><u>文脈</u>**：</p><p>「<strong>古い神社の境内には、苔むした石段が静かに佇み、時間の流れを感じさせる。</strong>」</p><p>５.**<u>主観的な感情</u>**を込める：</p><p>「<strong>夕焼けに染まった空を見上げると、心の中に懐かしさがこみ上げ来る。</strong>」</p><p>今日から日記を書くつもりです、その原因で、ここからこちらに私の文字を沢山積み上げたいです。とは言え、ここに集まていることは普通に他の人に言えないです、例えば日常の中に何気ない言葉、そして他の人に見せたくない妄想。</p><blockquote><p>今日から日記を書くつもりです、そのために、ここにたくさん書き留めたいです。とはいえ、書く内容、普通に他の人に言えません、そして他の人に見せたくない妄想。</p></blockquote><p>それらを書く原因はいっぱいあって、自分の過ごしたことには記録されたいとか、過去の感情の再現することをやすくなるとか、余計なことはここまでだ、これからは日記そのものだ。</p><blockquote><p>それらを書く原因はいっぱいあって、自分が過ごしたことを記録に残したい、過去の感情を再現しやすくなる、余計なことはここまでにして、これからは日記そのものに集中する。</p></blockquote><p>​今日の朝９時に、目が覚めた、今日は昼間の授業がない次第で、寮で一日のやりたいことを解決した。やたことの内容はMusicusのプレイーだけ、夜は難しい授業を受けた。日本語で風景を描くことについて、些細なことを心得る。</p><blockquote><p>朝９時に目が覚めた、寮で一日やりたいことを済ませた・やり遂げた、やったことはMusicusをプレイするだけだった、日本語で風景を描く際、いくつかの注意点を心得ている。</p></blockquote><p>惹云是风的孩子，风送她到不周山上，然后小熊猫遇到她了，因为是云指引他捡到的，所以起名叫惹云，祾是仙鹤，老松树是祾的导师，祾能力很强，只是有心结，因为全员神子，然后不周山查了一下好像在新疆，所以改成类似于眷思量那种困神的地方了，只不过是一卷画，松和浣熊是画里的npc，惹云可能会有恋父情结（），祾是风的一部分，风是惹云的女儿，祾本来觉得自己比惹云强，有点傲气在身上，后面发现惹云更厉害，就蔫儿了。</p><p>​20241023:</p><p>​今日はちょっと悩みがあります。朝八時に目が覚めた、気がつけば、既に教室の中に座り込んだままになっていた。授業を聞きたくなっかたは、宿題の未完成と相まって、宿題を完成させた。後は英語論文の授業です、先生が述べたことはずいぶん前からしてたんだ、そのために、少々自分のタスクをやりたっか。</p><blockquote><p>今日はちょっと悩みがあります。朝八時に目が覚めると、気がつくと、既に教室の中に座り込んでいました。授業を聞きたくなかったので、宿題が未完成だったため、宿題を完成させました。あとは英語の論文の授業です。先生が述べたことはずいぶん前から知っていたので、自分のタスクを少しやりたかった。</p></blockquote><p>完成されたタスクはこちら：</p><ol><li>文芸批評</li><li>ディープラーリング</li><li>Kフレームタイミングを合わせる</li><li>アルゴリズム問題</li><li>線形代数</li></ol><blockquote><p>完成したタスクはこちらです：</p><ol><li>文芸批評</li><li>ディープラーニング</li><li>Kフレームタイミングを合わせる</li><li>アルゴリズム問題</li><li>線形代数</li></ol></blockquote><p>​以外のこともあります、例えばさきは桃沢紗奈に＠された、私とともに＠されたひともあります、ただ一人の女の子だけれど、深い原因はとてもいいです。</p><blockquote><p>その他にも、例えば、さきは桃沢紗奈に@されたことがあります。私と一緒に@された人もいます。ただ一人の女の子ですが、その深い理由はとても良いです。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​	20241018:　&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;月明かりが煌々と輝いていて、ぼんやりと陽だまりのように、世界をでらしていた。&lt;/strong&gt;今日から日記を書くつもりです、その原因で、ここからこちらに私の文字を沢山積み上げたいです。とは言え、ここに集まていること</summary>
      
    
    
    
    
    <category term="日記" scheme="http://example.com/tags/%E6%97%A5%E8%A8%98/"/>
    
  </entry>
  
  <entry>
    <title>MUSICUS!</title>
    <link href="http://example.com/2024/10/18/MUSICUS/"/>
    <id>http://example.com/2024/10/18/MUSICUS/</id>
    <published>2024-10-18T02:22:46.000Z</published>
    <updated>2024-10-18T17:11:25.741Z</updated>
    
    <content type="html"><![CDATA[<p>MUSICUS！启动</p><h3 id="共通"><a href="#共通" class="headerlink" title="共通"></a>共通</h3><p>タイトル画面から「NEW GAME」を選択</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">進学のために頑張ってきたけど、正直なところほかの道もあるんじゃないかなって迷う気持ちもある</td></tr><tr><td align="center">これも音楽の力なのか……？</td></tr><tr><td align="center">両方をやる</td></tr><tr><td align="center">そうかもしれない</td></tr><tr><td align="center">尾崎さんにバンド活動を含め、夏休みの出来事を話す</td></tr><tr><td align="center">先のことはわかりませんが、世の中にはそういう道もあります</td></tr><tr><td align="center">なんと思われても構いません。僕は自分の道は自分の価値観で選びます</td></tr><tr><td align="center">まだわからないですが、彼が何を見たのか、知ることが出来ればとは思います</td></tr></tbody></table><p>**<a href="https://mono-iki.com/musicus-pc-guide/#1">セーブポイント①</a>**<strong>作成</strong><br><a href="https://mono-iki.com/musicus-pc-guide/#yako">弥子√</a>分岐</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">誰かを犠牲にすることは出来ない。でも、何かにかける生き方もあるんだ</td></tr><tr><td align="center">ライブは表現の場所だと思う。心の中の何かを伝えるため、最高のサウンドを目指すバンドにしたい</td></tr><tr><td align="center">まだわからない</td></tr><tr><td align="center">なんか格好いいからですよ。それじゃダメですか？</td></tr><tr><td align="center">気が向いたらね。どういう風に受け止められてるのかなって寂しくなった時にでも見るよ</td></tr><tr><td align="center">いや、どっちかといえば香坂さんに近いかな</td></tr></tbody></table><p>**<a href="https://mono-iki.com/musicus-pc-guide/#2">セーブポイント②</a>**<strong>作成</strong><br><a href="https://mono-iki.com/musicus-pc-guide/#meguru">めぐる√</a>分岐</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">基本的には三日月と似てるかな。やっぱり、音楽や演奏を通して何かを伝えたいという気持ちがある</td></tr><tr><td align="center">そりゃ、多くの人に認められれば嬉しいけれど</td></tr><tr><td align="center">これでいい。ステージには等身大の自分を上げるんだ</td></tr></tbody></table><p>**<a href="https://mono-iki.com/musicus-pc-guide/#3">セーブポイント③</a>**<strong>作成</strong><br><a href="https://mono-iki.com/musicus-pc-guide/#sumi">澄√</a>・<a href="https://mono-iki.com/musicus-pc-guide/#mika">三日月√</a>分岐</p><h3 id="尾崎弥子"><a href="#尾崎弥子" class="headerlink" title="尾崎弥子"></a>尾崎弥子</h3><p><img src="https://mono-iki.com/wp-content/uploads/2022/09/yako.jpg" alt="尾崎弥子">@OVERDRIVE『MUSICUS!』</p><p><a href="https://mono-iki.com/musicus-pc-guide/#1">セーブポイント①</a>から</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">どんな形であれ、自分の人生をギャンブルにするなんてあってはいけない</td></tr><tr><td align="center">その手を取る。</td></tr></tbody></table><p><strong>ED：尾崎弥子</strong></p><h3 id="香坂めぐる"><a href="#香坂めぐる" class="headerlink" title="香坂めぐる"></a>香坂めぐる</h3><p><img src="https://mono-iki.com/wp-content/uploads/2022/09/meguru.jpg" alt="香坂めぐる">@OVERDRIVE『MUSICUS!』</p><p><a href="https://mono-iki.com/musicus-pc-guide/#2">セーブポイント②</a>から</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">香坂さんよりかもしれないなあ。表現どうこうより、音楽そのものを楽しみたい</td></tr></tbody></table><p><strong>ED：香坂めぐる</strong></p><h3 id="来島澄"><a href="#来島澄" class="headerlink" title="来島澄"></a>来島澄</h3><p><img src="https://mono-iki.com/wp-content/uploads/2022/09/sumi.jpg" alt="来島澄">@OVERDRIVE『MUSICUS!』</p><p><a href="https://mono-iki.com/musicus-pc-guide/#3">セーブポイント③</a>から</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">僕らの新曲として発表する。花井さんが作曲したことは公表しない</td></tr><tr><td align="center">バンドのことは後で考えよう。とにかくやるべきだ</td></tr></tbody></table><p><strong>ED：来島澄（No title）</strong></p><h3 id="花井三日月"><a href="#花井三日月" class="headerlink" title="花井三日月"></a>花井三日月</h3><p><img src="https://mono-iki.com/wp-content/uploads/2022/09/mika.jpg" alt="花井三日月">@OVERDRIVE『MUSICUS!』</p><p><a href="https://mono-iki.com/musicus-pc-guide/#3">セーブポイント③</a>から</p><table><thead><tr><th align="center">選択肢</th></tr></thead><tbody><tr><td align="center">花井さんの遺作であることを告知して、今度の三回忌で発表する</td></tr><tr><td align="center">賛成出来ない。これからバンド活動も忙しくなる。両立は不可能だ</td></tr></tbody></table><p><strong>ED：花井三日月</strong></p><p>人名：</p><p>対馬 馨 つしま けい</p><p>花井 三日月 はない みかづき</p><p>香坂 めぐる こうさか めぐる</p><p>尾崎 弥子 おざき やこ</p><p>花井 是清 はない これきよ</p><p>来島 澄 きしま すみ</p><p>髙橋 風雅  たかはし ふうが</p><p>金田 かねだ</p><p>田崎 京香 たざき きょうか</p><p>対馬 直美 つしま なおみ </p><p>対馬 脩作 つしま しゅうさく</p><p>田村 怜 たむら れい</p><p>篠崎 しのざき </p><p>佐藤 未来  さとう みらい</p><p>村田 龍一 むらた りゅういち</p><p>八木原 やぎはら</p><p>　そうしてスタッフさんとメンバーがやりとりをしながら、それぞれの楽器をかき鳴らしてゆく。どうやら音の調整をしているようだった。　それぞれの音のチェックが終わると、曲を流してチェック。　あ、結構良い曲だ。聴いたことがないけれど、これが『花鳥風月』の曲なのか。　続きが聴きたいなあと思っているところで、花井さんが手をあげて止める。</p><p>「そうなんですかあ。見たことがないイケメンがいるから、誰かなあってさっきから気になってて。……あ、私、『プテラノドン』のＲＡＹです。『花鳥風月』さんにはいつもお世話になってます」「対馬と言います。『花鳥風月』のお知り合いですか？」</p><p>　特に花井さんがやたらと天才と書かれているのが目に付く。当時の写真などもあって、見てみるけれど……それはあんまり今と変わっていないな。僕より年下のはずだけど、どう見ても年上にしか見えない。老けてる。でも今より少し痩せていて、目つきが鋭い。やっぱり、今より意欲に満ちあふれていたんだろうか？　その頃の記事はやたらとある。が、最近の活動を扱った記事は少ないようだ。それでも、熱狂的なファンはいるようだけれど。</p><p>「頑張ろうが、何をしようが、クソなもんはクソなんだよ。残念なことにね……」　と溜息をついた。</p><p>　ステージには煌々と照明があたっているけれど、客席の方は真っ暗だ。鳥居さんはその間をずんずんと進む。僕はそれについてゆく。　</p><p>​特に関係者用の席というものはないらしい。鳥居さんは奥の方の人が少ないスペースを見つけ、壁にもたれかかった。　そこは会場を一望出来る場所だった。　客たちの黒い影の折り重なる向こうに、演奏する人々の輝く姿が頭一つ分くらい浮かんでいる。</p><p>　ここはそういうところを気にする場所ではないと、僕だってそれくらいは理解出来る。でも、飼い猫を外に出すと鼠やら雀やらを捕まえてきて血みどろの死体をテーブルの下に並べるように、勝手におかしなところを捕まえては僕の前に差し出してくる。</p><p>　もしステージの上の人たちが、僕みたいな素人がそんなふうに感じていると知ったら、さぞかし不愉快だろう。　ひどい自己嫌悪だ。</p><p>　ああ、こんな仕事は請けるべきじゃなかったな。　亡くなった祖母の作る料理は全然僕の好みじゃなかった。僕は祖母のことが大好きだったけれど、料理はまずくてまずくて仕方なかった。いつも美味しい美味しいと言って食べていたけれど、でも内心ではまずくて仕方なくて、そんな風に感じる自分がひどい人間に思えて、いやで、ぽろぽろ涙をこぼして泣いてしまったことがある。　急にその時のことを思い出した。</p><p><img src="https://i.postimg.cc/qBDgCj2N/image-20241018105208725.png"></p><p><img src="https://i.postimg.cc/FH7yLYf4/image-20241018105309859.png" alt="もしステージの上の人たちが、僕みたいな素人がそんなふうに感じていると知ったら、さぞかし不愉快だろう。"></p><p>　僕は壁にもたれかかる。壁もみんなの蒸気でしめっている。　激しく揺れる人の向こうに、花井さんが歌っているのが見えた。こんなに興奮のど真ん中にいる彼は、やっぱり汗だくだったけれど、目つきはとても冷静で、表情は冷たくこわばって、死神みたいだ。　その顔を見ていると、僕はまた何も考えられなくなる。</p><p>「その時は、ピーマンを廃止しようと思ってたな。嫌いだったから。ピーマン農家とか、料理にピーマンを入れる人をみんな牢屋に入れようと思ってた」</p><p>​狭窄的Live House会场，硕大的音箱放射出震耳欲聋的声响，</p><p>​『花鳥風月がね、解散するんだそうだ』「えっ」</p><p>「ライブハウスにお金を払って夢を見させてもらってるだけなんだから、客としかいいようがないだろう？　バンドがどうやったら収益を上げられるかを考えず、工夫もせず、ただせっせと独りよがりな曲を書いてライブをやるだけ。いつか自分たちの演奏する素晴らしい曲が、真実を理解する大物プロデューサーか何かに届くと信じながら、交通整理だとかテレアポだとかのバイトで貯めたなけなしの金をライブハウスに貢いで、貢いで、貢ぎ続けて、そのうち心が折れてやめてゆくんだ。裏路地の居酒屋でホッピーか何かを飲みながら、世間は何もわかってないとか言ってな！　そして携帯電話を見ると、親から『田舎に帰ってきなさい。まだ人生のやり直</p><p>『お前は続けろよ。いや、続けて欲しいんだ。お前なら絶対『花鳥風月』を成功させられる。おれなんかはただ好きでやってるだけで、いてもいなくてもいいような存在だけど、花井是清のバンドは業界に必要なんだ』　でも、この盟友の言葉でも花井さんは意見を変えなかった。</p><p>　教室にはクーラーがついているから涼しいが、廊下に出ると昼の熱気が残っていてむっとする。　夏の夜のこの暗くて生暖かいという空気に触れるたび、僕にはなにか大気そのものが体温をもった獣のように感じられる。　夏は夜、と言ったものだが僕はあまり好きではない。</p><p>　どこに座ったらいいのかな？　わからないままぼんやり机の上に開いたままになった雑誌を見ると、それは就職情報誌だった。　あっ、こんなものを買ったのか。しかも、未経験ＯＫの求人広告ばかりを集めたページが開かれていて、倉庫内の軽作業だとか、引っ越しの手伝いといった仕事が紹介されている。</p><p>「ねえきみ、音楽の神って存在すると思うかい？」</p><p>「おれの知人にピアニストがいたんだけれど、彼女は生まれつき病気にかかっていてね、筋肉がおとろえて段々身体が動かなくなってゆくんだ。そして最後には心臓が止まって死んでしまう。おれが知り合ったうちじゃ一番才能があるとんでもないやつだったんだが、世に出る前に死んでしまった。これは、そいつが最後に演奏した曲の録音だ。葬式の時に親から手渡されたんだ。どうしてもおれに聴いて欲しいと言って、親に身体を支えてもらいながら弾いたんだそうだ」</p><p>我坚持音乐的理由是什么？蝉鸣声萦绕在我的耳畔，终端中逐渐播放的音乐，仿佛是从老旧八音盒中浸染出来的一般。称之为死的深渊在背后凝视着孱弱的生命，向前亦是无尽的深渊，无力的双手敲击着键盘，将自我蕴含的所有生命力全部注入到音符当中，形成音乐之河，观众的神思被蒸馏，徘徊于音乐编织的梦之幻境。</p><p>「映画やドラマでは、主人公が路上で演奏して通りすがりの人がみな感動したり、ひどいと泣いたりする描写があったりするけれど、実際は音だけで全ての人間を魅了するような音楽は存在しない。魂をこめた演奏なんて言っても、実際にはそんなの誰にも聴きわけることは出来ない。みんな音じゃなくてストーリーに騙されるんだ。専門の批評家たちが、そろってゴーストライターに騙されたこともある。音楽の世界だけじゃない。哲学の世界でも、偽物の数式をそれらしくちりばめた嘘の論文に騙されたことがあったそうだ。誰もよくわからないものを、よくわからないまま背景だけでありがたがるなんてのはありふれた話だ」</p><p>「別にそういう感じ方を否定するつもりはないんだよ。そういうのも含めて音楽だしね。時間に間に合わせるためにでっちあげた曲が評価されて、自分の魂を削って作った曲が酷評されたりするのもどうでもいいさ。批評家だとかはまだしも、熱烈におれの曲が好きだとかいう人がそんなことを言ってると多少はゲッソリするがね。まあ、それだっておれの知ったことじゃない。おれはただ自分の好きな曲を作っていればいいと、ずっとそう思ってやってた」</p><p>「でも、最近それに何の意味があるのかなって思い始めてたところなんだよ。聴く人間の感じ方なんか無視してやるのなら、最初から他人に見せないで、自分の頭の中で作って、頭の中で流れる曲を自分で聴いてればいいんだって。わざわざパソコン画面とにらめっこしながら音を並べるのもめんどくさいし、みんなと練習してライブをするのもだるいし、無駄が多いんだ。……鳥居が抜けるって言った時、それを思い出したね。ああ、理想の音楽環境を実行に移すときがきたんだなって。そもそもおれが音楽をはじめたのは、音を並べて曲を作るゲームを買ったのがきっかけで、それを自分で聴いてるだけで幸せだったのさ。……ほら、一緒にやろうぜ」</p><p>「それに、ゲームが下手だなあ。どれだけ下手なんだ。おれも下手だけど、きみには負けた。こんな下手な人間を見たことがない」　花井さんはしかめっつらで溜息をつく。</p><p><img src="https://i.postimg.cc/VkDhYrxP/image-20241018153728988.png" alt="それに、ゲームが下手だなあ。どれだけ下手なんだ。おれも下手だけど、きみには負けた。こんな下手な人間を見たことがない"></p><p>　花井さんの周りにはいくらでも喜んで引き受けるバンドマンがいるはずじゃないか。　彼は確かにちょっと人の好き嫌いが強いようだけど、それにしたって一人も仲の良いギタリストがいないってこともないだろう。　なのに、よりによって僕を選んだのはなぜだ？　ロックの『ロ』の字も、エレキギターの『エ』の字も知らないようなド素人なのに。</p><p><img src="https://i.postimg.cc/4NMZX0V1/image-20241018161939656.png" alt="ごっ、ごめんなさいっ！　せっ、性欲がっ、我慢出来なくなっちゃってっ！」　彼女はベッドに両手を突いて頭を下げ、土下座のポーズをする。"></p><p>　彼女が白いのは髪の毛だけでなく、眉毛も、そして豊かで長い睫毛も雪のように真っ白だった。そしてその瞳は、南国の白い砂浜に打ち寄せる波を思わせるような薄い水色だ。　この感じはブリーチやカラーコンタクトじゃない。　眼皮膚白皮症……いわゆるアルビノだ。</p><p>「この人に、オナニー見せちゃったよお」</p><p><img src="/2024/10/18/MUSICUS/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241018165931108.png" alt="「馨君。これをきみにやろう。おれが『花鳥風月』をはじめた時に使っていたギターだ」"></p><p>　花井さんはそういって立ち上がると、ローテーブルを片付けはじめる。　そしてギターを一本持って来て、僕に手渡した。「自分で器もって食ってろ」「だってぇ」「じゃあ、さっそく練習をするか。おい、ミカ、いつまでのろのろ食ってるんだ」「しっ、しないよ！　もう！　人がいるときは……」　なるほど、いないときならするらしい。「脱ぐのはいいけど、オナニーはするなよ」　花井さんが冗談のつもりなのか判別つきにくい真顔で言うと、三日月は顔を真っ赤にして、「わかった。本当にいやだけど、お兄ちゃんがそれで音楽やってくれるなら、一肌脱ぐよ」「脱ぐのはいいけど、オナニーはするなよ」　花井さんが冗談のつもりなのか判別つきにくい真顔で言うと、三日月は顔を真っ赤にして、「しっ、しないよ！　もう！　人がいるときは……」　なるほど、いないときならするらしい。「じゃあ、さっそく練習をするか。おい、ミカ、いつまでのろのろ食ってるんだ」「だってぇ」「自分で器もって食ってろ」　花井さんはそういって立ち上がると、ローテーブルを片付けはじめる。　そしてギターを一本持って来て、僕に手渡した。「馨君。これをきみにやろう。おれが『花鳥風月』をはじめた時に使っていたギターだ」</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MUSICUS！启动&lt;/p&gt;
&lt;h3 id=&quot;共通&quot;&gt;&lt;a href=&quot;#共通&quot; class=&quot;headerlink&quot; title=&quot;共通&quot;&gt;&lt;/a&gt;共通&lt;/h3&gt;&lt;p&gt;タイトル画面から「NEW GAME」を選択&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th a</summary>
      
    
    
    
    
    <category term="galgame" scheme="http://example.com/tags/galgame/"/>
    
  </entry>
  
  <entry>
    <title>galgame补全计划</title>
    <link href="http://example.com/2024/10/15/galgame%EF%BC%9Agalgame%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/"/>
    <id>http://example.com/2024/10/15/galgame%EF%BC%9Agalgame%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92/</id>
    <published>2024-10-14T22:54:04.000Z</published>
    <updated>2024-10-15T10:04:41.116Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从三个角度出发补全galgame名作</p></blockquote><h2 id="会社："><a href="#会社：" class="headerlink" title="会社："></a>会社：</h2><h4 id="Makura-KeroQ-PetitKeroQ-水镜：-H2O-～FOOTPRINTS-IN-THE-SAND～-√after-and-another"><a href="#Makura-KeroQ-PetitKeroQ-水镜：-H2O-～FOOTPRINTS-IN-THE-SAND～-√after-and-another" class="headerlink" title="Makura&#x2F;KeroQ&#x2F;PetitKeroQ&#x2F;水镜：**  H2O** ～FOOTPRINTS IN THE SAND～** ** √after and another"></a>Makura&#x2F;KeroQ&#x2F;PetitKeroQ&#x2F;水镜：**  H2O** <strong>～FOOTPRINTS IN THE SAND～</strong>** ** √after and another</h4><p> H2O -FOOTPRINTS IN THE SAND-</p><p>サクラノ詩 -The tear flows because of tenderness.- 春ノ雪</p><p>しゅぷれ～むキャンディ～王道には王道たる理由があるんです！</p><p>いきなりあなたに恋している</p><p>向日葵の教会と長い夏休み</p><p>サクラノ詩 —櫻の森の上を舞う—</p><p> ATRI -My Dear Moments-</p><p>サクラノ刻 -櫻の森の下を歩む-</p><p><strong>Leaf</strong>：</p><p><strong>DR2ナイト雀鬼</strong></p><p><strong>痕 ～きずあと～</strong></p><p><strong>Filsnown</strong> <strong>～光と刻～</strong></p><p><strong>雫 ～しずく～</strong></p><p><strong>初音のないしょ！！</strong></p><h4 id="To-Heart"><a href="#To-Heart" class="headerlink" title="To Heart"></a><strong>To Heart</strong></h4><h4 id="To-Heart-PSE"><a href="#To-Heart-PSE" class="headerlink" title="To Heart PSE"></a>To Heart PSE</h4><p>ToHeart2 XRATED</p><p>ToHeart2 AnotherDays</p><h3 id="WHITE-ALBUM"><a href="#WHITE-ALBUM" class="headerlink" title="WHITE ALBUM"></a>WHITE ALBUM</h3><p> WHITE ALBUM -綴られる冬の想い出-</p><p>WHITE ALBUM2 -closing chapter-</p><p>WHITE ALBUM2 -幸せの向こう側-<br> WHITE ALBUM2 EXTENDED EDITION</p><h3 id="猪名川でいこう！！"><a href="#猪名川でいこう！！" class="headerlink" title="猪名川でいこう！！"></a>猪名川でいこう！！</h3><p><strong>こみっくパーティー</strong></p><p><strong>まじかる☆アンティーク</strong></p><p><strong>誰彼～たそがれ～</strong></p><p><strong>うたわれるもの<br> Routes -ルーツ</strong>-</p><p><strong>天使のいない12月</strong></p><p><strong>アルルゥとあそぼ!!</strong></p><p><strong>Tears to Tiara</strong> <strong>～ティアーズ</strong>・<strong>トゥ</strong>・<strong>ティアラ～</strong></p><p><strong>鎖</strong> <strong>-クサリ</strong>-<br><strong>フルアニ</strong></p><p><strong>君が呼ぶ、メギドの丘で</strong></p><p><strong>愛佳でいくの!～Leaf Amusement Soft Vol.5～</strong></p><p><strong>WHITE ALBUM -綴られる冬の想い出-</strong></p><p><strong>星の王子くん</strong></p><h2 id="Key："><a href="#Key：" class="headerlink" title="Key："></a>Key：</h2><h2 id="Yuzusoft："><a href="#Yuzusoft：" class="headerlink" title="Yuzusoft："></a>Yuzusoft：</h2><h2 id="Minori："><a href="#Minori：" class="headerlink" title="Minori："></a>Minori：</h2><h2 id="Nitro："><a href="#Nitro：" class="headerlink" title="Nitro："></a>Nitro：</h2><h2 id="August："><a href="#August：" class="headerlink" title="August："></a>August：</h2><h2 id="Purple-Software："><a href="#Purple-Software：" class="headerlink" title="Purple Software："></a>Purple Software：</h2><h2 id="Palette："><a href="#Palette：" class="headerlink" title="Palette："></a>Palette：</h2><h2 id="脚本家"><a href="#脚本家" class="headerlink" title="脚本家"></a>脚本家</h2><h3 id="久弥直树："><a href="#久弥直树：" class="headerlink" title="久弥直树："></a>久弥直树：</h3><h3 id="竜騎士07"><a href="#竜騎士07" class="headerlink" title="竜騎士07"></a><a href="https://bangumi.tv/person/2962">竜騎士07</a></h3><p><strong>祝姫</strong></p><p><strong>Silent Hill f</strong></p><p><strong>ひぐらしのなく頃に</strong><br> <strong>Rewrite</strong></p><p><strong>トライアンソロジー ～三面鏡の国のアリス～</strong></p><h3 id="田中罗密欧："><a href="#田中罗密欧：" class="headerlink" title="田中罗密欧："></a>田中罗密欧：</h3><p><strong>加奈 〜いもうと〜</strong><br> <strong>星空☆ぷらねっと</strong></p><p><strong>ドーターメーカー</strong><br> <strong>黒の図書館</strong></p><p><strong>夏夢夜話</strong></p><p><strong>PIZZICATO POLKA－彗星幻夜－</strong></p><p><strong>神樹の館</strong></p><p><strong>ユメミルクスリ</strong><br> I&#x2F;O**</p><p><strong>雪影</strong> **-setsuei-<br>** <strong>おたく☆っしぐら</strong></p><p><strong>Chanter -キミの歌がとどいたら-</strong></p><p><strong>彗星（ほし）に願いを…</strong></p><p><strong>セカンドノベル ～彼女の夏、15分の記憶～</strong><br><strong>ピアノ～紅楼館の隷嬢達～</strong></p><p><strong>終のステラ</strong></p><p><strong>和香様の座する世界</strong></p><p><strong>水平線まで何マイル？-ORIGINAL FLIGHT-</strong>**<br><strong>CROSS†CHANNEL</strong></p><p><strong>最果てのイマ</strong></p><p><strong>家族計画～再開～</strong></p><p><strong>Rewrite</strong></p><h3 id="麻枝准："><a href="#麻枝准：" class="headerlink" title="麻枝准："></a>麻枝准：</h3><p><strong>Rewrite</strong></p><p><strong>Little Busters! EX</strong></p><p><strong>Summer Pockets</strong></p><p><strong>Kanon</strong></p><h3 id="ルースぽーい："><a href="#ルースぽーい：" class="headerlink" title="ルースぽーい："></a>ルースぽーい：</h3><p><strong>車輪の国、悠久の少年少女</strong></p><p><strong>車輪の国、向日葵の少女</strong></p><p><strong>G線上の魔王</strong></p><p><strong>夏の燈火</strong><br> <strong>A Profile ア・プロフィール</strong></p><h3 id="丸户史明："><a href="#丸户史明：" class="headerlink" title="丸户史明："></a>丸户史明：</h3><p><strong>パルフェ ～chocolat second brew～</strong></p><p><strong>この青空に約束を―</strong></p><p><strong>フォセット - Cafe au Le Ciel Bleu -</strong></p><p><strong>世界でいちばんNG（だめ）な恋</strong></p><p><strong>WHITE ALBUM2 -introductory chapter-</strong></p><p><strong>WHITE ALBUM2 -closing chapter-</strong></p><h3 id="星空めてお："><a href="#星空めてお：" class="headerlink" title="星空めてお："></a>星空めてお：</h3><p><strong>腐り姫 ～<strong><strong>euthanasia</strong></strong>～</strong></p><p><strong>CANNONBALL****～ねこねこマシン猛レース</strong></p><p><a href="https://bangumi.tv/subject/5395"><strong>Forest</strong></a></p><p><strong>腐り姫 帰省～<strong><strong>jamais vu</strong></strong>～</strong></p><h3 id="瀬戸口廉也："><a href="#瀬戸口廉也：" class="headerlink" title="瀬戸口廉也："></a>瀬戸口廉也：</h3><p><strong>ロックンロール兄弟</strong></p><p><strong>CARNIVAL</strong></p><p><strong>SWAN SONG</strong></p><p><strong>キラ☆キラ</strong></p><p><strong>暗い部屋</strong></p><p><strong>セカンドノベル ～彼女の夏、<strong><strong>15</strong></strong>分の記憶～</strong></p><p><strong>MUSICUS!<br> BLACK SHEEP TOWN</strong></p><p><strong>ヒラヒラヒヒル</strong></p><h4 id="小说："><a href="#小说：" class="headerlink" title="小说："></a>小说：</h4><p>CARNIVAL<a href="https://bangumi.tv/subject/6931">**<br>** PSYCHE</a><a href="https://bangumi.tv/subject/162097">**<br>** 犬附少女</a></p><p>ドッペルゲンガーの恋人</p><p>死体泥棒</p><p>電気サーカス</p><p>つめたいオゾン</p><h3 id="SCA-自："><a href="#SCA-自：" class="headerlink" title="SCA-自："></a>SCA-自：</h3><p><strong>終ノ空</strong></p><p>二重影</p><p><strong>二重箱</strong></p><p><strong>モエかん</strong></p><p><strong>モエてん</strong></p><p><strong>モエカす</strong></p><p><strong>灯穂奇譚</strong>**<br> H2O** <strong>～<strong><strong>FOOTPRINTS IN THE SAND</strong></strong>～**</strong><br>** <strong>√after and another</strong></p><p><strong>サクラノ詩 -The tear flows because of tenderness.- 春ノ雪</strong></p><p><strong>しゅぷれ～むキャンディ～王道には王道たる理由があるんです！</strong></p><p><strong>素晴らしき日々～不連続存在～</strong></p><p><strong>いきなりあなたに恋している</strong></p><p><strong>向日葵の教会と長い夏休み</strong></p><p><strong>サクラノ詩</strong> <strong>—<strong><strong>櫻の森の上を舞う</strong></strong>—</strong></p><p><strong>終ノ空</strong> <strong>remake</strong></p><p><strong>サクラノ刻</strong> <strong>-<strong><strong>櫻の森の下を歩む</strong></strong>-</strong></p><h2 id="原画"><a href="#原画" class="headerlink" title="原画"></a>原画</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从三个角度出发补全galgame名作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;会社：&quot;&gt;&lt;a href=&quot;#会社：&quot; class=&quot;headerlink&quot; title=&quot;会社：&quot;&gt;&lt;/a&gt;会社：&lt;/h2&gt;&lt;h4 id=&quot;Makura-K</summary>
      
    
    
    
    
    <category term="galgame" scheme="http://example.com/tags/galgame/"/>
    
  </entry>
  
  <entry>
    <title>算法：二叉树</title>
    <link href="http://example.com/2024/09/11/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2024/09/11/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2024-09-11T08:51:14.000Z</published>
    <updated>2024-09-11T11:22:59.984Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树总结笔记"><a href="#二叉树总结笔记" class="headerlink" title="二叉树总结笔记"></a>二叉树总结笔记</h3><hr><h4 id="二叉树的类别"><a href="#二叉树的类别" class="headerlink" title="二叉树的类别"></a><strong>二叉树的类别</strong></h4><ol><li><p><strong>满二叉树</strong>  </p><ul><li>一个深度为 <code>k</code>，且包含 <code>2^k - 1</code> 个节点的二叉树。</li><li>每一层的节点数都是最大值。</li></ul></li><li><p><strong>完全二叉树</strong>  </p><ul><li>除最后一层外，所有层的节点都充满，且最后一层的节点从左到右排列。</li></ul></li><li><p><strong>二叉搜索树（BST, Binary Search Tree）</strong>  </p><ul><li>对于每个节点，左子树上的所有节点值都小于该节点值，右子树上的所有节点值都大于该节点值。</li><li>具有高效的查找、插入和删除操作，时间复杂度为 <code>O(log n)</code>（在平衡情况下）。</li></ul></li><li><p><strong>平衡二叉树</strong>  </p><ul><li>保证任何节点的左、右子树的高度差不超过 1。</li><li>常见类型有 AVL 树和红黑树。</li></ul></li><li><p><strong>完全二叉树</strong>  </p><ul><li>所有叶子节点都集中在最后两层，且最后一层的节点集中在最左侧。</li></ul></li></ol><hr><h4 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a><strong>二叉树的概念</strong></h4><ul><li><p><strong>根节点 (Root)</strong><br>树的最顶层节点，没有父节点。</p></li><li><p><strong>节点 (Node)</strong><br>每个节点包含三个部分：值、左子节点、右子节点。</p></li><li><p><strong>子树 (Subtree)</strong><br>任何节点和其所有后代构成的树。</p></li><li><p><strong>父节点 (Parent)</strong><br>具有子节点的节点。</p></li><li><p><strong>叶子节点 (Leaf)</strong><br>没有子节点的节点。</p></li><li><p><strong>深度 (Depth)</strong><br>节点到根节点的距离。</p></li><li><p><strong>高度 (Height)</strong><br>节点到叶子节点的最长路径。</p></li></ul><hr><h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a><strong>二叉树的遍历方式</strong></h4><ol><li><p><strong>前序遍历 (Pre-order Traversal)</strong></p><ul><li>顺序：根节点 -&gt; 左子树 -&gt; 右子树</li><li>过程：访问当前节点，递归前序遍历左子树，再递归前序遍历右子树。</li><li>应用：可以用来复制树结构。</li></ul></li><li><p><strong>中序遍历 (In-order Traversal)</strong></p><ul><li>顺序：左子树 -&gt; 根节点 -&gt; 右子树</li><li>过程：递归中序遍历左子树，访问当前节点，再递归中序遍历右子树。</li><li>应用：可以用于输出有序的节点值（如果是二叉搜索树）。</li></ul></li><li><p><strong>后序遍历 (Post-order Traversal)</strong></p><ul><li>顺序：左子树 -&gt; 右子树 -&gt; 根节点</li><li>过程：递归后序遍历左子树，递归后序遍历右子树，最后访问当前节点。</li><li>应用：适合用于删除树或释放资源。</li></ul></li><li><p><strong>层次遍历 (Level-order Traversal)</strong></p><ul><li>顺序：从上到下、从左到右逐层访问。</li><li>应用：适合用于按层操作节点。</li></ul></li></ol><hr><h4 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a><strong>平衡树</strong></h4><ul><li><p><strong>平衡二叉树 (Balanced Binary Tree)</strong></p><ul><li>定义：保证任何节点的左右子树高度差不超过1，以避免极端情况如链表状树（退化为线性结构）。</li><li>优点：查找、插入和删除操作能始终保持 <code>O(log n)</code> 的时间复杂度。</li></ul></li><li><p><strong>常见平衡树类型：</strong></p><ol><li><p><strong>AVL树</strong></p><ul><li>定义：一种严格平衡的二叉搜索树，确保每个节点的左右子树高度差至多为1。</li><li>调整：通过旋转操作（左旋、右旋、左右旋、右左旋）来保持平衡。</li><li>应用：适用于读操作远多于写操作的场景。</li></ul></li><li><p><strong>红黑树 (Red-Black Tree)</strong></p><ul><li>定义：一种自平衡二叉搜索树，确保树在最坏情况下也是接近平衡的。</li><li>性质：<ul><li>每个节点要么是红色，要么是黑色。</li><li>根节点是黑色，所有叶节点（空节点）都是黑色。</li><li>如果一个节点是红色，它的子节点必须是黑色（不能有连续的红色节点）。</li><li>从根到叶子节点的每条路径上必须包含相同数量的黑色节点。</li></ul></li><li>应用：广泛用于许多系统中的平衡二叉树，如 Java 中的 <code>TreeMap</code> 和 C++ 中的 <code>map</code>。</li></ul></li></ol></li></ul><h3 id="深度优先搜索（DFS-Depth-First-Search）"><a href="#深度优先搜索（DFS-Depth-First-Search）" class="headerlink" title="深度优先搜索（DFS, Depth-First Search）"></a>深度优先搜索（DFS, Depth-First Search）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>深度优先搜索是一种遍历或搜索图和树的算法，它尽可能深入每一个分支，直到无法继续为止，再回溯到最近的未探索节点继续搜索。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li><strong>递归性</strong>：DFS通常使用递归的方式实现，沿着某个路径深入到最深处，再逐步回溯。</li><li><strong>栈结构</strong>：如果使用迭代方式实现，DFS依赖栈结构来记录节点的路径。</li><li><strong>遍历顺序</strong>：优先探索每个节点的所有子节点，只有在无法深入时才回溯。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li>适合用于<strong>找路径</strong>或<strong>找到树或图的连通性</strong>。</li><li>解决问题如<strong>迷宫问题</strong>，<strong>拓扑排序</strong>，<strong>岛屿数量</strong>等。</li></ul><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a><strong>实现方法</strong></h4><ol><li><p>递归实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 处理当前节点</span></span><br><span class="line">    <span class="built_in">visit</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> child : node-&gt;children) &#123;</span><br><span class="line">        <span class="built_in">DFS</span>(child);  <span class="comment">// 递归处理子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>迭代实现（使用栈）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;Node*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* current = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">visit</span>(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child : current-&gt;children) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(child);  <span class="comment">// 将子节点压入栈中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li>对于树和图的分支，能够深入到最深处。</li><li>在有解的情况下，如果目标节点比较深，DFS通常能较早找到解。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li>可能会陷入<strong>无限深度</strong>的递归，尤其是当存在环的图中，DFS可能需要额外的机制避免重复访问。</li><li>不适合用于寻找最短路径。</li></ul><hr><h3 id="广度优先搜索（BFS-Breadth-First-Search）"><a href="#广度优先搜索（BFS-Breadth-First-Search）" class="headerlink" title="广度优先搜索（BFS, Breadth-First Search）"></a>广度优先搜索（BFS, Breadth-First Search）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>广度优先搜索是一种遍历图和树的算法，逐层展开，先访问与起点距离最近的节点，然后逐层向外扩展。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul><li><strong>队列结构</strong>：BFS依赖队列（FIFO）来保证节点按层次顺序被访问。</li><li><strong>层次遍历</strong>：先访问当前节点的所有邻居节点，再继续访问这些邻居节点的子节点。</li><li><strong>找到最短路径</strong>：在无权图中，BFS保证找到起点到任意节点的最短路径。</li></ul><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li>适合用于寻找<strong>最短路径</strong>。</li><li>解决问题如<strong>最短路径问题</strong>，<strong>图的遍历</strong>，<strong>广度优先迷宫</strong>，<strong>连通性检测</strong>等。</li></ul><h4 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a><strong>实现方法</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* current = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">visit</span>(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child : current-&gt;children) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(child);  <span class="comment">// 将子节点加入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li>在无权图中，能够找到起点到目标节点的<strong>最短路径</strong>。</li><li>对于树的广度遍历非常直观，能够完整遍历所有节点。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li>由于广度优先扩展，BFS的空间复杂度可能会较高，尤其是当图的广度非常大时。</li></ul><hr><h3 id="对比-DFS-和-BFS"><a href="#对比-DFS-和-BFS" class="headerlink" title="对比 DFS 和 BFS"></a><strong>对比 DFS 和 BFS</strong></h3><ul><li><p><strong>DFS 深度优先搜索</strong>：  </p><ul><li>优先探索尽可能深的路径，适合用于找路径、连通性检测。</li><li>空间复杂度通常较低，但在深度很大时可能引发栈溢出（递归方式）。</li></ul></li><li><p><strong>BFS 广度优先搜索</strong>：  </p><ul><li>按层次遍历，保证找到最短路径，适合用于无权图的最短路径问题。</li><li>空间复杂度较高，尤其是图的广度较大时。</li></ul></li></ul><p>在实际使用中，根据问题的具体需求选择合适的算法。例如，在寻找迷宫最短路径问题中，BFS较为适合；在连通性检测或路径问题中，DFS可能更为高效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;二叉树总结笔记&quot;&gt;&lt;a href=&quot;#二叉树总结笔记&quot; class=&quot;headerlink&quot; title=&quot;二叉树总结笔记&quot;&gt;&lt;/a&gt;二叉树总结笔记&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;二叉树的类别&quot;&gt;&lt;a href=&quot;#二叉树的类别&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>概率论第二课</title>
    <link href="http://example.com/2024/09/05/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E4%BA%8C%E8%AF%BE/"/>
    <id>http://example.com/2024/09/05/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E4%BA%8C%E8%AF%BE/</id>
    <published>2024-09-05T08:56:52.000Z</published>
    <updated>2024-09-05T16:00:51.310Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概率的公理化定义"><a href="#概率的公理化定义" class="headerlink" title="概率的公理化定义"></a>概率的公理化定义</h3><p>概率的公理化定义由俄罗斯数学家 <strong>安德烈·柯尔莫哥洛夫</strong>（Andrey Kolmogorov）在1933年提出，称为<strong>柯尔莫哥洛夫公理</strong>。该定义将概率理论建立在严密的数学公理基础之上，主要有三个公理：</p><h4 id="1-非负性公理"><a href="#1-非负性公理" class="headerlink" title="1. 非负性公理"></a>1. <strong>非负性公理</strong></h4><p>对于任何一个事件 ( A )，其概率 $( P(A) )$ 都是一个非负数：<br>$$<br>P(A) \geq 0<br>$$<br>这意味着任何事件发生的概率不能为负数。</p><h4 id="2-规范性公理"><a href="#2-规范性公理" class="headerlink" title="2. 规范性公理"></a>2. <strong>规范性公理</strong></h4><p>全集（或样本空间）( S ) 的概率为 1：<br>$$<br>P(S) &#x3D; 1<br>$$<br>这表示在样本空间内，某些事件肯定会发生，因此概率为 1。</p><h4 id="3-可加性公理"><a href="#3-可加性公理" class="headerlink" title="3. 可加性公理"></a>3. <strong>可加性公理</strong></h4><p>对于任何两个互不相容的事件 ( A ) 和 ( B ) （即$( A \cap B &#x3D; \emptyset )$），它们的联合概率等于各自概率之和：<br>$$<br>P(A \cup B) &#x3D; P(A) + P(B)<br>$$<br>如果事件 ( A ) 和 ( B ) 互不重叠，它们共同发生的概率是各自发生的概率之和。</p><h3 id="拓展定义"><a href="#拓展定义" class="headerlink" title="拓展定义"></a>拓展定义</h3><p>根据这三个公理，可以推导出概率的其他性质和规则。例如：</p><ul><li><p><strong>有限可加性</strong>：对于有限个两两互不相容的事件 $( A_1, A_2, …, A_n )$，有<br>$$<br>P(A_1 \cup A_2 \cup … \cup A_n) &#x3D; P(A_1) + P(A_2) + … + P(A_n)<br>$$</p></li><li><p><strong>单调性</strong>：如果事件 $( A \subseteq B )$，则 $( P(A) \leq P(B) )$。</p></li><li><p><strong>补事件的概率</strong>：对于任何事件 ( A )，补集事件 ( A^c ) 的概率为<br>$$<br>P(A^c) &#x3D; 1 - P(A)<br>$$</p></li></ul><h3 id="公理化定义的意义"><a href="#公理化定义的意义" class="headerlink" title="公理化定义的意义"></a>公理化定义的意义</h3><p>柯尔莫哥洛夫的公理化定义提供了一个严密、统一的数学框架，确保概率论具有自洽性和逻辑一致性。通过这套公理，概率的计算和应用变得更加系统化，广泛应用于统计学、物理学、经济学等领域。</p><h3 id="概率的公理化定义（详细版）"><a href="#概率的公理化定义（详细版）" class="headerlink" title="概率的公理化定义（详细版）"></a>概率的公理化定义（详细版）</h3><p>概率论的公理化定义由<strong>柯尔莫哥洛夫</strong>提出，它基于三个基本公理构建而成，用数学的方式定义了事件及其发生的概率。下面是概率的详细公理化定义：</p><h3 id="事件与样本空间"><a href="#事件与样本空间" class="headerlink" title="事件与样本空间"></a>事件与样本空间</h3><p>设 ( S ) 为样本空间，即所有可能结果的集合。事件 ( A ) 是样本空间的一个子集，表示某个特定的结果或一组结果。</p><h3 id="概率的三个公理"><a href="#概率的三个公理" class="headerlink" title="概率的三个公理"></a>概率的三个公理</h3><ol><li><p><strong>非负性公理（Non-negativity Axiom）</strong><br>对于任何事件 ( A \subseteq S )，其概率 ( P(A) ) 为非负数：<br>$$<br>P(A) \geq 0<br>$$<br><strong>解释</strong>：任意事件发生的概率是一个非负数，不能为负。</p></li><li><p><strong>规范性公理（Normalization Axiom）</strong><br>样本空间 ( S ) 中包含的所有可能结果的总概率为 1：<br>$$<br>P(S) &#x3D; 1<br>$$<br><strong>解释</strong>：在样本空间中，必然会发生某个事件，因此所有可能结果的总概率为 1。</p></li><li><p><strong>可加性公理（Additivity Axiom）</strong><br>如果事件 ( A ) 和 ( B ) 互斥（即 ( A \cap B &#x3D; \emptyset )，它们不能同时发生），则事件 ( A \cup B ) 的概率等于两个事件的概率之和：<br>$$<br>P(A \cup B) &#x3D; P(A) + P(B) \quad \text{当} \quad A \cap B &#x3D; \emptyset<br>$$<br><strong>解释</strong>：对于两个互不相容的事件，合并发生的概率等于它们各自发生概率的总和。</p></li></ol><h3 id="推论和拓展"><a href="#推论和拓展" class="headerlink" title="推论和拓展"></a>推论和拓展</h3><p>从柯尔莫哥洛夫公理，可以推导出一系列其他重要性质：</p><h4 id="1-有限可加性"><a href="#1-有限可加性" class="headerlink" title="1. 有限可加性"></a>1. <strong>有限可加性</strong></h4><p>   对于有限多个两两互不相容的事件 ( A_1, A_2, \dots, A_n )，则它们并集的概率为：<br>$$<br>   P\left(\bigcup_{i&#x3D;1}^{n} A_i\right) &#x3D; \sum_{i&#x3D;1}^{n} P(A_i) \quad \text{当} \quad A_i \cap A_j &#x3D; \emptyset \quad \text{对于} \quad i \neq j<br>$$</p><h4 id="2-单调性"><a href="#2-单调性" class="headerlink" title="2. 单调性"></a>2. <strong>单调性</strong></h4><p>   如果 ( A \subseteq B )（即事件 ( A ) 是事件 ( B ) 的子集，发生 ( A ) 意味着 ( B ) 也发生），那么：<br>$$<br>   P(A) \leq P(B)<br>$$</p><h4 id="3-补事件的概率"><a href="#3-补事件的概率" class="headerlink" title="3. 补事件的概率"></a>3. <strong>补事件的概率</strong></h4><p>   对于任何事件 ( A )，其补集（事件 ( A ) 不发生的事件） ( A^c ) 的概率为：<br>$$<br>   P(A^c) &#x3D; 1 - P(A)<br>$$<br>   其中，( A^c ) 表示事件 ( A ) 不发生的情况。</p><h4 id="4-全概率公式"><a href="#4-全概率公式" class="headerlink" title="4. 全概率公式"></a>4. <strong>全概率公式</strong></h4><p>   如果事件 ( A_1, A_2, …, A_n ) 形成样本空间 ( S ) 的一个划分，即 ( S &#x3D; A_1 \cup A_2 \cup … \cup A_n ) 且 ( A_i \cap A_j &#x3D; \emptyset )，则对于任何事件 ( B )，有：<br>$$<br>   P(B) &#x3D; \sum_{i&#x3D;1}^{n} P(B \cap A_i) &#x3D; \sum_{i&#x3D;1}^{n} P(B | A_i) P(A_i)<br>$$<br>   <strong>解释</strong>：全概率公式用于计算事件 ( B ) 的概率，其中事件 ( B ) 可能通过不同的途径（事件 ( A_i ) ）发生。</p><h4 id="5-条件概率"><a href="#5-条件概率" class="headerlink" title="5. 条件概率"></a>5. <strong>条件概率</strong></h4><p>   给定事件 ( A ) 和事件 ( B )，如果 ( P(B) &gt; 0 )，则事件 ( A ) 在事件 ( B ) 已经发生的条件下的概率为：<br>$$<br>   P(A | B) &#x3D; \frac{P(A \cap B)}{P(B)} \quad \text{当} \quad P(B) &gt; 0<br>$$<br>   <strong>解释</strong>：条件概率描述了事件 ( B ) 发生时，事件 ( A ) 的发生概率。</p><h4 id="6-乘法法则"><a href="#6-乘法法则" class="headerlink" title="6. 乘法法则"></a>6. <strong>乘法法则</strong></h4><p>   由条件概率公式可得，事件 ( A ) 和 ( B ) 同时发生的概率为：<br>$$<br>   P(A \cap B) &#x3D; P(A | B) P(B)<br>$$</p><h4 id="7-贝叶斯定理"><a href="#7-贝叶斯定理" class="headerlink" title="7. 贝叶斯定理"></a>7. <strong>贝叶斯定理</strong></h4><p>   如果事件 ( A_1, A_2, …, A_n ) 形成样本空间 ( S ) 的划分，则对于任意事件 ( B ) 和 ( A_i )，有：<br>$$<br>   P(A_i | B) &#x3D; \frac{P(B | A_i) P(A_i)}{\sum_{j&#x3D;1}^{n} P(B | A_j) P(A_j)}<br>$$<br>   <strong>解释</strong>：贝叶斯定理用于通过已知条件重新计算事件的概率，广泛应用于统计推断和机器学习中。</p><p>下面是几个经典的概率论证明例题，涵盖了基本概率计算、条件概率、全概率公式、贝叶斯定理等内容。</p><h3 id="例题-1：掷骰子的联合概率问题"><a href="#例题-1：掷骰子的联合概率问题" class="headerlink" title="例题 1：掷骰子的联合概率问题"></a>例题 1：掷骰子的联合概率问题</h3><p><strong>问题</strong>：两枚骰子同时掷出，求两枚骰子的点数之和为7的概率。</p><p><strong>解法</strong>：</p><p>样本空间 ( S ) 包含所有可能的结果，即两枚骰子可能的组合。因为每个骰子有6种可能的结果，所以样本空间的大小为：<br>$$<br>|S| &#x3D; 6 \times 6 &#x3D; 36<br>$$</p><p>满足两枚骰子点数之和为7的事件 ( A ) 包含以下组合：<br>$$<br>A &#x3D; {(1,6), (2,5), (3,4), (4,3), (5,2), (6,1)}<br>$$</p><p>共有6种可能的组合，因此事件 ( A ) 的概率为：<br>$$<br>P(A) &#x3D; \frac{|A|}{|S|} &#x3D; \frac{6}{36} &#x3D; \frac{1}{6}<br>$$</p><h3 id="例题-2：条件概率问题"><a href="#例题-2：条件概率问题" class="headerlink" title="例题 2：条件概率问题"></a>例题 2：条件概率问题</h3><p><strong>问题</strong>：盒子中有3个红球和2个蓝球，从中随机取出2个球。已知第一个取出的球是红球，求第二个球是红球的概率。</p><p><strong>解法</strong>：</p><p>这是一个条件概率问题，要求的是在第一个球为红球的条件下，第二个球是红球的概率。记事件 ( A ) 为 “第一个球是红球”，事件 ( B ) 为 “第二个球是红球”。</p><p>已知 ( P(A) &#x3D; \frac{3}{5} )，因为盒子中最初有3个红球和2个蓝球。</p><p>在取出第一个红球之后，剩下的球中有2个红球和2个蓝球，因此第二个球是红球的条件概率为：<br>$$<br>P(B | A) &#x3D; \frac{2}{4} &#x3D; \frac{1}{2}<br>$$</p><h3 id="例题-3：全概率公式"><a href="#例题-3：全概率公式" class="headerlink" title="例题 3：全概率公式"></a>例题 3：全概率公式</h3><p><strong>问题</strong>：某射手进行射击比赛，每次射击命中的概率为0.8。如果射手射击三次，求至少命中一次的概率。</p><p><strong>解法</strong>：</p><p>先计算射手<strong>每次都未命中</strong>的概率。因为每次命中的概率为0.8，所以每次未命中的概率为：<br>$$<br>P(\text{未命中}) &#x3D; 1 - 0.8 &#x3D; 0.2<br>$$</p><p>射手在三次射击中都未命中的概率为：<br>$$<br>P(\text{三次未命中}) &#x3D; 0.2 \times 0.2 \times 0.2 &#x3D; 0.008<br>$$</p><p>因此，至少命中一次的概率为：<br>$$<br>P(\text{至少命中一次}) &#x3D; 1 - P(\text{三次未命中}) &#x3D; 1 - 0.008 &#x3D; 0.992<br>$$</p><h3 id="例题-4：贝叶斯定理"><a href="#例题-4：贝叶斯定理" class="headerlink" title="例题 4：贝叶斯定理"></a>例题 4：贝叶斯定理</h3><p><strong>问题</strong>：某种疾病的检验准确率为90%，即有90%的几率检验结果正确（包括阳性和阴性）。某地疾病的患病率为1%，假设一个人检测结果呈阳性，求该人实际患病的概率（即患病条件下阳性检测的概率）。</p><p><strong>解法</strong>：</p><p>记事件：</p><ul><li>( A )：患病</li><li>( B )：检测结果呈阳性</li></ul><p>已知：</p><ul><li>( P(A) &#x3D; 0.01 )（患病率）</li><li>( P($A^c$) &#x3D; 0.99 )（不患病率）</li><li>( P(B | A) &#x3D; 0.9 )（患病时检测阳性的概率）</li><li>( P(B | $A^c$) &#x3D; 0.1 )（不患病时检测阳性的概率）</li></ul><p>根据贝叶斯定理，有：<br>$$<br>P(A | B) &#x3D; \frac{P(B | A) P(A)}{P(B)}<br>$$</p><p>首先，利用全概率公式计算 ( P(B) )：<br>$$<br>P(B) &#x3D; P(B | A) P(A) + P(B | A^c) P(A^c)<br>$$<br>$$<br>P(B) &#x3D; 0.9 \times 0.01 + 0.1 \times 0.99 &#x3D; 0.009 + 0.099 &#x3D; 0.108<br>$$</p><p>然后，代入贝叶斯公式计算 ( P(A | B) )：<br>$$<br>P(A | B) &#x3D; \frac{0.9 \times 0.01}{0.108} &#x3D; \frac{0.009}{0.108} \approx 0.0833<br>$$</p><p>因此，检测阳性时，实际患病的概率为约8.33%。</p><h3 id="例题-5：独立事件的联合概率"><a href="#例题-5：独立事件的联合概率" class="headerlink" title="例题 5：独立事件的联合概率"></a>例题 5：独立事件的联合概率</h3><p><strong>问题</strong>：两个人分别投篮，每次投篮命中的概率分别为0.7和0.6，求两人都命中的概率。</p><p><strong>解法</strong>：</p><p>这是一个独立事件的联合概率问题，记事件 ( A ) 为 “第一个人命中”，事件 ( B ) 为 “第二个人命中”。因为两人投篮是独立的，联合概率为：<br>$$<br>P(A \cap B) &#x3D; P(A) \times P(B) &#x3D; 0.7 \times 0.6 &#x3D; 0.42<br>$$</p><p>因此，两人都命中的概率为0.42。</p><hr><p>这些例题展示了概率论中的一些经典证明方法和公式的应用，涵盖了独立事件、条件概率、全概率公式、贝叶斯定理等重要概念。</p><h3 id="古典概型（Classical-Probability-Model）笔记"><a href="#古典概型（Classical-Probability-Model）笔记" class="headerlink" title="古典概型（Classical Probability Model）笔记"></a><strong>古典概型（Classical Probability Model）笔记</strong></h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>古典概型是概率论中的一种基本概率模型，适用于有限且等可能的结果集。其基本特点是所有实验的基本事件发生的可能性相同。古典概型适用于计算离散型随机事件的概率。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ol><li><strong>有限性</strong>：样本空间中的基本事件个数是有限的。</li><li><strong>等可能性</strong>：每个基本事件发生的概率相同。</li><li><strong>概率的计算方式简单</strong>：只需考虑事件的有利结果数与总结果数的比例。</li></ol><h4 id="古典概型的概率公式"><a href="#古典概型的概率公式" class="headerlink" title="古典概型的概率公式"></a><strong>古典概型的概率公式</strong></h4><p>设样本空间 ( S ) 包含 ( n ) 个等可能的结果，某事件 ( A ) 包含 ( m ) 个与 ( A ) 有关的有利结果，则事件 ( A ) 发生的概率 ( P(A) ) 由以下公式计算：</p><p>$$<br>P(A) &#x3D; \frac{m}{n}<br>$$</p><ul><li>( P(A) )：事件 ( A ) 发生的概率</li><li>( m )：事件 ( A ) 对应的有利结果数</li><li>( n )：样本空间中所有可能结果的总数</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a><strong>例子</strong></h4><ol><li><p><strong>掷骰子</strong>  </p><ul><li>样本空间 ( S &#x3D; {1, 2, 3, 4, 5, 6} )</li><li>求掷出偶数的概率 ( P(A) )，其中 ( A ) 是偶数事件 ( A &#x3D; {2, 4, 6} )</li><li>结果数 ( n &#x3D; 6 )，有利结果数 ( m &#x3D; 3 )</li><li>计算概率：<br>$$<br>P(A) &#x3D; \frac{m}{n} &#x3D; \frac{3}{6} &#x3D; 0.5<br>$$</li></ul></li><li><p><strong>从一副扑克牌中抽一张牌</strong>  </p><ul><li>样本空间 ( S ) 包含52张牌</li><li>求抽到红心的概率，红心牌数为13</li><li>结果数 ( n &#x3D; 52 )，有利结果数 ( m &#x3D; 13 )</li><li>计算概率：<br>$$<br>P(A) &#x3D; \frac{13}{52} &#x3D; 0.25<br>$$</li></ul></li></ol><h4 id="古典概型的条件"><a href="#古典概型的条件" class="headerlink" title="古典概型的条件"></a><strong>古典概型的条件</strong></h4><p>古典概型成立时需要满足以下条件：</p><ol><li><strong>实验结果有限</strong>：实验的所有可能结果数量必须是有限的。</li><li><strong>等可能性</strong>：所有基本事件发生的概率必须是相同的。</li></ol><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ol><li><strong>抛硬币</strong>：每次抛硬币时，正反两面是等可能出现的。</li><li><strong>掷骰子</strong>：每个面出现的概率相等，符合古典概型。</li><li><strong>抽扑克牌</strong>：从一副标准扑克牌中随机抽牌，所有牌的抽取概率相等。</li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h4><ul><li>古典概型适用于<strong>等可能事件</strong>，如果事件的发生概率不等，则不能使用古典概型计算。</li><li>古典概型只适用于有限个结果，若有无限多可能结果，需要使用其他概率模型。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>古典概型通过等可能结果的简单计算方法来确定事件的概率，适用于有限的样本空间，在一些典型的随机实验（如掷骰子、抛硬币等）中有广泛应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概率的公理化定义&quot;&gt;&lt;a href=&quot;#概率的公理化定义&quot; class=&quot;headerlink&quot; title=&quot;概率的公理化定义&quot;&gt;&lt;/a&gt;概率的公理化定义&lt;/h3&gt;&lt;p&gt;概率的公理化定义由俄罗斯数学家 &lt;strong&gt;安德烈·柯尔莫哥洛夫&lt;/strong&gt;（An</summary>
      
    
    
    
    
    <category term="概率论" scheme="http://example.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据结构：树和二叉树</title>
    <link href="http://example.com/2024/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2024/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2024-09-04T14:42:58.000Z</published>
    <updated>2024-09-05T08:49:10.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>树（Tree）是一种重要的非线性数据结构，由一组节点（Node）和边（Edge）组成，用于表示具有层次关系的数据。树具有以下几个特点：</p><ul><li><strong>层次性</strong>：树是一种分层结构，每个节点与其他节点之间有明确的父子关系。</li><li><strong>有根性</strong>：树中有且只有一个根节点（Root Node），它是树的起点，没有父节点。</li><li><strong>递归性</strong>：树结构具有递归的性质，每棵树由一个根节点和若干子树组成，每棵子树本身也是一棵树。</li><li><img src="https://i.postimg.cc/tRKdzdtV/36a04d2fc8f6a5d03173a01a27b4d451.png"></li></ul><h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><p><strong>节点（Node）</strong><br>节点是树中的基本元素，每个节点包含一个数据值，并且可能有零个或多个子节点。节点是树的基本构成单元。</p><p><strong>根节点（Root Node）</strong><br>根节点是树的起始节点，是层次结构中的最高层。根节点没有父节点，它是树的唯一入口点。</p><p><strong>子节点（Child Node）</strong><br>子节点是某个节点的直接后继节点。一个节点可以有多个子节点，表示树中的层次关系。</p><p><strong>父节点（Parent Node）</strong><br>父节点是某个节点的直接前驱节点。子节点与父节点之间由一条边连接。</p><p><strong>叶子节点（Leaf Node）</strong><br>叶子节点是没有子节点的节点，位于树的最底层，也称为终端节点。</p><p><strong>兄弟节点（Sibling Node）</strong><br>兄弟节点是同一个父节点的子节点，它们在树的层次结构中位于同一层。</p><p><strong>路径（Path）</strong><br>路径是从一个节点到另一个节点的边的序列。路径长度是路径上边的数量。</p><p><strong>深度（Depth）</strong><br>深度是从根节点到某个节点的路径长度，也可以理解为该节点的层数。</p><p><strong>高度（Height）</strong><br>高度是从该节点到叶节点的最长路径长度。树的高度是其根节点的高度。</p><p><strong>层（Level）</strong><br>层表示节点在树中的层级，根节点的层级为0，其子节点的层级为1，依此类推。</p><p><strong>度（Degree）</strong><br>度是一个节点拥有的子节点的数量。树的度是所有节点度的最大值。</p><p><strong>子树（Subtree）</strong><br>子树是树的一个子集，它由某个节点及其所有后代节点组成。子树本身也是一棵树。</p><p><strong>森林（Forest）</strong><br>森林是由多棵互不相连的树组成的集合。将树的根节点删除后会得到一个森林。</p><p>通过这些定义和基本术语，可以全面了解树这种数据结构及其在各种应用场景中的重要性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;树的定义&quot;&gt;&lt;a href=&quot;#树的定义&quot; class=&quot;headerlink&quot; title=&quot;树的定义&quot;&gt;&lt;/a&gt;树的定义&lt;/h3&gt;&lt;p&gt;树（Tree）是一种重要的非线性数据结构，由一组节点（Node）和边（Edge）组成，用于表示具有层次关系的数据。树具有以下</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>writing</title>
    <link href="http://example.com/2024/09/04/acedemic%20English%20writing/"/>
    <id>http://example.com/2024/09/04/acedemic%20English%20writing/</id>
    <published>2024-09-04T02:38:00.000Z</published>
    <updated>2024-09-04T09:08:24.501Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>key words:</p><p>format、differences、research paper writing 、writing process、cohesive devices、summary、topic、thesis、focus、paraphrasing、hedging words、reporting verbs、interested topic、EWA.</p></blockquote><h2 id="Key-words"><a href="#Key-words" class="headerlink" title="Key words"></a>Key words</h2><hr><h3 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h3><p><strong>Definition</strong><br>Refers to the structure and layout of an academic paper, including the title page, abstract, introduction, body, conclusion, and references. Proper formatting enhances the readability and professionalism of the paper.</p><p><strong>Example</strong>  </p><ul><li><strong>Title Page</strong>: Includes the paper’s title, author’s name, institution, and date.</li><li><strong>Abstract</strong>: “This study examines the effects of climate change on agricultural productivity, highlighting significant trends and potential impacts.”</li><li><strong>Introduction</strong>: “Climate change has become a critical issue with far-reaching effects on various aspects of life, particularly agriculture.”</li><li><strong>Body</strong>: Contains sections like literature review, methodology, results, and discussion.</li><li><strong>Conclusion</strong>: “The findings suggest that climate change is likely to reduce crop yields, necessitating the adoption of adaptive agricultural practices.”</li><li><strong>References</strong>: “Smith, J. (2020). <em>Climate Change and Agriculture</em>. Cambridge University Press.”</li></ul><hr><h3 id="Differences"><a href="#Differences" class="headerlink" title="Differences"></a>Differences</h3><p><strong>Definition</strong><br>In academic writing, refers to the discrepancies in viewpoints or results between different sources. It is crucial to compare and contrast relevant research accurately to demonstrate analytical skills.</p><p><strong>Example</strong>  </p><ul><li><strong>Comparing Studies</strong>: “While Smith (2020) argues that climate change significantly impacts crop yields, Jones (2019) finds that the effects are less pronounced, suggesting regional variability.”</li><li><strong>Different Perspectives</strong>: “The theoretical framework proposed by Brown (2018) differs from that of White (2017) in its approach to economic impacts.”</li></ul><hr><h3 id="Research-Paper-Writing"><a href="#Research-Paper-Writing" class="headerlink" title="Research Paper Writing"></a>Research Paper Writing</h3><p><strong>Definition</strong><br>Encompasses the entire process from topic selection, literature review, research methods, data analysis to conclusions. The key is to ensure logical clarity and thorough argumentation.</p><p><strong>Example</strong>  </p><ul><li><strong>Topic Selection</strong>: “The impact of urbanization on biodiversity.”</li><li><strong>Literature Review</strong>: “Previous studies have shown mixed results regarding urbanization’s effects on local species (Green, 2019; Lee, 2021).”</li><li><strong>Research Methods</strong>: “This study employs a mixed-methods approach, combining quantitative surveys with qualitative interviews.”</li><li><strong>Data Analysis</strong>: “Statistical analysis revealed a significant decline in native species in urban areas (p &lt; 0.05).”</li><li><strong>Conclusion</strong>: “The study concludes that urbanization negatively affects biodiversity, with implications for conservation strategies.”</li></ul><hr><h3 id="Writing-Process"><a href="#Writing-Process" class="headerlink" title="Writing Process"></a>Writing Process</h3><p><strong>Definition</strong><br>The writing process typically includes prewriting, drafting, revising, and proofreading stages. Each stage focuses on different tasks, such as brainstorming, writing the first draft, modifying content, and checking for errors.</p><p><strong>Example</strong>  </p><ul><li><strong>Prewriting</strong>: “Brainstorming ideas for a research paper on renewable energy technologies.”</li><li><strong>Drafting</strong>: “Writing an initial draft of the paper, focusing on the introduction and literature review.”</li><li><strong>Revising</strong>: “Revising the draft based on feedback from peers, adjusting arguments and adding evidence.”</li><li><strong>Proofreading</strong>: “Checking the final draft for grammatical errors, typos, and formatting inconsistencies.”</li></ul><hr><h3 id="Cohesive-Devices"><a href="#Cohesive-Devices" class="headerlink" title="Cohesive Devices"></a>Cohesive Devices</h3><p><strong>Definition</strong><br>Also known as linking words or coherence devices, they help create smooth transitions between sentences and paragraphs. Examples include “therefore,” “however,” and “additionally.”</p><p><strong>Example</strong>  </p><ul><li><strong>Therefore</strong>: “The experiment showed significant results; therefore, the hypothesis was supported.”</li><li><strong>However</strong>: “The initial findings were promising; however, further research is needed to confirm these results.”</li><li><strong>Additionally</strong>: “The study also explored the impact on local wildlife. Additionally, it examined the socioeconomic effects.”</li></ul><hr><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><strong>Definition</strong><br>A brief overview of a paper or document, highlighting key points and conclusions. An effective summary should be concise and cover the core content.</p><p><strong>Example</strong>  </p><ul><li><strong>Paper Summary</strong>: “This paper investigates the relationship between exercise and mental health. Results indicate that regular physical activity is associated with reduced symptoms of depression and anxiety.”</li></ul><hr><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p><strong>Definition</strong><br>The subject or research question of a paper, serving as the foundation for all research and discussion. Choosing a clear, researchable topic is crucial for successful writing.</p><p><strong>Example</strong>  </p><ul><li><strong>Topic</strong>: “The effects of social media on academic performance.”</li><li><strong>Research Question</strong>: “How does the use of social media platforms impact students’ academic achievements?”</li></ul><hr><h3 id="Thesis"><a href="#Thesis" class="headerlink" title="Thesis"></a>Thesis</h3><p><strong>Definition</strong><br>The central argument or claim of a paper, typically stated in the introduction and supported throughout the paper.</p><p><strong>Example</strong>  </p><ul><li><strong>Thesis Statement</strong>: “While social media offers significant benefits for communication, its excessive use negatively impacts students’ academic performance by reducing study time and increasing distractions.”</li></ul><hr><h3 id="Focus"><a href="#Focus" class="headerlink" title="Focus"></a>Focus</h3><p><strong>Definition</strong><br>Refers to the specific issue or angle a paper will concentrate on. Maintaining focus helps prevent deviation from the main topic and clarifies the argument.</p><p><strong>Example</strong>  </p><ul><li><strong>Focus</strong>: “This paper will focus on the impact of social media on high school students’ GPA, rather than exploring its effects on college students or professionals.”</li></ul><hr><h3 id="Paraphrasing"><a href="#Paraphrasing" class="headerlink" title="Paraphrasing"></a>Paraphrasing</h3><p><strong>Definition</strong><br>Rewriting information in different words and sentence structures to avoid direct quotation and demonstrate understanding of the material. Effective paraphrasing should preserve the original meaning.</p><p><strong>Example</strong>  </p><ul><li><strong>Original</strong>: “Global warming is leading to an increase in extreme weather events.”</li><li><strong>Paraphrased</strong>: “The rise in global temperatures is contributing to a higher frequency of extreme weather conditions.”</li></ul><hr><h3 id="Hedging-Words"><a href="#Hedging-Words" class="headerlink" title="Hedging Words"></a>Hedging Words</h3><p><strong>Definition</strong><br>Words used to express uncertainty or to avoid making absolute statements, such as “may,” “seems,” or “to some extent.” These words help add a level of caution to academic writing.</p><p><strong>Example</strong>  </p><ul><li><strong>May</strong>: “The findings may suggest a trend towards increased biodiversity in urban areas.”</li><li><strong>Seems</strong>: “The data seems to indicate a positive correlation between exercise and mental health improvements.”</li></ul><hr><h3 id="Reporting-Verbs"><a href="#Reporting-Verbs" class="headerlink" title="Reporting Verbs"></a>Reporting Verbs</h3><p><strong>Definition</strong><br>Verbs used to attribute information or viewpoints to other authors, such as “argues,” “claims,” “finds,” etc. Choosing the right reporting verb can accurately convey the original author’s intention.</p><p><strong>Example</strong>  </p><ul><li><strong>Argues</strong>: “Smith (2020) argues that climate change is the primary driver of biodiversity loss.”</li><li><strong>Finds</strong>: “The study finds a significant relationship between early childhood education and later academic success.”</li></ul><hr><h3 id="Interested-Topic"><a href="#Interested-Topic" class="headerlink" title="Interested Topic"></a>Interested Topic</h3><p><strong>Definition</strong><br>A topic related to one’s academic interests. Choosing a topic of personal interest can enhance motivation and quality of research.</p><p><strong>Example</strong>  </p><ul><li><strong>Interested Topic</strong>: “The role of artificial intelligence in personalized medicine.”</li><li><strong>Research Direction</strong>: “Examining how AI technologies can tailor medical treatments to individual patient needs.”</li></ul><hr><h3 id="EWA-English-for-Academic-Purposes"><a href="#EWA-English-for-Academic-Purposes" class="headerlink" title="EWA (English for Academic Purposes)"></a>EWA (English for Academic Purposes)</h3><p><strong>Definition</strong><br>Focuses on improving academic writing, reading, listening, and speaking skills to meet the language demands of academic environments.</p><p><strong>Example</strong>  </p><ul><li><strong>Academic Writing</strong>: “Learning to write research papers with clear arguments and proper citations.”</li><li><strong>Academic Reading</strong>: “Developing skills to analyze and understand complex academic texts and articles.”</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;key words:&lt;/p&gt;
&lt;p&gt;format、differences、research paper writing 、writing process、cohesive devices、summary、topic、thesis、focus、par</summary>
      
    
    
    
    
    <category term="English" scheme="http://example.com/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>概率论</title>
    <link href="http://example.com/2024/09/02/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    <id>http://example.com/2024/09/02/%E6%A6%82%E7%8E%87%E8%AE%BA/</id>
    <published>2024-09-02T12:17:48.000Z</published>
    <updated>2024-09-04T11:51:19.545Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正态分布（Normal Distribution），也称为高斯分布（Gaussian Distribution），是统计学中最重要、最常见的一种概率分布。它广泛应用于自然科学、社会科学、经济学和工程学等领域。以下是正态分布的详细讲解：</p></blockquote><h2 id="正态分布的定义"><a href="#正态分布的定义" class="headerlink" title="正态分布的定义"></a><strong>正态分布的定义</strong></h2><p>正态分布是一种连续概率分布，其概率密度函数（PDF）由下式定义：</p><p>$f(x∣μ,σ2)&#x3D;12πσ2exp⁡(−(x−μ)22σ2)f(x | \mu, \sigma^2) &#x3D;\ \frac{1}{\sqrt{2\pi\sigma^2}} \exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)f(x∣μ,σ2)&#x3D;\2πσ21exp(−2σ2(x−μ)2)$</p><p>其中：</p><ul><li>$\mu$是均值，表示分布的中心位置。</li></ul><ul><li><p>$\sigma^2$是方差，表示数据分布的离散程度。</p></li><li><p>$\sigma$ 是标准差，等于方差的平方根。</p></li></ul><h3 id="正态分布的形状"><a href="#正态分布的形状" class="headerlink" title="正态分布的形状"></a><strong>正态分布的形状</strong></h3><p>正态分布的概率密度函数呈现出一个对称的钟形曲线，其主要特征包括：</p><ul><li><p>均值 $\mu$：决定了曲线的中心位置。正态分布是以均值为中心对称的。均值</p></li><li><p>标准差 $\sigma$：决定了曲线的宽度。标准差越大，曲线越宽，数据分布越分散；标准差越小，曲线越窄，数据分布越集中。</p></li></ul><h3 id="正态分布的性质"><a href="#正态分布的性质" class="headerlink" title="正态分布的性质"></a><strong>正态分布的性质</strong></h3><ul><li><p><strong>对称性</strong>：</p><p>正态分布是关于均值$\mu$对称的，意味着平均值的两侧分布是镜像的。</p></li><li><p><strong>68-95-99.7 规则</strong>：</p><p>在正态分布中，数据有约68%落在均值的一个标准差范围内，约95%落在两个标准差范围内，约99.7%落在三个标准差范围内。</p></li><li><p><strong>单峰性</strong>：</p><p>正态分布只有一个峰值，即均值$ \mu$ 处。</p></li></ul><h3 id="标准正态分布"><a href="#标准正态分布" class="headerlink" title="标准正态分布"></a><strong>标准正态分布</strong></h3><p>标准正态分布是均值为0、标准差为1的特殊正态分布。其概率密度函数为：</p><p>其中<br>$$<br>z&#x3D;x−μσz &#x3D; \frac{x - \mu}{\sigma}z&#x3D;σx−μ<br>$$</p><p> 是标准分数（Z分数）。标准正态分布常用于将任意正态分布标准化，从而方便进行统计分析。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a><strong>应用</strong></h3><p>正态分布在许多领域有广泛应用，如：</p><ul><li><strong>自然现象</strong>：许多自然现象（如身高、智商）的数据近似服从正态分布。</li><li><strong>统计推断</strong>：假设数据服从正态分布，可以进行参数估计、假设检验等统计分析。</li><li><strong>误差分析</strong>：由于中心极限定理的作用，很多随机变量的和或平均值趋近于正态分布，即使这些变量本身不服从正态分布。</li></ul><h3 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h3><p>中心极限定理（Central Limit Theorem）是正态分布中的一个重要结果，它表明：对于一个具有任意分布的随机变量，其独立同分布的样本均值，当样本量足够大时，将近似服从正态分布。该定理解释了正态分布在自然界中的普遍性。</p><h3 id="正态分布的图示"><a href="#正态分布的图示" class="headerlink" title="正态分布的图示"></a>正态分布的图示</h3><p>正态分布的图形是一条光滑的钟形曲线，左侧和右侧对称，曲线的宽度由标准差决定。</p><p>样本空间和随机事件是概率论的基本概念，它们构成了概率论的基础。以下是对这两个概念的详细总结：</p><h2 id="样本空间（Sample-Space）"><a href="#样本空间（Sample-Space）" class="headerlink" title="样本空间（Sample Space）"></a><strong>样本空间（Sample Space）</strong></h2><p>   样本空间是概率论中用于描述所有可能结果的集合。</p><p>它是一个实验或随机试验的所有可能结果的集合，用符号$ ( S )$ 或 $( \Omega )$ 表示。</p><ul><li><p><strong>定义</strong>：样本空间是一个集合，其中包含了所有可能的实验结果。例如，在抛掷一枚硬币的实验中，样本空间 ( S ) 包含两个结果，即 $( S &#x3D; { \text{正面}, \text{反面} } )$ 或者 $( S &#x3D; { H, T } )$。</p></li><li><p><strong>离散样本空间</strong>：如果样本空间包含有限个或可数无限多个结果，则称为离散样本空间。例如，掷一个六面骰子的样本空间为$( S &#x3D; {1, 2, 3, 4, 5, 6} )$。</p></li><li><p><strong>连续样本空间</strong>：如果样本空间包含不可数无限多个结果，则称为连续样本空间。例如，在区间 [0, 1] 上随机选取一个数，样本空间为 $( S &#x3D; [0, 1] )$。</p></li></ul><h3 id="随机事件（Random-Event）"><a href="#随机事件（Random-Event）" class="headerlink" title="随机事件（Random Event）"></a><strong>随机事件（Random Event）</strong></h3><p>   随机事件是样本空间的一个子集，它表示实验中可能发生的结果集合。</p><ul><li><p><strong>定义</strong>：随机事件是样本空间的子集，可以包括一个或多个实验结果。例如，在抛掷一枚硬币的实验中，事件 ( A ) 可以是“出现正面”，即 $( A &#x3D; { \text{正面} } )$。</p></li><li><p><strong>简单事件</strong>：简单事件（Elementary Event）是样本空间中的单个元素，表示某个特定的结果。例如，掷骰子得到1的事件是一个简单事件$( A &#x3D; {1} )$。</p></li><li><p><strong>复合事件</strong>：复合事件（Compound Event）是样本空间的一个子集，包含多个可能的结果。例如，掷骰子得到偶数的事件$( B &#x3D; {2, 4, 6} )$是一个复合事件。</p></li><li><p><strong>必然事件</strong>：必然事件（Certain Event）是样本空间本身，表示实验中总会发生的结果。它的概率为1。例如，在掷骰子的实验中，样本空间$( S &#x3D; {1, 2, 3, 4, 5, 6} )$是一个必然事件。</p></li><li><p><strong>不可能事件</strong>：</p><p>不可能事件（Impossible Event）是空集$ ( \emptyset )$，表示实验中永远不会发生的结果。它的概率为0。</p></li></ul><h3 id="随机事件的运算"><a href="#随机事件的运算" class="headerlink" title="随机事件的运算"></a><strong>随机事件的运算</strong></h3><p>   随机事件可以通过集合运算进行组合，形成新的事件。</p><ul><li><p><strong>并集（Union）</strong>：事件 ( A ) 和事件 ( B ) 的并集 </p><p>事件 ( A ) 和事件 ( B ) 的并集$ ( A \cup B )$ 表示“事件 ( A )”或“事件 ( B )”发生的集合。它包含所有在 ( A ) 或 ( B ) 中的元素。</p></li><li><p><strong>交集（Intersection）</strong>：</p><p>事件 ( A ) 和事件 ( B ) 的交集 $( A \cap B )$表示“事件 ( A )”且“事件 ( B )”同时发生的集合。它包含所有同时在 ( A ) 和 ( B ) 中的元素。</p></li><li><p><strong>补集（Complement）</strong>：</p><p>事件 ( A ) 的补集$ ( A^c )$ 表示“事件 ( A )”不发生的集合。它包含所有在样本空间中但不在 ( A ) 中的元素。</p></li></ul><h3 id="随机事件的分类"><a href="#随机事件的分类" class="headerlink" title="随机事件的分类"></a>随机事件的分类</h3><ul><li><p><strong>互斥事件</strong>：两个事件 ( A ) 和 ( B ) 是互斥的（也称为不相容的），如果它们不能同时发生，即 $( A \cap B &#x3D; \emptyset )$。</p></li><li><p><strong>独立事件</strong>：两个事件 ( A ) 和 ( B ) 是独立的，如果其中一个事件的发生不影响另一个事件的发生概率，即$( P(A \cap B) &#x3D; P(A) \times P(B) )$。</p></li></ul><h2 id="概率的定义"><a href="#概率的定义" class="headerlink" title="概率的定义"></a><strong>概率的定义</strong></h2><p>   概率是随机事件发生的可能性度量，通常用 ( P(A) ) 表示事件 ( A ) 的概率。</p><ul><li><p><strong>经典概率</strong>：在有限样本空间中，事件 ( A ) 的概率定义为：<br>$$<br>[<br>P(A) &#x3D; \frac{|A|}{|S|}<br>]<br>$$<br>其中 ( |A| ) 表示事件 ( A ) 中的结果数，( |S| ) 表示样本空间中的总结果数。</p></li><li><p><strong>频率解释</strong>：概率也可以理解为在大量重复实验中事件发生的相对频率。</p></li><li><p><strong>公理化定义</strong>：安德雷·科尔莫戈罗夫（Andrey Kolmogorov）提出的公理化概率定义，包括三个公理：</p><ol><li><p>$( 0 \leq P(A) \leq 1 )$对任意事件 ( A ) 成立。</p></li><li><p>$( P(S) &#x3D; 1 )$。</p></li><li><p>若事件$( A_1, A_2, \dots )$是互斥事件，则<br>$$<br>( P\left(\bigcup_{i&#x3D;1}^{\infty} A_i\right) &#x3D; \sum_{i&#x3D;1}^{\infty} P(A_i) )<br>$$</p></li></ol></li></ul><p>事件的关系及其运算是概率论中的重要内容，涉及如何组合不同的随机事件以及如何计算这些组合事件的概率。以下是关于事件关系及其运算的详细总结：</p><h3 id="事件的基本概念"><a href="#事件的基本概念" class="headerlink" title="事件的基本概念"></a><strong>事件的基本概念</strong></h3><ul><li><p><strong>事件（Event）</strong>：事件是样本空间的一个子集，表示实验中可能发生的结果集合。</p></li><li><p><strong>简单事件</strong>：只包含一个样本点的事件。</p></li><li><p><strong>复合事件</strong>：包含多个样本点的事件。</p></li><li><p><strong>必然事件</strong>：包含样本空间中所有可能结果的事件，通常表示为 ( S )。</p></li><li><p><strong>不可能事件</strong>：不包含任何样本点的事件，表示为空集 $( \emptyset )$</p><p>。</p></li></ul><h3 id="事件之间的关系"><a href="#事件之间的关系" class="headerlink" title="事件之间的关系"></a>事件之间的关系</h3><ul><li><p><strong>包含关系</strong>：如果事件 ( A ) 的所有结果都包含在事件 ( B ) 中，则称事件 ( A ) 包含于事件 ( B ) 中，记为 </p><p>$( A \subseteq B )$。</p></li><li><p><strong>相等关系</strong>：如果事件 ( A ) 和 ( B ) 包含完全相同的结果，则 ( A &#x3D; B )。</p></li></ul><h3 id="事件的运算"><a href="#事件的运算" class="headerlink" title="事件的运算"></a>事件的运算</h3><p>   事件可以通过集合运算进行组合，形成新的事件。常见的运算包括并集、交集和补集。</p><ul><li><p><strong>并集（Union）</strong>：事件 ( A ) 和事件 ( B ) 的并集 $( A \cup B )$</p><p>表示“事件 ( A )”或“事件 ( B )”发生的集合。并集包含所有在 ( A ) 或 ( B ) 中的结果。用语言描述就是“或”。</p><ul><li><strong>运算公式</strong>：<br>$$<br>( P(A \cup B) &#x3D; P(A) + P(B) - P(A \cap B) )<br>$$</li></ul></li><li><p><strong>交集（Intersection）</strong>：事件 ( A ) 和事件 ( B ) 的交集 $( A \cap B )$</p><p>表示“事件 ( A )”且“事件 ( B )”同时发生的集合。交集包含所有同时在 ( A ) 和 ( B ) 中的结果。用语言描述就是“且”。</p><ul><li><strong>运算公式</strong>：若 ( A ) 和 ( B ) 独立，则<br>$$<br>( P(A \cap B) &#x3D; P(A) \times P(B) )<br>$$<br>。</li></ul></li><li><p><strong>补集（Complement）</strong>：事件 ( A ) 的补集 $( A^c )$</p><p>表示“事件 ( A )”不发生的集合。补集包含所有在样本空间中但不在 ( A ) 中的结果。</p><ul><li><strong>运算公式</strong>：<br>$$<br>( P(A^c) &#x3D; 1 - P(A) )<br>$$</li></ul></li></ul><h3 id="事件的分类"><a href="#事件的分类" class="headerlink" title="事件的分类"></a>事件的分类</h3><ul><li><p><strong>互斥事件（Mutually Exclusive Events）</strong>：两个事件 ( A ) 和 ( B ) 是互斥的，如果它们不能同时发生，即 </p><p>$( A \cap B &#x3D; \emptyset )$</p><p>。互斥事件的并集概率为两个事件概率的和：</p><ul><li><strong>公式</strong>：<br>$$<br>( P(A \cup B) &#x3D; P(A) + P(B) )<br>$$<br>（仅适用于互斥事件）。</li></ul></li><li><p><strong>独立事件（Independent Events）</strong>：两个事件 ( A ) 和 ( B ) 是独立的，如果其中一个事件的发生不影响另一个事件的发生概率。对于独立事件，交集概率为两个事件概率的乘积：</p><ul><li><strong>公式</strong>：<br>$$<br>( P(A \cap B) &#x3D; P(A) \times P(B) )<br>$$<br>。</li></ul></li></ul><h3 id="全概率公式和贝叶斯公式"><a href="#全概率公式和贝叶斯公式" class="headerlink" title="全概率公式和贝叶斯公式"></a>全概率公式和贝叶斯公式</h3><ul><li><p><strong>全概率公式</strong>：用于计算一个事件的概率，基于事件的分解。设<br>$$<br>( B_1, B_2, \dots, B_n )<br>$$<br> 是样本空间的一个划分，则对任意事件 ( A ) 有：<br>$$<br>[<br>P(A) &#x3D; \sum_{i&#x3D;1}^{n} P(A \cap B_i) &#x3D; \sum_{i&#x3D;1}^{n} P(A | B_i) \cdot P(B_i)<br>]<br>$$</p></li><li><p><strong>贝叶斯公式（Bayes’ Theorem）</strong>：用于反向计算条件概率。设 ( B_1, B_2, \dots, B_n ) 是样本空间的一个划分，则对于任意事件 ( A ) 和 ( B_j )，有：<br>$$<br>[<br>P(B_j | A) &#x3D; \frac{P(A | B_j) \cdot P(B_j)}{\sum_{i&#x3D;1}^{n} P(A | B_i) \cdot P(B_i)}<br>]<br>$$</p></li></ul><h3 id="事件的运算性质"><a href="#事件的运算性质" class="headerlink" title="事件的运算性质"></a>事件的运算性质</h3><ul><li><p><strong>交换律</strong>：</p><ul><li>$$<ul><li>( A \cup B &#x3D; B \cup A )\\</li><li>( A \cap B &#x3D; B \cap A )<br>$$</li></ul></li></ul></li><li><p><strong>结合律</strong>：</p><ul><li>$$<ul><li>( (A \cup B) \cup C &#x3D; A \cup (B \cup C) )\\</li><li>( (A \cap B) \cap C &#x3D; A \cap (B \cap C) )<br>$$</li></ul></li></ul></li><li><p><strong>分配律</strong>：</p><ul><li>$$<ul><li>( A \cap (B \cup C) &#x3D; (A \cap B) \cup (A \cap C) )\\</li><li>( A \cup (B \cap C) &#x3D; (A \cup B) \cap (A \cup C) )<br>$$</li></ul></li></ul></li><li><p><strong>德·摩根律（De Morgan’s Laws）</strong>：</p><ul><li>$$<ul><li>( (A \cup B)^c &#x3D; A^c \cap B^c )\\</li><li>( (A \cap B)^c &#x3D; A^c \cup B^c )<br>$$</li></ul></li></ul></li></ul><h3 id="事件的运算实例"><a href="#事件的运算实例" class="headerlink" title="事件的运算实例"></a>事件的运算实例</h3><ul><li><p><strong>例1：掷骰子</strong>。设事件 ( A ) 表示“掷出偶数”，事件 ( B ) 表示“掷出的数大于4”。则：</p><ul><li>$$<ul><li>( A &#x3D; {2, 4, 6} )\\</li><li>( B &#x3D; {5, 6} )\\</li><li>( A \cup B &#x3D; {2, 4, 5, 6} )\\</li><li>( A \cap B &#x3D; {6} )\\</li><li>( A^c &#x3D; {1, 3, 5} )<br>$$</li></ul></li></ul></li><li><p><strong>例2：抽牌</strong>。从一副52张的扑克牌中随机抽取一张。设事件 ( A ) 表示“抽到红色的牌”，事件 ( B ) 表示“抽到一张A”。则：</p><ul><li>$$<ul><li>( A &#x3D; {红心A, 红心2, \dots, 红心K, 方块A, 方块2, \dots, 方块K} )\\</li><li>( B &#x3D; {红心A, 黑桃A, 梅花A, 方块A} )\\</li><li>( A \cup B ) 包含所有红色牌和其他两张A牌。\\</li><li>( A \cap B &#x3D; {红心A, 方块A} )\\</li><li>( A^c ) 包含所有黑色牌。<br>$$</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;正态分布（Normal Distribution），也称为高斯分布（Gaussian Distribution），是统计学中最重要、最常见的一种概率分布。它广泛应用于自然科学、社会科学、经济学和工程学等领域。以下是正态分布的详细讲解：&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法：数学</title>
    <link href="http://example.com/2024/08/20/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E5%AD%A6/"/>
    <id>http://example.com/2024/08/20/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E5%AD%A6/</id>
    <published>2024-08-20T11:41:21.000Z</published>
    <updated>2024-08-20T12:26:43.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1矩阵"><a href="#1-1矩阵" class="headerlink" title="1.1矩阵"></a>1.1矩阵</h1><h2 id="1-1-1矩阵类"><a href="#1-1-1矩阵类" class="headerlink" title="1.1.1矩阵类"></a>1.1.1矩阵类</h2><ul><li>任务：</li></ul><p>实现矩阵的基本变换</p><ul><li>接口</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">结构体：Matrix</span><br><span class="line">成员变量：</span><br><span class="line"><span class="type">int</span> n,m 矩阵大小</span><br><span class="line"><span class="type">int</span> a[][] 矩阵内容</span><br><span class="line">重载运算符：+、-、x</span><br><span class="line">成员函数：</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> 清空矩阵</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="type">int</span> a[MAXN][MAXM];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n=m=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    &#125; </span><br><span class="line">    Matrix <span class="keyword">operator</span>+(<span class="type">const</span> Matrix&amp;b) <span class="type">const</span>&#123;</span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n;</span><br><span class="line">        tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.a[i][j]=a[i][j]+b.a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>-(<span class="type">const</span> Matrix&amp;b) <span class="type">const</span>&#123;</span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n;</span><br><span class="line">        tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.a[i][j]=a[i][j]-b.a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix&amp;b) <span class="type">const</span>&#123;</span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n;</span><br><span class="line">        tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.a[i][j]+=a[i][k]*b.a[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><h4 id="矩阵乘法分析，在线性代数里面，矩阵的乘法规则如下："><a href="#矩阵乘法分析，在线性代数里面，矩阵的乘法规则如下：" class="headerlink" title="矩阵乘法分析，在线性代数里面，矩阵的乘法规则如下："></a>矩阵乘法分析，在线性代数里面，矩阵的乘法规则如下：</h4></li></ul><p>矩阵中某行（n）某列（m）确定的元素的值，等于前一个矩阵的该行向量（n，k）与后一个矩阵的该列向量（k，m）的乘积，k代表行向量和列向量中的第几个值。</p><ul><li><h4 id="重载运算符的规则"><a href="#重载运算符的规则" class="headerlink" title="重载运算符的规则"></a>重载运算符的规则</h4></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix&amp;b) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="comment">//本质是一个函数，传入的参数是常引用，函数本身是常函数，不可更改</span></span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n;</span><br><span class="line">        tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.a[i][j]+=a[i][k]*b.a[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1-1-2Gauss消元"><a href="#1-1-2Gauss消元" class="headerlink" title="1.1.2Gauss消元"></a>1.1.2Gauss消元</h2><ul><li>任务：</li></ul><p>给一个n元一次方程组，求它们的解集</p><ul><li>说明</li></ul><p>将方程组做成矩阵形式，再利用三种初等矩阵变换，得到上三角矩阵，最后回代得到解集。</p><ul><li>接口</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">double</span> a[][MAXN],<span class="type">bool</span> l[],<span class="type">double</span> ans[],<span class="type">const</span> <span class="type">int</span>&amp;n)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>复杂度</li></ul><p>$$<br>O(n^3)<br>$$</p><ul><li>输入</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a 方程组对应的矩阵</span><br><span class="line">n 未知数个数</span><br><span class="line">l，ans 存储解，l[]表示是否为自由元</span><br></pre></td></tr></table></figure><ul><li>输出</li></ul><p>解空间的维数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-1矩阵&quot;&gt;&lt;a href=&quot;#1-1矩阵&quot; class=&quot;headerlink&quot; title=&quot;1.1矩阵&quot;&gt;&lt;/a&gt;1.1矩阵&lt;/h1&gt;&lt;h2 id=&quot;1-1-1矩阵类&quot;&gt;&lt;a href=&quot;#1-1-1矩阵类&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法：栈与队列</title>
    <link href="http://example.com/2024/08/20/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2024/08/20/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2024-08-20T01:00:40.000Z</published>
    <updated>2024-09-04T14:42:33.376Z</updated>
    
    <content type="html"><![CDATA[<p>1212</p><h2 id="栈与队列理论基础"><a href="#栈与队列理论基础" class="headerlink" title="栈与队列理论基础"></a>栈与队列理论基础</h2><h3 id="栈（stack）："><a href="#栈（stack）：" class="headerlink" title="栈（stack）："></a>栈（stack）：</h3><p>先进后出，属于STL中的数据结构，提供push、pop等外部接口，栈不提供走访功能，以及迭代器（iterator）。</p><h4 id="初始化语句"><a href="#初始化语句" class="headerlink" title="初始化语句"></a>初始化语句</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure><h3 id="队列（queue）："><a href="#队列（queue）：" class="headerlink" title="队列（queue）："></a>队列（queue）：</h3><p>先进先出，属于STL中的数据结构，如果是双向队列，简写就是deque。</p><h4 id="初始化语句-1"><a href="#初始化语句-1" class="headerlink" title="初始化语句"></a>初始化语句</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235346563.png" alt="栈与队列理论1"></p><blockquote><p>在STL中，栈和队列两种数据结构都不被归类为容器，而被归类为container adapter（容器适配器）</p></blockquote><h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p><p>实现 <code>MyQueue</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li><li><code>int pop()</code> 从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li></ul><p><strong>说明：</strong></p><ul><li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><p><strong>进阶：</strong></p><ul><li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初等构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接复用栈的push函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="comment">//pop的逻辑是退出一个元素，如果还有元素，那就不用再从s1中push元素。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将s1的所有元素都push到s2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> a=s2.<span class="built_in">top</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> a;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        s2.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>()&amp;&amp;s2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>例如用双栈实现队列的以下功能</p><ul><li>pop</li><li>peek</li><li>empty</li><li>push</li></ul><p>实现功能的前提是熟知这个功能的具体内容是什么。</p><h5 id="pop函数的功能："><a href="#pop函数的功能：" class="headerlink" title="pop函数的功能："></a>pop函数的功能：</h5><p>将最先进入队列的元素推出队列，并返回它的值。我们将功能依次翻译为代码，最先进入队列的元素：使用双栈，用out栈反向接受in栈的元素（我们只有栈作为工具，栈的特点是后进后出，我们的操作是为了让最先进队列的元素变成最先进栈的元素）、使用一个值记录要推出的元素的值，再对栈使用pop函数，将该元素退出。</p><h5 id="peek函数的功能："><a href="#peek函数的功能：" class="headerlink" title="peek函数的功能："></a>peek函数的功能：</h5><p>要返回最后进入队列的元素，搭载队列的底层数据结构是栈，直接将队列当栈使用，调用栈的top函数。</p><h5 id="empty函数的功能："><a href="#empty函数的功能：" class="headerlink" title="empty函数的功能："></a>empty函数的功能：</h5><p>当in栈和out栈都为空时，队列才为空，我们只需要返回一个判定两者是否同时为空的布尔变量。</p><h5 id="push函数的功能："><a href="#push函数的功能：" class="headerlink" title="push函数的功能："></a>push函数的功能：</h5><p>要返回最后进入队列的元素，搭载队列的底层数据结构是栈，直接将队列当栈使用，调用栈的push函数。</p><blockquote><p>整体的程序设计其实有部分问题，在使用过队列的pop函数过后，in栈的元素全都逆向进入了out栈，此时再用栈的push函数，新元素进入in栈，这个时候问题就出现了，in栈和out栈的元素失去了原先的顺序特征。因此，在pop函数达到目标功能过后，最好把out栈的元素归位。</p><p>注意：上方的注释忽略了一个事实，pop函数在执行的时候是有前提的，out栈为空，这样函数整体的逻辑就像从要从顶部将竹子分为竹节，我们为了便利（等竹子生长），从竹子的根部以上将其砍开，先分解上部的竹节，而下面竹子的生长能够继续，当我们分解完上部的竹节之后，再将下面的竹节砍下，继续分解，这样既不会耽误我们分解竹子，也不会耽误竹子生长。</p></blockquote><h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 x 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用队列的标准操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li><li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // 返回 2</span><br><span class="line">myStack.pop(); // 返回 2</span><br><span class="line">myStack.empty(); // 返回 False</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li><li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li></ul><p><strong>进阶：</strong>你能否仅用一个队列来实现栈。</p><p>利用队列实现栈</p><blockquote><p>这部分的程序设计可以抽象出队列元素的特点，就像用栈实现队列的时候一样，是从顶上开始分解竹子的逻辑。这边将优先级放到了顶部的竹节上，类似地，可以将这个属性进行迁移。就像重要度不同的一系列人请你帮忙，假设队列的逻辑是从最重要的人开始处理，那栈的逻辑就是从最不重要的人开始处理，要用队列的逻辑实现栈的逻辑，就得将最重要的人转变为最不重要的人，这里选择的方式是将重要的人（具有优先处理权）直接转移到另一个队列里，然后将最不重要的人视为最重要的人处理。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que2; <span class="comment">// 辅助队列，用来备份</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que1.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123; <span class="comment">// 将que1 导入que2，但要留下最后一个元素</span></span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = que1.<span class="built_in">front</span>(); <span class="comment">// 留下的最后一个元素就是要返回的值</span></span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line">        que1 = que2;            <span class="comment">// 再将que2赋值给que1</span></span><br><span class="line">        <span class="keyword">while</span> (!que2.<span class="built_in">empty</span>()) &#123; <span class="comment">// 清空que2</span></span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element.</span></span><br><span class="line"><span class="comment">     ** Can not use back() direactly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que1.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--)&#123;</span><br><span class="line">            <span class="comment">// 将que1 导入que2，但要留下最后一个元素</span></span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = que1.<span class="built_in">front</span>(); <span class="comment">// 留下的最后一个元素就是要回返的值</span></span><br><span class="line">        que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());   <span class="comment">// 获取值后将最后一个元素也加入que2中，保持原本的结构不变</span></span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        que1 = que2; <span class="comment">// 再将que2赋值给que1</span></span><br><span class="line">        <span class="keyword">while</span> (!que2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 清空que2</span></span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>整体的程序设计其实有部分问题，在使用过队列的pop函数过后，in栈的元素全都逆向进入了out栈，此时再用栈的push函数，新元素进入in栈，这个时候问题就出现了，in栈和out栈的元素失去了原先的顺序特征。因此，在pop函数达到目标功能过后，最好把out栈的元素归位。</p></blockquote><p>我在用栈实现队列的时候，提到了这个细节，现在它能在队列实现栈时派上用场。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>在使用单个队列进行模拟的时候发现，将最不重要的元素化为最重要的元素就可以了，然而在实现的过程中，需要新开队列空间，将需要移除的元素暂存，等处理完目标元素之后，再将它们放回来，实际上并不需要这样操作。要做的事情就只有将元素移除，再添加进当前队列，直接让最加入的元素变成最先加入的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123; <span class="comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span></span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = que.<span class="built_in">front</span>(); <span class="comment">// 此时弹出的元素顺序就是栈的顺序了</span></span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element.</span></span><br><span class="line"><span class="comment">     ** Can not use back() direactly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--)&#123;</span><br><span class="line">            <span class="comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span></span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = que.<span class="built_in">front</span>(); <span class="comment">// 此时获得的元素就是栈顶的元素了</span></span><br><span class="line">        que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());    <span class="comment">// 将获取完的元素也重新添加到队列尾部，保证数据结构没有变化</span></span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><p><img src="https://code-thinking.cdn.bcebos.com/gifs/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="20.有效括号"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果s的长度为奇数，一定不符合要求</span></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span></span><br><span class="line">            <span class="comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>(); <span class="comment">// st.top() 与 s[i]相等，栈弹出元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h2><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= S.length &lt;= 20000</code></li><li><code>S</code> 仅由小写英文字母组成。</li></ol><p><img src="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif" alt="1047.删除字符串中的所有相邻重复项"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> s : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || s != st.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// s 与 st.top()相等的情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123; <span class="comment">// 将栈中元素放到result字符串汇总</span></span><br><span class="line">            result += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span> (result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 此时字符串需要反转一下</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h2><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p><p>请你计算该表达式。返回一个表示表达式值的整数。</p><p><strong>注意：</strong></p><ul><li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li><li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li><li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li><li>表达式中不含除零运算。</li><li>输入是一个根据逆波兰表示法表示的算术表达式。</li><li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= tokens.length &lt;= 104</code></li><li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li></ul><p><strong>逆波兰表达式：</strong></p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><ul><li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li><li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li></ul><p>逆波兰表达式主要有以下两个优点：</p><ul><li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li><li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li></ul><p><img src="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="150.逆波兰表达式求值"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 力扣修改了后台测试数据，需要用longlong</span></span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; st; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(num2 + num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;-&quot;</span>) st.<span class="built_in">push</span>(num2 - num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;*&quot;</span>) st.<span class="built_in">push</span>(num2 * num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;/&quot;</span>) st.<span class="built_in">push</span>(num2 / num1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoll</span>(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>(); <span class="comment">// 把栈里最后一个元素弹出（其实不弹出也没事）</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回 <em>滑动窗口中的最大值</em> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><p>在解决滑动窗口最大值的问题的时候，我们注意到P：小窗口向右移动、Q：窗口右端达到数组的右端，在P中，小窗口的元素进出规律如下：小窗口最多容纳k个元素，小窗口每次向右移动一格，会push一个新元素，而窗口内部，最先进来的那个元素被pop出去，这就是队列的先进先出的思想。而整个题目还给我们留下了一个R：输出滑动窗口的最大值。</p><p>最后我们解决这个题目要做到的就是<br>$$<br>P\cap Q\cap R<br>$$<br>实现思路就是建立一个单向队列充当小窗口，然后我们每次从滑动窗口里面取k个元素，总体的进程是让窗口向滑动窗口的右端移动。</p><p>队列的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="built_in">empty</span>()&amp;&amp;val==que.<span class="built_in">front</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(val&gt;que.<span class="built_in">back</span>()&amp;&amp;!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对此处代码的理解，现在回忆代码内容，能注意到正确的逻辑如下：push函数的意义是，当val大于back处的值时，将back处的值pop掉，一直这样操作，直到val大于back处的值，将val作为back处的值，一直这样操作，让整个队列处于递增的情况。</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">queue</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="built_in">empty</span>()&amp;&amp;val==que.<span class="built_in">front</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()&amp;&amp;val&gt;que.<span class="built_in">back</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i-k]);</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p><p>要解决这个题目，我们首先需要了解堆是什么。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1212&lt;/p&gt;
&lt;h2 id=&quot;栈与队列理论基础&quot;&gt;&lt;a href=&quot;#栈与队列理论基础&quot; class=&quot;headerlink&quot; title=&quot;栈与队列理论基础&quot;&gt;&lt;/a&gt;栈与队列理论基础&lt;/h2&gt;&lt;h3 id=&quot;栈（stack）：&quot;&gt;&lt;a href=&quot;#栈（stack）</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>离散数学：逻辑与证明（1）</title>
    <link href="http://example.com/2024/08/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    <id>http://example.com/2024/08/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</id>
    <published>2024-08-19T06:09:35.000Z</published>
    <updated>2024-08-19T06:10:52.636Z</updated>
    
    <content type="html"><![CDATA[<p>113</p><h2 id="第⼀章-逻辑与证明-Logic-and-Proof"><a href="#第⼀章-逻辑与证明-Logic-and-Proof" class="headerlink" title="第⼀章 逻辑与证明 Logic and Proof"></a>第⼀章 逻辑与证明 Logic and Proof</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;113&lt;/p&gt;
&lt;h2 id=&quot;第⼀章-逻辑与证明-Logic-and-Proof&quot;&gt;&lt;a href=&quot;#第⼀章-逻辑与证明-Logic-and-Proof&quot; class=&quot;headerlink&quot; title=&quot;第⼀章 逻辑与证明 Logic and Proof&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="离散数学" scheme="http://example.com/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>算法：程序自由度</title>
    <link href="http://example.com/2024/08/19/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%87%AA%E7%94%B1%E5%BA%A6/"/>
    <id>http://example.com/2024/08/19/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%87%AA%E7%94%B1%E5%BA%A6/</id>
    <published>2024-08-19T02:01:29.000Z</published>
    <updated>2024-08-20T02:11:40.631Z</updated>
    
    <content type="html"><![CDATA[<p>在研究算法的时间复杂度和空间复杂度的时候，总是会遇到，在写出一个完整的算法程序之前，无法预判这个算法的时间复杂度和空间复杂度的情况，从而出现思路混乱，每一步都依靠灵感思考的问题。在这篇文章，我将着重于时间复杂度和空间复杂度背后的底层逻辑，在写出算法前，预判其两种复杂度。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在反转链表的算法练习中，我们着重于分析链表反转的基本自由度，在一开始的陌生化思考过程中，我们提到了一种类似于数组反转的算法，即直接对链表中的元素做一个镜像对称，但是在思考过后，我们发现这种算法并不可取，为什么呢？问题就出在程序的自由度上，由于这是我自己的算法笔记，我就在这里规定一些我个人定义的概念：</p><ul><li><strong>空间自由度：</strong></li></ul><p>是指元素受数据结构的影响，必须按照某种规则进行操作的受限程度。比如在链表这个数据结构中，对元素的表示不能使用索引，必须遍历到某个特定的节点之上才能调用节点的成员，对数据结构的限制的抵抗体现为这个遍历的过程。很明显，链表的遍历是一维遍历，而这里的由于链表的数据结构，在数组中属于单元操作的步骤，变成了一维操作。</p><ul><li><strong>遍历自由度</strong></li></ul><p>就是指必须完成的运算步骤（遍历过程）需要运算的规模。比如链表，我们对其的遍历自由度是一维，然而矩阵则是二维.</p><ul><li><strong>基元程序</strong></li></ul><p>基本算法就是执行同一个步骤的程序.例如反转链表之中,就只需要存元素、反向、移动元素、移动元素这个循环。</p><ul><li><h5 id="距离格数"><a href="#距离格数" class="headerlink" title="距离格数"></a>距离格数</h5></li></ul><p>在处理双指针问题的时候，通常会遇到不知道怎么处理循环次数的问题,这里提出一种从距离视角出发，解决循环次数问题的方法。</p><p>总所周知,如果有n棵树，那么就会有n-1个间隔，在数组的数据结构的背景下，索引会比实际的元素序数少1位。在进行一个基元操作之后,实际上是跨越了一个距离，可以在观测元素未知的时候，从三个角度出发：其一是序数，其二是索引，其三是跨度。</p><ul><li>序数</li></ul><p>序数对应实际考虑问题时，分析的对象。</p><ul><li>索引</li></ul><p>索引是在写代码时，需要序数转化为的对象。</p><ul><li>跨度</li></ul><p>跨度是某个维度遍历，在空间上呈现的变化。</p><p>在考虑第n个元素时，可以知道它的索引应该是n-1，而跨度也是n-1。如果考虑镜像对称的元素，能发现对称元素的序数和恒定为n+1，索引恒定为n-1，跨度之和为n-1（对称之后处于同一位置）。</p><h4 id="while语句与for语句的对比"><a href="#while语句与for语句的对比" class="headerlink" title="while语句与for语句的对比"></a>while语句与for语句的对比</h4><p>在使用两个循环语句的时候，while语句更适合条件循环，而for语句则更适合扫描循环，这使得while在更复杂的条件下，使用起来更加方便，可以用抽象条件来控制循环。</p><h4 id="逻辑语句的快速判断"><a href="#逻辑语句的快速判断" class="headerlink" title="逻辑语句的快速判断"></a>逻辑语句的快速判断</h4><p>现在观察到的逻辑运算符号中，比较容易弄混的有：！&#x3D;、while语句判断条件、a？b：c运算。</p><ul><li>a！+while（for）：a不成立时运行。</li></ul><h4 id="高精度循环"><a href="#高精度循环" class="headerlink" title="高精度循环"></a>高精度循环</h4><p>在复杂的算法问题中，我们经常用到非二维遍历的双重循环。在用到这样的循环时，应该考虑些什么问题呢？</p><ul><li>筛选型</li></ul><p>这类高精度循环，外层通常套了抽象条件的循环，而内层存在if语句，作为目标条件的筛选，到达外部抽象条件后，内部循环处理的是题目要求的内容。</p><ul><li>去重型</li></ul><p>在三数之和的问题中，用到了while语句进行去重，算是一个条件指令。</p><h4 id="仿射变换实现"><a href="#仿射变换实现" class="headerlink" title="仿射变换实现"></a>仿射变换实现</h4><h4 id="功能性程序"><a href="#功能性程序" class="headerlink" title="功能性程序"></a>功能性程序</h4><p>例如用双栈实现队列的以下功能</p><ul><li>pop</li><li>peek</li><li>empty</li><li>push</li></ul><p>实现功能的前提是熟知这个功能的具体内容是什么。</p><h5 id="pop函数的功能："><a href="#pop函数的功能：" class="headerlink" title="pop函数的功能："></a>pop函数的功能：</h5><p>将最先进入队列的元素推出队列，并返回它的值。我们将功能依次翻译为代码，最先进入队列的元素：使用双栈，用out栈反向接受in栈的元素（我们只有栈作为工具，栈的特点是后进后出，我们的操作是为了让最先进队列的元素变成最先进栈的元素）、使用一个值记录要推出的元素的值，再对栈使用pop函数，将该元素退出。</p><h5 id="peek函数的功能："><a href="#peek函数的功能：" class="headerlink" title="peek函数的功能："></a>peek函数的功能：</h5><p>要返回最后进入队列的元素，搭载队列的底层数据结构是栈，直接将队列当栈使用，调用栈的top函数。</p><h5 id="empty函数的功能："><a href="#empty函数的功能：" class="headerlink" title="empty函数的功能："></a>empty函数的功能：</h5><p>当in栈和out栈都为空时，队列才为空，我们只需要返回一个判定两者是否同时为空的布尔变量。</p><h5 id="push函数的功能："><a href="#push函数的功能：" class="headerlink" title="push函数的功能："></a>push函数的功能：</h5><p>要返回最后进入队列的元素，搭载队列的底层数据结构是栈，直接将队列当栈使用，调用栈的push函数。</p><blockquote><p>整体的程序设计其实有部分问题，在使用过队列的pop函数过后，in栈的元素全都逆向进入了out栈，此时再用栈的push函数，新元素进入in栈，这个时候问题就出现了，in栈和out栈的元素失去了原先的顺序特征。因此，在pop函数达到目标功能过后，最好把out栈的元素归位。</p><p>注意：上方的注释忽略了一个事实，pop函数在执行的时候是有前提的，out栈为空，这样函数整体的逻辑就像从要从顶部将竹子分为竹节，我们为了便利（等竹子生长），从竹子的根部以上将其砍开，先分解上部的竹节，而下面竹子的生长能够继续，当我们分解完上部的竹节之后，再将下面的竹节砍下，继续分解，这样既不会耽误我们分解竹子，也不会耽误竹子生长。</p></blockquote><p>利用队列实现栈</p><p>这部分的程序设计可以抽象出队列元素的特点，就像用栈实现队列的时候一样，是从顶上开始分解竹子的逻辑。这边将优先级放到了顶部的竹节上，类似地，可以将这个属性进行迁移。就像重要度不同的一系列人请你帮忙，假设队列的逻辑是从最重要的人开始处理，那栈的逻辑就是从最不重要的人开始处理，要用队列的逻辑实现栈的逻辑，就得将最重要的人转变为最不重要的人，这里选择的方式是将重要的人（具有优先处理权）直接转移到另一个队列里，然后将最不重要的人视为最重要的人处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在研究算法的时间复杂度和空间复杂度的时候，总是会遇到，在写出一个完整的算法程序之前，无法预判这个算法的时间复杂度和空间复杂度的情况，从而出现思路混乱，每一步都依靠灵感思考的问题。在这篇文章，我将着重于时间复杂度和空间复杂度背后的底层逻辑，在写出算法前，预判其两种复杂度。&lt;/</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>神樹の館竜胆線</title>
    <link href="http://example.com/2024/08/17/%E7%A5%9E%E6%A8%B9%E3%81%AE%E9%A4%A8%E7%AB%9C%E8%83%86%E7%B7%9A/"/>
    <id>http://example.com/2024/08/17/%E7%A5%9E%E6%A8%B9%E3%81%AE%E9%A4%A8%E7%AB%9C%E8%83%86%E7%B7%9A/</id>
    <published>2024-08-17T14:51:04.000Z</published>
    <updated>2024-08-19T12:55:37.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="竜胆01a"><a href="#竜胆01a" class="headerlink" title="竜胆01a"></a>竜胆01a</h2><p>◇00000001◇―――時という言葉は―――<br>◆00000001◆―――所谓时间―――</p><p>◇00000002◇―――『とける』とか『とかす』という言葉と似ていると思わない？<br>◆00000002◆―――不觉得和“融化”还有溶解这样的言语相似吗？</p><p>◇00000003◇―――硬く冷たい氷が溶けて流れ出すように。<br>◆00000003◆―――不觉得宛若坚硬冰冷的冰块溶解流淌一般。</p><p>◇00000004◇―――物事がたえず移り変わり、流れていくことを言うのだと思わない？<br>◆00000004◆―――事物在不断迁移变换，流动着吗？</p><p>◇00000005◇―――変わらないで、凍りついたままでいるのは、時が停まっているのと同じ。<br>◆00000005◆―――处于不变之中，持续冰封的状态，直与时间停滞仿佛。</p><p>◇00000006◇―――それは死んでいるのと一緒よ。<br>◆00000006◆―――那与持续死亡是一样的。</p><p>◇00000007◇―――だから―――<br>◆00000007◆―――于是乎―――</p><p>◇00000008◇―――凍りついた私の時を動かして―――<br>◆00000008◆―――驱以被冰封之吾之时间―――</p><p>◇00000009◇―――嘆かないで。<br>◆00000009◆―――勿要叹息。</p><p>◇00000010◇―――哀しまないで。<br>◆00000010◆―――勿要哀伤。</p><p>◇00000011◇―――恐れないで。<br>◆00000011◆―――勿要恐慌。</p><p>◇00000012◇―――なにかが変わってしまったとしても。<br>◆00000012◆―――就算将至何物之改变。</p><p>◇00000013◇―――たとえお互い見失ってしまったとしても。<br>◆00000013◆―――就算目睹彼此之沦丧。</p><p>◇00000014◇―――私はいる。<br>◆00000014◆―――吾永远于此。</p><p>◇00000015◇―――ずっとあなたを待っている。<br>◆00000015◆―――等候汝之到来。</p><p>◇00000016◇―――また、逢いましょう―――<br>◆00000016◆―――再次，逢迎吧―――</p><p>◇00000017◇―――ボォ―――ォ―――ォ―――<br>◆00000017◆―――嘣―――哦―――哦―――</p><p>◇00000018◇―――ンンン―――ンンンン…………<br>◆00000018◆―――嗯嗯嗯―――嗯嗯嗯嗯…………</p><p>◇00000019◇蜜蜂の唸るような旋音が、まだその弾力の深い余韻を工月の耳孔の中に引き残し―――<br>◆00000019◆宛若蜜蜂呢喃的转音，仍旧在工月的耳中，留下富于弹性的余韵―――</p><p>◇00000020◇―――ォ―――ォ―――ンンン―――<br>◆00000020◆―――ォ―――ォ―――ンンン―――</p><p>◇00000021◇―――ンンン―――ンンンン…………<br>◆00000021◆―――ンンン―――ンンンン…………</p><p>◇00000022◇眠りに逃避しようとする彼の意識を縫い止めた。<br>◆00000022◆想要躲避睡意的他，将意识缝补静止。</p><p>◇00000023◇―――ンンン―――ンンンン…………<br>◆00000023◆―――ンンン―――ンンンン…………</p><p>◇00000024◇……ンン……ンンン………………<br>◆00000024◆……ンン……ンンン………………</p><p>◇00000025◇柱時計がどこかで時鐘を鳴らし、機構が巻き戻る音までが{静:せい}{寂:じゃく}を濁らせているのだなと、うとうとと。<br>◆00000025◆不知何处的柱钟敲响了时钟，席卷而来的机器声污浊了静寂，进入浅睡眠。</p><p>◇00000026◇旋音の輪唱も一つ一つと鎮まり、しまいに全き沈黙が立ち返ってきたが、一度破られた眠りはどうあがいても工月の手をすり抜け―――<br>◆00000026◆旋音的轮唱也一阵阵镇定下来，最终万物归寂，不管涌现的睡意如何浓郁，工月都不睡了―――</p><p>◇00000027◇―――ン―――<br>◆00000027◆―――ン―――</p><p>◇00000028◇――――――<br>◆00000028◆――――――</p><p>◇00000029◇なぜ眠りに固執せねばならぬのかという疑念にかられた時、工月はようやく目を覚ました。<br>◆00000029◆此时，怀着为何不得不执着于睡眠的疑问，工月逐渐睁开双眼。</p><p>◇00000030◇覚醒直後の視界は水気が多く焦点がぶれ、はじめはなぜ丸太が頭上にあるのだとどうにも{怪訝:け　げ　ん}だったが、やがてそれが{梁:はり}なのだと思い当たる。<br>◆00000030◆刚苏醒后，眼前有着许多水汽结成的点，刚开始还在惊讶为什么头上有去皮的木材，最后才发现那是房梁。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000031◇（……また随分丈夫そうな造りだな……）<br>◆00000031◆（……还有这样结实的建筑啊……）</p><p>◇00000032◇梁から天井を伝い{欄間:ら　ん　ま}を支える柱も頑丈な屋造り、どれもが艶々と手沢に黒光りしている。<br>◆00000032◆从房梁到天花板，用来支撑栏间的柱子也是兼顾的房屋建筑，无论哪一个都熠熠生辉，散发着经手抛光而有的黑色光泽。</p><p>◇00000033◇敷き布団の綿も暖かで、畳も毛羽立った目などいささかもなく、見事な座敷ではあったが豪奢を押しつけてくるような嫌味はない。<br>◆00000033◆铺设的布团的棉花很温暖，榻榻米也是一尘不染，坐席虽漂亮，但却不显故作奢侈。</p><p>◇00000034◇なのに工月は今まで安らかに抱かれてあった掛け布団が、急に変に蒸し暑く感じられ、自分の息を詰まらせるのではないかという恐怖にかられた。<br>◆00000034◆然而工月在那迄今为止安心地怀抱着的布团上，突然感受到了异常的闷热，他感到恐惧，担心这会让他喘不过气来。</p><p>◇00000035◇布団を蹴り剥がし、まごまごと座敷を見回す。<br>◆00000035◆踢开布团，神思恍惚得回望坐席。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000036◇（ここは―――）<br>◆00000036◆（这个是―――）</p><p>◇00000037◇座敷の調度はやけに巨大に見え、自分へのしかかって押し潰してくるような。<br>◆00000037◆坐席的规模变得十分巨大，开始向着自己拥来。</p><p>◇00000038◇異様な圧迫感にひしがれる工月に、自分が小さな子供に逆戻りしたかのような恐慌が波となって押し寄せる。<br>◆00000038◆工月对此，感受到了异样的压迫感，是否要像小孩子一样调转方向回去的恐惧如同海波一般像他涌来。</p><p>◇00000039◇―――そう、母に手を引いてもらわないと怖くて外にも出られなかったあの頃に。<br>◆00000039◆―――对，就像向母亲伸手却没有应答一般恐怖，那时，出不去外面。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000040◇（いったい―――）<br>◆00000040◆（到底―――）</p><p>◇00000041◇座敷の中に自分以外の誰もいないという孤独がふいごとなって、工月の恐慌をことさらに猛らせるような風を送る。<br>◆00000041◆坐席中除自己外谁都不在，这样的孤独袭来，工月的恐慌愈加强烈，像猛烈的飓风般袭来。</p><p>◇00000042◇なんと恐ろしいのだろう。<br>◆00000042◆这是怎样的恐怖啊。</p><p>◇00000043◇目覚めた時、誰もいてくれないと言うのは。<br>◆00000043◆醒来的时刻，所谓谁都不在身旁。</p><p>◇00000044◇この座敷を隙間なく埋めているこの心細さ、一体誰に抗議すればいいのか判らなくなるほどの心細さに、工月の全身の細胞がてんでばらばらに震え出す。<br>◆00000044◆不给这个坐席留任何死角的谨慎，到了判别不了应该像谁抗争程度的谨慎，工月全身的细胞就像要一粒粒坠落一般。</p><p>◇00000045◇その心細さは喩えるなら、昼とは全く異質の相に様変わりした夜の学校、それも見知らぬ校舎で迷子になった心細さを何倍にも拡大したのに近い。<br>◆00000045◆如果要将这份谨慎作一个比喻，那就是，幻化模样变成了与白天全然为异质相位的夜晚学校，那和将在这座未知校园里迷路的恐惧放大数倍很接近。</p><p>◇00000046◇恐怖は{抗:こう}しようもなく、工月にできることといったら、{強硬症:カ タ レ プ シ ー}を起こした者がするように、背を丸め膝を抱き寄せるくらい。<br>◆00000046◆想与恐惧对抗也没有办法，要说工月能做到的事情的话，就只能像患有强迫症的患者那样，弯着抱膝的程度罢了。</p><p>◇00000047◇己から外界を閉め出して胎児の形に閉じこもろうとした工月の耳に。<br>◆00000047◆将自己以外的世界封闭，化为胎儿的形状的工月的耳朵处。</p><p>☆AAAAAAAA★ ？？？</p><p>◇00000048◇「―――くすっ」<br>◆00000048◆「―――啊啊」</p><p>☆AAAAAAAA★ ？？？</p><p>◇00000049◇「あはは……っ」<br>◆00000049◆「啊哈哈……っ」</p><p>◇00000050◇届いたのは障子戸越しで、座敷の沈黙がなければ聞き逃しそうなほどに{幽:かす}かなものだったが、その声がなければ工月は発狂していたかも知れない。<br>◆00000050◆传达到的是越过了障碍门，那是坐席不陷入沉默就会逃走的细微声响，如果没有那个声音，工月说不定会发狂。</p><p>◇00000051◇かろうじて聴き取った声は、それで体の内側を暖かく安堵させるには至らなかったけれど、ひたすらに退行していこうとする工月に細い糸を垂らした。<br>◆00000051◆艰辛地听到的那声音，虽不至于温暖地安抚身体内部，但向一心想着退缩的工月垂下了一缕细绳。</p><p>◇00000052◇希望に繋がる糸と思われたのは、声に聞き覚えがあったからだった。<br>◆00000052◆之所以认为那是通往希望的线索，那时因为对那个声音感到熟悉。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000053◇（知っている……）<br>◆00000053◆（知道……）</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000054◇（俺は、今の声を知っている……！）<br>◆00000054◆（我，知道刚才那个声音……！）</p><p>◇00000055◇心細さの呪縛にほんの僅かな隙間が開いた。<br>◆00000055◆不安的束缚隙开了细微的裂缝。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000056◇（知っているけれど―――誰だったろうか）<br>◆00000056◆（虽说是知道―――但这是谁呢）</p><p>◇00000057◇物を考えられるようになる、というのはそれだけの余地を頭の中に取り戻すこと。<br>◆00000057◆思考事物，是取回思考余地的唯一办法。</p><p>◇00000058◇ほんの少しだけ思考できる余裕を取り戻した工月は、どうして自分がこんなにも心細いのか、その理由に見当がついたのである。<br>◆00000058◆取回了稍微思考余裕的工月，找到了为什么自己会如此的不安的理由。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000059◇（今の声は、誰だ……そしてここはどこで、なぜ俺はここにいる……！？）<br>◆00000059◆（刚才是声音，是谁……以及这里是哪里，为什么我会在此处……！？）</p><p>◇00000060◇見当がついたのは理由だけ。<br>◆00000060◆寻找到的只有理由。</p><p>◇00000061◇工月の恐怖、心細さは、この座敷がどこで、自分が何故ここにいるのか思い出せないと言う事に拠っていたのだった。<br>◆00000061◆工月的恐惧与不安是由，这个坐席在哪里，自己是因为什么在这里，这样的事情想不起来了导致的。</p><p>◇00000062◇いきなり見知らぬ世界に放り出された赤子の根源的な恐怖に等しく、唯一の救いは自分が何者であるのか、それだけは判っていると言うこと。<br>◆00000062◆与突然之间被流放到了未知世界的婴儿的根源性的恐怖对等，唯一的救赎就是自己到底是谁，唯有这件事是能够判别的。</p><p>◇00000063◇その点だけがまだ自我さえ構築できていない赤子と違うが、状況が判らないことにかけては赤子と同じ。<br>◆00000063◆只有这一点和仍然连自我都不能构筑的婴儿不同，但与不能判别状况的婴儿相同。</p><p>☆AAAAAAAA★ ？？？</p><p>◇00000064◇「―――くすす」<br>◆00000064◆「―――くすす」</p><p>☆AAAAAAAA★ ？？？</p><p>◇00000065◇「ふふ……」<br>◆00000065◆「ふふ……」</p><p>◇00000066◇また声が、声ばかりが聞こえた。<br>◆00000066◆又是那个声音，只有那个声音能听见。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000067◇（―――！）<br>◆00000067◆（―――！）</p><p>◇00000068◇いや、救いはもう一つあった。<br>◆00000068◆不对，救赎还有一个。</p><p>◇00000069◇今の声だ。<br>◆00000069◆就是刚才的声音。</p><p>◇00000070◇その声に聞き覚えがあるということだ。<br>◆00000070◆那个声音我有听过的记忆。</p><p>◇00000071◇溺れる者は藁にもすがると言って、状況に窮じた人間があてにもならない物を必死に追い求める様を喩えるが、今の工月がまさにそれ。<br>◆00000071◆俗话说溺水之人连稻草也会抓住，形容在绝境之中拼命追寻哪怕是没用的东西，此时的工月正是如此。</p><p>◇00000072◇{掴:つか}んだ蜘蛛の糸が伸びきってちぎれてしまうのを恐れるように、工月は声がどこから聞こえてきたのか判らなくなる前に必死で当りをつける。<br>◆00000072◆工月拼命地试图确定声音的来源，正如他害怕手中紧握的蜘蛛丝会被拉断一样，他生怕在找到声音的来源之前就迷失了方向。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000073◇（こっちからだ……っ）<br>◆00000073◆（这边……っ）</p><p>◇00000074◇いったい音というものは、少しでも遮蔽があれば反響でたちどころに源が怪しくなるものだが、今それを言いたてて{躊躇:た　め　ら}えばきっと動き出せなくなる。<br>◆00000074◆声音这种东西，只要有一点遮蔽，就会因为回响而难以确定源头，可是如果现在因为这个犹豫不决，恐怕就再也无法行动了。</p><p>◇00000075◇疑念が自分をがんじがらめにする前に、工月は声が響いてきたとおぼしき障子戸を繰り開けた。<br>◆00000075◆在疑虑将自己束缚住之前，工月迅速拉开了那扇他认为声音传来的障子门。</p><h2 id="竜胆01b"><a href="#竜胆01b" class="headerlink" title="竜胆01b"></a>竜胆01b</h2><p>◇00000001◇工月の足取りは著しく乱れ、心臓は追いかけ回された獲物のように激しく動悸し、破裂しそうなほどのありさま。<br>◆00000001◆工月的脚步变得混乱非凡，心脏宛若被角逐的猎物一般悸动，到了像是要破裂的程度。</p><p>◇00000002◇ここまで彼を追い立てる恐怖というのは、はじめは確かにこの広い座敷に一人きりという心細さだったのだが。<br>◆00000002◆迄今为止追赶工月的恐怖最初确实是，这宽敞房间中独自一人的不安。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000003◇（なぜ―――なぜ追いつけない！？）<br>◆00000003◆（为何———为何不追赶上来！？）</p><p>◇00000004◇もう何度も声のすぐそばまで迫った。<br>◆00000004◆声音已然不知何次，协迫到了身边。</p><p>◇00000005◇今度こそと、もう何度猛然と{襖:ふすま}を開けたろう。<br>◆00000005◆这次才是，已经不知推开了几次拉门。</p><p>◇00000006◇その都度無人の部屋が工月を出迎えた。<br>◆00000006◆每次推开都是空无一人的房间迎接工月。</p><p>◇00000007◇二度、三度それをやられるうちは怒りが工月を突き動かしたのだが、度を超して打ち続くとなると怒りは冷える。<br>◆00000007◆两次，三次被玩弄，工月怒不可遏，三番五次的戏弄浇灭了工月的怒火。</p><p>◇00000008◇怒りが収まれば心細さが再び頭をもたげ、手に負えないことに別の恐怖まで引きつれてきていた。<br>◆00000008◆平息怒气不安再度袭来，招至不输当前的以外的恐怖。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000009◇（ついさっきまで、ほんの数瞬―――いや一瞬前まで間違いなくいた筈なんだ、なのに……）<br>◆00000009◆（截止刚才，在数秒之间———不对，是一瞬间，那明明还在的，但是……）</p><p>◇00000010◇恐怖は疲労を倍加させるし気力も奪う。<br>◆00000010◆恐惧倍增疲劳，夺走了体力。</p><p>◇00000011◇工月は途方に暮れ、ついに廊下にへたりこむ。<br>◆00000011◆工月陷入了穷途末路，瘫坐于走廊。</p><p>◇00000012◇こうして全ての気概を使い果たし、立ちあがる事もできなくなる。<br>◆00000012◆如此竭尽全身气力，已然不能站起。</p><p>◇00000013◇後はこの薄暗い廊下で、干からびていくだけ。<br>◆00000013◆随后只能于这昏暗走廊中，干涸然后逝去。</p><p>◇00000014◇工月が最期の息を虚空に放つ瞬間、廊下の両脇の扉が一斉に開き、無数の顔が突きだされてきて嘲笑うのではないか。<br>◆00000014◆在工月将最后的吐息，朝向虚空的时刻，廊道两侧的门倏忽齐齐洞开，无数的脸庞，探出门外，宛作揶揄模样。</p><p>◇00000015◇ぞっとしたが疲労で手足が鈍くなっているのも事実であり、少し休まないことには本当にこの長大な廊下に途中で行き倒れにもなりかねない。<br>◆00000015◆虽确感一丝寒意，但因疲劳，手脚迟钝。若不适作休息，恐怕真会在这漫长走廊上中途倒下。</p><p>◇00000016◇少し休息をとり、体力を回復させないことにはと、座りこんで{襖:ふすま}に寄り掛かろうとした、ら。<br>◆00000016◆思索着，定要稍作休息，回复体力，于是支起身子，想靠于拉门，结果……。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000017◇「……わあ！？」<br>◆00000017◆「……哇啊！？」</p><p>◇00000018◇バランスが崩れて視界が流れた。背中を預けようとした{襖:ふすま}が前触れなく開いたのだからたまらない。<br>◆00000018◆平衡崩塌，视线模糊。预先准备靠在背后的拉门，结果拉门毫无预兆地打开，是时手足无措。。</p><p>◇00000019◇見事に透かされもんどりうって仰向けの、天井を睨むことになった工月の視界をひょいと覗いた顔がある。<br>◆00000019◆工月靠门未果，结实摔倒于走廊，仰面朝天，凝视天花板，倏忽，有一人脸，现于工月面前。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000020◇「秋成？　なにしてるのよこんな廊下で」<br>◆00000020◆「秋成？　在走廊里做什么呢」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000021◇「寝る場所ならこの通り、いくらでもお座敷があるのに、なにもこんな硬い廊下を選ばなくってもいいじゃない」<br>◆00000021◆「明明这里有那么多房间可以睡觉，为什么偏偏选择这么硬的走廊呢」</p><p>◇00000022◇大学の構内で挨拶を交わすような全く自然な物言いに、工月はなにも自分が寄り掛かったタイミングを見計らうように{襖:ふすま}を開けずとも、と憤然となる。<br>◆00000022◆对方用一种就像在大学校园里打招呼一样自然的语气说话，这让工月感到愤怒。他心想，根本不需要故意在我靠上去的那一刻打开拉门。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000023◇「ご挨拶だなッ。君はもしかして俺が寄り掛かる隙をこっそり{窺:うかが}っていたんじゃなかろうな麻子ッ」<br>◆00000023◆「真是好一套招呼啊！麻子，你不会是在偷偷窥伺我什么时候靠上去的吧」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000024◇「―――？」<br>◆00000024◆「―――？」</p><p>◇00000025◇驚きは、一拍遅れてやってきた。<br>◆00000025◆惊讶来得稍微迟了一拍。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000026◇「あさ、こ―――？」<br>◆00000026◆「あさ、こ―――？」</p><p>◇00000027◇長く口にしていなかったように、麻子の名を口の中で転がしてその響きを確かめる。<br>◆00000027◆还未叫出那个，麻子的名字就辗转着从口中传出，确认着那个回响。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000028◇「……なんで人をそんな目で見るかなあ」<br>◆00000028◆「……为什么要用那种眼神看别人啊」</p><p>◇00000029◇彼女はつい先程別れたような口調だったが、工月の脳裏に―――<br>◆00000029◆她用着与之前不同的语气，在工月的脑内―――</p><p>◇00000030◇麻子の顔を見たのがきっかけとなって、溢れ出す記憶があった。<br>◆00000030◆以看见麻子的脸为契机，有记忆涌现了出来。</p><p>◇00000031◇記憶が次々と、工月を突き抜けていく。<br>◆00000031◆记忆依涌入工月的脑海。</p><p>◇00000032◇だがそれなのに、そういうことが確かにあったのだと断片的に思い出されるばかり。<br>◆00000032◆就算如此，也净是那些记忆也确实存在般断片的回忆。</p><p>◇00000033◇それらの記憶を貫くはずの物語がどうしても思い出せないのだった。<br>◆00000033◆为什么连贯的记忆的故事无论如何也回忆不起来呢。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000034◇「ちょっと……どうしたの本当に？　倒れた拍子に頭でも打った？」<br>◆00000034◆「等一下……怎么了真的吗？在倒下的时候撞到脑子了？」</p><p>◇00000035◇麻子と共有した物語は、目覚めて思い出せない夢のように哀しく{儚:はかな}いものだったと、そのイメージばかりが工月の喉を熱くする。<br>◆00000035◆与麻子共同经历的故事，像记得但却回忆不起的梦境一般哀伤，只有印象让工月的喉咙感到一阵热意。</p><p>◇00000036◇なのに麻子の方は、まるで何事もなかったように工月に接している。<br>◆00000036◆然而对于麻子，就像什么事情都没有发生一样对待工月。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000037◇「麻子……君なのか、本当に？」<br>◆00000037◆「麻子……吗，真的吗？」</p><p>◇00000038◇……にわかに麻子が不安そうに眉根を曇らせた。<br>◆00000038◆……麻子突然眉头紧蹙，感到不安。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000039◇「あああ……やっぱり頭打ったんだ……っ」<br>◆00000039◆「啊啊啊……果然是撞到头了吗……っ」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000040◇「秋成、あのね、これは何本！？」<br>◆00000040◆「秋成，那个，这是几根手指！？」</p><p>◇00000041◇工月の前に人差し指と中指を立てて突きだす、表情はあくまで真剣そのもの。<br>◆00000041◆在工月的面前伸出食指和中指，表情依旧严肃认真。</p><p>◇00000042◇釣りこまれるように『二本』と素直に答えてから工月は。<br>◆00000042◆在是被引导一般，直接回答“两根”之后。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000043◇「どこも打ってはいないぞっ」<br>◆00000043◆「什么地方也没打到哦」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000044◇「わあ！」<br>◆00000044◆「哇啊！」</p><p>◇00000045◇そこで麻子が上手く頭を引っこめなかったら、猛然と起きあがった工月の額に鼻筋を強打されていたことだろう。<br>◆00000045◆如果麻子当时没能及时把头缩回去，猛然坐起的工月的额头就会被她的鼻梁撞到。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000046◇「ただ俺は、君達を捜していただけなんだっ」<br>◆00000046◆「我只是想找你们而已」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000047◇「起きてみれば、このだだっ広い屋敷に俺一人」<br>◆00000047◆「醒来时发现这个大宅子里只有我一个人」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000048◇「不安になって捜し回っても仕方ないと思わないか！？」<br>◆00000048◆「不觉得不安到到处找也没什么用吗！？」</p><p>◇00000049◇と真剣そのものの工月なのに、麻子の眼差しに浮かんだ輝きは、猫が格好の遊び相手を見つけた時のそれ。<br>◆00000049◆尽管工月非常认真，麻子眼中的光辉却像是猫发现了一个理想的玩伴。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000050◇「へえ……不安だったんだ、秋成が」<br>◆00000050◆「哎……秋成竟然不安了」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000051◇「あ。なんだその目は。そのいかにも『獲物を見つけました』って目は」<br>◆00000051◆「啊。那是什么眼神？那种一看就像是‘发现了猎物’的眼神」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000052◇「日頃から冷静沈着を旨としている秋成が、ねえ」<br>◆00000052◆「一向冷静沉着的秋成，真是」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000053◇「起きてみると一人っきりで、さびしいのが我慢できなくて、お屋敷の中駆けずり回ってたんだぁ……」<br>◆00000053◆「醒来时发现自己一个人，忍受不了寂寞，到处在大宅子里跑来跑去……」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000054◇「……ぐ」<br>◆00000054◆「……呜」</p><p>◇00000055◇余計な弱みを見せてしまったと後悔したところでもう遅い。<br>◆00000055◆已经为露出了不必要的弱点而感到后悔，但已经为时已晚。</p><p>◇00000056◇麻子はらんらんと目を輝かせ、それは楽しそうに工月をからかおうと唇を吊り上げて笑みを浮かべ―――<br>◆00000056◆麻子眼中闪耀着光芒，嘴角上扬，准备开心地逗弄工月——</p><p>◇00000057◇しかし、ふっとすぐに真顔に戻る。<br>◆00000057◆但她很快就恢复了严肃的表情。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000058◇「……ごめんね」<br>◆00000058◆「……对不起」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000059◇「え……あ……？」<br>◆00000059◆「嗯……啊……？」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000060◇「秋成、よく眠ってたみたいだったし、起こすのも悪いかなって思ったんだ」<br>◆00000060◆「秋成，你似乎睡得很香，我觉得叫醒你可能不好」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000061◇「だから声も掛けなかったんだけど……」<br>◆00000061◆「所以我没有叫你……」</p><p>◇00000062◇眼差しに浮かべていたのは、まぎれもなく懸念と申し訳なさ。<br>◆00000062◆她眼中浮现的毫无疑问是关切和歉意。</p><p>◇00000063◇それで工月の中の強ばっていた気持ちがいっぺんに溶けた。<br>◆00000063◆这使得工月心中僵硬的情感瞬间融化。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000064◇「いや……別にいいんだ。考えてみれば俺の方も、そんなに焦るほどの事ではなかったわけだし」<br>◆00000064◆「不……没关系。仔细想想，我也不必那么焦虑」</p><p>◇00000065◇考えてみれば捜していた相手に会えたと言うことには変わりない。<br>◆00000065◆毕竟，能见到一直在寻找的人也没错。</p><p>◇00000066◇ただ―――今のやりとり一つをとっても、自分がこの麻子と近しい間だったというのは判るのだが、なにかそれ以上のことがあったような。<br>◆00000066◆只是——从现在的对话中，我能感受到自己与麻子的关系是如此亲近，但似乎还有更深层次的东西存在。</p><p>◇00000067◇物足りなさが、古い傷のように疼いた。<br>◆00000067◆这种不满足感像旧伤一样隐隐作痛。。</p><h2 id="竜胆01c"><a href="#竜胆01c" class="headerlink" title="竜胆01c"></a>竜胆01c</h2><p>◇00000001◇縁側に腰かけ、ぽぉんぽぉんと宙に舞う{袱:ふく}{紗:さ}の玉を眺めるともなしに眺める。<br>◆00000001◆坐在走廊边，漫不经心地看着袱纱的球在空中轻轻飘舞。</p><p>◇00000002◇麻子に連れられて差しかかった通り土間には、二つの小柄な影。<br>◆00000002◆麻子带着（某人）走到的通道土间上，有两个小小的影子。</p><p>◇00000003◇麻子と再会した時ほどの衝撃はなかったけれど、それでも工月は深い安堵に、肩のあたりにわだかまっていた{靄:もや}が薄れるのを感じた。<br>◆00000003◆虽不及再逢麻子时的冲击，但工月却深感安慰，肩边郁积的雾霭也随之雾散。</p><p>◇00000004◇もっとも双子の方は、工月がいることがさも当たり前のように、ちょっと頭を下げただけ。<br>◆00000004◆对于双胞胎，工月的存在本来就仿若理所当然，她俩略微颔首。</p><p>◇00000005◇―――親しげな笑みを口元にたまらせてはいたけれど。<br>◆00000005◆―――虽然在嘴角挤出了亲切的笑容。</p><p>☆AAAAAAAA★ 伊美</p><p>◇00000006◇「じゅうごやのよるに」<br>◆00000006◆「仿若十五夜一般」</p><p>◇00000007◇伊美の手から綺麗に縫われたお手玉が、二つ、三つと宙に投げられる様子が軽やかだった。<br>◆00000007◆伊美亲手缝制的手玉，两枚、三枚地向空中投掷的模样略显轻巧。</p><p>☆AAAAAAAA★ 斎</p><p>◇00000008◇「つきみぬやつは」<br>◆00000008◆「未赏月的家伙」</p><p>◇00000009◇かたわれの歌の端を継いで、斎もお手玉を投げ上げる。<br>◆00000009◆支离的歌曲继续，斋也将手玉投掷。</p><p>◇00000010◇その手さばきは余りにも巧みで、お手玉は宙にある間だけ生命を得ているようだ。<br>◆00000010◆那副动作游刃有余地精巧，手玉只有在空中的时刻，才像获得了生命一般。</p><p>☆AAAAAAAA★ 伊美</p><p>◇00000011◇「じごくのおにめが」<br>◆00000011◆「地狱的鬼眼在」</p><p>☆AAAAAAAA★ 斎</p><p>◇00000012◇「きねでつく」<br>◆00000012◆「杵打」</p><p>☆AAAAAAAA★ 伊美</p><p>◇00000013◇「あ、しょっぱいな」<br>◆00000013◆「啊，咸」</p><p>☆AAAAAAAA★ 斎</p><p>◇00000014◇「しょっぱいな」<br>◆00000014◆「苦咸」</p><p>◇00000015◇二人の戯れ歌は糸車から繰り出すように{澱:よど}みなく、それに誘われたように工月の記憶も解けていく。<br>◆00000015◆两人的戏曲像从纺车编织出来一般沉降，如同被它们引诱了一般，工月的记忆也解放了。</p><p>◇00000016◇ただその記憶も、麻子の時と同じようにとぎれとぎれで、本当はこの双子とも、もっともっと深い時間を経てきた筈なのに、どうしても届かない。<br>◆00000016◆只是那份记忆也，和麻子那时一样短短续续，事实上双胞胎，明明应当历经了愈加长久的时间，但无论如何也传达不到。</p><p>◇00000017◇その記憶は多分に凄惨なものであるのに、どこか艶めかしく官能的な―――<br>◆00000017◆明明那份记忆大部分是凄惨的，但是哪里缺娇艳诱人―――</p><p>◇00000018◇伊美は掌で操っていたお手玉を、宙にあるうちに手を返して今度は甲で受け、跳ね上げる。<br>◆00000018◆伊美将手里掌握的手玉悬空之时，将手收回，这次用甲来接受，跳跃而起。</p><p>◇00000019◇斎は負けじと右手と左手を交差させ、それでなにも差し支えなくお手玉を舞わせているのだからさすがだ。<br>◆00000019◆斋将左右手交错负背，就这样不用任何事物接来舞动手玉，不愧是她啊。</p><p>◇00000020◇この域に達するまで、二人はよほど同じ遊びを繰り返したことだろう。<br>◆00000020◆抵达这个领域前，两人如此这般，重复一样的游戏。</p><p>◇00000021◇対して麻子の方はといえば。<br>◆00000021◆对于麻子这边的话。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000022◇「……むっ。……よっ。……はっ！」<br>◆00000022◆「……唔。……喲。……哈！」</p><p>◇00000023◇掛け声ばかりは勇ましいが、お手玉二つを回すのにも苦戦している様子、双子の{袂:たもと}が小鳥のように軽く舞うのに比べて麻子の{袂:たもと}はまだまだ雛の手習い。<br>◆00000023◆但是念咒就算勇敢了，但是将手玉来回抛掷也算苦战，与仿若小鸟一般轻盈飞舞的双胞胎的裙摆相比，麻子的裙摆还只是雏鸟的练习。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000024◇「……って、ああもう、もどかしいっ」<br>◆00000024◆「……真是的，啊，太令人着急了」</p><p>◇00000025◇ちょっと拍子を早くしただけで、あっさり爪の先で弾いて土間にころころと、工月は足元に跳ねてきたそれを麻子に放ってやる。<br>◆00000025◆虽然时机还尚早，果断地将指尖在土间弹来弹去，工月将其从脚尖向麻子发射。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000026◇「苦戦してるようだな。慣れないことはあんまりするものじゃないぞ」<br>◆00000026◆「貌似是一场苦战呢。做了太多不熟悉的事情了。」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000027◇「そりゃあ、あたしにこういうのは向いてないってわかるけど」<br>◆00000027◆「那个，虽然我也知道不应该参与进来的」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000028◇「でもこの子たちがこんなに上手にしてるのを見ると、ついあたしもって気になって」<br>◆00000028◆「但是看到她们如此得熟练，就此我也变得在意起来了。」</p><p>◇00000029◇めげずに再びお手玉に挑む麻子を、双子は敢えて手も出さずに見守っている。<br>◆00000029◆不认输的麻子再次将手玉挑起，双胞胎故意不出手只是守望着她。</p><p>◇00000030◇こういうのは自分の手で自分に覚えさせるのが一番とよく判っているのだろう。<br>◆00000030◆这种事情最好自己上手才能熟悉。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000031◇（穏やかな情景だ……）<br>◆00000031◆（安稳的情景……）</p><p>◇00000032◇工月もまた、娘達の手遊びにはそれ以上の差し出口を挟まずに、眺めさせてもらうだけで良しとする。<br>◆00000032◆工月仍然，不能对女孩们的游戏过多地插嘴，只好眺望着她们。</p><p>◇00000033◇古い時代の正月の過ごし方を見るような、しみじみとした郷愁を覚えているのは、娘たちが皆それぞれに色とりどりの振り袖姿だからだろう。<br>◆00000033◆仿若在见识古老时代正月的度过方式一般，深情地忆起乡愁，大概是因为女孩们各自袖姿五彩缤纷的舞动吧。</p><p>◇00000034◇双子や麻子が手遊びに耽る様子は、工月の心を穏やかに鎮め、もうずっと昔からこうしてこの屋敷で過ごしているような気持ちになってくる。<br>◆00000034◆双胞胎与麻子沉浸在手的游戏的样子，使得工月的心镇定，就像很久以前就住在这座宅邸一般。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000035◇「てや……っ。……うう、やっぱりあたし、こういうの苦手～～」<br>◆00000035◆「唉……。……呜呜，果然我，不擅长这些」</p><p>◇00000036◇今度は二ついっぺんに取り落とし、さすがに麻子も飽きてきたのか、それ以上は続けようとせずに立ちあがって腰の埃と一緒に手遊びへの執着も払う。<br>◆00000036◆现在两枚手玉突然坠落，果然连麻子也厌倦了吗，不继续游戏转而站起，将腰间的尘土与一起游戏的执着拂去。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000037◇「もうおしまいか？」<br>◆00000037◆「已经结束了吗？」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000038◇「すぐに上達するもんじゃないしね」<br>◆00000038◆「这不是马上就提升了吗」</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000039◇「それにもうすぐ晩御飯だから、紫織さんの手伝いもしないと」<br>◆00000039◆「话说回来，马上就要吃晚饭了，紫织小姐也不传达消息」</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000040◇「紫織さん―――」<br>◆00000040◆「紫织小姐―――」</p><p>◇00000041◇麻子から聴かされれば意外な響きのその名も、工月自身が口にしてみれば優しい姉に抱くような信頼を伴って据わりがいい。<br>◆00000041◆从麻子那里听闻的一个意外有响度的名字，从工月自己嘴里说出来的话，会有仿若被温柔的姐姐拥抱一般的信赖陪伴，坐立心安。</p><p>☆AAAAAAAA★ 秋成</p><p>◇00000042◇（そうだ―――彼女だっているんだ）<br>◆00000042◆（对啊―――她也在）</p><p>◇00000043◇伊美と斎、麻子が戯れる様子を間近にしながら、どこかしら足りない姿があるように思えて目で捜していたのは彼女なのだった。<br>◆00000043◆伊美、斋还有麻子的嬉戏的样子在眼前时，不知何处有着不满足的身姿一般，神思片刻，凝目巡查，正是在寻找她。</p><p>☆AAAAAAAA★ 麻子</p><p>◇00000044◇「秋成は座敷で待ってて」<br>◆00000044◆「秋成在宅邸等候着」</p><p>◇00000045◇土間に続きの台所に下がっていく麻子の後ろ姿に、何百年もこの屋敷にこうして住んでいたような安定感を見て、工月はほっと溜息をつく。<br>◆00000045◆延续到了土间的厨房，麻子的背影向下，目睹仿若居于此屋数百年之安定，工月深叹一息。</p><p>◇00000046◇きっと自分はこうして{那:な}{越:ごし}の女達と、ずっと一緒に暮らしてきたのではないか。<br>◆00000046◆自己定然将同女孩们，就如此，一直一起生活吧。</p><p>◇00000047◇そう思うのが、一番収まりが良さそうなのに。<br>◆00000047◆虽是如此思索，但还是最为收敛为妙。</p><p>◇00000048◇どうしてか工月は、座りこんだ縁側が軟泥と化して自分が呑みこまれていくような、そんな{儚:はかな}さを感じていた―――<br>◆00000048◆为什么呢，工月感受到了如此的梦幻，坐卧的走廊，化为软泥，仿佛要将自我裹挟―――</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;竜胆01a&quot;&gt;&lt;a href=&quot;#竜胆01a&quot; class=&quot;headerlink&quot; title=&quot;竜胆01a&quot;&gt;&lt;/a&gt;竜胆01a&lt;/h2&gt;&lt;p&gt;◇00000001◇―――時という言葉は―――&lt;br&gt;◆00000001◆―――所谓时间―――&lt;/p&gt;
&lt;p&gt;◇00</summary>
      
    
    
    
    
    <category term="汉化" scheme="http://example.com/tags/%E6%B1%89%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>算法：双指针</title>
    <link href="http://example.com/2024/08/15/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>http://example.com/2024/08/15/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2024-08-15T06:57:01.000Z</published>
    <updated>2024-08-19T06:05:15.150Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>数组其实是一个连续的内存空间，删除元素的基本原理是</p><ul><li>空间不变</li><li>计数方法会进行包装</li></ul><h3 id="erase函数"><a href="#erase函数" class="headerlink" title="erase函数"></a>erase函数</h3><p>在vector这个模板里面，就算使用了erase函数，原本申请的数组所占有的内存也是不发生变化的。</p><table><thead><tr><th>a[0]</th><th>a[1]</th><th>a[2]</th><th>a[3]</th><th>a[4]</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td></tr><tr><td>1</td><td>2</td><td>3</td><td>5</td><td>5</td></tr></tbody></table><blockquote><p>删除4元素的原理，就是删除将下一位的元素那进来补位，然后通过某些手段，屏蔽接下来的元素，这样就可以形成一个新的数组</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void erase(&amp;a,int b)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]==b)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[j-1]=a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">复杂度O(i+(n-i))=O(n)</span><br></pre></td></tr></table></figure><h3 id="库函数的使用"><a href="#库函数的使用" class="headerlink" title="库函数的使用"></a>库函数的使用</h3><p>过于简单的题目（能用库函数一次解决的），就不要用库函数</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><blockquote><p>其实就是牺牲空间，获取时间，原理是这样的，我们采用额外的空间，比如再声明一个数组，这样一个数组有了之后，我们就可以采用快慢指针的方法，快指针的作用很简单，就是用于遍历数组中的所有元素，而慢指针的作用在于标度待删除元素的存在，确认数组在最后拥有的数组大小。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delete element(&amp;a,int b)</span><br><span class="line">&#123;</span><br><span class="line">int slow=0;</span><br><span class="line">vector&lt;int&gt;a_1;</span><br><span class="line">for(int fast=0;fast&lt;a.size();fast++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[fast]!=b) slow++;</span><br><span class="line">&#125;</span><br><span class="line">return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是快慢指针"><a href="#什么是快慢指针" class="headerlink" title="什么是快慢指针"></a>什么是快慢指针</h4><p>快慢指针是双指针算法中的一种。不同于左右对撞指针，快慢指针中的两个指针是从同一侧但以不同的策略移动的指针。因此，两个指针中会有一个移动较快的快指针（fast）和一个较慢的慢指针（slow）。当快指针移动到数组的顶端时，停止遍历或进行新一轮遍历。</p><h4 id="为什么要用快慢指针"><a href="#为什么要用快慢指针" class="headerlink" title="为什么要用快慢指针"></a>为什么要用快慢指针</h4><p>使用双指针最实在的好处在于，我们的快指针相当于一个探路侠，它每走一步就会给予慢指针一个信息，让慢指针完成它的一部分工作，这样尽量让两个指针分工操作。</p><p>快指针的工作在前面进行，而快指针完成工作之后，对于它本身信息的传递，其实是不消耗空间，也不消耗时间的。我们可以利用信息的充分化利用，使得两个指针能干更多有意义的事情。</p><h4 id="快慢指针是怎么用的"><a href="#快慢指针是怎么用的" class="headerlink" title="快慢指针是怎么用的"></a>快慢指针是怎么用的</h4><ul><li>链表：在链表中，链表往往是单向链表，这个时候使用快慢指针，让它们朝着同一个方向进行迭代。</li><li>数组：数组利用的是索引的只是，在return值里面使用索引，便可以返回对应长度数组的值。</li></ul><h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><ul><li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li><li>返回 <code>k</code>。</li></ul><p><strong>用户评测：</strong></p><p>评测机将使用以下代码测试您的解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int val = ...; // 要移除的值</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的预期答案。</span><br><span class="line">                            // 它以不等于 val 的值排序。</span><br><span class="line"></span><br><span class="line">int k = removeElement(nums, val); // 调用你的实现</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">sort(nums, 0, k); // 排序 nums 的前 k 个元素</span><br><span class="line">for (int i = 0; i &lt; actualLength; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有的断言都通过，你的解决方案将会 <strong>通过</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2,_,_]</span><br><span class="line">解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。</span><br><span class="line">注意这五个元素可以任意顺序返回。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h3 id="题解（双指针）"><a href="#题解（双指针）" class="headerlink" title="题解（双指针）"></a>题解（双指针）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val)</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以联想为两排数组，快指针的那排数组具有元素，当快指针找到不是val的值的时候，就把这个值丢给慢指针，反之则不丢，最后慢指针在的那个数组中，去除了所有的目标元素。</p><p><img src="https://p.sda1.dev/18/496fb1149023399a4fb0163b1520cb4b/B7EC9CA94D6DF2BEB4E92654E268692E.png"></p><h4 id="硬解"><a href="#硬解" class="headerlink" title="硬解"></a>硬解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 相向双指针⽅法，基于元素顺序可以改变的题⽬描述改变了元素相对位置，确保了移动最少元素</span></span><br><span class="line"><span class="comment">* 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">* 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> leftIndex = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> rightIndex = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (leftIndex &lt;= rightIndex) &#123;</span><br><span class="line"><span class="comment">// 找左边等于val的元素</span></span><br><span class="line"><span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[leftIndex] != val)&#123;</span><br><span class="line">++leftIndex;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 找右边不等于val的元素</span></span><br><span class="line"><span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[rightIndex] == val) &#123;</span><br><span class="line">-- rightIndex;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 将右边不等于val的元素覆盖左边等于val的元素</span></span><br><span class="line"><span class="keyword">if</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">nums[leftIndex++] = nums[rightIndex--];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">return</span> leftIndex; <span class="comment">// leftIndex⼀定指向了最终数组末尾的下⼀个元素</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><ul><li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li><li>返回 <code>k</code> 。</li></ul><p><strong>判题标准:</strong></p><p>系统会用下面的代码来测试你的题解:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2,_]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li></ul><p>​我们来分析删除元素这个算法的原理，首先我们给定的一个数组它是严格递增的，在这里我们需要把重复的元素都删掉，然后返回整个数组的长度，可以看到我们这边是使用了一个快慢指针的方法，一个慢指针，一个快指针。</p><p>​这里基本的思路是，如果说就是快指针和慢指针所指的两个数它相同的话。那么就只有快指针向前走一步，慢指针不动。在这里我们可以举一个例子，假如说嗯，这时候有三个相同的元素卖指针已经指向了第1个元素，而会计证指向的是第2个元素，这时候进行一步操作。因为这两个指针指向的元素的值是相同的，所以说慢指针不动，然后快指针向前走一步。</p><p>​接下来继续操作，这个时候慢指针指向了第1个元素，然后快指针指向了第3个元素。因为这个时候会计证和慢指针的值还是相同的，所以说慢指针不动，快指针继续前进。这个时候快指针已经指向了和慢指针不同的元素。这个时候循环继续，因为快指针和慢指针它指向的元素已经不同了，所以说慢指针和快指针都向前走一步。而我们的操作中，当慢指针和快指针它们的值不同的时候，我们会将快指针的值赋给慢指针。</p><p>​所以说慢指针，它最后会走的步数是。数组中不同元素的个数，而慢指针它本身的一个值是索引，所以说我们在计算数组长度的时候需要返回就是慢指针它的值，加上一个1。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">1</span>; fast &lt; nums.<span class="built_in">size</span>(); fast = fast + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] != nums[fast])</span><br><span class="line">                nums[++slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://p.sda1.dev/18/0310a04d7db7eb8d955b8c89eca22e95/0DEE598ED87C4D5522F12F9FD0F44B2C.png"></p><ul><li><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 105</code></li><li><code>s[i]</code> 都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li></ul><h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[l],s[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="双指针底层"><a href="#双指针底层" class="headerlink" title="双指针底层"></a>双指针底层</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=s[l];</span><br><span class="line">            s[l]=s[r];</span><br><span class="line">            s[r]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="LCR-122-路径加密"><a href="#LCR-122-路径加密" class="headerlink" title="LCR 122. 路径加密"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">LCR 122. 路径加密</a></h3><p>假定一段路径记作字符串 <code>path</code>，其中以 “<code>.</code>“ 作为分隔符。现需将路径加密，加密方法为将 <code>path</code> 中的分隔符替换为空格 “<code> </code>“，请返回加密后的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;a.aef.qerf.bb&quot;</span><br><span class="line"></span><br><span class="line">输出：&quot;a aef qerf bb&quot;</span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= path.length &lt;= 10000</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">pathEncryption</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fast=<span class="number">0</span>,slow=<span class="number">0</span>;fast&lt;path.<span class="built_in">size</span>();fast++,slow++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(path[fast]==<span class="string">&#x27;.&#x27;</span>) path[slow]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原地修改</p><h3 id="剑指Offer-05-替换空格"><a href="#剑指Offer-05-替换空格" class="headerlink" title="剑指Offer 05.替换空格"></a>剑指Offer 05.替换空格</h3><p>请实现⼀个函数，把字符串 s 中的每个空格替换成”%20”。 </p><p>示例 1： </p><p>输⼊：s &#x3D; “We are happy.” </p><p>输出：”We**%20<strong>are</strong>%20**happy.” </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计空格的个数</span></span><br><span class="line"><span class="type">int</span> sOldSize = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 扩充字符串s的⼤⼩，也就是每个空格替换成&quot;%20&quot;之后的⼤⼩</span></span><br><span class="line">s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> sNewSize = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 从后先前将空格替换为&quot;%20&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = sNewSize - <span class="number">1</span>, j = sOldSize - <span class="number">1</span>; j &lt; i; i--, j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">s[i] = s[j];</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">s[i - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">s[i - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">i -= <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="拓展：字符串和数组的区别"><a href="#拓展：字符串和数组的区别" class="headerlink" title="拓展：字符串和数组的区别"></a>拓展：字符串和数组的区别</h3><p>C&#x2F;C++中的字符串以’\0’作为结束的标志</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">5</span>] = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; a[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++中，string类中会给我们提供size接口，这可以用来判断string类字符串是否结束，可以避免’\0’的使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string a = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector<char>和vector<string>的区别是string类中重载了一些运算符，在处理字符串的时候会显得更加方便。</string></char></p><h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p><p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p><p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p><p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li><li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li></ul><p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p><h4 id="自己的思路"><a href="#自己的思路" class="headerlink" title="自己的思路"></a>自己的思路</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; s1;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        a.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//左边隔板的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;a.<span class="built_in">push_back</span>(i);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录中间隔板的位置</span></span><br><span class="line">        a.<span class="built_in">push_back</span>(s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">//右边界隔板的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!a.<span class="built_in">size</span>()) <span class="keyword">return</span> s;</span><br><span class="line">            <span class="comment">//单个单词直接返回</span></span><br><span class="line">            s1.<span class="built_in">push_back</span>(s.<span class="built_in">begin</span>()+a[i]+<span class="number">1</span>,s.<span class="built_in">begin</span>()+a[i+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//左隔板前移动一位，右隔板后移一位，切出一个单词</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s1.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;r;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s1[l],s1[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        string s2=s1[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//左右指针将单词反转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s1.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s2+=<span class="string">&#x27; &#x27;</span>+s1[i];</span><br><span class="line">        &#125;<span class="comment">//利用占头部的方式消除前置零</span></span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123; <span class="comment">//翻转，区间写法：左闭又闭 []</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;<span class="comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;   <span class="comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//遇到非空格就处理，即删除所有空格。</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//补上该单词，遇到空格说明单词结束。</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow); <span class="comment">//slow的大小即为去除多余空格后的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s); <span class="comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i - <span class="number">1</span>); <span class="comment">//翻转，注意是左闭右闭 []的翻转。</span></span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">//更新下一个单词的开始下标start</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Split库-分隔单词"><a href="#Split库-分隔单词" class="headerlink" title="Split库+分隔单词"></a>Split库+分隔单词</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">istringstream <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">        string str;</span><br><span class="line">        stack&lt;string&gt; zhan;</span><br><span class="line">        <span class="keyword">while</span>(is&gt;&gt;str)&#123;</span><br><span class="line">            zhan.<span class="built_in">push</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用输入流，将单词分别输入</span></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!zhan.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res += zhan.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(zhan.<span class="built_in">size</span>() != <span class="number">1</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            zhan.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//利用栈原理，逆向接受单词空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="栈原理"><a href="#栈原理" class="headerlink" title="栈原理"></a>栈原理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">// self solution! yeah!!</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack &lt;string&gt; stk;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;<span class="comment">//先遍历字符串，提前单词，word入栈</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                word += s[i];</span><br><span class="line">                <span class="keyword">if</span> (i ==  n<span class="number">-1</span> || s[i+<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//关键判断条件：什么时候入栈，当字母后有空格或已是最后一个则判断为word，入栈</span></span><br><span class="line">                    stk.<span class="built_in">push</span>(word);</span><br><span class="line">                    word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>())&#123;<span class="comment">//释放栈中元素，加入空格组成反转后结果</span></span><br><span class="line">            ans += stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>())  ans += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><p>通常我们会在大厂里的第一道比较简单的面试题里面，见到反转链表这样的题目，这是对单链表数据结构的基本操作，是需要掌握的知识点。</p><p>众所周知，链表中一个基础结构叫做节点，节点之中有<strong>数据域和指针域</strong>两个部分，一个链表由<strong>头节点决定链表整体的地址信息</strong>，头接点可以遍历整个链表，而要把链表反转，就是让每个节点的<strong>指针域进行反向操作</strong>，这是比较高级的做法，下面从最开始接触到反转链表的问题的想法。</p><p>最容易想到的是，利用双指针的方法，进一步说明就是利用左右指针的算法，从链表两侧往中间遍历。对于整个链表，基本操作方式就是，左指针从链表的左侧一直往右侧移动，右测的指针往左测移动，当左右指针都能移动一步过后，我们把这两个指针所在的节点的数据域进行交换。但是，这里交换数据域出现问题，我们不能直接像数组一样，利用索引就调出某个元素的值，这边我们要调用单列表的某个元素是，只能从头节点开始遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;target;i++)</span><br><span class="line">&#123;</span><br><span class="line">    currPtr=currPtr-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果像这样去调用每个对象的数据域，会出现currPtr的指向一直在变化，我们要调用两个镜像的节点的数据域需要考虑预设中间节点，但是我们没有回退的指针运算，不管如何，都得从头节点出发。如果是能够从中间开始，这里就需要考虑元素的奇偶性，必然会导致“数数”的过程，增加运算的步骤，出现这样的情况。</p><blockquote><p>注意：如果出现奇偶的情况，最先考虑二者最后的执行情况是否能一致。</p></blockquote><p>很显然，反转链表是一道简单题，如果是选择数据域进行操作，可以计算一下操作的自由度：这里存在链表给予的空间自由度，还有链表本身的一维遍历自由度.</p><p>单链表有一个特点:每一个节点之间以一个next指针连接,要遍历整个链表只需找头接点,头接点规定为链表的末尾节点,接着将所有的指针域反转,就可以实现链表反转的目标.</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>空</th></tr></thead><tbody><tr><td>head</td><td>head-&gt;next</td><td>~</td><td>~</td><td>~</td><td>~</td><td>nullptr</td></tr><tr><td>currPtr</td><td>currPtr-&gt;next</td><td></td><td></td><td></td><td></td><td>prevPtr</td></tr><tr><td></td><td>temPtr</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://pic.leetcode-cn.com/1631933586-mEtOBg-008eGmZEly1gnrf1oboupg30gy0c44qp.gif" alt="img"></p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>空</th></tr></thead><tbody><tr><td>head</td><td>head-&gt;next</td><td>~</td><td>~</td><td>~</td><td>~</td><td>nullptr</td></tr><tr><td>currPtr</td><td>currPtr-&gt;next</td><td></td><td></td><td></td><td></td><td>prevPtr</td></tr><tr><td></td><td>temPtr</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>存c下一位,转向切换</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h4 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* currPtr=head;</span><br><span class="line">        ListNode* prevPtr=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(currPtr!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode*temPtr=currPtr-&gt;next;</span><br><span class="line">            <span class="comment">//①</span></span><br><span class="line">            currPtr-&gt;next=prevPtr;</span><br><span class="line">            <span class="comment">//其实是调转方向的指令②</span></span><br><span class="line">            prevPtr=currPtr;</span><br><span class="line">            <span class="comment">//③</span></span><br><span class="line">            currPtr=temPtr;</span><br><span class="line">            <span class="comment">//④</span></span><br><span class="line">            <span class="comment">//①④是完成操作后,使c前进一位</span></span><br><span class="line">            <span class="comment">//③是完成调转方向后,使p前进一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prevPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链表的操作可以微元化单个步骤的重复.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(currPtr!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode*temPtr=currPtr-&gt;next;</span><br><span class="line">            <span class="comment">//①</span></span><br><span class="line">            currPtr-&gt;next=prevPtr;</span><br><span class="line">            <span class="comment">//其实是调转方向的指令②</span></span><br><span class="line">            prevPtr=currPtr;</span><br><span class="line">            <span class="comment">//③</span></span><br><span class="line">            currPtr=temPtr;</span><br><span class="line">            <span class="comment">//④</span></span><br><span class="line">            <span class="comment">//①④是完成操作后,使c前进一位</span></span><br><span class="line">            <span class="comment">//③是完成调转方向后,使p前进一位</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre,ListNode* cur)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">ListNode* temp = cur-&gt;next;</span><br><span class="line">cur-&gt;next = pre;</span><br><span class="line"><span class="comment">// 可以和双指针法的代码进⾏对⽐，如下递归的写法，其实就是做了这两步</span></span><br><span class="line"><span class="comment">// pre = cur;</span></span><br><span class="line"><span class="comment">// cur = temp;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse</span>(cur,temp);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 和双指针法初始化是⼀样的逻辑</span></span><br><span class="line"><span class="comment">// ListNode* cur = head;</span></span><br><span class="line"><span class="comment">// ListNode* pre = NULL;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">NULL</span>, head);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p><ul><li><h4 id="虚拟头结点"><a href="#虚拟头结点" class="headerlink" title="虚拟头结点"></a>虚拟头结点</h4></li></ul><p>我们在处理链表问题时,通常会用到虚拟头结点这个工具,虚拟头结点本身不储存任何数据,它的存在只是为了更方便我们去对链表中的元素进行操作.</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th><th>f</th><th>g</th></tr></thead><tbody><tr><td>dummyhead</td><td>head</td><td>head-&gt;next</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>如果我们要删除头结点,那么就只需要将dummyhead的指针指向head-&gt;next所在的节点,清理掉头结点的内存,然后head节点指向dummyhead.</p><p>这里我们要删除链表的倒数第二个元素，首先我们要知道链表，我们是<strong>无法直接指定他到某个索引找出它的节点</strong>，我们需要用到一些方法就是<strong>快慢指针</strong>的那一种方式。</p><p>快慢指针的方式：快指针先走n步，慢指针后走，这样能在两个指针之间形成n个节点的间隔，当快指针走到空指针的位置的时候，慢指针刚好在倒数第n个节点的前一个节点的位置，之后对倒数第n个元素进行删除就好了，这里我们还需要使用到虚拟头接点的方式，有了虚拟头节点我们就方便地进行链表节点的删除。</p><p>关于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyhead= <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next=head;</span><br><span class="line">        ListNode* fast=dummyhead;</span><br><span class="line">        ListNode* slow=dummyhead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next=slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://i.postimg.cc/WzGdvtRY/A0-A70-DA070-ECE89284-F06-FC7-C8-FBC855.png" alt="删除链表的倒数第n个元素"></p><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><p><strong>自定义评测：</strong></p><p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p><p><strong>示例 1：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p><h4 id="逻辑环-双指针"><a href="#逻辑环-双指针" class="headerlink" title="逻辑环+双指针"></a>逻辑环+双指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *A=headA,*B=headB;</span><br><span class="line">        <span class="keyword">while</span>(A!=B)</span><br><span class="line">        &#123;</span><br><span class="line">            A=A!=<span class="literal">nullptr</span>?A-&gt;next:headB;</span><br><span class="line">            B=B!=<span class="literal">nullptr</span>?B-&gt;next:headA;</span><br><span class="line">            <span class="comment">//相当于将两个链表结成一个环，当两个指针完全一致的时候，就返回对应的指针</span></span><br><span class="line">            <span class="comment">//这里的环只是逻辑上的环，实际上并没有改变链表的任何数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复杂双指针"><a href="#复杂双指针" class="headerlink" title="复杂双指针"></a>复杂双指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表A的长度</span></span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表B的长度</span></span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">// 让curA为最长链表的头，lenA为其长度</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求长度差</span></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">        <span class="comment">// 让curA和curB在同一起点上（末尾位置对齐）</span></span><br><span class="line">        <span class="keyword">while</span> (gap--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历curA 和 curB，遇到相同则直接返回</span></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>层次分析</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//外层为具体条件,while语句对链表进行扫描</span></span><br><span class="line"><span class="comment">//slow一次移动一个节点,fast则移动两个</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span>(slow==fast)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode*index1=fast;</span><br><span class="line">    ListNode*index2=head;</span><br><span class="line">    <span class="comment">//用index1和index2标记头结点和fast节点</span></span><br><span class="line">    <span class="comment">//标记slow也可以</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">while</span>(index1!=index2)</span><br><span class="line">            &#123;</span><br><span class="line">                index1=index1-&gt;next;</span><br><span class="line">                index2=index2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> index2;</span><br><span class="line"><span class="comment">//用快指针定位,已知x=(n-1)(y+z)+z</span></span><br><span class="line"><span class="comment">//就是当index1(fast)指针到达相交点后,index2(head)指针也在这里</span></span><br></pre></td></tr></table></figure><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h4 id="哈希法"><a href="#哈希法" class="headerlink" title="哈希法"></a>哈希法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="双指针法-2"><a href="#双指针法-2" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    <span class="comment">//如果不进行收缩,那么一会儿还会重复计算一次算过的数据</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h3><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>你可以按 <strong>任意顺序</strong> 返回答案 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h4 id="双指针法-3"><a href="#双指针法-3" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝处理</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 这里使用break，统一通过最后的return返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对nums[k]去重</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="comment">// 2级剪枝处理</span></span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对nums[i]去重</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;数组其实是一个连续的内存空间，删除元素的基本原理是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间不变&lt;/li&gt;
&lt;li&gt;计数方法会进行包装&lt;/li&gt;
&lt;/</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>SPOC（12）:异常处理</title>
    <link href="http://example.com/2024/08/15/SPOC-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://example.com/2024/08/15/SPOC-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2024-08-15T01:19:59.000Z</published>
    <updated>2024-08-15T01:33:41.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第-12-章-异常处理"><a href="#第-12-章-异常处理" class="headerlink" title="第 12 章 异常处理"></a>第 12 章 异常处理</h2><h3 id="本章主要内容"><a href="#本章主要内容" class="headerlink" title="本章主要内容"></a>本章主要内容</h3><ul><li><p>异常处理的基本思想与程序实现 </p></li><li><p>异常处理中的构造与析构 </p></li><li><p>标准程序库异常处理 </p></li><li><p>小结</p></li></ul><h3 id="异常处理的思想与程序实现"><a href="#异常处理的思想与程序实现" class="headerlink" title="异常处理的思想与程序实现"></a>异常处理的思想与程序实现</h3><h4 id="异常处理的基本思想"><a href="#异常处理的基本思想" class="headerlink" title="异常处理的基本思想"></a>异常处理的基本思想</h4><p><img src="https://i.postimg.cc/wvpSVg4J/QQ20240815-092055.png"></p><h4 id="异常处理的语法"><a href="#异常处理的语法" class="headerlink" title="异常处理的语法"></a>异常处理的语法</h4><p><img src="https://i.postimg.cc/BbZkrN0n/QQ20240815-092109.png"></p><h4 id="例12-1处理除零异常"><a href="#例12-1处理除零异常" class="headerlink" title="例12-1处理除零异常"></a>例12-1处理除零异常</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//12_1.cpp #include &lt;iostream&gt; </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (y == <span class="number">0</span>) </span><br><span class="line"> <span class="keyword">throw</span> x; </span><br><span class="line"> <span class="keyword">return</span> x / y; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;5 / 2 = &quot;</span> &lt;&lt; <span class="built_in">divide</span>(<span class="number">5</span>, <span class="number">2</span>) &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;8 / 0 = &quot;</span> &lt;&lt; <span class="built_in">divide</span>(<span class="number">8</span>, <span class="number">0</span>) &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;7 / 1 = &quot;</span> &lt;&lt; <span class="built_in">divide</span>(<span class="number">7</span>, <span class="number">1</span>) &lt;&lt; endl; </span><br><span class="line"> &#125; <span class="built_in">catch</span> (<span class="type">int</span> e) &#123; </span><br><span class="line"> cout &lt;&lt; e &lt;&lt; <span class="string">&quot; is divided by zero!&quot;</span> &lt;&lt; endl; </span><br><span class="line"> &#125; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;That is ok.&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="异常接口声明"><a href="#异常接口声明" class="headerlink" title="异常接口声明"></a>异常接口声明</h4><ul><li><p>一个函数显式声明可能抛出的异常，有利于函数的调用者为异常处理做好准备 </p></li><li><p>可以在函数的声明中列出这个函数可能抛掷的所有异常类型。</p></li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(A，B，C，D)</span></span>; </span><br></pre></td></tr></table></figure><ul><li><p>若无异常接口声明，则此函数可以抛掷任何类型的异常。 </p></li><li><p>不抛掷任何类型异常的函数声明如下：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; </span><br></pre></td></tr></table></figure><h4 id="异常处理中的构造与析构"><a href="#异常处理中的构造与析构" class="headerlink" title="异常处理中的构造与析构"></a>异常处理中的构造与析构</h4><p>自动的析构,找到一个匹配的catch异常处理后初始化异常参数。 将从对应的try块开始到异常被抛掷处之间构造（且尚未析构）的所有自动对象进行析构。 从最后一个catch处理之后开始恢复执行。 </p><h4 id="例-12-2-带析构语义的类的-C-异常处理"><a href="#例-12-2-带析构语义的类的-C-异常处理" class="headerlink" title="例 12-2 带析构语义的类的 C++异常处理"></a>例 12-2 带析构语义的类的 C++异常处理</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//12_2.cpp </span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">MyException</span>(<span class="type">const</span> string &amp;message) : <span class="built_in">message</span>(message) &#123;&#125; </span><br><span class="line"> ~<span class="built_in">MyException</span>() &#123;&#125; </span><br><span class="line"> <span class="function"><span class="type">const</span> string &amp;<span class="title">getMessage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> message; &#125; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> string message; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">Demo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Constructor of Demo&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"> ~<span class="built_in">Demo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destructor of Demo&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span> <span class="params">(MyException)</span> </span>&#123; </span><br><span class="line"> Demo d; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Throw MyException in func()&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;exception thrown by func()&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;In main function&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="built_in">func</span>(); </span><br><span class="line"> &#125; <span class="built_in">catch</span> (MyException&amp; e) &#123; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Caught an exception: &quot;</span> &lt;&lt; e.<span class="built_in">getMessage</span>() &lt;&lt; endl; </span><br><span class="line"> &#125; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Resume the execution of main()&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure><h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">In main function </span></span><br><span class="line"><span class="function">Constructor of Demo </span></span><br><span class="line"><span class="function">Throw MyException in <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Destructor of Demo </span></span><br><span class="line"><span class="function">Caught an exception: exception thrown by func() </span></span><br><span class="line"><span class="function">Resume the execution of main() </span></span><br></pre></td></tr></table></figure><h3 id="标准程序库异常处理"><a href="#标准程序库异常处理" class="headerlink" title="标准程序库异常处理"></a>标准程序库异常处理</h3><h4 id="标准异常类的继承关系"><a href="#标准异常类的继承关系" class="headerlink" title="标准异常类的继承关系"></a>标准异常类的继承关系</h4><p><img src="https://i.postimg.cc/KzDCpwCW/QQ20240815-092119.png"></p><h4 id="C-标准库各种异常类所代表的异常"><a href="#C-标准库各种异常类所代表的异常" class="headerlink" title="C++标准库各种异常类所代表的异常"></a>C++标准库各种异常类所代表的异常</h4><p><img src="https://i.postimg.cc/gjMQmRzq/QQ20240815-092129.png"> </p><h4 id="标准异常类的基础"><a href="#标准异常类的基础" class="headerlink" title="标准异常类的基础"></a>标准异常类的基础</h4><ul><li><p>exception：标准程序库异常类的公共基类 </p></li><li><p>logic_error表示可以在程序中被预先检测到的异常 </p></li><li><p>如果小心地编写程序，这类异常能够避免 </p></li><li><p>runtime_error表示难以被预先检测的异常</p></li></ul><h3 id="例-12-3-三角形面积计算"><a href="#例-12-3-三角形面积计算" class="headerlink" title="例 12-3 三角形面积计算"></a>例 12-3 三角形面积计算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//12_3.cpp </span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> </span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="comment">//给出三角形三边长，计算三角形面积 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> <span class="title">throw</span> <span class="params">(invalid_argument)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//判断三角形边长是否为正 </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (a &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || c &lt;= <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;the side length should be positive&quot;</span>); </span><br><span class="line"></span><br><span class="line"> <span class="comment">//判断三边长是否满足三角不等式 </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (a + b &lt;= c || b + c &lt;= a || c + a &lt;= b) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;the side length should fit the triangle </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inequation&quot;</span>); </span><br><span class="line"></span><br><span class="line"> <span class="comment">//由Heron公式计算三角形面积 </span></span><br><span class="line"></span><br><span class="line"> <span class="type">double</span> s = (a + b + c) / <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">sqrt</span>(s * (s - a) * (s - b) * (s - c)); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="type">double</span> a, b, c; <span class="comment">//三角形三边长 </span></span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Please input the side lengths of a triangle: &quot;</span>; </span><br><span class="line"></span><br><span class="line"> cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="type">double</span> s = <span class="built_in">area</span>(a, b, c); <span class="comment">//尝试计算三角形面积 </span></span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; s &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"> &#125; <span class="built_in">catch</span> (exception &amp;e) &#123; </span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>• 运行结果1： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please input the side lengths of a triangle: <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line">Area: <span class="number">6</span> </span><br></pre></td></tr></table></figure><p>• 运行结果2： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please input the side lengths of a triangle: <span class="number">0</span> <span class="number">5</span> <span class="number">5</span> </span><br><span class="line">Error: the side length should be positive </span><br></pre></td></tr></table></figure><p>• 运行结果2： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please input the side lengths of a triangle: <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line">Error: the side length should fit the triangle inequation 小结 </span><br></pre></td></tr></table></figure><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul><li><p>异常处理的基本思想</p></li><li><p>C++异常处理的实现</p></li><li><p>异常处理中的构造与析构</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第-12-章-异常处理&quot;&gt;&lt;a href=&quot;#第-12-章-异常处理&quot; class=&quot;headerlink&quot; title=&quot;第 12 章 异常处理&quot;&gt;&lt;/a&gt;第 12 章 异常处理&lt;/h2&gt;&lt;h3 id=&quot;本章主要内容&quot;&gt;&lt;a href=&quot;#本章主要内容&quot; cla</summary>
      
    
    
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>SPOC(11)：流类库与输入输出</title>
    <link href="http://example.com/2024/08/14/SPOC%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%B5%81%E7%B1%BB%E5%BA%93%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://example.com/2024/08/14/SPOC%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%B5%81%E7%B1%BB%E5%BA%93%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2024-08-14T02:11:36.000Z</published>
    <updated>2024-08-14T02:19:02.929Z</updated>
    
    <content type="html"><![CDATA[<p>第十一章 流类库与输入&#x2F;输出</p><p>主要内容</p><p> I&#x2F;O流的概念</p><p> 流类库结构</p><p> 输出流</p><p> 输入流</p><p> 输入&#x2F;输出流</p><p> 读写文本文件的格式控制</p><p>I&#x2F;O 流的概念及流类库结构</p><p>程序与外界环境的信息交换</p><p> 当程序与外界环境进行信息交换时，存在着两个对象：程序中的对象、文件对象。</p><p>流</p><p> 一种抽象，负责在数据的生产者和数据的消费者之间建立联系，并管理数据的流动。</p><p>流对象与文件操作</p><p> 程序建立一个流对象</p><p> 指定这个流对象与某个文件对象建立连接</p><p> 程序操作流对象</p><p> 流对象通过文件系统对所连接的文件对象产生作用。</p><p>提取与插入</p><p> 读操作在流数据抽象中被称为（从流中）提取</p><p> 写操作被称为（向流中）插入。</p><p>流类库结构流类列表</p><p>输出流概述</p><p>最重要的三个输出流</p><p> ostream</p><p> ofstream</p><p> ostringstream</p><p>预先定义的输出流对象</p><p> cout 标准输出</p><p> cerr 标准错误输出，没有缓冲，发送给它的内容立即被输出。 clog 类似于cerr，但是有缓冲，缓冲区满时被输出。</p><p>标准输出换向</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;b.out&quot;</span>)</span></span>;</span><br><span class="line">streambuf* pOld =cout.<span class="built_in">rdbuf</span>(fout.<span class="built_in">rdbuf</span>()); </span><br><span class="line"><span class="comment">//…</span></span><br><span class="line">cout.<span class="built_in">rdbuf</span>(pOld); </span><br></pre></td></tr></table></figure><p>构造输出流对象</p><p> ofstream类支持磁盘文件输出</p><p> 如果在构造函数中指定一个文件名，当构造这个对象时该文件是自动打开的</p><p>ofstream myFile(“filename”);</p><p> 可以在调用默认构造函数之后使用open成员函数打开文件</p><p>ofstream myFile; &#x2F;&#x2F;声明一个静态文件输出流对象</p><p>myFile.open(“filename”); &#x2F;&#x2F;打开文件，使流对象与文件建立联系</p><p> 在构造对象或用open打开文件时可以指定模式</p><p>ofstream myFile(“filename”, ios_base::out | ios_base::binary);</p><p>文件输出流成员函数的三种类型</p><p> 与操纵符等价的成员函数。</p><p> 执行非格式化写操作的成员函数。</p><p> 其它修改流状态且不同于操纵符或插入运算符的成员函数。</p><p>文件输出流成员函数</p><p> open函数</p><p>把流与一个特定的磁盘文件关联起来。</p><p>需要指定打开模式。</p><p> put函数</p><p>把一个字符写到输出流中。</p><p> write函数</p><p>把内存中的一块内容写到一个文件输出流中</p><p> seekp和tellp函数</p><p>操作文件流的内部指针</p><p> close函数</p><p>关闭与一个文件输出流关联的磁盘文件</p><p> 错误处理函数在写到一个流时进行错误处理</p><p>向文本文件输出</p><p>标准输出设备显示器被系统看作文本文件，所以我们以向标准设备输出为例，介绍文本</p><p>文件输出格式控制</p><p>插入运算符</p><p> 插入(&lt;&lt;)运算符</p><p> </p><p>为所有标准C++数据类型预先设计的，用于传送字节到一个输出流对象。</p><p>操纵符（manipulator）</p><p> 插入运算符与操纵符一起工作</p><p> </p><p>控制输出格式。</p><p> 很多操纵符都定义在</p><p> </p><p>ios_base类中（如hex()）、<iomanip>头文件（如setprecision()）。</iomanip></p><p> 控制输出宽度</p><p> </p><p>在流中放入setw操纵符或调用width成员函数为每个项指定输出宽度。</p><p> setw和width仅影响紧随其后的输出项，但其它流格式操纵符保持有效直到发生改</p><p>变。</p><p> dec、oct和hex操纵符设置输入和输出的默认进制。</p><p>例 11-1 使用 width 控制输出宽度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.23</span> <span class="number">35.36</span></span><br><span class="line"><span class="number">653.7</span></span><br><span class="line"><span class="number">4358.24</span></span><br></pre></td></tr></table></figure><p>例 11-2 使用 <strong>setw</strong> 操纵符指定宽度</p><p>&#x2F;&#x2F;11_2.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i] </span><br><span class="line"> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Zoot <span class="number">1.23</span></span><br><span class="line">Jimmy <span class="number">35.36</span></span><br><span class="line"> Al <span class="number">653.7</span></span><br><span class="line"> Stan <span class="number">4358.24</span></span><br></pre></td></tr></table></figure><p>例 11-3 设置对齐方式</p><p>&#x2F;&#x2F;11_3.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)<span class="comment">//左对齐 &lt;&lt; setw(6) &lt;&lt; names[i]</span></span><br><span class="line"> &lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)</span><br><span class="line"> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1.23</span></span><br><span class="line">Jimmy <span class="number">35.36</span></span><br><span class="line">Al <span class="number">653.7</span></span><br><span class="line">Stan <span class="number">4358.24</span></span><br></pre></td></tr></table></figure><p>setiosflags 操纵符</p><p> 这个程序中，通过使用带参数的setiosflags操纵符来设置左对齐，setiosflags定</p><p>义在头文件iomanip中。</p><p> 参数ios_base::left是ios_base的静态常量，因此引用时必须包括ios_base::前缀。</p><p> 这里需要用resetiosflags操纵符关闭左对齐标志。setiosflags不同于width和setw，</p><p>它的影响是持久的，直到用resetiosflags重新恢复默认值时为止 。</p><p> setiosflags的参数是该流的格式标志值，可用按位或（|）运算符进行组合</p><p>setiosflags 的参数（流的格式标识）</p><p> ios_base::skipws 在输入中跳过空白 。</p><p> ios_base::left 左对齐值，用填充字符填充右边。</p><p> ios_base::right 右对齐值，用填充字符填充左边（默认对齐方式）。</p><p> ios_base::internal 在规定的宽度内，指定前缀符号之后，数值之前，插入指定的</p><p>填充字符。</p><p> ios_base::dec 以十进制形式格式化数值（默认进制）。</p><p> ios_base::oct 以八进制形式格式化数值 。</p><p> ios_base::hex 以十六进制形式格式化数值。</p><p> ios_base::showbase 插入前缀符号以表明整数的数制。</p><p> ios_base::showpoint 对浮点数值显示小数点和尾部的0 。</p><p> ios_base::uppercase 对于十六进制数值显示大写字母A到F，对于科学格式显示大</p><p>写字母E 。</p><p> ios_base::showpos 对于非负数显示正号（“+”）。</p><p> ios_base::scientific 以科学格式显示浮点数值。</p><p> ios_base::fixed 以定点格式显示浮点数值（没有指数部分） 。</p><p> ios_base::unitbuf 在每次插入之后转储并清除缓冲区内容。精度</p><p> 浮点数输出精度的默认值是6，例如：3466.98。</p><p> 要改变精度：setprecision操纵符（定义在头文件iomanip中）。</p><p> 如果不指定fixed或scientific，精度值表示有效数字位数。</p><p> 如果设置了ios_base::fixed或ios_base::scientific精度值表示小数点之后的位数。</p><p>例 11-4 控制输出精度——未指定 fixed 或 scientific</p><p>&#x2F;&#x2F;11_4_1.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1</span></span><br><span class="line">Jimmy <span class="number">4e+001</span></span><br><span class="line">Al <span class="number">7e+002</span></span><br><span class="line">Stan <span class="number">4e+003</span></span><br></pre></td></tr></table></figure><p>例 11-4 控制输出精度——指定 fixed</p><p>&#x2F;&#x2F;11_4_2.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::fixed);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1.2</span></span><br><span class="line">Jimmy <span class="number">35.4</span></span><br><span class="line">Al <span class="number">653.7</span></span><br><span class="line">Stan <span class="number">4358.2</span></span><br></pre></td></tr></table></figure><p>例 11-4 控制输出精度——指定 scientific</p><p>&#x2F;&#x2F;11_4_3.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::scientific);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1.2e+000</span>Jimmy <span class="number">3.5e+001</span></span><br><span class="line">Al <span class="number">6.5e+002</span></span><br><span class="line">Stan <span class="number">4.4e+003</span></span><br></pre></td></tr></table></figure><p>向二进制文件输出</p><p>二进制文件流</p><p> 使用ofstream构造函数中的模式参量指定二进制输出模式；</p><p> 以通常方式构造一个流，然后使用setmode成员函数，在文件打开后改变模式；</p><p> 通过二进制文件输出流对象完成输出。</p><p>例 11-5 向二进制文件输出</p><p>&#x2F;&#x2F;11_5.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span> &#123; </span><br><span class="line"><span class="type">int</span> mon, day, year; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Date dt = &#123; <span class="number">6</span>, <span class="number">10</span>, <span class="number">92</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;date.dat&quot;</span>, ios_base::binary)</span></span>;</span><br><span class="line">file.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;dt),<span class="built_in">sizeof</span>(dt));</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向字符串输出</p><p>将字符串作为输出流的目标，可以实现将其他数据类型转换为字符串的功能</p><p>字符串输出流（ ostringstream ）</p><p> 用于构造字符串</p><p> 功能</p><p> </p><p>支持ofstream类的除open、close外的所有操作</p><p> </p><p>str函数可以返回当前已构造的字符串 典型应用</p><p> </p><p>将数值转换为字符串</p><p>例 11-6 用 ostringstream 将数值转换为字符串</p><p>&#x2F;&#x2F;11_6.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">toString</span><span class="params">(<span class="type">const</span> T &amp;v)</span> </span>&#123;</span><br><span class="line">ostringstream os; <span class="comment">//创建字符串输出流</span></span><br><span class="line">os &lt;&lt; v; </span><br><span class="line"><span class="comment">//将变量v的值写入字符串流</span></span><br><span class="line"><span class="keyword">return</span> os.<span class="built_in">str</span>(); </span><br><span class="line"><span class="comment">//返回输出流生成的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str1 = <span class="built_in">toString</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2 = <span class="built_in">toString</span>(<span class="number">1.2</span>);</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure><p>输入流概述</p><p>重要的输入流类</p><p> istream类最适合用于顺序文本模式输入。cin是其实例<strong>。</strong></p><p> ifstream类支持磁盘文件输入。</p><p> istringstream</p><p>函数模板 toString 可以将各种支持</p><p>“&lt;&lt;“插入符的类型的对象转换为字符串。构造输入流对象</p><p> 如果在构造函数中指定一个文件名，在构造该对象时该文件便自动打开。</p><p><strong>ifstream myFile(“filename”);</strong></p><p> 在调用默认构造函数之后使用open函数来打开文件。</p><p>ifstream myFile; &#x2F;&#x2F;建立一个文件流对象</p><p><strong>myFile.open(“filename”); &#x2F;&#x2F;<strong><strong>打开文件</strong></strong>“filename****”</strong></p><p> 打开文件时可以指定模式</p><p><strong>ifstream myFile(“filename”, ios_base::in | ios_base::binary);</strong></p><p>使用提取运算符从文本文件输入</p><p> 提取运算符(&gt;&gt;)对于所有标准C++数据类型都是预先设计好的。</p><p> 是从一个输入流对象获取字节最容易的方法。</p><p> ios类中的很多操纵符都可以应用于输入流。但是只有少数几个对输入流对象具有</p><p>实际影响，其中最重要的是进制操纵符dec、oct和hex。</p><p>输入流相关函数</p><p> open 把该流与一个特定磁盘文件相关联。</p><p> get 功能与提取运算符（&gt;&gt;）很相像，主要的不同点是get函数在读入数据时包</p><p>括空白字符。</p><p> getline 功能是从输入流中读取多个字符，并且允许指定输入终止字符，读取完成</p><p>后，从读取的内容中删除终止字符。</p><p> read 从一个文件读字节到一个指定的内存区域，由长度参数确定要读的字节数。</p><p>当遇到文件结束或者在文本模式文件中遇到文件结束标记字符时结束读取。</p><p> seekg 用来设置文件输入流中读取数据位置的指针。</p><p> tellg 返回当前文件读指针的位置。</p><p> close 关闭与一个文件输入流关联的磁盘文件。</p><p>输入流应用举例</p><p>例 11-7 <strong>get</strong> 函数应用举例</p><p>&#x2F;&#x2F;11_7.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> ch;<span class="keyword">while</span> ((ch = cin.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">cout.<span class="built_in">put</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例 11-8 为输入流指定一个终止字符：</p><p>&#x2F;&#x2F;11_8.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> string line;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Type a line terminated by &#x27;t&#x27; &quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="built_in">getline</span>(cin, line, <span class="string">&#x27;t&#x27;</span>);</span><br><span class="line"> cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例 11-9 从文件读一个二进制记录到一个结构中</p><p>&#x2F;&#x2F;11_9.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SalaryInfo</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> id;</span><br><span class="line"><span class="type">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SalaryInfo employee1 = &#123; <span class="number">600001</span>, <span class="number">8000</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">os</span><span class="params">(<span class="string">&quot;payroll&quot;</span>, ios_base::out | ios_base::binary)</span></span>;</span><br><span class="line">os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;employee1), <span class="built_in">sizeof</span>(employee1));</span><br><span class="line">os.<span class="built_in">close</span>();<span class="function">ifstream <span class="title">is</span><span class="params">(<span class="string">&quot;payroll&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (is) &#123;</span><br><span class="line">SalaryInfo employee2;</span><br><span class="line">is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;employee2), <span class="built_in">sizeof</span>(employee2));</span><br><span class="line">cout &lt;&lt; employee2.id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; employee2.salary &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;payroll&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">is.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例 11-10 用 <strong>seekg</strong> 函数设置位置指针</p><p>&#x2F;&#x2F;11_10.cpp, 头部分省略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> values[] = &#123; <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">os</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::out | ios_base::binary)</span></span>;</span><br><span class="line">os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(values), <span class="built_in">sizeof</span>(values));</span><br><span class="line">os.<span class="built_in">close</span>();</span><br><span class="line"><span class="function">ifstream <span class="title">is</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (is) &#123;</span><br><span class="line">is.<span class="built_in">seekg</span>(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;v), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The 4th integer in the file &#x27;integers&#x27; is &quot;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;integers&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例 11-11 读一个文件并显示出其中 0 元素的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_11.cpp, 头部分省略int main() &#123;</span></span><br><span class="line"><span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line"><span class="keyword">while</span> (file) &#123;<span class="comment">//读到文件尾file为0</span></span><br><span class="line"> streampos here = file.<span class="built_in">tellg</span>();</span><br><span class="line"> <span class="type">int</span> v;</span><br><span class="line"> file.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;v), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">if</span> (file &amp;&amp; v == <span class="number">0</span>) </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Position &quot;</span> &lt;&lt; here &lt;&lt; <span class="string">&quot; is 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;integers&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从字符串输入</p><p>将字符串作为文本输入流的源，可以将字符串转换为其他数据类型</p><p>字符串输入流（ istringstream）</p><p> 用于从字符串读取数据</p><p> 在构造函数中设置要读取的字符串</p><p> 功能</p><p> </p><p>支持ifstream类的除open、close外的所有操作</p><p> 典型应用</p><p> </p><p>将字符串转换为数值</p><p>例 11-12 用 istringstream 将字符串转换为数值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_12.cpp, 头部分省略</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">fromString</span><span class="params">(<span class="type">const</span> string &amp;str)</span> </span>&#123;</span><br><span class="line"><span class="function">istringstream <span class="title">is</span><span class="params">(str)</span></span>; <span class="comment">//创建字符串输入流</span></span><br><span class="line">T v;is &gt;&gt; v;<span class="comment">//从字符串输入流中读取变量v</span></span><br><span class="line"><span class="keyword">return</span> v; </span><br><span class="line"><span class="comment">//返回变量v</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> v1 = <span class="built_in">fromString</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">cout &lt;&lt; v1 &lt;&lt; endl;</span><br><span class="line"><span class="type">double</span> v2 = <span class="built_in">fromString</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;1.2&quot;</span>);</span><br><span class="line">cout &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure><p>输入&#x2F;输出流</p><p>两个重要的输入&#x2F;输出流</p><p> 一个iostream对象可以是数据的源或目的。</p><p> 两个重要的I&#x2F;O流类都是从iostream派生的，它们是fstream和stringstream。这</p><p>些类继承了前面描述的istream和ostream类的功能。</p><p>fstream 类</p><p> fstream类支持磁盘文件输入和输出。</p><p> 如果需要在同一个程序中从一个特定磁盘文件读并写到该磁盘文件，可以构造一个</p><p>fstream对象。</p><p> 一个fstream对象是有两个逻辑子流的单个流，两个子流一个用于输入，另一个用</p><p>于输出。</p><p>stringstream 类</p><p> stringstream类支持面向字符串的输入和输出</p><p> 可以用于对同一个字符串的内容交替读写，同样是由两个逻辑子流构成。</p><p>小结 主要内容</p><p> </p><p>I&#x2F;O流的概念、流类库结构、输出流、输入流、输入&#x2F;输出流、读写文本文件</p><p>的格式控制。</p><p> 达到的目标</p><p>能够将数据持久化。</p><p>能够处理文本文件和二进制文件。</p><p>能够利用字符串流进行字符串与其他类型之间的转换</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第十一章 流类库与输入&amp;#x2F;输出&lt;/p&gt;
&lt;p&gt;主要内容&lt;/p&gt;
&lt;p&gt; I&amp;#x2F;O流的概念&lt;/p&gt;
&lt;p&gt; 流类库结构&lt;/p&gt;
&lt;p&gt; 输出流&lt;/p&gt;
&lt;p&gt; 输入流&lt;/p&gt;
&lt;p&gt; 输入&amp;#x2F;输出流&lt;/p&gt;
&lt;p&gt; 读写文本文件的格式控制&lt;</summary>
      
    
    
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>SPOC(11)：流类库与输入输出</title>
    <link href="http://example.com/2024/08/14/SPOC%EF%BC%9A%E6%B5%81%E7%B1%BB%E5%BA%93%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <id>http://example.com/2024/08/14/SPOC%EF%BC%9A%E6%B5%81%E7%B1%BB%E5%BA%93%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</id>
    <published>2024-08-14T02:11:36.000Z</published>
    <updated>2024-08-15T01:45:38.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十一章-流类库与输入-输出"><a href="#第十一章-流类库与输入-输出" class="headerlink" title="第十一章 流类库与输入&#x2F;输出"></a>第十一章 流类库与输入&#x2F;输出</h2><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ul><li><p>I&#x2F;O流的概念</p></li><li><p>流类库结构</p></li><li><p>输出流</p></li><li><p>输入流</p></li><li><p>输入&#x2F;输出流</p></li><li><p>读写文本文件的格式控制</p></li></ul><h3 id="I-O-流的概念及流类库结构"><a href="#I-O-流的概念及流类库结构" class="headerlink" title="I&#x2F;O 流的概念及流类库结构"></a>I&#x2F;O 流的概念及流类库结构</h3><h4 id="程序与外界环境的信息交换"><a href="#程序与外界环境的信息交换" class="headerlink" title="程序与外界环境的信息交换"></a>程序与外界环境的信息交换</h4><p>当程序与外界环境进行信息交换时，存在着两个对象：程序中的对象、文件对象。</p><h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>一种抽象，负责在数据的生产者和数据的消费者之间建立联系，并管理数据的流动。流对象与文件操作</p><ul><li><p>程序建立一个流对象</p></li><li><p>指定这个流对象与某个文件对象建立连接</p></li><li><p>程序操作流对象</p></li><li><p>流对象通过文件系统对所连接的文件对象产生作用。</p></li></ul><h4 id="提取与插入"><a href="#提取与插入" class="headerlink" title="提取与插入"></a>提取与插入</h4><ul><li><p>读操作在流数据抽象中被称为（从流中）提取</p></li><li><p>写操作被称为（向流中）插入。</p></li></ul><p>流类库结构流类列表</p><p>输出流概述</p><h4 id="最重要的三个输出流"><a href="#最重要的三个输出流" class="headerlink" title="最重要的三个输出流"></a>最重要的三个输出流</h4><ul><li><p>ostream</p></li><li><p>ofstream</p></li><li><p>ostringstream</p></li></ul><h4 id="预先定义的输出流对象"><a href="#预先定义的输出流对象" class="headerlink" title="预先定义的输出流对象"></a>预先定义的输出流对象</h4><ul><li><p>cout 标准输出</p></li><li><p>cerr 标准错误输出，没有缓冲，发送给它的内容立即被输出。 clog 类似于cerr，但是有缓冲，缓冲区满时被输出。</p></li></ul><h4 id="标准输出换向"><a href="#标准输出换向" class="headerlink" title="标准输出换向"></a>标准输出换向</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;b.out&quot;</span>)</span></span>;</span><br><span class="line">streambuf* pOld =cout.<span class="built_in">rdbuf</span>(fout.<span class="built_in">rdbuf</span>()); </span><br><span class="line"><span class="comment">//…</span></span><br><span class="line">cout.<span class="built_in">rdbuf</span>(pOld); </span><br></pre></td></tr></table></figure><h4 id="构造输出流对象"><a href="#构造输出流对象" class="headerlink" title="构造输出流对象"></a>构造输出流对象</h4><ul><li><p>ofstream类支持磁盘文件输出</p></li><li><p>如果在构造函数中指定一个文件名，当构造这个对象时该文件是自动打开的ofstream myFile(“filename”);</p></li><li><p>可以在调用默认构造函数之后使用open成员函数打开文件ofstream myFile; &#x2F;&#x2F;声明一个静态文件输出流对象myFile.open(“filename”); &#x2F;&#x2F;打开文件，使流对象与文件建立联系</p></li><li><p>在构造对象或用open打开文件时可以指定模式ofstream myFile(“filename”, ios_base::out | ios_base::binary);</p></li></ul><h4 id="文件输出流成员函数的三种类型"><a href="#文件输出流成员函数的三种类型" class="headerlink" title="文件输出流成员函数的三种类型"></a>文件输出流成员函数的三种类型</h4><ul><li><p>与操纵符等价的成员函数。</p></li><li><p>执行非格式化写操作的成员函数。</p></li><li><p>其它修改流状态且不同于操纵符或插入运算符的成员函数。</p></li></ul><h4 id="文件输出流成员函数"><a href="#文件输出流成员函数" class="headerlink" title="文件输出流成员函数"></a>文件输出流成员函数</h4><ul><li>open函数</li></ul><p>把流与一个特定的磁盘文件关联起来。</p><p>需要指定打开模式。</p><ul><li>put函数</li></ul><p>把一个字符写到输出流中。</p><ul><li>write函数</li></ul><p>把内存中的一块内容写到一个文件输出流中</p><ul><li>seekp和tellp函数</li></ul><p>操作文件流的内部指针</p><ul><li>close函数</li></ul><p>关闭与一个文件输出流关联的磁盘文件</p><ul><li>错误处理函数在写到一个流时进行错误处理</li></ul><h4 id="向文本文件输出"><a href="#向文本文件输出" class="headerlink" title="向文本文件输出"></a>向文本文件输出</h4><p>标准输出设备显示器被系统看作文本文件，所以我们以向标准设备输出为例，介绍文本</p><p>文件输出格式控制</p><h4 id="插入运算符"><a href="#插入运算符" class="headerlink" title="插入运算符"></a>插入运算符</h4><ul><li><p>插入(&lt;&lt;)运算符</p></li><li><p>为所有标准C++数据类型预先设计的，用于传送字节到一个输出流对象。</p></li></ul><h4 id="操纵符（manipulator）"><a href="#操纵符（manipulator）" class="headerlink" title="操纵符（manipulator）"></a>操纵符（manipulator）</h4><ul><li><p>插入运算符与操纵符一起工作</p></li><li><p>控制输出格式。</p></li><li><p>很多操纵符都定义在ios_base类中（如hex()）、<iomanip>头文件（如setprecision()）。</iomanip></p></li><li><p>控制输出宽度</p><ol><li><p>在流中放入setw操纵符或调用width成员函数为每个项指定输出宽度。</p></li><li><p>setw和width仅影响紧随其后的输出项，但其它流格式操纵符保持有效直到发生改</p></li></ol></li></ul><p>变。</p><ul><li>dec、oct和hex操纵符设置输入和输出的默认进制。</li></ul><h4 id="例-11-1-使用-width-控制输出宽度"><a href="#例-11-1-使用-width-控制输出宽度" class="headerlink" title="例 11-1 使用 width 控制输出宽度"></a>例 11-1 使用 width 控制输出宽度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果:"></a>输出结果:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.23</span> <span class="number">35.36</span></span><br><span class="line"><span class="number">653.7</span></span><br><span class="line"><span class="number">4358.24</span></span><br></pre></td></tr></table></figure><h4 id="例-11-2-使用-setw-操纵符指定宽度"><a href="#例-11-2-使用-setw-操纵符指定宽度" class="headerlink" title="例 11-2 使用 setw 操纵符指定宽度"></a>例 11-2 使用 <strong>setw</strong> 操纵符指定宽度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i] </span><br><span class="line"> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果:"></a>输出结果:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Zoot <span class="number">1.23</span></span><br><span class="line">Jimmy <span class="number">35.36</span></span><br><span class="line"> Al <span class="number">653.7</span></span><br><span class="line"> Stan <span class="number">4358.24</span></span><br></pre></td></tr></table></figure><h4 id="例-11-3-设置对齐方式"><a href="#例-11-3-设置对齐方式" class="headerlink" title="例 11-3 设置对齐方式"></a>例 11-3 设置对齐方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_3.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)<span class="comment">//左对齐 &lt;&lt; setw(6) &lt;&lt; names[i]</span></span><br><span class="line"> &lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)</span><br><span class="line"> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果-2"><a href="#输出结果-2" class="headerlink" title="输出结果:"></a>输出结果:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1.23</span></span><br><span class="line">Jimmy <span class="number">35.36</span></span><br><span class="line">Al <span class="number">653.7</span></span><br><span class="line">Stan <span class="number">4358.24</span></span><br></pre></td></tr></table></figure><h4 id="setiosflags-操纵符"><a href="#setiosflags-操纵符" class="headerlink" title="setiosflags 操纵符"></a>setiosflags 操纵符</h4><ul><li><p>这个程序中，通过使用带参数的setiosflags操纵符来设置左对齐，setiosflags定义在头文件iomanip中。</p></li><li><p>参数ios_base::left是ios_base的静态常量，因此引用时必须包括ios_base::前缀。</p></li><li><p>这里需要用resetiosflags操纵符关闭左对齐标志。setiosflags不同于width和setw，它的影响是持久的，直到用resetiosflags重新恢复默认值时为止 。</p></li><li><p>setiosflags的参数是该流的格式标志值，可用按位或（|）运算符进行组合setiosflags 的参数（流的格式标识）</p></li><li><p>ios_base::skipws 在输入中跳过空白 。</p></li><li><p>ios_base::left 左对齐值，用填充字符填充右边。</p></li><li><p>ios_base::right 右对齐值，用填充字符填充左边（默认对齐方式）。</p></li><li><p>ios_base::internal 在规定的宽度内，指定前缀符号之后，数值之前，插入指定的填充字符。</p></li><li><p>ios_base::dec 以十进制形式格式化数值（默认进制）。</p></li><li><p>ios_base::oct 以八进制形式格式化数值 。</p></li><li><p>ios_base::hex 以十六进制形式格式化数值。</p></li><li><p>ios_base::showbase 插入前缀符号以表明整数的数制。</p></li><li><p>ios_base::showpoint 对浮点数值显示小数点和尾部的0 。</p></li><li><p>ios_base::uppercase 对于十六进制数值显示大写字母A到F，对于科学格式显示大写字母E 。</p></li><li><p>ios_base::showpos 对于非负数显示正号（“+”）。</p></li><li><p>ios_base::scientific 以科学格式显示浮点数值。</p></li><li><p>ios_base::fixed 以定点格式显示浮点数值（没有指数部分） 。</p></li><li><p>ios_base::unitbuf 在每次插入之后转储并清除缓冲区内容。精度</p></li><li><p>浮点数输出精度的默认值是6，例如：3466.98。</p></li><li><p>要改变精度：setprecision操纵符（定义在头文件iomanip中）。</p></li><li><p>如果不指定fixed或scientific，精度值表示有效数字位数。</p></li><li><p>如果设置了ios_base::fixed或ios_base::scientific精度值表示小数点之后的位数。</p></li></ul><h4 id="例-11-4-控制输出精度——未指定-fixed-或-scientific"><a href="#例-11-4-控制输出精度——未指定-fixed-或-scientific" class="headerlink" title="例 11-4 控制输出精度——未指定 fixed 或 scientific"></a>例 11-4 控制输出精度——未指定 fixed 或 scientific</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_4_1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1</span></span><br><span class="line">Jimmy <span class="number">4e+001</span></span><br><span class="line">Al <span class="number">7e+002</span></span><br><span class="line">Stan <span class="number">4e+003</span></span><br></pre></td></tr></table></figure><h4 id="例-11-4-控制输出精度——指定-fixed"><a href="#例-11-4-控制输出精度——指定-fixed" class="headerlink" title="例 11-4 控制输出精度——指定 fixed"></a>例 11-4 控制输出精度——指定 fixed</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_4_2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::fixed);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果：-1"><a href="#输出结果：-1" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1.2</span></span><br><span class="line">Jimmy <span class="number">35.4</span></span><br><span class="line">Al <span class="number">653.7</span></span><br><span class="line">Stan <span class="number">4358.2</span></span><br></pre></td></tr></table></figure><h4 id="例-11-4-控制输出精度——指定-scientific"><a href="#例-11-4-控制输出精度——指定-scientific" class="headerlink" title="例 11-4 控制输出精度——指定 scientific"></a>例 11-4 控制输出精度——指定 scientific</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_4_3.cpp</span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::scientific);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果：-2"><a href="#输出结果：-2" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Zoot <span class="number">1.2e+000</span>Jimmy <span class="number">3.5e+001</span></span><br><span class="line">Al <span class="number">6.5e+002</span></span><br><span class="line">Stan <span class="number">4.4e+003</span></span><br></pre></td></tr></table></figure><h3 id="向二进制文件输出"><a href="#向二进制文件输出" class="headerlink" title="向二进制文件输出"></a>向二进制文件输出</h3><h4 id="二进制文件流"><a href="#二进制文件流" class="headerlink" title="二进制文件流"></a>二进制文件流</h4><ul><li><p>使用ofstream构造函数中的模式参量指定二进制输出模式；</p></li><li><p>以通常方式构造一个流，然后使用setmode成员函数，在文件打开后改变模式；</p></li><li><p>通过二进制文件输出流对象完成输出。</p></li></ul><h4 id="例-11-5-向二进制文件输出"><a href="#例-11-5-向二进制文件输出" class="headerlink" title="例 11-5 向二进制文件输出"></a>例 11-5 向二进制文件输出</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_5.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span> &#123; </span><br><span class="line"><span class="type">int</span> mon, day, year; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Date dt = &#123; <span class="number">6</span>, <span class="number">10</span>, <span class="number">92</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;date.dat&quot;</span>, ios_base::binary)</span></span>;</span><br><span class="line">file.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;dt),<span class="built_in">sizeof</span>(dt));</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向字符串输出"><a href="#向字符串输出" class="headerlink" title="向字符串输出"></a>向字符串输出</h4><p>将字符串作为输出流的目标，可以实现将其他数据类型转换为字符串的功能</p><h4 id="字符串输出流（-ostringstream-）"><a href="#字符串输出流（-ostringstream-）" class="headerlink" title="字符串输出流（ ostringstream ）"></a>字符串输出流（ ostringstream ）</h4><ul><li><p>用于构造字符串</p></li><li><p>功能</p><ol><li>支持ofstream类的除open、close外的所有操作</li><li>str函数可以返回当前已构造的字符串 典型应用</li><li>将数值转换为字符串</li></ol></li></ul><h4 id="例-11-6-用-ostringstream-将数值转换为字符串"><a href="#例-11-6-用-ostringstream-将数值转换为字符串" class="headerlink" title="例 11-6 用 ostringstream 将数值转换为字符串"></a>例 11-6 用 ostringstream 将数值转换为字符串</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_6.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">toString</span><span class="params">(<span class="type">const</span> T &amp;v)</span> </span>&#123;</span><br><span class="line">ostringstream os; <span class="comment">//创建字符串输出流</span></span><br><span class="line">os &lt;&lt; v; </span><br><span class="line"><span class="comment">//将变量v的值写入字符串流</span></span><br><span class="line"><span class="keyword">return</span> os.<span class="built_in">str</span>(); </span><br><span class="line"><span class="comment">//返回输出流生成的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str1 = <span class="built_in">toString</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2 = <span class="built_in">toString</span>(<span class="number">1.2</span>);</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果：-3"><a href="#输出结果：-3" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure><h3 id="输入流概述"><a href="#输入流概述" class="headerlink" title="输入流概述"></a>输入流概述</h3><h4 id="重要的输入流类"><a href="#重要的输入流类" class="headerlink" title="重要的输入流类"></a>重要的输入流类</h4><ul><li><p>istream类最适合用于顺序文本模式输入。cin是其实例<strong>。</strong></p></li><li><p>ifstream类支持磁盘文件输入。</p></li><li><p>istringstream</p></li></ul><p>函数模板 toString 可以将各种支持“&lt;&lt;“插入符的类型的对象转换为字符串。构造输入流对象</p><ul><li>如果在构造函数中指定一个文件名，在构造该对象时该文件便自动打开。</li></ul><h4 id="ifstream-myFile-“filename”"><a href="#ifstream-myFile-“filename”" class="headerlink" title="ifstream myFile(“filename”);"></a><strong>ifstream myFile(“filename”);</strong></h4><ul><li>在调用默认构造函数之后使用open函数来打开文件。</li></ul><p>ifstream myFile; &#x2F;&#x2F;建立一个文件流对象</p><h4 id="myFile-open-“filename”-打开文件“filename-”"><a href="#myFile-open-“filename”-打开文件“filename-”" class="headerlink" title="myFile.open(“filename”); &#x2F;&#x2F;打开文件“filename****”"></a><strong>myFile.open(“filename”); &#x2F;&#x2F;<strong><strong>打开文件</strong></strong>“filename****”</strong></h4><p> 打开文件时可以指定模式</p><h4 id="ifstream-myFile-“filename”-ios-base-in-ios-base-binary"><a href="#ifstream-myFile-“filename”-ios-base-in-ios-base-binary" class="headerlink" title="ifstream myFile(“filename”, ios_base::in | ios_base::binary);"></a><strong>ifstream myFile(“filename”, ios_base::in | ios_base::binary);</strong></h4><p>使用提取运算符从文本文件输入</p><ul><li><p>提取运算符(&gt;&gt;)对于所有标准C++数据类型都是预先设计好的。</p></li><li><p>是从一个输入流对象获取字节最容易的方法。</p></li><li><p>ios类中的很多操纵符都可以应用于输入流。但是只有少数几个对输入流对象具有</p></li></ul><p>实际影响，其中最重要的是进制操纵符dec、oct和hex。</p><h4 id="输入流相关函数"><a href="#输入流相关函数" class="headerlink" title="输入流相关函数"></a>输入流相关函数</h4><ul><li><p>open 把该流与一个特定磁盘文件相关联。</p></li><li><p>get 功能与提取运算符（&gt;&gt;）很相像，主要的不同点是get函数在读入数据时包括空白字符。</p></li><li><p>getline 功能是从输入流中读取多个字符，并且允许指定输入终止字符，读取完成后，从读取的内容中删除终止字符。</p></li><li><p>read 从一个文件读字节到一个指定的内存区域，由长度参数确定要读的字节数。当遇到文件结束或者在文本模式文件中遇到文件结束标记字符时结束读取。</p></li><li><p>seekg 用来设置文件输入流中读取数据位置的指针。</p></li><li><p>tellg 返回当前文件读指针的位置。</p></li><li><p>close 关闭与一个文件输入流关联的磁盘文件。</p></li></ul><h4 id="输入流应用举例"><a href="#输入流应用举例" class="headerlink" title="输入流应用举例"></a>输入流应用举例</h4><h4 id="例-11-7-get-函数应用举例"><a href="#例-11-7-get-函数应用举例" class="headerlink" title="例 11-7 get 函数应用举例"></a>例 11-7 <strong>get</strong> 函数应用举例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_7.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> ch;<span class="keyword">while</span> ((ch = cin.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">cout.<span class="built_in">put</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例-11-8-为输入流指定一个终止字符："><a href="#例-11-8-为输入流指定一个终止字符：" class="headerlink" title="例 11-8 为输入流指定一个终止字符："></a>例 11-8 为输入流指定一个终止字符：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_8.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> string line;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Type a line terminated by &#x27;t&#x27; &quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="built_in">getline</span>(cin, line, <span class="string">&#x27;t&#x27;</span>);</span><br><span class="line"> cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例-11-9-从文件读一个二进制记录到一个结构中"><a href="#例-11-9-从文件读一个二进制记录到一个结构中" class="headerlink" title="例 11-9 从文件读一个二进制记录到一个结构中"></a>例 11-9 从文件读一个二进制记录到一个结构中</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_9.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SalaryInfo</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> id;</span><br><span class="line"><span class="type">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SalaryInfo employee1 = &#123; <span class="number">600001</span>, <span class="number">8000</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">os</span><span class="params">(<span class="string">&quot;payroll&quot;</span>, ios_base::out | ios_base::binary)</span></span>;</span><br><span class="line">os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;employee1), <span class="built_in">sizeof</span>(employee1));</span><br><span class="line">os.<span class="built_in">close</span>();<span class="function">ifstream <span class="title">is</span><span class="params">(<span class="string">&quot;payroll&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (is) &#123;</span><br><span class="line">SalaryInfo employee2;</span><br><span class="line">is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;employee2), <span class="built_in">sizeof</span>(employee2));</span><br><span class="line">cout &lt;&lt; employee2.id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; employee2.salary &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;payroll&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">is.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例-11-10-用-seekg-函数设置位置指针"><a href="#例-11-10-用-seekg-函数设置位置指针" class="headerlink" title="例 11-10 用 seekg 函数设置位置指针"></a>例 11-10 用 <strong>seekg</strong> 函数设置位置指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_10.cpp, 头部分省略</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> values[] = &#123; <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">os</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::out | ios_base::binary)</span></span>;</span><br><span class="line">os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(values), <span class="built_in">sizeof</span>(values));</span><br><span class="line">os.<span class="built_in">close</span>();</span><br><span class="line"><span class="function">ifstream <span class="title">is</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (is) &#123;</span><br><span class="line">is.<span class="built_in">seekg</span>(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;v), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The 4th integer in the file &#x27;integers&#x27; is &quot;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;integers&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例-11-11-读一个文件并显示出其中-0-元素的位置"><a href="#例-11-11-读一个文件并显示出其中-0-元素的位置" class="headerlink" title="例 11-11 读一个文件并显示出其中 0 元素的位置"></a>例 11-11 读一个文件并显示出其中 0 元素的位置</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_11.cpp, 头部分省略int main() &#123;</span></span><br><span class="line"><span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line"><span class="keyword">while</span> (file) &#123;<span class="comment">//读到文件尾file为0</span></span><br><span class="line"> streampos here = file.<span class="built_in">tellg</span>();</span><br><span class="line"> <span class="type">int</span> v;</span><br><span class="line"> file.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;v), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">if</span> (file &amp;&amp; v == <span class="number">0</span>) </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Position &quot;</span> &lt;&lt; here &lt;&lt; <span class="string">&quot; is 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;integers&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="从字符串输入"><a href="#从字符串输入" class="headerlink" title="从字符串输入"></a>从字符串输入</h3><p>将字符串作为文本输入流的源，可以将字符串转换为其他数据类型</p><h4 id="字符串输入流（-istringstream）"><a href="#字符串输入流（-istringstream）" class="headerlink" title="字符串输入流（ istringstream）"></a>字符串输入流（ istringstream）</h4><ul><li><p>用于从字符串读取数据</p></li><li><p>在构造函数中设置要读取的字符串</p></li><li><p>功能</p><ol><li>支持ifstream类的除open、close外的所有操作</li></ol></li><li><p>典型应用</p><ol><li>将字符串转换为数值</li></ol></li></ul><h4 id="例-11-12-用-istringstream-将字符串转换为数值"><a href="#例-11-12-用-istringstream-将字符串转换为数值" class="headerlink" title="例 11-12 用 istringstream 将字符串转换为数值"></a>例 11-12 用 istringstream 将字符串转换为数值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//11_12.cpp, 头部分省略</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">fromString</span><span class="params">(<span class="type">const</span> string &amp;str)</span> </span>&#123;</span><br><span class="line"><span class="function">istringstream <span class="title">is</span><span class="params">(str)</span></span>; <span class="comment">//创建字符串输入流</span></span><br><span class="line">T v;is &gt;&gt; v;<span class="comment">//从字符串输入流中读取变量v</span></span><br><span class="line"><span class="keyword">return</span> v; </span><br><span class="line"><span class="comment">//返回变量v</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> v1 = <span class="built_in">fromString</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">cout &lt;&lt; v1 &lt;&lt; endl;</span><br><span class="line"><span class="type">double</span> v2 = <span class="built_in">fromString</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;1.2&quot;</span>);</span><br><span class="line">cout &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果：-4"><a href="#输出结果：-4" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure><h3 id="输入-输出流"><a href="#输入-输出流" class="headerlink" title="输入&#x2F;输出流"></a>输入&#x2F;输出流</h3><h4 id="两个重要的输入-输出流"><a href="#两个重要的输入-输出流" class="headerlink" title="两个重要的输入&#x2F;输出流"></a>两个重要的输入&#x2F;输出流</h4><ul><li><p>一个iostream对象可以是数据的源或目的。</p></li><li><p>两个重要的I&#x2F;O流类都是从iostream派生的，它们是fstream和stringstream。这些类继承了前面描述的istream和ostream类的功能。</p></li></ul><h4 id="fstream-类"><a href="#fstream-类" class="headerlink" title="fstream 类"></a>fstream 类</h4><ul><li><p>fstream类支持磁盘文件输入和输出。</p></li><li><p>如果需要在同一个程序中从一个特定磁盘文件读并写到该磁盘文件，可以构造一个</p></li></ul><h4 id="fstream对象。"><a href="#fstream对象。" class="headerlink" title="fstream对象。"></a>fstream对象。</h4><ul><li>一个fstream对象是有两个逻辑子流的单个流，两个子流一个用于输入，另一个用于输出。</li></ul><p>stringstream 类</p><ul><li><p>stringstream类支持面向字符串的输入和输出</p></li><li><p>可以用于对同一个字符串的内容交替读写，同样是由两个逻辑子流构成。</p></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="主要内容-1"><a href="#主要内容-1" class="headerlink" title="主要内容"></a>主要内容</h4><ul><li><p>I&#x2F;O流的概念</p></li><li><p>流类库结构</p></li><li><p>输出流</p></li><li><p>输入流</p></li><li><p>输入&#x2F;输出流</p></li><li><p>读写文本文件的格式控制</p></li></ul><h4 id="达到的目标"><a href="#达到的目标" class="headerlink" title="达到的目标"></a>达到的目标</h4><ol><li><p>能够将数据持久化。</p></li><li><p>能够处理文本文件和二进制文件。</p></li><li><p>能够利用字符串流进行字符串与其他类型之间的转换</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第十一章-流类库与输入-输出&quot;&gt;&lt;a href=&quot;#第十一章-流类库与输入-输出&quot; class=&quot;headerlink&quot; title=&quot;第十一章 流类库与输入&amp;#x2F;输出&quot;&gt;&lt;/a&gt;第十一章 流类库与输入&amp;#x2F;输出&lt;/h2&gt;&lt;h3 id=&quot;主要内容&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="c++" scheme="http://example.com/tags/c/"/>
    
  </entry>
  
</feed>
