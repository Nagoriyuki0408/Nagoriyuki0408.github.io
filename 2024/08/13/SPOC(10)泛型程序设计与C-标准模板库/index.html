<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>SPOC（10）：泛型程序设计与C++标准模板库 |  柳瀬しおこうの夢</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="柳瀬しおこうの夢" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-SPOC(10)泛型程序设计与C-标准模板库"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  SPOC（10）：泛型程序设计与C++标准模板库
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/08/13/SPOC(10)%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EC-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/" class="article-date">
  <time datetime="2024-08-12T22:20:17.000Z" itemprop="datePublished">2024-08-13</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">9.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">40 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="泛型程序设计的基本概念"><a href="#泛型程序设计的基本概念" class="headerlink" title="泛型程序设计的基本概念"></a>泛型程序设计的基本概念</h2><ul>
<li>编写不依赖于<strong>具体数据类型</strong>的程序</li>
<li>将算法从特定的<strong>数据结构</strong>中抽象出来，成为了<strong>通用</strong>的</li>
<li>C++的模板为<strong>泛型程序设计</strong>奠定了关键的基础</li>
</ul>
<h3 id="术语：概念"><a href="#术语：概念" class="headerlink" title="术语：概念"></a>术语：概念</h3><ul>
<li>用来界定具备一定功能的数<strong>据类型</strong></li>
</ul>
<ol>
<li><p>将 “ <strong>可 以 比 大 小</strong> 的 所 有 数 据 类 型 （ 有 比 较 运 算 符 ）” 这 一 概 念 记 为<strong>Comparable</strong></p>
</li>
<li><p>将“具有<strong>公有的复制构造函数</strong>并可以<strong>用‘&#x3D;’赋值</strong>的数据类型”这一概念记为Assignable</p>
</li>
<li><p>将“可以<strong>比大小</strong>、具有<strong>公有的复制构造函数</strong>并可以<strong>用‘&#x3D;’赋值</strong>的所有数据类型”这个概念记作Sortable。</p>
</li>
</ol>
<ul>
<li>对于两个不同的概念A和B，如果概念A所需要的<strong>所有功能</strong>也是概念B<strong>所需求的功能</strong>，那么就说概念B是概念A的子概念。例如：</li>
</ul>
<p>Sortable既是Comparable的子概念，也是Assignable的子概念</p>
<h3 id="术语：模型"><a href="#术语：模型" class="headerlink" title="术语：模型"></a>术语：模型</h3><ul>
<li>模型（model）：<strong>符合一个概念的数据类型</strong>称为该概念的模型，例如：</li>
</ul>
<ol>
<li><p>int型是Comparable概念的模型。</p>
</li>
<li><p>静态数组类型不是Assignable概念的模型（无法用“&#x3D;”给整个静态数组赋值）</p>
</li>
</ol>
<h3 id="用概念做模板参数名"><a href="#用概念做模板参数名" class="headerlink" title="用概念做模板参数名"></a>用概念做模板参数名</h3><ul>
<li><p>很多STL的实现代码就是使用<strong>概念来命名模板参数</strong>的。</p>
</li>
<li><p>为概念赋予一个名称，并使用该名称作为<strong>模板参数名</strong>。</p>
</li>
<li><p>例如</p>
</li>
</ul>
<ol>
<li><p>表示insertionSort这样一个函数模板的原型：</p>
</li>
<li><p>template <class sortable></class></p>
</li>
<li><p>void insertionSort(Sortable a[], int n);</p>
</li>
</ol>
<h2 id="STL-简介"><a href="#STL-简介" class="headerlink" title="STL 简介"></a>STL 简介</h2><p>标准模板库（Standard Template Library，简称STL）提供了一些非常常用的数据结构和算法</p>
<h3 id="STL-简介-1"><a href="#STL-简介-1" class="headerlink" title="STL 简介"></a>STL 简介</h3><ul>
<li><p>标准模板库（Standard Template Library，简称STL）定义了一套概念体系，为泛型程序设计提供了逻辑基础</p>
</li>
<li><p>STL中的各个类模板、函数模板的参数都是用这个体系中的概念来规定的。</p>
</li>
<li><p>使用STL的模板时，类型参数既可以是C++标准库中已有的类型，也可以是自定义的类型——只要这些类型是所要求概念的模型。</p>
</li>
</ul>
<h3 id="STL-的基本组件"><a href="#STL-的基本组件" class="headerlink" title="STL 的基本组件"></a>STL 的基本组件</h3><ul>
<li><p>容器（container）</p>
</li>
<li><p>迭代器（iterator）</p>
</li>
<li><p>函数对象（function object）</p>
</li>
<li><p>算法（algorithms）</p>
</li>
</ul>
<h3 id="STL-的基本组件间的关系"><a href="#STL-的基本组件间的关系" class="headerlink" title="STL 的基本组件间的关系"></a>STL 的基本组件间的关系</h3><ul>
<li>Iterators（迭代器）是<strong>算法和容器的桥梁</strong>。</li>
</ul>
<ol>
<li>将迭代器作为<strong>算法的参数</strong>、通过迭代器<strong>来访问容器</strong>而不是把容器直接作为<strong>算法的参数</strong>。</li>
</ol>
<ul>
<li><p>将<strong>函数对象</strong>作为<strong>算法的参数</strong>而不是将函数所执行的运算作为算法的一部分。</p>
</li>
<li><p>使用STL中提供的或自定义的迭代器和函数对象，配合STL的算法，可以组合出各种各样的功能。</p>
</li>
</ul>
<p><img src="https://i.postimg.cc/DfjktKxc/33b0c9e6efcf36164beda0525394a156.png" alt="STL"></p>
<h3 id="STL-的基本组件——容器（container）"><a href="#STL-的基本组件——容器（container）" class="headerlink" title="STL 的基本组件——容器（container）"></a>STL 的基本组件——容器（container）</h3><ul>
<li><p>容纳、包含一组元素的<strong>对象</strong>。</p>
</li>
<li><p>基本容器类模板</p>
</li>
</ul>
<ol>
<li><p><strong>顺序容器</strong></p>
</li>
<li><p>array（数组）、vector（向量）、deque（双端队列）、forward_list（单链表）、list（列表）</p>
</li>
<li><p>(<strong>有序)关联容器</strong></p>
</li>
<li><p>set（集合）、multiset（多重集合）、map（映射）、multimap（多重映射）</p>
</li>
<li><p><strong>无序关联容器</strong></p>
</li>
<li><p>unordered_set （无序集合）、unordered_multiset（无序多重集合）</p>
</li>
<li><p>unordered_map（无序映射）、unorder_multimap（无序多重映射）</p>
</li>
</ol>
<ul>
<li><strong>容器适配器</strong></li>
</ul>
<ol>
<li>stack（栈）、queue（队列）、priority_queue（优先队列）</li>
</ol>
<ul>
<li>使用容器，需要包含对应的头文件</li>
</ul>
<h3 id="STL-的基本组件——迭代器（iterator）"><a href="#STL-的基本组件——迭代器（iterator）" class="headerlink" title="STL 的基本组件——迭代器（iterator）"></a>STL 的基本组件——迭代器（iterator）</h3><ul>
<li><p>迭代器是<strong>泛化的指针</strong>，提供了<strong>顺序访问容器</strong>中每个元素的方法</p>
</li>
<li><p>提供了顺序访问容器中每个元素的方法；</p>
</li>
<li><p>可以使用“++”运算符来<strong>获得指向下一个元素的迭代器</strong>；</p>
</li>
<li><p>可以<strong>使用“*”运算符访问一个迭代器所指向的元素</strong>，如果元素类型是<strong>类或结构体</strong>，还可以使用“-&gt;”运算符直接访问该元素的一个成员；</p>
</li>
<li><p>有些迭代器还支持通过“–”运算符获得指向上一个元素的迭代器；</p>
</li>
<li><p>迭代器是泛化的指针：指针也具有同样的特性，因此指针本身就是一种迭代器；</p>
</li>
<li><p>使用独立于<strong>STL容器的迭代器</strong>，需要包含头文件<iterator>。</iterator></p>
</li>
</ul>
<h3 id="STL-的基本组件——函数对象（function-object）"><a href="#STL-的基本组件——函数对象（function-object）" class="headerlink" title="STL 的基本组件——函数对象（function object）"></a>STL 的基本组件——函数对象（function object）</h3><ul>
<li><p>一个<strong>行为类似函数</strong>的对象，对它可以像调用函数一样调用。</p>
</li>
<li><p>函数对象是<strong>泛化的函数</strong>：任何普通的函数和任何重载了“()” 运算符的类的对象都可以作为函数对象使用</p>
</li>
<li><p>使用STL的函数对象，需要包含头文件<functional></functional></p>
</li>
</ul>
<h3 id="STL-的基本组件——算法（algorithms）"><a href="#STL-的基本组件——算法（algorithms）" class="headerlink" title="STL 的基本组件——算法（algorithms）"></a>STL 的基本组件——算法（algorithms）</h3><ul>
<li>STL包括70多个算法</li>
</ul>
<ol>
<li>例如：排序算法，消除算法，计数算法，比较算法，变换算法，置换算法和</li>
</ol>
<p>容器管理等</p>
<ul>
<li><p>可以广泛用于<strong>不同的对象</strong>和<strong>内置的数据类型</strong>。</p>
</li>
<li><p>使用STL的算法，需要包含头文件<algorithm>。</algorithm></p>
</li>
<li><p>例10-1从标准输入读入几个整数，存入向量容器，输出它们的相反数</p>
</li>
</ul>
<h3 id="例-10-1：STL-程序实例"><a href="#例-10-1：STL-程序实例" class="headerlink" title="例 10-1：STL 程序实例"></a>例 10-1：STL 程序实例</h3><ul>
<li>transform算法</li>
</ul>
<ol>
<li>transform算法的一种实现：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">UnaryFunction</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">transform</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;first != last; ++first, ++result)</span><br><span class="line">*result = <span class="built_in">op</span>(*first);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>transform算法<strong>顺序遍历first和last两个迭代器所指向</strong>的元素；</p>
</li>
<li><p>将每个元素的值作为<strong>函数对象op</strong>的参数；</p>
</li>
<li><p>将op的返回值通过<strong>迭代器result</strong>顺序输出；</p>
</li>
<li><p>遍历完成后result迭代器指向的是输出的最后一个元素的下一个位置，transform会将该迭代器返回</p>
</li>
</ol>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>迭代器是算法和容器的桥梁</li>
</ul>
<ol>
<li>迭代器用作访问容器中的元素</li>
<li>算法不直接操作容器中的数据，而是通<strong>过迭代器间接操作</strong></li>
</ol>
<ul>
<li>算法和容器独立</li>
</ul>
<ol>
<li><p>增加新的算法，无需影响容器的实现</p>
</li>
<li><p>增加新的容器，原有的算法也能适用</p>
</li>
</ol>
<h3 id="输入流迭代器和输出流迭代器"><a href="#输入流迭代器和输出流迭代器" class="headerlink" title="输入流迭代器和输出流迭代器"></a>输入流迭代器和输出流迭代器</h3><ul>
<li>输入流迭代器</li>
</ul>
<p>istream_iterator<T></T></p>
<ol>
<li><p>以<strong>输入流（如cin）</strong>为参数构造</p>
</li>
<li><p>*<em>可用</em>(p++)**获得下一个输入的元素</p>
</li>
</ol>
<ul>
<li>输出流迭代器</li>
</ul>
<p>ostream_iterator<T></T></p>
<ol>
<li><p>构造时需要提供输出流（如cout）</p>
</li>
<li><p>可用(*p++) &#x3D; x将x输出到输出流</p>
</li>
</ol>
<ul>
<li>二者都属于适配器</li>
</ul>
<ol>
<li><p>适配器是用来为已有<strong>对象提供新的接口的对象</strong></p>
</li>
<li><p>输入流适配器和输出流适配器为<strong>流对象</strong>提供了迭代器的接口</p>
</li>
</ol>
<h3 id="例-10-2-从标准输入读入几个实数，分别将它们的平方输出"><a href="#例-10-2-从标准输入读入几个实数，分别将它们的平方输出" class="headerlink" title="例 10-2 从标准输入读入几个实数，分别将它们的平方输出"></a>例 10-2 从标准输入读入几个实数，分别将它们的平方输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//求平方的函数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//从标准输入读入若干个实数，分别将它们的平方输出</span></span><br><span class="line"> <span class="built_in">transform</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">double</span>&gt;(cin), <span class="built_in">istream_iterator</span>&lt;<span class="type">double</span>&gt;(),</span><br><span class="line"><span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout, <span class="string">&quot;\t&quot;</span>), square);</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h3><p><img src="https://i.postimg.cc/0Nz1kXrw/60ee0dff11d1d4065b50330cd32adcd7.png"></p>
<h3 id="迭代器支持的操作"><a href="#迭代器支持的操作" class="headerlink" title="迭代器支持的操作"></a>迭代器支持的操作</h3><ul>
<li>迭代器是<strong>泛化的指针</strong>，提供了类似指针的操作（诸如++、*、-&gt;运算符）</li>
</ul>
<ol>
<li><p>输入迭代器</p>
<p>可以用来从序列中<strong>读取数据</strong>，如<strong>输入流迭代器</strong></p>
</li>
<li><p>输出迭代器</p>
<p>允许向序列中<strong>写入数据</strong>，如<strong>输出流迭代器</strong></p>
</li>
<li><p>前向迭代器</p>
<p>既是输入迭代器又是输出迭代器，并且可以<strong>对序列进行单向的遍历</strong></p>
</li>
<li><p>双向迭代器</p>
<p>与前向迭代器相似，但是在<strong>两个方向上</strong>都可以对数据遍历</p>
</li>
<li><p>随机访问迭代器</p>
<p>也是双向迭代器，但能够在序列中的<strong>任意两个位置</strong>之间进行跳转，如指针、使用vector的begin()、end()函数得到的迭代器</p>
</li>
</ol>
<h3 id="迭代器的区间"><a href="#迭代器的区间" class="headerlink" title="迭代器的区间"></a>迭代器的区间</h3><ul>
<li><p>两个<strong>迭代器</strong>表示一个区间：[p1, p2)</p>
</li>
<li><p>STL算法常以迭代器的区间作为<strong>输入，传递输入数据</strong></p>
</li>
<li><p><strong>合法的区间</strong></p>
</li>
<li><p>p1经过n次(n &gt; 0)自增(++)操作后<strong>满足p1 &#x3D;&#x3D; p2</strong></p>
</li>
<li><p>区间<strong>包含p1</strong>，但<strong>不包含p2</strong></p>
</li>
</ul>
<h3 id="例-10-3-综合运用几种迭代器的示例"><a href="#例-10-3-综合运用几种迭代器的示例" class="headerlink" title="例 10-3 综合运用几种迭代器的示例"></a>例 10-3 综合运用几种迭代器的示例</h3><p>程序涉及到<strong>输入迭代器、输出迭代器、随机访问迭代器</strong>这三个迭代器概念，并且以前两个概念为基础编写了一个通用算法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_3.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//将来自输入迭代器的n个T类型的数值排序，将结果通过输出迭代器result输出</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过输入迭代器将输入数据存入向量容器s中</span></span><br><span class="line">vector&lt;T&gt; s;</span><br><span class="line"><span class="keyword">for</span> (;first != last; ++first)</span><br><span class="line">s.<span class="built_in">push_back</span>(*first);</span><br><span class="line"><span class="comment">//对s进行排序，sort函数的参数必须是随机访问迭代器</span></span><br><span class="line"> <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); </span><br><span class="line"><span class="built_in">copy</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), result); <span class="comment">//将s序列通过输出迭代器输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//将s数组的内容排序后输出</span></span><br><span class="line"><span class="type">double</span> a[<span class="number">5</span>] = &#123; <span class="number">1.2</span>, <span class="number">2.4</span>, <span class="number">0.8</span>, <span class="number">3.3</span>, <span class="number">3.2</span> &#125;;</span><br><span class="line"><span class="built_in">mySort</span>&lt;<span class="type">double</span>&gt;(a, a + <span class="number">5</span>, <span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//从标准输入读入若干个整数，将排序后的结果输出</span></span><br><span class="line"><span class="built_in">mySort</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(cin), <span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(), </span><br><span class="line"><span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.8</span> <span class="number">1.2</span> <span class="number">2.4</span> <span class="number">3.2</span> <span class="number">3.3</span></span><br><span class="line"><span class="number">2</span> <span class="number">-4</span> <span class="number">5</span> <span class="number">8</span> <span class="number">-1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">-5</span></span><br><span class="line"><span class="number">-5</span> <span class="number">-4</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器的辅助函数"><a href="#迭代器的辅助函数" class="headerlink" title="迭代器的辅助函数"></a>迭代器的辅助函数</h3><ul>
<li>advance(p, n)</li>
</ul>
<p>对p执行<strong>n次自增操作</strong></p>
<ul>
<li>distance(first, last)</li>
</ul>
<p>计算两个迭代器<strong>first和last的距离</strong>，即对first执行多少次“++”操作后能够使得first &#x3D;&#x3D; last</p>
<h2 id="容器的基本功能与分类"><a href="#容器的基本功能与分类" class="headerlink" title="容器的基本功能与分类"></a>容器的基本功能与分类</h2><ul>
<li><p>容器类是<strong>容纳、包含一组元素或元素集合</strong>的对象。</p>
</li>
<li><p>基于容器中元素的组织方式：<strong>顺序容器、关联容器</strong></p>
</li>
<li><p>按照与容器所关联的迭代器类型划分：<strong>可逆容器</strong> <strong>随机访问容器</strong></p>
</li>
</ul>
<h3 id="容器的基本功能与分类-1"><a href="#容器的基本功能与分类-1" class="headerlink" title="容器的基本功能与分类"></a>容器的基本功能与分类</h3><ul>
<li>容器</li>
</ul>
<ol>
<li><strong>顺序</strong>容器</li>
</ol>
<p>array（数组）、vector（向量）、deque（双端队列）、forward_list（单链表）、list（列表）</p>
<ol start="2">
<li><strong>(有序)关联</strong>容器</li>
</ol>
<p>set（集合）、multiset（多重集合）、map（映射）、multimap（多重映射）</p>
<ol start="3">
<li><strong>无序关联</strong>容器</li>
</ol>
<p>unordered_set （无序集合）、unordered_multiset（无序多重集合）</p>
<p>unordered_map（无序映射）、unorder_multimap（无序多重映射）</p>
<h3 id="容器的分类"><a href="#容器的分类" class="headerlink" title="容器的分类"></a>容器的分类</h3><p><img src="https://i.postimg.cc/Ss808X6Q/abdc044a9a2dc26fc478d24d8ce1db1f.png"></p>
<p><img src="https://i.postimg.cc/8cV2b14R/049c148163a903ba980087b8738a3323.png"></p>
<h3 id="容器的通用功能"><a href="#容器的通用功能" class="headerlink" title="容器的通用功能"></a>容器的通用功能</h3><ul>
<li>容器的<strong>通用</strong>功能</li>
</ul>
<ol>
<li><p>用默认构造函数构造空容器</p>
</li>
<li><p>支持关系运算符：&#x3D;&#x3D;、!&#x3D;、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</p>
</li>
<li><p>begin()、end()：获得容器首、尾迭代器</p>
</li>
<li><p>clear()：将容器清空</p>
</li>
<li><p>empty()：判断容器是否为空</p>
</li>
<li><p>size()：得到容器元素个数</p>
</li>
<li><p>s1.swap(s2)：将s1和s2两容器内容交换</p>
</li>
<li><p>相关数据类型（S表示容器类型）</p>
</li>
<li><p>S::iterator：指向容器元素的迭代器类型</p>
</li>
<li><p>S::const_iterator：常迭代器类型</p>
</li>
</ol>
<h4 id="对可逆容器的访问"><a href="#对可逆容器的访问" class="headerlink" title="对可逆容器的访问"></a>对可逆容器的访问</h4><ul>
<li><p>STL为每个可逆容器都提供了逆向迭代器，逆向迭代器可以通过下面的成员函数得到：</p>
<ol>
<li>rbegin() ：指向容器尾的逆向迭代器</li>
<li>rend()：指向容器首的逆向迭代器</li>
</ol>
</li>
<li><p>逆向迭代器的类型名的表示方式如下：</p>
</li>
<li><ol>
<li>S::reverse_iterator：逆向迭代器类型</li>
<li>S::const_reverse_iterator：逆向常迭代器类型</li>
</ol>
</li>
</ul>
<h3 id="随机访问容器"><a href="#随机访问容器" class="headerlink" title="随机访问容器"></a>随机访问容器</h3><ul>
<li><p>随机访问容器支持对容器的元素进行随机访问</p>
</li>
<li><p>s[n]：获得容器s的第n个元素</p>
</li>
</ul>
<h2 id="顺序容器的基本功能"><a href="#顺序容器的基本功能" class="headerlink" title="顺序容器的基本功能"></a>顺序容器的基本功能</h2><h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><ol>
<li><p>向量（vector）</p>
</li>
<li><p>双端队列（deque）</p>
</li>
<li><p>列表（list）</p>
</li>
<li><p>单向链表（forward_list）</p>
</li>
<li><p>数组（array）</p>
</li>
<li><p>元素线性排列，可以随时在指定位置插入元素和删除元素。</p>
</li>
</ol>
<p> 必须符合<strong>Assignable</strong>这一概念（即具有公有的拷贝构造函数并可以用“&#x3D;”赋值）。</p>
<p>array对象的<strong>大小固定</strong>，forward_list有<strong>特殊的添加和删除操作</strong></p>
<h3 id="顺序容器的接口（不包含单向链表（forward-list）和数组（array））"><a href="#顺序容器的接口（不包含单向链表（forward-list）和数组（array））" class="headerlink" title="顺序容器的接口（不包含单向链表（forward_list）和数组（array））"></a>顺序容器的接口（不包含单向链表（forward_list）和数组（array））</h3><ol>
<li><p>构造函数</p>
</li>
<li><p>赋值函数</p>
</li>
<li><p>assign</p>
</li>
</ol>
<ul>
<li>插入函数</li>
</ul>
<p>insert， push_front（只对list和deque）， push_back，emplace，</p>
<p>emplace_front</p>
<ul>
<li>删除函数</li>
</ul>
<p>erase ， clear ， pop_front （只对 list 和 deque ） ， pop_back ，</p>
<p>emplace_back</p>
<ul>
<li>首尾元素的直接访问</li>
</ul>
<p>front，back</p>
<p>在逻辑上可看作是一个长度可扩展的数组</p>
<p>改变大小</p>
<p>resize</p>
<h3 id="例-10-4-顺序容器的基本操作"><a href="#例-10-4-顺序容器的基本操作" class="headerlink" title="例 10-4 顺序容器的基本操作"></a>例 10-4 顺序容器的基本操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_4.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="comment">//输出指定的顺序容器的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printContainer</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">const</span> T&amp; s)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; msg &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line"><span class="built_in">copy</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//从标准输入读入10个整数，将它们分别从s的头部加入</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">s.<span class="built_in">push_front</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printContainer</span>(<span class="string">&quot;deque at first&quot;</span>, s);</span><br><span class="line"><span class="comment">//用s容器的内容的逆序构造列表容器l</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(s.rbegin(), s.rend())</span></span>;</span><br><span class="line"><span class="built_in">printContainer</span>(<span class="string">&quot;list at first&quot;</span>, l);</span><br><span class="line">例<span class="number">10</span><span class="number">-4</span> 顺序容器的基本操作</span><br><span class="line"><span class="comment">//将列表容器l的每相邻两个元素顺序颠倒</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator iter = l.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (iter != l.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="type">int</span> v = *iter;</span><br><span class="line">iter = l.<span class="built_in">erase</span>(iter);</span><br><span class="line">l.<span class="built_in">insert</span>(++iter, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printContainer</span>(<span class="string">&quot;list at last&quot;</span>, l);</span><br><span class="line"><span class="comment">//用列表容器l的内容给s赋值，将s输出</span></span><br><span class="line">s.<span class="built_in">assign</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printContainer</span>(<span class="string">&quot;deque at last&quot;</span>, s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">9</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line">deque at first: <span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span></span><br><span class="line">list at first: <span class="number">0</span> <span class="number">9</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line">list at last: <span class="number">9</span> <span class="number">0</span> <span class="number">6</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">deque at last: <span class="number">9</span> <span class="number">0</span> <span class="number">6</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="顺序容器的特性"><a href="#顺序容器的特性" class="headerlink" title="顺序容器的特性"></a>顺序容器的特性</h2><p>顺序容器：向量、双端队列、列表、单向链表、数组</p>
<h3 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h3><ul>
<li>特点</li>
</ul>
<ol>
<li><p>一个可以扩展的动态数组</p>
</li>
<li><p>随机访问、在尾部插入或删除元素快</p>
</li>
<li><p>在中间或头部插入或删除元素慢</p>
</li>
</ol>
<ul>
<li>向量的容量</li>
</ul>
<ol>
<li><p>容量(capacity)：实际分配空间的大小</p>
</li>
<li><p>s.capacity() ：返回当前容量</p>
</li>
<li><p>s.reserve(n)：若容量小于n，则对s进行扩展，使其容量至少为n</p>
</li>
</ol>
<h3 id="双端队列（deque）"><a href="#双端队列（deque）" class="headerlink" title="双端队列（deque）"></a>双端队列（deque）</h3><ul>
<li>特点</li>
</ul>
<ol>
<li><p>在两端插入或删除元素快</p>
</li>
<li><p>在中间插入或删除元素慢</p>
</li>
<li><p>随机访问较快，但比向量容器慢</p>
</li>
</ol>
<h3 id="例-10-5-奇偶排序"><a href="#例-10-5-奇偶排序" class="headerlink" title="例 10-5 奇偶排序"></a>例 10-5 奇偶排序</h3><p>先按照从大到小顺序输出奇数，再按照从小到大顺序输出偶数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头部分省略</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">i1</span><span class="params">(cin)</span>, i2</span>; <span class="comment">//建立一对输入流迭代器</span></span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s1</span><span class="params">(i1, i2)</span></span>; <span class="comment">//通过输入流迭代器从标准输入流中输入数据</span></span><br><span class="line"> <span class="built_in">sort</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>()); <span class="comment">//将输入的整数排序</span></span><br><span class="line"> deque&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"> <span class="comment">//以下循环遍历s1</span></span><br><span class="line"> <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = s1.<span class="built_in">begin</span>(); iter != s1.<span class="built_in">end</span>(); ++iter) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (*iter % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">//偶数放到s2尾部</span></span><br><span class="line"> s2.<span class="built_in">push_back</span>(*iter);</span><br><span class="line"> <span class="keyword">else</span> <span class="comment">//奇数放到s2首部</span></span><br><span class="line"> s2.<span class="built_in">push_front</span>(*iter);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//将s2的结果输出</span></span><br><span class="line"> <span class="built_in">copy</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h3><ul>
<li>特点</li>
</ul>
<ol>
<li><p>在<strong>任意位置插入和删除元素</strong>都很快</p>
</li>
<li><p>不支持<strong>随机</strong>访问</p>
</li>
<li><p>接合(splice)操作</p>
</li>
<li><p>s1.splice(p, s2, q1, q2)：将s2中[q1, q2)移动到<strong>s1中p所指向元素之前</strong></p>
</li>
</ol>
<p>&#x2F;&#x2F; 头部分省略</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string names1[] = &#123; <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Helen&quot;</span>, <span class="string">&quot;Lucy&quot;</span>, <span class="string">&quot;Susan&quot;</span> &#125;;</span><br><span class="line">string names2[] = &#123; <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Levin&quot;</span>, <span class="string">&quot;Mike&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//用names1数组的内容构造列表s1</span></span><br><span class="line"> <span class="function">list&lt;string&gt; <span class="title">s1</span><span class="params">(names1, names1 + <span class="number">4</span>)</span></span>; </span><br><span class="line"><span class="comment">//用names2数组的内容构造列表s2</span></span><br><span class="line"> <span class="function">list&lt;string&gt; <span class="title">s2</span><span class="params">(names2, names2 + <span class="number">4</span>)</span></span>; </span><br><span class="line"><span class="comment">//将s1的第一个元素放到s2的最后</span></span><br><span class="line"> s2.<span class="built_in">splice</span>(s2.<span class="built_in">end</span>(), s1, s1.<span class="built_in">begin</span>());</span><br><span class="line"> list&lt;string&gt;::iterator iter1 = s1.<span class="built_in">begin</span>(); <span class="comment">//iter1指向s1首</span></span><br><span class="line"> <span class="built_in">advance</span>(iter1, <span class="number">2</span>); <span class="comment">//iter1前进2个元素，它将指向s1第3个元素</span></span><br><span class="line"> list&lt;string&gt;::iterator iter2 = s2.<span class="built_in">begin</span>(); <span class="comment">//iter2指向s2首</span></span><br><span class="line"> ++iter2; <span class="comment">//iter2前进1个元素，它将指向s2第2个元素</span></span><br><span class="line"> list&lt;string&gt;::iterator iter3 = iter2; <span class="comment">//用iter2初始化iter3</span></span><br><span class="line"> <span class="built_in">advance</span>(iter3, <span class="number">2</span>); <span class="comment">//iter3前进2个元素，它将指向s2第4个元素</span></span><br><span class="line"> <span class="comment">//将[iter2, iter3)范围内的结点接到s1中iter1指向的结点前</span></span><br><span class="line"> s1.<span class="built_in">splice</span>(iter1, s2, iter2, iter3); </span><br><span class="line"> <span class="comment">//分别将s1和s2输出</span></span><br><span class="line"> <span class="built_in">copy</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">copy</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单向链表（forward-list）"><a href="#单向链表（forward-list）" class="headerlink" title="单向链表（forward_list）"></a>单向链表（forward_list）</h3><ol>
<li><p>单向链表每个结点只有指向下个结点的指针，没有简单的方法来获取一个结点的前驱；</p>
</li>
<li><p>未定义insert、emplace和erase操作，而定义了insert_after、emplace_after和erase_after操作，其参数与list的insert、emplace和erase相同，但并不是插入或删除迭代器p1所指的元素，而是对p1所指元素之后的结点进行操作；</p>
</li>
<li><p>不支持size操作。</p>
</li>
</ol>
<h3 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h3><ol>
<li><p>array是对内置数组的封装，提供了更安全，更方便的使用数组的方式</p>
</li>
<li><p>array的对象的大小是固定的，定义时除了需要指定元素类型，还需要指定容器大</p>
</li>
</ol>
<p>小。</p>
<ol start="3">
<li>不能动态地改变容器大小</li>
</ol>
<h3 id="顺序容器的比较"><a href="#顺序容器的比较" class="headerlink" title="顺序容器的比较"></a>顺序容器的比较</h3><ol>
<li>STL所提供的顺序容器各有所长也各有所短，我们在编写程序时应当根据我们对容</li>
</ol>
<p>器所需要执行的操作来决定选择哪一种容器。</p>
<ol start="2">
<li>如果需要执行<strong>大量的随机访问操作</strong>，而且当<strong>扩展容器</strong>时只需要向容器尾部加</li>
</ol>
<p>入新的元素，就应当选择向量容器vector；</p>
<ol start="3">
<li>如果需要<strong>少量的随机访问</strong>操作，需要在<strong>容器两端插入或删除元素</strong>，则应当选</li>
</ol>
<p>择<strong>双端队列容器deque</strong>；</p>
<ol start="4">
<li>如果<strong>不需要</strong>对容器<strong>进行随机访问</strong>，但是需要在中<strong>间位置插入或者删除元素</strong>，</li>
</ol>
<p>就应当选择列表容器list或forward_list；</p>
<ol start="5">
<li>如果需要数组，array相对于<strong>内置数组</strong>类型而言，是一种更安全、更容易使</li>
</ol>
<p>用的数组类型</p>
<h2 id="顺序容器的插入迭代器与适配器"><a href="#顺序容器的插入迭代器与适配器" class="headerlink" title="顺序容器的插入迭代器与适配器"></a>顺序容器的插入迭代器与适配器</h2><h3 id="顺序容器的插入迭代器"><a href="#顺序容器的插入迭代器" class="headerlink" title="顺序容器的插入迭代器"></a>顺序容器的插入迭代器</h3><ol>
<li><p>用于向容器头部、尾部或中间指定位置插入元素的迭代器</p>
</li>
<li><p>包括前插迭代器（front_inserter）、后插迭代器（back_insrter）和任意位置插入</p>
</li>
</ol>
<p>迭代器（inserter）</p>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function">back_inserter <span class="title">iter</span><span class="params">(s)</span></span>;</span><br><span class="line">*(iter++) = <span class="number">5</span>; <span class="comment">//通过iter把5插入s末尾</span></span><br></pre></td></tr></table></figure>

<h3 id="顺序容器的适配器"><a href="#顺序容器的适配器" class="headerlink" title="顺序容器的适配器"></a>顺序容器的适配器</h3><ul>
<li><p>以顺序容器为基础构建一些常用数据结构，是对<strong>顺序容器的封装</strong></p>
</li>
<li><p>栈(stack)：最先压入的元素<strong>最后被弹出</strong></p>
</li>
<li><p>队列(queue)：<strong>最先压入</strong>的元素最<strong>先被弹出</strong></p>
</li>
<li><p>优先级队列(priority_queue)：<strong>最“大”的元素</strong>最先被弹出</p>
</li>
</ul>
<h3 id="栈和队列模板"><a href="#栈和队列模板" class="headerlink" title="栈和队列模板"></a>栈和队列模板</h3><ul>
<li>栈模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt; <span class="keyword">class</span> stack;</span><br></pre></td></tr></table></figure>

<ul>
<li>队列模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">FrontInsertionSequence</span> = deque&lt;T&gt; &gt; <span class="keyword">class</span> queue;</span><br></pre></td></tr></table></figure>

<ul>
<li>栈可以用任何一种顺序容器作为基础容器，而队列只允许用前插顺序容器（双端队列或列表）</li>
</ul>
<h3 id="栈和队列共同支持的操作"><a href="#栈和队列共同支持的操作" class="headerlink" title="栈和队列共同支持的操作"></a>栈和队列共同支持的操作</h3><ul>
<li><p>s1 op s2 op可以是&#x3D;&#x3D;、!&#x3D;、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;之一，它会对两个容器适配器之间的元素按字典序进行比较</p>
</li>
<li><p>s.size()  </p>
<p>返回s的元素个数</p>
</li>
<li><p>s.empty() 返回s是否为空</p>
</li>
<li><p>s.push(t)</p>
<p>   将元素t压入到s中</p>
</li>
<li><p>s.pop() 将一个元素从s中弹出，对于栈来说，每次弹出的是最后被压入的元素，而对于队列，每次被弹出的是最先被压入的元素</p>
</li>
<li><p>不支持迭代器，因为它们不允许对任意元素进行访问</p>
</li>
</ul>
<h3 id="栈和队列不同的操作"><a href="#栈和队列不同的操作" class="headerlink" title="栈和队列不同的操作"></a>栈和队列不同的操作</h3><ul>
<li>栈的操作</li>
</ul>
<p>s.top() </p>
<p>返回栈顶元素的引用</p>
<ul>
<li>队列操作</li>
</ul>
<p>s.front() </p>
<p>获得队头元素的引用</p>
<ul>
<li>s.back()</li>
</ul>
<p>获得队尾元素的引用</p>
<h3 id="例-10-7-利用栈反向输出单词"><a href="#例-10-7-利用栈反向输出单词" class="headerlink" title="例 10-7 利用栈反向输出单词"></a>例 10-7 利用栈反向输出单词</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_7.cpp， 省略头部分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str; <span class="comment">//从键盘输入一个字符串</span></span><br><span class="line"><span class="comment">//将字符串的每个元素顺序压入栈中</span></span><br><span class="line"><span class="keyword">for</span> (string::iterator iter = str.<span class="built_in">begin</span>(); iter != str.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">s.<span class="built_in">push</span>(*iter);</span><br><span class="line"><span class="comment">//将栈中的元素顺序弹出并输出</span></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果如下："><a href="#运行结果如下：" class="headerlink" title="运行结果如下："></a>运行结果如下：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">congratulations</span><br><span class="line">snoitalutargnoc</span><br></pre></td></tr></table></figure>

<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><ul>
<li>优先级队列也像栈和队列一样支持元素的压入和弹出，但元素弹出的顺序与元素的大小有关，每次弹出的总是容器中最“大”的一个元素。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt; &gt; <span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优先级队列的<strong>基础容器</strong>必须是支持<strong>随机访问的顺序容器</strong>。</p>
</li>
<li><p>支持栈和<strong>队列的size、empty、push、pop</strong>几个成员函数，用法与栈和队列相同。</p>
</li>
<li><p>优先级队列并<strong>不支</strong>持<strong>比较</strong>操作。</p>
</li>
<li><p>与栈类似，优先级队列提供<strong>一个top函数</strong>，可以获得下一个即将被<strong>弹出元素（即最“大”的元素）的引用</strong>。</p>
</li>
</ul>
<h3 id="例-10-8-细胞分裂模拟"><a href="#例-10-8-细胞分裂模拟" class="headerlink" title="例 10-8 细胞分裂模拟"></a>例 10-8 细胞分裂模拟</h3><p>一种细胞在诞生（即上次分裂）后会在500到2000秒内分裂为两个细胞，每个细胞又按照同样的规律继续分裂。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10.8.cpp, 头部分省略</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SPLIT_TIME_MIN = <span class="number">500</span>; <span class="comment">//细胞分裂最短时间</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SPLIT_TIME_MAX = <span class="number">2000</span>; <span class="comment">//细胞分裂最长时间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span>;</span><br><span class="line">priority_queue&lt;Cell&gt; cellQueue;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span> &#123; <span class="comment">//细胞类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count; <span class="comment">//细胞总数</span></span><br><span class="line"><span class="type">int</span> id; <span class="comment">//当前细胞编号</span></span><br><span class="line"><span class="type">int</span> time; <span class="comment">//细胞分裂时间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cell</span>(<span class="type">int</span> birth) : <span class="built_in">id</span>(count++) &#123; <span class="comment">//birth为细胞诞生时间</span></span><br><span class="line"><span class="comment">//初始化，确定细胞分裂时间</span></span><br><span class="line">time = birth + (<span class="built_in">rand</span>() % (SPLIT_TIME_MAX - SPLIT_TIME_MIN))+ </span><br><span class="line">SPLIT_TIME_MIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> id; &#125; <span class="comment">//得到细胞编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSplitTime</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> time; &#125; <span class="comment">//得到细胞分裂时间</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Cell&amp; s) <span class="type">const</span> <span class="comment">//定义“&lt;”</span></span><br><span class="line"> &#123; <span class="keyword">return</span> time &gt; s.time; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span> </span>&#123; <span class="comment">//细胞分裂</span></span><br><span class="line"> <span class="function">Cell <span class="title">child1</span><span class="params">(time)</span>, <span class="title">child2</span><span class="params">(time)</span></span>; <span class="comment">//建立两个子细胞</span></span><br><span class="line"> cout &lt;&lt; time &lt;&lt; <span class="string">&quot;s: Cell #&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; splits to #&quot;</span></span><br><span class="line">&lt;&lt; child1.<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; and #&quot;</span> &lt;&lt; child2.<span class="built_in">getId</span>() &lt;&lt; endl;</span><br><span class="line"> cellQueue.<span class="built_in">push</span>(child1); <span class="comment">//将第一个子细胞压入优先级队列</span></span><br><span class="line"> cellQueue.<span class="built_in">push</span>(child2); <span class="comment">//将第二个子细胞压入优先级队列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Cell::count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span>&gt;(<span class="built_in">time</span>(<span class="number">0</span>)));</span><br><span class="line"><span class="type">int</span> t; <span class="comment">//模拟时间长度</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Simulation time: &quot;</span>;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">cellQueue.<span class="built_in">push</span>(<span class="built_in">Cell</span>(<span class="number">0</span>)); <span class="comment">//将第一个细胞压入优先级队列</span></span><br><span class="line"><span class="keyword">while</span> (cellQueue.<span class="built_in">top</span>().<span class="built_in">getSplitTime</span>() &lt;= t) &#123;</span><br><span class="line">cellQueue.<span class="built_in">top</span>().<span class="built_in">split</span>(); <span class="comment">//模拟下一个细胞的分裂</span></span><br><span class="line">cellQueue.<span class="built_in">pop</span>(); <span class="comment">//将刚刚分裂的细胞弹出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Simulation time: <span class="number">5000</span></span><br><span class="line"><span class="number">971</span>s: Cell #<span class="number">0</span> splits to #<span class="number">1</span> <span class="keyword">and</span> #<span class="number">2</span></span><br><span class="line"><span class="number">1719</span>s: Cell #<span class="number">1</span> splits to #<span class="number">3</span> <span class="keyword">and</span> #<span class="number">4</span></span><br><span class="line"><span class="number">1956</span>s: Cell #<span class="number">2</span> splits to #<span class="number">5</span> <span class="keyword">and</span> #<span class="number">6</span></span><br><span class="line"><span class="number">2845</span>s: Cell #<span class="number">6</span> splits to #<span class="number">7</span> <span class="keyword">and</span> #<span class="number">8</span></span><br><span class="line"><span class="number">3551</span>s: Cell #<span class="number">3</span> splits to #<span class="number">9</span> <span class="keyword">and</span> #<span class="number">10</span></span><br><span class="line"><span class="number">3640</span>s: Cell #<span class="number">4</span> splits to #<span class="number">11</span> <span class="keyword">and</span> #<span class="number">12</span></span><br><span class="line"><span class="number">3919</span>s: Cell #<span class="number">5</span> splits to #<span class="number">13</span> <span class="keyword">and</span> #<span class="number">14</span></span><br><span class="line"><span class="number">4162</span>s: Cell #<span class="number">10</span> splits to #<span class="number">15</span> <span class="keyword">and</span> #<span class="number">16</span></span><br><span class="line"><span class="number">4197</span>s: Cell #<span class="number">8</span> splits to #<span class="number">17</span> <span class="keyword">and</span> #<span class="number">18</span></span><br><span class="line"><span class="number">4317</span>s: Cell #<span class="number">7</span> splits to #<span class="number">19</span> <span class="keyword">and</span> #<span class="number">20</span></span><br><span class="line"><span class="number">4686</span>s: Cell #<span class="number">13</span> splits to #<span class="number">21</span> <span class="keyword">and</span> #<span class="number">22</span></span><br><span class="line"><span class="number">4809</span>s: Cell #<span class="number">12</span> splits to #<span class="number">23</span> <span class="keyword">and</span> #<span class="number">24</span></span><br><span class="line"><span class="number">4818</span>s: Cell #<span class="number">17</span> splits to #<span class="number">25</span> <span class="keyword">and</span> #<span class="number">26</span></span><br></pre></td></tr></table></figure>

<h2 id="关联容器分类和的基本功能"><a href="#关联容器分类和的基本功能" class="headerlink" title="关联容器分类和的基本功能"></a>关联容器分类和的基本功能</h2><h3 id="关联容器的特点和接口"><a href="#关联容器的特点和接口" class="headerlink" title="关联容器的特点和接口"></a>关联容器的特点和接口</h3><ul>
<li>关联容器的特点</li>
</ul>
<p>每个关联容器都有一个键(key)</p>
<p>可以根据键高效地查找元素</p>
<ul>
<li>接口</li>
</ul>
<ol>
<li><p>插入：insert</p>
</li>
<li><p>删除：erase</p>
</li>
<li><p>查找：find</p>
</li>
<li><p>定界：lower_bound、upper_bound、equal_range</p>
</li>
<li><p>计数：count</p>
</li>
</ol>
<h3 id="关联容器概念图"><a href="#关联容器概念图" class="headerlink" title="关联容器概念图"></a>关联容器概念图</h3><p><img src="https://i.postimg.cc/6q0mLCyK/cce8c0eb52bb35bba409d63dc64ebfb8.png"></p>
<h3 id="四种关联容器"><a href="#四种关联容器" class="headerlink" title="四种关联容器"></a>四种关联容器</h3><ul>
<li>单重关联容器(set和map)</li>
</ul>
<ol>
<li>键值是唯一的，一个键值只能对应一个元素</li>
</ol>
<ul>
<li>多重关联容器(multiset和multimap)</li>
</ul>
<ol>
<li>键值是不唯一的，一个键值可以对应多个元素</li>
</ol>
<ul>
<li>简单关联容器(set和multiset)</li>
</ul>
<ol>
<li><p>容器只有一个类型参数，如set<K>、multiset<K>，表示键类型</K></K></p>
</li>
<li><p>容器的元素就是键本身</p>
</li>
</ol>
<ul>
<li>二元关联容器(map和multimap)</li>
</ul>
<ol>
<li><p>容器有两个类型参数，如map&lt;K,V&gt;、multimap&lt;K,V&gt;，分别表示键和附加数据的类型</p>
</li>
<li><p>容器的元素类型是pair&lt;K,V&gt;，即由键类型和元素类型复合而成的二元组</p>
</li>
</ol>
<h3 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h3><ul>
<li>C++11新标准中定义了4个无序关联容器</li>
</ul>
<ol>
<li>unordered_set 、 unordered_map 、 unordered_multiset 、unordered_multimap</li>
</ol>
<p> 不是使用比较运算符来组织元素的，而是通过一个哈希函数和键类型的&#x3D;&#x3D;运算符。</p>
<p> 提供了与有序容器相同的操作 可以直接定义关键字是内置类型的无序容器。</p>
<p> 不能直接定义关键字类型为自定义类的无序容器，如果需要，必须提供我们自己的hash模板。</p>
<h2 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h2><p>集合用来存储一组无重复的元素。由于集合的元素本身是有序的，可以高效地查找指</p>
<p>定元素，也可以方便地得到指定大小范围的元素在容器中所处的区间。</p>
<h3 id="例-10-9"><a href="#例-10-9" class="headerlink" title="例 10-9"></a>例 10-9</h3><p>输入一串实数，将重复的去掉，取最大和最小者的中值，分别输出小于等于此中值和</p>
<p>大于等于此中值的实数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_9.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">set&lt;<span class="type">double</span>&gt; s;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="type">double</span> v;</span><br><span class="line"> cin &gt;&gt; v;</span><br><span class="line"> <span class="keyword">if</span> (v == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//输入0表示结束</span></span><br><span class="line"> <span class="comment">//尝试将v插入</span></span><br><span class="line"> pair&lt;set&lt;<span class="type">double</span>&gt;::iterator,<span class="type">bool</span>&gt; r=s.<span class="built_in">insert</span>(v); </span><br><span class="line"> <span class="keyword">if</span> (!r.second) <span class="comment">//如果v已存在，输出提示信息</span></span><br><span class="line"> cout &lt;&lt; v &lt;&lt; <span class="string">&quot; is duplicated&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//得到第一个元素的迭代器</span></span><br><span class="line">set&lt;<span class="type">double</span>&gt;::iterator iter1=s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//得到末尾的迭代器</span></span><br><span class="line">set&lt;<span class="type">double</span>&gt;::iterator iter2=s.<span class="built_in">end</span>();</span><br><span class="line"> <span class="comment">//得到最小和最大元素的中值</span></span><br><span class="line"><span class="type">double</span> medium=(*iter1 + *(--iter2)) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//输出小于或等于中值的元素</span></span><br><span class="line">cout&lt;&lt; <span class="string">&quot;&lt;= medium: &quot;</span></span><br><span class="line"><span class="built_in">copy</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">upper_bound</span>(medium), <span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout, <span class="string">&quot; </span></span><br><span class="line"><span class="string">&quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出大于或等于中值的元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&gt;= medium: &quot;</span>;</span><br><span class="line"><span class="built_in">copy</span>(s.<span class="built_in">lower_bound</span>(medium), s.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2.5</span> <span class="number">5</span> <span class="number">3.5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">2.5</span> <span class="number">0</span></span><br><span class="line"><span class="number">5</span> is duplicated</span><br><span class="line"><span class="number">2.5</span> is duplicated</span><br><span class="line">&lt;= medium: <span class="number">1</span> <span class="number">2.5</span> <span class="number">3.5</span> <span class="number">5</span></span><br><span class="line">&gt;= medium: <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h2 id="映射（map）"><a href="#映射（map）" class="headerlink" title="映射（map）"></a>映射（map）</h2><ol>
<li>映射与集合同属于单重关联容器，它们的主要区别在于，集合的元素类型是键本身，</li>
</ol>
<p>而映射的元素类型是由键和附加数据所构成的二元组。</p>
<ol start="2">
<li>在集合中按照键查找一个元素时，一般只是用来确定这个元素是否存在，而在映射</li>
</ol>
<p>中按照键查找一个元素时，除了能确定它的存在性外，还可以得到相应的附加数据。</p>
<h3 id="例-10-10"><a href="#例-10-10" class="headerlink" title="例 10-10"></a>例 10-10</h3><p>有五门课程，每门都有相应学分，从中选择三门，输出学分总和</p>
<p>&#x2F;&#x2F;10_10.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; courses;</span><br><span class="line"><span class="comment">//将课程信息插入courses映射中</span></span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;CSAPP&quot;</span>, <span class="number">3</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++&quot;</span>, <span class="number">2</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;CSARCH&quot;</span>, <span class="number">4</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;COMPILER&quot;</span>, <span class="number">4</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;OS&quot;</span>, <span class="number">5</span>));</span><br><span class="line"><span class="type">int</span> n = <span class="number">3</span>; <span class="comment">//剩下的可选次数</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//学分总和</span></span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name; <span class="comment">//输入课程名称</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::iterator iter = courses.<span class="built_in">find</span>(name);<span class="comment">//查找课程</span></span><br><span class="line"><span class="keyword">if</span> (iter == courses.<span class="built_in">end</span>()) &#123; <span class="comment">//判断是否找到</span></span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is not available&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum += iter-&gt;second; <span class="comment">//累加学分</span></span><br><span class="line">courses.<span class="built_in">erase</span>(iter); <span class="comment">//将刚选过的课程从映射中删除</span></span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Total credit: &quot;</span> &lt;&lt; sum &lt;&lt; endl; <span class="comment">//输出总学分</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C++</span><br><span class="line">COMPILER</span><br><span class="line">C++</span><br><span class="line">C++ is <span class="keyword">not</span> available</span><br><span class="line">CSAPP</span><br><span class="line">Total credit: <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="例-10-11"><a href="#例-10-11" class="headerlink" title="例 10-11"></a>例 10-11</h3><p>统计一句话中每个字母出现的次数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10_11.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; s; <span class="comment">//用来存储字母出现次数的映射</span></span><br><span class="line"><span class="type">char</span> c; <span class="comment">//存储输入字符</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"> cin &gt;&gt; c; <span class="comment">//输入下一个字符</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c))&#123; <span class="comment">//判断是否是字母</span></span><br><span class="line"> c = <span class="built_in">tolower</span>(c); <span class="comment">//将字母转换为小写</span></span><br><span class="line"> s[c]++; <span class="comment">//将该字母的出现频率加1</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (c != <span class="string">&#x27;.&#x27;</span>); <span class="comment">//碰到“.”则结束输入</span></span><br><span class="line"><span class="comment">//输出每个字母出现次数</span></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;::iterator iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多重集合（multiset）与多重映射（multimap）"><a href="#多重集合（multiset）与多重映射（multimap）" class="headerlink" title="多重集合（multiset）与多重映射（multimap）"></a>多重集合（multiset）与多重映射（multimap）</h2><ul>
<li><p>多重集合是允许有重复元素的集合，多重映射是允许一个键对应多个附加数据的映射。</p>
</li>
<li><p>多重集合与集合、多重映射与映射的用法差不多，只在几个成员函数上有细微差异，其差异主要表现在去除了键必须唯一的限制。</p>
</li>
</ul>
<h3 id="例-10-12-上课时间查询"><a href="#例-10-12-上课时间查询" class="headerlink" title="例 10-12 上课时间查询"></a>例 10-12 上课时间查询</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_12.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">multimap&lt;string, string&gt; courses;</span><br><span class="line"><span class="keyword">typedef</span> multimap&lt;string, string&gt;::iterator CourseIter;</span><br><span class="line"><span class="comment">//将课程上课时间插入courses映射中</span></span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;2-6&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;COMPILER&quot;</span>, <span class="string">&quot;3-1&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;COMPILER&quot;</span>, <span class="string">&quot;5-2&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;OS&quot;</span>, <span class="string">&quot;1-2&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;OS&quot;</span>, <span class="string">&quot;4-1&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;OS&quot;</span>, <span class="string">&quot;5-5&quot;</span>));</span><br><span class="line"><span class="comment">//输入一个课程名，直到找到该课程为止，记下每周上课次数</span></span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">count = courses.<span class="built_in">count</span>(name);</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Cannot find this course!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">while</span> (count == <span class="number">0</span>);</span><br><span class="line"><span class="comment">//输出每周上课次数和上课时间</span></span><br><span class="line">cout &lt;&lt; count &lt;&lt; <span class="string">&quot; lesson(s) per week: &quot;</span>;</span><br><span class="line">pair&lt;CourseIter, CourseIter&gt; range = courses.<span class="built_in">equal_range</span>(name);</span><br><span class="line"><span class="keyword">for</span> (CourseIter iter = range.first; iter != range.second; ++iter)</span><br><span class="line">cout &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">Cannot find <span class="keyword">this</span> course!</span><br><span class="line">OS</span><br><span class="line"><span class="number">3</span> <span class="built_in">lesson</span>(s) per week: <span class="number">1</span><span class="number">-2</span> <span class="number">4</span><span class="number">-1</span> <span class="number">5</span><span class="number">-5</span></span><br></pre></td></tr></table></figure>

<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><ul>
<li><p>一个行为类似函数的对象</p>
</li>
<li><p>可以没有参数，也可以带有若干参数</p>
</li>
<li><p>其功能是获取一个值，或者改变操作的状态。</p>
</li>
<li><p>例</p>
</li>
</ul>
<ol>
<li><p>普通函数就是函数对象</p>
</li>
<li><p>重载了“()”运算符的类的实例是函数对象</p>
</li>
</ol>
<h3 id="函数对象概念图"><a href="#函数对象概念图" class="headerlink" title="函数对象概念图"></a>函数对象概念图</h3><p><img src="https://i.postimg.cc/63xjkMZw/79fc9c5da64631a30a7b023715e142a7.png"></p>
<h3 id="例-10-13、例-10-14："><a href="#例-10-13、例-10-14：" class="headerlink" title="例 10-13、例 10-14："></a>例 10-13、例 10-14：</h3><ol>
<li><p>使用两种方式定义表示乘法的函数对象</p>
</li>
<li><p>通过定义普通函数（例10-13）</p>
</li>
<li><p>通过重载类的“()”运算符（例10-14）</p>
</li>
</ol>
<p>• 用到以下算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> Type, <span class="keyword">class</span> BinaryFunction&gt;</span></span><br><span class="line"><span class="function">Type <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, Type val, </span></span></span><br><span class="line"><span class="params"><span class="function">BinaryFunction binaryOp)</span></span>;</span><br></pre></td></tr></table></figure>

<p> 对[first, last)区间内的数据进行累“加”，binaryOp为用二元函数对象表示的“加”运算符，val为累“加”的初值</p>
<h3 id="例-10-13"><a href="#例-10-13" class="headerlink" title="例 10-13"></a>例 10-13</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">//包含数值算法头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义一个普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mult</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The result by multipling all elements in a is &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">accumulate</span>(a, a + N, <span class="number">1</span>, mult)</span><br><span class="line">&lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例-10-14"><a href="#例-10-14" class="headerlink" title="例 10-14"></a>例 10-14</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_14.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">//包含数值算法头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultClass</span>&#123; <span class="comment">//定义MultClass类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">//重载操作符operator()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The result by multipling all elements in a is &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">accumulate</span>(a, a + N, <span class="number">1</span>, <span class="built_in">MultClass</span>()) <span class="comment">//将类multclass传递给通用算法</span></span><br><span class="line">&lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="STL-提供的函数对象"><a href="#STL-提供的函数对象" class="headerlink" title="STL 提供的函数对象"></a>STL 提供的函数对象</h3><ul>
<li>用于算术运算的函数对象：</li>
</ul>
<ol>
<li><p>一元函数对象(一个参数) ：negate</p>
</li>
<li><p>二元函数对象(两个参数) ：plus、minus、multiplies、divides、modulus</p>
</li>
<li><p>用于关系运算、逻辑运算的函数对象(要求返回值为bool)</p>
</li>
<li><p>一元谓词(一个参数)：logical_not</p>
</li>
<li><p>二 元 谓 词 ( 两 个 参 数 ) ： equal_to 、 not_equal_to 、 greater 、 less 、greater_equal、less_equal、logical_and、logical_or</p>
</li>
</ol>
<h3 id="例-10-15-利用-STL-标准函数对象"><a href="#例-10-15-利用-STL-标准函数对象" class="headerlink" title="例 10-15 利用 STL 标准函数对象"></a>例 10-15 利用 STL 标准函数对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_15.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">//包含数值算法头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">//包含标准函数对象头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The result by multipling all elements in A is “</span></span><br><span class="line"><span class="string"> &lt;&lt; accumulate(a, a + N, 1, multiplies&lt;int&gt;())</span></span><br><span class="line"><span class="string">&lt;&lt; endl; //将标准函数对象传递给通用算法</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="例-10-16-利用-STL-中的二元谓词函数对象"><a href="#例-10-16-利用-STL-中的二元谓词函数对象" class="headerlink" title="例 10-16 利用 STL 中的二元谓词函数对象"></a>例 10-16 利用 STL 中的二元谓词函数对象</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10_16.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> intArr[] = &#123; <span class="number">30</span>, <span class="number">90</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(intArr, intArr + N)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;before sorting:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;after sorting:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h2><ul>
<li>绑定适配器：bind1st、bind2nd</li>
</ul>
<ol>
<li><p>将n元函数对象的指定参数绑定为一个常数，得到n-1元函数对象</p>
</li>
<li><p>组合适配器：not1、not2</p>
</li>
<li><p>将指定谓词的结果取反</p>
</li>
<li><p>函数指针适配器：ptr_fun</p>
</li>
<li><p>将一般函数指针转换为函数对象，使之能够作为其它函数适配器的输入。</p>
</li>
<li><p>在进行参数绑定或其他转换的时候，通常需要函数对象的类型信息，例如bind1st和bind2nd要求函数对象必须继承于binary_function类型。但如果传入的是函数指针形式的函数对象，则无法获得函数对象的类型信息。</p>
</li>
<li><p>成员函数适配器：ptr_fun、ptr_fun_ref</p>
</li>
<li><p>对成员函数指针使用，把n元成员函数适配为n + 1元函数对象，该函数对象的第一个参数为调用该成员函数时的目的对象</p>
</li>
<li><p>也就是需要将“object-&gt;method()”转为“method(object)”形式。将“object-&gt;method(arg1)”转为二元函数“method(object, arg1)”。</p>
</li>
</ol>
<h3 id="绑定适配器"><a href="#绑定适配器" class="headerlink" title="绑定适配器"></a>绑定适配器</h3><ol>
<li><p>binder2nd的实例构造通常比较冗长，bind2nd函数用于辅助构造binder2nd，产生它的一个实例。</p>
</li>
<li><p>binder1st和bind1st，将一个具体值绑定到二元函数的第一个参数。</p>
</li>
</ol>
<h3 id="例-10-17：函数适配器实例——找到数组中第一个大于-40-的元素"><a href="#例-10-17：函数适配器实例——找到数组中第一个大于-40-的元素" class="headerlink" title="例 10-17：函数适配器实例——找到数组中第一个大于 40 的元素"></a>例 10-17：函数适配器实例——找到数组中第一个大于 40 的元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_17.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> intArr[] = &#123; <span class="number">30</span>, <span class="number">90</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(intArr, intArr + N)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator p = <span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), </span><br><span class="line"><span class="number">40</span>));</span><br><span class="line"><span class="keyword">if</span> (p == a.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;no element greater than 40&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;first element greater than 40 is: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>find_if算法在STL中的原型声明为：</p>
<p>template&lt;class InputIterator, class UnaryPredicate&gt;</p>
<p>InputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate pred);它的功能是查找数组[first, last)区间中第一个pred(x)为真的元素。</p>
<h3 id="组合适配器"><a href="#组合适配器" class="headerlink" title="组合适配器"></a>组合适配器</h3><ol>
<li><p>对于一般的逻辑运算，有时可能还需要对结果求一次逻辑反。</p>
</li>
<li><p>unary_negate和binary_negate实现了这一适配功能。STL还提供了not1和not2辅助生成相应的函数对象实例，分别用于一元谓词和二元谓词的逻辑取反。</p>
</li>
</ol>
<h3 id="例-10-18-ptr-fun、not1-和-not2-产生函数适配器实例"><a href="#例-10-18-ptr-fun、not1-和-not2-产生函数适配器实例" class="headerlink" title="例 10-18 ptr_fun、not1 和 not2 产生函数适配器实例"></a>例 10-18 ptr_fun、not1 和 not2 产生函数适配器实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10_18.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> intArr[] = &#123; <span class="number">30</span>, <span class="number">90</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(intArr, intArr + N)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator p;</span><br><span class="line">p = <span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(g), <span class="number">40</span>));</span><br><span class="line"><span class="keyword">if</span> (p == a.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;no element greater than 40&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;first element greater than 40 is: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">p = <span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">15</span>)));</span><br><span class="line"><span class="keyword">if</span> (p == a.<span class="built_in">end</span>())</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;no element is not greater than 15&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;first element that is not greater than 15 is: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">p = <span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">not2</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()), <span class="number">15</span>));</span><br><span class="line"><span class="keyword">if</span> (p == a.<span class="built_in">end</span>())</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;no element is not greater than 15&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;first element that is not greater than 15 is: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例-10-19-成员函数适配器实例"><a href="#例-10-19-成员函数适配器实例" class="headerlink" title="例 10-19 成员函数适配器实例"></a>例 10-19 成员函数适配器实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//10_19.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="built_in">Car</span>(<span class="type">int</span> id) &#123; <span class="keyword">this</span>-&gt;id = id; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;car &quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;Car *&gt; pcars;</span><br><span class="line">vector&lt;Car&gt; cars;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">pcars.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Car</span>(i));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">cars.<span class="built_in">push_back</span>(<span class="built_in">Car</span>(i));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;elements in pcars: &quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(pcars.<span class="built_in">begin</span>(), pcars.<span class="built_in">end</span>(), std::<span class="built_in">mem_fun</span>(&amp;Car::display));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;elements in cars: &quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(cars.<span class="built_in">begin</span>(), cars.<span class="built_in">end</span>(), std::<span class="built_in">mem_fun_ref</span>(&amp;Car::display));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pcars.<span class="built_in">size</span>(); ++i)</span><br><span class="line"><span class="keyword">delete</span> pcars[i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法</p>
<p>STL 算法特点</p>
<ol>
<li><p>STL算法本身是一种函数模版</p>
</li>
<li><p>通过迭代器获得输入数据</p>
</li>
<li><p>通过函数对象对数据进行处理</p>
</li>
<li><p>通过迭代器将结果输出</p>
</li>
<li><p>STL算法是通用的，独立于具体的数据类型、容器类型</p>
</li>
</ol>
<p>STL 算法分类</p>
<ol>
<li><p>不可变序列算法</p>
</li>
<li><p>可变序列算法</p>
</li>
<li><p>排序和搜索算法</p>
</li>
<li><p>数值算法</p>
</li>
</ol>
<p>不可变序列算法</p>
<ol>
<li><p>不直接修改所操作的容器内容的算法</p>
</li>
<li><p>用于查找指定元素、比较两个序列是否相等、对元素进行计数等</p>
</li>
</ol>
<ul>
<li>例：</li>
</ul>
<p>template&lt;class InputIterator, class UnaryPredicate&gt;</p>
<p>InputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate pred);</p>
<p>查找[first, last)区间内pred(x)为真的首个元素</p>
<p>可变序列算法</p>
<ol>
<li><p>可以修改它们所操作的容器对象</p>
</li>
<li><p>包括对序列进行复制、删除、替换、倒序、旋转、交换、分割、去重、填充、洗牌</p>
</li>
</ol>
<p>的算法及生成一个序列的算法</p>
<ul>
<li>例：</li>
</ul>
<p>template&lt;class ForwardIterator, class T&gt;</p>
<p>void fill (ForwardIterator first, ForwardIterator last, const T&amp; x);</p>
<p>将[first, last)区间内的元素全部改写为x。</p>
<p>排序和搜索算法</p>
<ol>
<li><p>对序列进行排序</p>
</li>
<li><p>对两有序序列进行合并</p>
</li>
<li><p>对有序序列进行搜索</p>
</li>
<li><p>有序序列的集合操作</p>
</li>
</ol>
<ul>
<li>堆算法</li>
</ul>
<p> 例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span> , <span class="keyword">class</span> <span class="title class_">UnaryPredicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last, UnaryPredicate comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以函数对象comp为“&lt;”，对 [first, last)区间内的数据进行排序</p>
<h3 id="数值算法"><a href="#数值算法" class="headerlink" title="数值算法"></a>数值算法</h3><ol>
<li><p>求序列中元素的“和”、部分“和”、相邻元素的“差”或两序列的内积</p>
</li>
<li><p>求“和”的“+”、求“差”的“-”以及求内积的“+”和“·”都可由函数对象</p>
</li>
</ol>
<p>指定</p>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator, <span class="keyword">class</span> </span></span><br><span class="line"><span class="function">BinaryFunction&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">partial_sum</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result, BinaryFunction op)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对[first, last)内的元素求部分“和”（所谓部分“和”，是一个长度与输入序</p>
<p>列相同的序列，其第n项为输入序列前n个元素的“和”），以函数对象op为“+”</p>
<p>运算符，结果通过result输出，返回的迭代器指向输出序列最后一个元素的下</p>
<p>一个元素</p>
<h3 id="算法应用举例"><a href="#算法应用举例" class="headerlink" title="算法应用举例"></a>算法应用举例</h3><ol>
<li><p>例10-20——例10-23演示了几类算法的应用。</p>
</li>
<li><p>详见教材第10章</p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>本章主要内容</p>
</li>
<li><p>泛型程序设计的概念</p>
</li>
<li><p>与标准模板库有关的概念和术语</p>
</li>
<li><p>迭代器</p>
</li>
<li><p>容器</p>
</li>
<li><p>函数对象</p>
</li>
<li><p>算法</p>
</li>
<li><p>本章学习目标</p>
</li>
</ul>
<ol>
<li><p>初步了解泛型程序设计的概念</p>
</li>
<li><p>学会C++标准模板库（STL）的使用方法</p>
</li>
</ol>
 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2024/08/13/SPOC(10)%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EC-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/08/14/SPOC%EF%BC%9A%E6%B5%81%E7%B1%BB%E5%BA%93%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            SPOC(11)：流类库与输入输出
          
        </div>
      </a>
    
    
      <a href="/2024/08/11/%E7%94%B5%E5%BD%B1%E6%89%B9%E8%AF%84%EF%BC%9A%E9%98%BF%E5%87%A1%E8%BE%BE/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">电影批评：阿凡达</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.staticfile.org/valine/1.4.16/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    appid: "NE1hi2bwLBi5TmvHcJqkvMj4-MdYXbMMI",
    appkey: "tlaS1mHTwUo374IsMy8CwE2j",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2025
        <i class="ri-heart-fill heart_icon"></i> SHIOKOU
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="柳瀬しおこうの夢"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://x.com/tsumugi0408">推特</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://bangumi.tv/">番组</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>帮我买张OST吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->
 
    
        <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.15.1/katex.min.css">
        <script src="https://cdn.staticfile.org/KaTeX/0.15.1/katex.min.js"></script>
        <script src="https://cdn.staticfile.org/KaTeX/0.15.1/contrib/auto-render.min.js"></script>
        
            <script src="https://cdn.staticfile.org/KaTeX/0.15.1/contrib/copy-tex.min.js"></script>
            <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.15.1/contrib/copy-tex.min.css">
        
    
 
<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=28699497&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    
<script>
  const password = "22360408";
  const lock_password = window.sessionStorage.getItem("lock_password");
  console.log(password, lock_password);
  if (lock_password !== password) {
    Swal.fire({
      title: "Please enter password",
      input: "text",
      inputAttributes: {
        autocapitalize: "off",
      },
      showCancelButton: false,
      showLoaderOnConfirm: true,
      allowOutsideClick: false,
      confirmButtonText: "Ok",
    }).then((result) => {
      console.log(result);
      if (result.isConfirmed) {
        console.log(password);
        if (result.value === password) {
          window.sessionStorage.setItem("lock_password", result.value);
        } else {
          Swal.fire({
            icon: "error",
            title: "Incorrect password, please try again",
            confirmButtonText: "Ok",
            allowOutsideClick: false,
          }).then(() => {
            window.location.reload();
          });
        }
      }
    });
  }
</script>


  </div>
</body>

</html>