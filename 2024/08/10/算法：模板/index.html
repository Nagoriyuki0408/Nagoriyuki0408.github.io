<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>算法：模板 |  柳瀬しおこうの夢</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="柳瀬しおこうの夢" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-算法：模板"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  算法：模板
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/08/10/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A8%A1%E6%9D%BF/" class="article-date">
  <time datetime="2024-08-09T20:44:54.000Z" itemprop="datePublished">2024-08-10</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">27.2k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">132 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n≤<span class="number">30</span> dfs+剪枝,状态压缩dp</span><br><span class="line">n≤<span class="number">100</span>， floyd,dp,高斯消元</span><br><span class="line">n≤<span class="number">1000</span> dp,二分,朴素版Dijkstra、朴素版Prim、Bellman-Ford</span><br><span class="line">n≤<span class="number">10</span>^<span class="number">4</span> 块状链表、分块、莫队</span><br><span class="line">n≤<span class="number">10</span>^<span class="number">5</span> 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、</span><br><span class="line">spfa、求凸包、求半平面交、二分、 CDQ分治、整体二分</span><br><span class="line">n≤<span class="number">10</span>^<span class="number">6</span> 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 <span class="built_in">O</span>(nlogn)<span class="built_in">O</span>(nlogn)</span><br><span class="line">的做法：sort、树状数组、heap、dijkstra、spfa</span><br><span class="line">n≤<span class="number">10</span>^<span class="number">7</span> 双指针扫描、kmp、AC自动机、线性筛素数</span><br><span class="line">n≤<span class="number">10</span>^<span class="number">9</span> 判断质数</span><br><span class="line">n≤<span class="number">10</span>^<span class="number">18</span> 最大公约数，快速幂</span><br></pre></td></tr></table></figure>

<h2 id="1-排序"><a href="#1-排序" class="headerlink" title="1 排序"></a><strong>1</strong> <strong>排序</strong></h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l ,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line"><span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line"><span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line"><span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line"><span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"><span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid; <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题-acwing-789</p>
<h2 id="2-高精度-前缀和-差分"><a href="#2-高精度-前缀和-差分" class="headerlink" title="2 高精度 前缀和 差分"></a><strong>2</strong> <strong>高精度 前缀和 差分</strong></h2><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="comment">// A, B 为倒序</span></span><br><span class="line"><span class="comment">// 计算A + B (1234 + 5678) 输入应该为 A [4, 3, 2, 1], B[8， 7， 6， 5]</span></span><br><span class="line"><span class="comment">// 得到的 C 也为倒序</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">&#123;</span><br><span class="line">t += A[i];</span><br><span class="line"><span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t); <span class="comment">// 最高位进位</span></span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="comment">// 同加法, 输入为逆序</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">&#123;</span><br><span class="line">t = A[i] - t;</span><br><span class="line"><span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 去掉先导 0</span></span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 去掉先导 0</span></span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">&#123;</span><br><span class="line">r = r * <span class="number">10</span> + A[i];</span><br><span class="line">C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">r %= b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一维前缀和</span><br><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br><span class="line">二维前缀和</span><br><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一维差分</span><br><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br><span class="line">二维差分</span><br><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] +=c</span><br></pre></td></tr></table></figure>

<p>一维差分-练习题</p>
<p>二维差分-练习题</p>
<h2 id="3-离散化-区间和并"><a href="#3-离散化-区间和并" class="headerlink" title="3 离散化 区间和并"></a><strong>3</strong> <strong>离散化 区间和并</strong></h2><h3 id="离散化-值域很大，但数据稀疏"><a href="#离散化-值域很大，但数据稀疏" class="headerlink" title="离散化 (值域很大，但数据稀疏)"></a>离散化 (值域很大，但数据稀疏)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>()); <span class="comment">// 去掉重复元素</span></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间和–-离散化-前缀和"><a href="#区间和–-离散化-前缀和" class="headerlink" title="区间和–(离散化 + 前缀和)"></a>区间和–(离散化 + 前缀和)</h3><h3 id="区间和并"><a href="#区间和并" class="headerlink" title="区间和并"></a>区间和并</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;PII&gt; res;</span><br><span class="line"><span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line"><span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">st = seg.first, ed = seg.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"><span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区间和并</p>
<h2 id="4-数组链表-单调栈-KMP"><a href="#4-数组链表-单调栈-KMP" class="headerlink" title="4 数组链表 单调栈 KMP"></a><strong>4</strong> <strong>数组链表 单调栈</strong> <strong>KMP</strong></h2><h3 id="数组实现静态链表，提高效率"><a href="#数组实现静态链表，提高效率" class="headerlink" title="数组实现静态链表，提高效率"></a>数组实现静态链表，提高效率</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">head = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单调栈习题</p>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ; <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>滑动窗口</p>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">cin &gt;&gt; m &gt;&gt; p + <span class="number">1</span> &gt;&gt; n &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 求 next 数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line"><span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>( j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line"><span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line"><span class="keyword">if</span> (j == m) &#123; <span class="comment">// 匹配成功</span></span><br><span class="line">j = ne[j];</span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KMP 字符串</p>
<h2 id="5-Tire树-并查集"><a href="#5-Tire树-并查集" class="headerlink" title="5 Tire树 并查集"></a><strong>5 Tire树 并查集</strong></h2><h3 id="Tire树"><a href="#Tire树" class="headerlink" title="Tire树"></a>Tire树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 这里 26 是表示所有小写字母(若有大写字母，则可修改为 52)</span></span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">p = son[p][u];</span><br><span class="line">&#125;</span><br><span class="line">cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">p = son[p][u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tire 字符串统计</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)朴素并查集：</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点,根节点满足 p[x] = x</span></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">(<span class="number">2</span>)维护size的并查集：</span><br><span class="line"><span class="type">int</span> p[N], size[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的</span></span><br><span class="line">数量</span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">p[i] = i;</span><br><span class="line">size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合, 必须先修改size, 再修改父节点。</span></span><br><span class="line">size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)]; <span class="comment">// 这行必须在前</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">(<span class="number">3</span>)维护到祖宗节点距离的并查集：</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x) &#123;</span><br><span class="line"><span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">d[x] += d[p[x]];</span><br><span class="line">p[x] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">p[i] = i;</span><br><span class="line">d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure>

<p>合并集合</p>
<p>连通块中点的数量</p>
<h3 id="手写堆"><a href="#手写堆" class="headerlink" title="手写堆"></a>手写堆</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line"><span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line"><span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> t = u;</span><br><span class="line"><span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 用 h[t]</span></span><br><span class="line">比较，取三者最小值</span><br><span class="line"><span class="keyword">if</span> (u != t) &#123;</span><br><span class="line"><span class="built_in">heap_swap</span>(u, t);</span><br><span class="line"><span class="built_in">down</span>(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>]) &#123;</span><br><span class="line"><span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure>

<p>堆排序</p>
<p>模拟堆</p>
<h2 id="6-字符串哈希-STL常用函数"><a href="#6-字符串哈希-STL常用函数" class="headerlink" title="6 字符串哈希 STL常用函数"></a><strong>6</strong> <strong>字符串哈希</strong> <strong>STL常用函数</strong></h2><h3 id="一般哈希"><a href="#一般哈希" class="headerlink" title="一般哈希"></a>一般哈希</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 拉链法</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">e[idx] = x;</span><br><span class="line">ne[idx] = h[k];</span><br><span class="line">h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (e[i] == x)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">2</span>) 开放寻址法</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line"><span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">&#123;</span><br><span class="line">t ++ ;</span><br><span class="line"><span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串哈希</p>
<h3 id="C-STL常用函数"><a href="#C-STL常用函数" class="headerlink" title="C++ STL常用函数"></a>C++ STL常用函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line"><span class="built_in">size</span>() 返回元素个数</span><br><span class="line"><span class="built_in">empty</span>() 返回是否为空</span><br><span class="line"><span class="built_in">clear</span>() 清空</span><br><span class="line"><span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line"><span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line"><span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">[]</span><br><span class="line">支持比较运算，按字典序</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">first, 第一个元素</span><br><span class="line">second, 第二个元素</span><br><span class="line">支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line">string，字符串</span><br><span class="line"><span class="built_in">size</span>()/<span class="built_in">length</span>() 返回字符串长度</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">substr</span>(起始下标，(子串长度)) 返回子串</span><br><span class="line"><span class="built_in">c_str</span>() 返回字符串所在字符数组的起始地址</span><br><span class="line">queue, 队列</span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>() 向队尾插入一个元素</span><br><span class="line"><span class="built_in">front</span>() 返回队头元素</span><br><span class="line"><span class="built_in">back</span>() 返回队尾元素</span><br><span class="line"><span class="built_in">pop</span>() 弹出队头元素</span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>() 插入一个元素</span><br><span class="line"><span class="built_in">top</span>() 返回堆顶元素</span><br><span class="line"><span class="built_in">pop</span>() 弹出堆顶元素</span><br><span class="line">定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">stack, 栈</span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>() 向栈顶插入一个元素</span><br><span class="line"><span class="built_in">top</span>() 返回栈顶元素</span><br><span class="line"><span class="built_in">pop</span>() 弹出栈顶元素</span><br><span class="line">deque, 双端队列</span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line"><span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line"><span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line"><span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">[]</span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line">set/<span class="function">multiset</span></span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">()</span> 插入一个数</span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">()</span> 查找一个数</span></span><br><span class="line"><span class="function"><span class="title">count</span><span class="params">()</span> 返回某一个数的个数</span></span><br><span class="line"><span class="function"><span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="number">1</span>)</span> 输入是一个数x，删除所有x <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function"><span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">lower_bound</span><span class="params">(x)</span> 返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function"><span class="title">upper_bound</span><span class="params">(x)</span> 返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">map/multimap</span></span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">()</span> 插入的数是一个pair</span></span><br><span class="line"><span class="function"><span class="title">erase</span><span class="params">()</span> 输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">[] 注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function"><span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br><span class="line"><span class="function">bitset, 圧位</span></span><br><span class="line"><span class="function">bitset&lt;10000&gt; s</span>;</span><br><span class="line">~, &amp;, |, ^</span><br><span class="line">&gt;&gt;, &lt;&lt;</span><br><span class="line">==, !=</span><br><span class="line">[]</span><br><span class="line"><span class="built_in">count</span>() 返回有多少个<span class="number">1</span></span><br><span class="line"><span class="built_in">any</span>() 判断是否至少有一个<span class="number">1</span></span><br><span class="line"><span class="built_in">none</span>() 判断是否全为<span class="number">0</span></span><br><span class="line"><span class="built_in">set</span>() 把所有位置成<span class="number">1</span></span><br><span class="line"><span class="built_in">set</span>(k, v) 将第k位变成v</span><br><span class="line"><span class="built_in">reset</span>() 把所有位变成<span class="number">0</span></span><br><span class="line"><span class="built_in">flip</span>() 等价于~</span><br><span class="line"><span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure>

<h2 id="7-DFS-BFS-拓扑排序"><a href="#7-DFS-BFS-拓扑排序" class="headerlink" title="7 DFS BFS 拓扑排序"></a><strong>7 DFS BFS</strong> <strong>拓扑排序</strong></h2><h3 id="树与图的存储-邻接表"><a href="#树与图的存储-邻接表" class="headerlink" title="树与图的存储(邻接表)"></a>树与图的存储(邻接表)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure>

<h3 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 深度优先</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">2</span>) 宽度优先</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (!st[j])</span><br><span class="line">&#123;</span><br><span class="line">st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树的重心</p>
<p>图中点的层次</p>
<h3 id="拓扑排序-O-n-m"><a href="#拓扑排序-O-n-m" class="headerlink" title="拓扑排序 O(n + m)"></a>拓扑排序 O(n + m)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30010</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> q[N], d[N];</span><br><span class="line">bitset&lt;N&gt; f[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (!d[i])</span><br><span class="line">q[ ++ tt] = i;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">q[ ++ tt] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="built_in">add</span>(x, y);</span><br><span class="line">d[y] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">topsort</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line"><span class="type">int</span> j = q[i];</span><br><span class="line">f[j][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = h[j]; ~k; k = ne[k])</span><br><span class="line">f[j] |= f[e[k]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cout &lt;&lt; f[i].<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有向图的拓扑排序</p>
<h3 id="最大最小搜索"><a href="#最大最小搜索" class="headerlink" title="最大最小搜索"></a><strong>最大最小搜索</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Alice 和 Bob 正在玩井字棋游戏。</span><br><span class="line">井字棋游戏的规则很简单：两人轮流往 <span class="number">3</span>×<span class="number">3</span> 的棋盘中放棋子，Alice 放的是 X，Bob 放的是 O，Alice执</span><br><span class="line">先。</span><br><span class="line">当同一种棋子占据一行、一列或一条对角线的三个格子时，游戏结束，该种棋子的持有者获胜。</span><br><span class="line">当棋盘被填满的时候，游戏结束，双方平手。</span><br><span class="line">Alice 设计了一种对棋局评分的方法：</span><br><span class="line">对于 Alice 已经获胜的局面，评估得分为(棋盘上的空格子数+<span class="number">1</span>)；</span><br><span class="line">对于 Bob 已经获胜的局面，评估得分为 -(棋盘上的空格子数+<span class="number">1</span>)；</span><br><span class="line">对于平局的局面，评估得分为 <span class="number">0</span>；</span><br><span class="line">输入格式</span><br><span class="line">输入的第一行包含一个正整数 T，表示数据的组数。</span><br><span class="line">每组数据输入有 <span class="number">3</span> 行，每行有 <span class="number">3</span> 个整数，用空格分隔，分别表示棋盘每个格子的状态。<span class="number">0</span> 表示格子为</span><br><span class="line">空，<span class="number">1</span> 表示格子中为X，<span class="number">2</span> 表示格子中为 O。保证不会出现其他状态。</span><br><span class="line">保证输入的局面合法。(即保证输入的局面可以通过行棋到达，且保证没有双方同时获胜的情况).保证输</span><br><span class="line">入的局面轮到 Alice 行棋。</span><br><span class="line">输出格式</span><br><span class="line">对于每组数据，输出一行一个整数，表示当前局面的得分</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line"><span class="keyword">if</span> (g[i][j] == x)</span><br><span class="line">s ++ ;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line"><span class="keyword">if</span> (g[j][i] == x)</span><br><span class="line">s ++ ;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (g[<span class="number">0</span>][<span class="number">0</span>] == x &amp;&amp; g[<span class="number">1</span>][<span class="number">1</span>] == x &amp;&amp; g[<span class="number">2</span>][<span class="number">2</span>] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (g[<span class="number">2</span>][<span class="number">0</span>] == x &amp;&amp; g[<span class="number">1</span>][<span class="number">1</span>] == x &amp;&amp; g[<span class="number">0</span>][<span class="number">2</span>] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">evaluate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!g[i][j])</span><br><span class="line">s ++ ;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(<span class="number">1</span>)) <span class="keyword">return</span> s + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(<span class="number">2</span>)) <span class="keyword">return</span> -(s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">evaluate</span>();</span><br><span class="line"><span class="keyword">if</span> (t != INF) <span class="keyword">return</span> t;</span><br><span class="line"><span class="keyword">if</span> (!u) <span class="comment">// Alice</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!g[i][j])</span><br><span class="line">&#123;</span><br><span class="line">g[i][j] = <span class="number">1</span>;</span><br><span class="line">res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(<span class="number">1</span>));</span><br><span class="line">g[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// Bob</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!g[i][j])</span><br><span class="line">&#123;</span><br><span class="line">g[i][j] = <span class="number">2</span>;</span><br><span class="line">res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(<span class="number">0</span>));</span><br><span class="line">g[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T -- )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">cin &gt;&gt; g[i][j];</span><br><span class="line">cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-最短路算法"><a href="#8-最短路算法" class="headerlink" title="8 最短路算法"></a><strong>8</strong> <strong>最短路算法</strong></h2><h3 id="朴素dijkstra-算法"><a href="#朴素dijkstra-算法" class="headerlink" title="朴素dijkstra*算法"></a><strong>朴素dijkstra*算法</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>; <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">t = j;</span><br><span class="line"><span class="comment">// 用t更新其他点的距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">st[t] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="comment">// 求最短路，初始化距离为极大</span></span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">g[x][y] = <span class="built_in">min</span>(g[x][y], z);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dijkstra 求最短路</p>
<h3 id="堆优化版dijkstra"><a href="#堆优化版dijkstra" class="headerlink" title="堆优化版dijkstra"></a><strong>堆优化版dijkstra</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(nm), n表示点数，m表示边数</span></span><br><span class="line"><span class="comment">// 注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"><span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"><span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">st[ver] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">&#123;</span><br><span class="line">dist[j] = distance + w[i];</span><br><span class="line">heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dijkstra 求最短路II</p>
<h3 id="拆点"><a href="#拆点" class="headerlink" title="拆点"></a><strong>拆点</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">小明和小芳出去乡村玩，小明负责开车，小芳来导航。</span><br><span class="line">小芳将可能的道路分为大道和小道。</span><br><span class="line">大道比较好走，每走 <span class="number">1</span> 公里小明会增加 <span class="number">1</span> 的疲劳度。</span><br><span class="line">小道不好走，如果连续走小道，小明的疲劳值会快速增加，连续走 s 公里小明会增加 s2 的疲劳度。</span><br><span class="line">现在小芳拿到了地图，请帮助她规划一个开车的路线，使得按这个路线开车小明的疲劳度最小。</span><br><span class="line">输入格式</span><br><span class="line">输入的第一行包含两个整数 n,m，分别表示路口的数量和道路的数量。路口由 <span class="number">1</span> 至 n 编号，小明需要</span><br><span class="line">开车从 <span class="number">1</span> 号路口到 n 号路口。</span><br><span class="line">接下来 m 行描述道路，每行包含四个整数 t,a,b,c，表示一条类型为 t，连接 a 与 b 两个路口，</span><br><span class="line">长度为 c 公里的双向道路。其中 t 为 <span class="number">0</span> 表示大道，t 为 <span class="number">1</span> 表示小道。</span><br><span class="line">保证 <span class="number">1</span> 号路口和 n 号路口是连通的。</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最优路线下小明的疲劳度。</span><br><span class="line">数据范围</span><br><span class="line">对于 <span class="number">30</span>% 的评测用例，<span class="number">1</span>≤n≤<span class="number">8</span>，<span class="number">1</span>≤m≤<span class="number">10</span>；</span><br><span class="line">对于另外 <span class="number">20</span>% 的评测用例，不存在小道；</span><br><span class="line">对于另外 <span class="number">20</span>% 的评测用例，所有的小道不相交；</span><br><span class="line">对于所有评测用例，<span class="number">1</span>≤n≤<span class="number">500</span>，<span class="number">1</span>≤m≤<span class="number">10</span>^<span class="number">5</span>，<span class="number">1</span>≤a,b≤n，t 是 <span class="number">0</span> 或 <span class="number">1</span>，c≤<span class="number">10</span>^<span class="number">5</span>。</span><br><span class="line">保证答案不超过 <span class="number">10</span>^<span class="number">6</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 答案不超过 10^6, 因此小路最大连续距离不超过 1000, 考虑拆点</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">200010</span>, INF = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N][<span class="number">1010</span>];</span><br><span class="line"><span class="type">bool</span> st[N][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y, v;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Node&amp; t) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> v &gt; t.v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, f[idx] = t, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">priority_queue&lt;Node&gt; heap;</span><br><span class="line">heap.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (heap.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (st[t.x][t.y]) <span class="keyword">continue</span>;</span><br><span class="line">st[t.x][t.y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t.x]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> x = e[i], y = t.y;</span><br><span class="line"><span class="keyword">if</span> (f[i]) &#123;</span><br><span class="line">y += w[i];</span><br><span class="line"><span class="keyword">if</span> (y &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (dist[x][y] &gt; t.v - t.y * t.y + y * y) &#123;</span><br><span class="line">dist[x][y] = t.v - t.y * t.y + y * y;</span><br><span class="line"><span class="keyword">if</span> (dist[x][y] &lt;= INF)</span><br><span class="line">heap.<span class="built_in">push</span>(&#123;x, y, dist[x][y]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dist[x][<span class="number">0</span>] &gt; t.v + w[i]) &#123;</span><br><span class="line">dist[x][<span class="number">0</span>] = t.v + w[i];</span><br><span class="line"><span class="keyword">if</span> (dist[x][<span class="number">0</span>] &lt;= INF)</span><br><span class="line">heap.<span class="built_in">push</span>(&#123;x, <span class="number">0</span>, dist[x][<span class="number">0</span>]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t, a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;t, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(t, a, b, c), <span class="built_in">add</span>(t, b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dijkstra</span>();</span><br><span class="line"><span class="type">int</span> res = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++ ) res = <span class="built_in">min</span>(res, dist[n][i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a><strong>Bellman-Ford</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> last[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ ) &#123; <span class="comment">// 循环 K 次, 从1号点到n号点的最多经过k条边的最短距离</span></span><br><span class="line"><span class="built_in">memcpy</span>(last, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ ) &#123;</span><br><span class="line"><span class="keyword">auto</span> e = edges[j];</span><br><span class="line">dist[e.b] = <span class="built_in">min</span>(dist[e.b], last[e.a] + e.c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">edges[i] = &#123;a, b, c&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bellman_ford</span>();</span><br><span class="line"><span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a><strong>spfa</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">G 国国王来中国参观后，被中国的高速铁路深深的震撼，决定为自己的国家也建设一个高速铁路系统。建设高</span><br><span class="line">速铁路投入非常大，为了节约建设成本，G 国国王决定不新建铁路，而是将已有的铁路改造成高速铁路。</span><br><span class="line">现在，请你为 G 国国王提供一个方案，将现有的一部分铁路改造成高速铁路，使得任何两个城市间都可以通</span><br><span class="line">过高速铁路到达，而且从所有城市乘坐高速铁路到首都的最短路程和原来一样长。</span><br><span class="line">请你告诉 G 国国王在这些条件下最少要改造多长的铁路。</span><br><span class="line">输入格式</span><br><span class="line">输入的第一行包含两个整数 n,m，分别表示 G 国城市的数量和城市间铁路的数量。所有的城市由 <span class="number">1</span> 到</span><br><span class="line">n 编号，首都为 <span class="number">1</span> 号。</span><br><span class="line">接下来 m 行，每行三个整数 a,b,c，表示城市 a 和城市 b 之间有一条长度为 c 的双向铁路。这条</span><br><span class="line">铁路不会经过 a 和 b 以外的城市。</span><br><span class="line">输出格式</span><br><span class="line">输出一行，表示在满足条件的情况下最少要改造的铁路长度</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], q[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 做完spfa之后, dist数组表示各个点到 源点 的最短路径距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (hh != tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line">st[t] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;</span><br><span class="line">dist[j] = dist[t] + w[i];</span><br><span class="line"><span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">q[tt ++ ] = j;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line">st[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">spfa</span>();</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 反推哪些边被选中, 很关键</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">2</span>; a &lt;= n; a ++ ) &#123;</span><br><span class="line"><span class="type">int</span> minw = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = h[a]; ~j; j = ne[j]) &#123;</span><br><span class="line"><span class="type">int</span> b = e[j];</span><br><span class="line"><span class="keyword">if</span> (dist[a] == dist[b] + w[j])</span><br><span class="line">minw = <span class="built_in">min</span>(minw, w[j]);</span><br><span class="line">&#125;</span><br><span class="line">res += minw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a><strong>Floyd</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, Q;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="comment">// 初始化：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line"><span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理结果时(查询 a b)</span></span><br><span class="line"><span class="keyword">if</span> (d[a][b] &gt; INF / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>); <span class="comment">// 可能存在 INF -&gt;(-2) INF 的情况</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, d[a][b]);</span><br></pre></td></tr></table></figure>

<p>Floyd求最短路</p>
<h3 id="Floyd-传递闭包"><a href="#Floyd-传递闭包" class="headerlink" title="Floyd 传递闭包"></a><strong>Floyd</strong> <strong>传递闭包</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">给定 n 个变量和 m 个不等式。其中 n 小于等于 <span class="number">26</span>，变量分别用前 n 的大写英文字母表示。</span><br><span class="line">不等式之间具有传递性，即若 A&gt;B 且 B&gt;C，则 A&gt;C。请从前往后遍历每对关系，每次遍历时判断：</span><br><span class="line"><span class="number">1.</span> 如果能够确定全部关系且无矛盾，则结束循环，输出确定的次序；</span><br><span class="line"><span class="number">2.</span> 如果发生矛盾，则结束循环，输出有矛盾；</span><br><span class="line"><span class="number">3.</span> 如果循环结束时没有发生上述两种情况，则输出无定解。</span><br><span class="line">输入格式</span><br><span class="line">输入包含多组测试数据。每组测试数据，第一行包含两个整数 n 和 m。接下来 m 行，每行包含一个不</span><br><span class="line">等式，不等式全部为小于关系。当输入一行 <span class="number">0</span> <span class="number">0</span> 时，表示输入终止。</span><br><span class="line">输出格式</span><br><span class="line">每组数据输出一个占一行的结果。结果可能为下列三种之一：</span><br><span class="line"><span class="number">1.</span> 如果可以确定两两之间的关系，则输出 <span class="string">&quot;Sorted sequence determined after t</span></span><br><span class="line"><span class="string">relations: yyy...y.&quot;</span>,其中<span class="string">&#x27;t&#x27;</span>指迭代次数，<span class="string">&#x27;yyy...y&#x27;</span>是指升序排列的所有变量。</span><br><span class="line"><span class="number">2.</span> 如果有矛盾，则输出： <span class="string">&quot;Inconsistency found after t relations.&quot;</span>，其中<span class="string">&#x27;t&#x27;</span>指迭代次</span><br><span class="line">数。</span><br><span class="line"><span class="number">3.</span> 如果没有矛盾，且不能确定两两之间的关系，则输出 <span class="string">&quot;Sorted sequence cannot be</span></span><br><span class="line"><span class="string">determined.&quot;</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">26</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> g[N][N], d[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(d, g, <span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">d[i][j] |= d[i][k] &amp;&amp; d[k][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (d[i][i])</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!d[i][j] &amp;&amp; !d[j][i])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get_min</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!st[j] &amp;&amp; d[j][i]) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">st[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m) &#123;</span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="type">int</span> type = <span class="number">0</span>, t;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) &#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>];</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"><span class="type">int</span> a = str[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>, b = str[<span class="number">2</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!type) &#123;</span><br><span class="line">g[a][b] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">floyd</span>();</span><br><span class="line">type = <span class="built_in">check</span>();</span><br><span class="line"><span class="keyword">if</span> (type) t = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!type) <span class="built_in">puts</span>(<span class="string">&quot;Sorted sequence cannot be determined.&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;Inconsistency found after %d relations.\n&quot;</span>,</span><br><span class="line">t);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Sorted sequence determined after %d relations: &quot;</span>, t);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">get_min</span>());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-最小生成树"><a href="#9-最小生成树" class="headerlink" title="9 最小生成树"></a><strong>9</strong> <strong>最小生成树</strong></h2><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a><strong>Prim</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">// 时间复杂度是 O(n^2 + m), n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">t = j;</span><br><span class="line"><span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">st[t] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 需要初始化 g[][] :</span></span><br><span class="line"><span class="comment">// g[i][i] = 0, g[i][j] = INF</span></span><br></pre></td></tr></table></figure>

<p>Prim求最小生成树</p>
<h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a><strong>Kruskal</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">// 时间复杂度是 O(mlogm), n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="comment">// 存储边</span></span><br><span class="line"><span class="type">int</span> a, b, w;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i; <span class="comment">// 初始化并查集</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line"><span class="keyword">if</span> (a != b) &#123; <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">p[a] = b;</span><br><span class="line">res += w;</span><br><span class="line">cnt ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kruskal最小生成树</p>
<h2 id="10-二分图"><a href="#10-二分图" class="headerlink" title="10 二分图"></a><strong>10</strong> <strong>二分图</strong></h2><p>二分图的一个等价定义是：不含有 含奇数条边的环 的图</p>
<h3 id="染色法判别二分图"><a href="#染色法判别二分图" class="headerlink" title="染色法判别二分图"></a><strong>染色法判别二分图</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n; <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N]; <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">color[u] = c;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> vis[<span class="number">101</span>], color[<span class="number">101</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;graph)</span></span>&#123;</span><br><span class="line">q.<span class="built_in">push</span>(u);</span><br><span class="line">color[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : graph[u])&#123;</span><br><span class="line"><span class="keyword">if</span> (color[v] != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (color[v] == color[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">color[v] = (color[u] == <span class="number">1</span>)? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!color[i] &amp;&amp; !<span class="built_in">bfs</span>(i, graph)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="匈牙利算法-二分图最大匹配算法"><a href="#匈牙利算法-二分图最大匹配算法" class="headerlink" title="匈牙利算法(二分图最大匹配算法)"></a><strong>匈牙利算法(二分图最大匹配算法)</strong></h3><p>最小点覆盖 : 无向图中选取最少的点，使得覆盖掉所有的边</p>
<p>最大独立集 : 无向图中选取最多的点，使得选出的点没有边</p>
<p>最大匹配数 &#x3D; 最小点覆盖 &#x3D; 总点数 - 最大独立集 &#x3D; 总点数 - 最小路径点覆盖</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2; <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向</span></span><br><span class="line">第二个集合的边，所以这里只用存一个方向的边</span><br><span class="line"><span class="type">int</span> match[N]; <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (!st[j])</span><br><span class="line">&#123;</span><br><span class="line">st[j] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">&#123;</span><br><span class="line">match[j] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分图的最大匹配</p>
<h2 id="11-背包问题"><a href="#11-背包问题" class="headerlink" title="11 背包问题"></a><strong>11</strong> <strong>背包问题</strong></h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a><strong>01背包</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"><span class="comment">// 状态转移方程 dp[i][j] = max(dp[i-1][j-w] + v, dp[i-1][j-w])</span></span><br><span class="line"><span class="comment">// 优化版本, 注意第二层循环, 思考优化的根据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; --j)</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>01背包模板题</p>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a><strong>完全背包</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[i,j] = max(f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2*v]+2*w,f[i-1,j-3*v]+3*w, .....)</span></span><br><span class="line"><span class="comment">f[i,j-v]= max(f[i-1,j-v],f[i-1,j-2*v]+w,f[i-1,j-2*v]+2*w,.....)</span></span><br><span class="line"><span class="comment">由上两式，可得出如下递推关系：</span></span><br><span class="line"><span class="comment">f[i][j]=max(f[i-1][j], f[i,j-v]+w)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; ++j) &#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完全背包模板题</p>
<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a><strong>多重背包</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">有 N 种物品和一个容量是 V 的背包。</span><br><span class="line">第 i 种物品最多有 s_i 件，每件体积是 v_i，价值是 w_i。</span><br><span class="line">求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。</span><br><span class="line">输出最大价值。</span><br><span class="line">输入格式</span><br><span class="line">第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</span><br><span class="line">接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++ )</span><br><span class="line">f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line">cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a><strong>分组背包</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">有 N 组物品和一个容量是 V 的背包。</span><br><span class="line">每组物品有若干个，同一组内的物品最多只能选一个。</span><br><span class="line">每件物品的体积是 v_ij，价值是 w_ij，其中 i 是组号，j 是组内编号。</span><br><span class="line">求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</span><br><span class="line">输出最大价值。</span><br><span class="line">输入格式</span><br><span class="line">第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。</span><br><span class="line">接下来有 N 组数据：</span><br><span class="line">每组数据第一行有一个整数 S_i，表示第 i 个物品组的物品数量；</span><br><span class="line">每组数据接下来有 S_i 行，每行有两个整数 v_ij,w_ij，用空格隔开，分别表示第 i 个物品组的第</span><br><span class="line">j 个物品的体积和价值；</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N], s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">cin &gt;&gt; s[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; j ++ )</span><br><span class="line">cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j -- )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; s[i]; k ++ )</span><br><span class="line"><span class="keyword">if</span> (v[i][k] &lt;= j)</span><br><span class="line">f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-数学相关"><a href="#12-数学相关" class="headerlink" title="12 数学相关"></a><strong>12</strong> <strong>数学相关</strong></h2><h3 id="判定质数"><a href="#判定质数" class="headerlink" title="判定质数"></a>判定质数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line"><span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求区间内-素数个数-线性筛法"><a href="#求区间内-素数个数-线性筛法" class="headerlink" title="求区间内 素数个数 (线性筛法)"></a>求区间内 素数个数 (线性筛法)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(n)</span></span><br><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++) &#123;</span><br><span class="line">st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求 m^k mod p，时间复杂度 O(logk)。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line"><span class="keyword">while</span> (k) &#123;</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * t % p;</span><br><span class="line">t = t * t % p;</span><br><span class="line">k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c[a][b] 表示从a个苹果中选b个的方案数</span></span><br><span class="line"><span class="comment">// 注意 溢出问题, 通常会在下面代码基础上取模</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展欧几里得算法, 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="comment">// 返回值为 gcd(a, b）</span></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) &#123;</span><br><span class="line">x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">LL d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">y -= (a / b) * x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-线段树"><a href="#13-线段树" class="headerlink" title="13 线段树"></a><strong>13</strong> <strong>线段树</strong></h2><h3 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a><strong>朴素版</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123; <span class="comment">// 根据问题具体选择存储内容</span></span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">LL sum, add;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 往上传一层</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 往下传一层</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (root.add) &#123;</span><br><span class="line">left.add += root.add, left.sum += (LL)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">right.add += root.add, right.sum += (LL)(right.r - right.l + <span class="number">1</span>) *</span><br><span class="line">root.add;</span><br><span class="line">root.add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建线段树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="comment">// 固定写法</span></span><br><span class="line"><span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, a[r], <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tr[u] = &#123;l, r&#125;; <span class="comment">// 左右端点初始化</span></span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;</span><br><span class="line">tr[u].sum += (LL)(tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">tr[u].add += d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// 分裂</span></span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">LL sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="comment">/*-----------------------------------具体看----------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r, d;</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line"><span class="keyword">if</span> (*op == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可在此测试代码</p>
<h3 id="支持加法和乘法"><a href="#支持加法和乘法" class="headerlink" title="支持加法和乘法"></a><strong>支持加法和乘法</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, p, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="type">int</span> sum, add, mul;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">tr[u].sum = (tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(Node &amp;t, <span class="type">int</span> add, <span class="type">int</span> mul)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先乘后加</span></span><br><span class="line"><span class="comment">// 修改前 x = x * a + b</span></span><br><span class="line"><span class="comment">// 修改后希望是 x = ((x * a) + b) * c + d = x * (a * c) + b * c + d</span></span><br><span class="line">t.sum = ((LL)t.sum * mul + (LL)(t.r - t.l + <span class="number">1</span>) * add) % p;</span><br><span class="line">t.mul = (LL)t.mul * mul % p;</span><br><span class="line">t.add = ((LL)t.add * mul + add) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line"><span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, a[r], <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> add, <span class="type">int</span> mul)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="built_in">eval</span>(tr[u], add, mul);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, add, mul);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, add, mul);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) sum = (sum + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r)) % p;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;p);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> t, l, r, d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;l, &amp;r);</span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, l, r, <span class="number">0</span>, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, l, r, d, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可在此测试代码</p>
<h2 id="14-网络流"><a href="#14-网络流" class="headerlink" title="14 网络流"></a><strong>14</strong> <strong>网络流</strong></h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">对于任意一张有向图（也就是网络），其中有N个点、M条边以及源点S和汇点<span class="function">T</span></span><br><span class="line"><span class="function"><span class="title">c</span><span class="params">(x,y)</span>称为边的容量</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(x,y)</span>称为边的流量</span></span><br><span class="line"><span class="function">流函数<span class="title">f</span><span class="params">(x,y)</span>三大性质:</span></span><br><span class="line"><span class="function">容量限制：每条边的流量总不可能大于该边的容量的（不然水管就爆了）</span></span><br><span class="line"><span class="function">斜对称：正向边的流量=</span>反向边的流量（反向边后面会具体讲）</span><br><span class="line">流量守恒：正向的所有流量和=反向的所有流量和（就是总量始终不变）</span><br><span class="line">最大流</span><br><span class="line">使得整个网络流量之和最大的流函数称为网络的最大流，此时的流量和被称为网络的最大流量</span><br><span class="line">增广路</span><br><span class="line">若一条从S到T的路径上所有边的剩余容量都大于<span class="number">0</span>，则称这样的路径为一条增广路</span><br><span class="line">反向边</span><br><span class="line">因为可能一条边可以被包含于多条增广路径，所以为了寻找所有的增广路经我们就要让这一条边有多次被</span><br><span class="line">选择的机会</span><br><span class="line">构建反向边则是这样一个机会，相当于给程序一个反悔的机会。</span><br><span class="line">残量网络</span><br><span class="line">在任意时刻，网络中所有节点以及剩余容量大于<span class="number">0</span>的边构成的子图被称为残量网络</span><br><span class="line">邻接表“成对存储”</span><br><span class="line">将正向边和反向边存在“<span class="number">2</span>和<span class="number">3</span>”、“<span class="number">4</span>和<span class="number">5</span>”、“<span class="number">6</span>和<span class="number">7</span>”。因为在更新边权的时候，我们就可以直接使用<span class="keyword">xor</span>的</span><br><span class="line">方</span><br><span class="line">式，找到对应的正向边和反向边</span><br></pre></td></tr></table></figure>

<h3 id="知识点梳理"><a href="#知识点梳理" class="headerlink" title="知识点梳理"></a><strong>知识点梳理</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 基本概念</span><br><span class="line"><span class="number">1.1</span> 流网络，不考虑反向边</span><br><span class="line"><span class="number">1.2</span> 可行流，不考虑反向边</span><br><span class="line"><span class="number">1.2</span><span class="number">.1</span> 两个条件：容量限制、流量守恒</span><br><span class="line"><span class="number">1.2</span><span class="number">.2</span> 可行流的流量指从源点流出的流量 - 流入源点的流量</span><br><span class="line"><span class="number">1.2</span><span class="number">.3</span> 最大流是指最大可行流</span><br><span class="line"><span class="number">1.3</span> 残留网络，考虑反向边，残留网络的可行流f<span class="number">&#x27;</span> + 原图的可行流f = 原题的另一个可行流</span><br><span class="line">(<span class="number">1</span>) |f<span class="number">&#x27;</span> + f| = |f<span class="number">&#x27;</span>| + |f|</span><br><span class="line">(<span class="number">2</span>) |f<span class="number">&#x27;</span>| 可能是负数</span><br><span class="line"><span class="number">1.4</span> 增广路径</span><br><span class="line"><span class="number">1.5</span> 割</span><br><span class="line"><span class="number">1.5</span><span class="number">.1</span> 割的定义</span><br><span class="line"><span class="number">1.5</span><span class="number">.2</span> 割的容量，不考虑反向边，“最小割”是指容量最小的割。</span><br><span class="line"><span class="number">1.5</span><span class="number">.3</span> 割的流量，考虑反向边，<span class="built_in">f</span>(S, T) &lt;= <span class="built_in">c</span>(S, T)</span><br><span class="line"><span class="number">1.5</span><span class="number">.4</span> 对于任意可行流f，任意割[S, T]，|f| = <span class="built_in">f</span>(S, T)</span><br><span class="line"><span class="number">1.5</span><span class="number">.5</span> 对于任意可行流f，任意割[S, T]，|f| &lt;= <span class="built_in">c</span>(S, T)</span><br><span class="line"><span class="number">1.5</span><span class="number">.6</span> 最大流最小割定理</span><br><span class="line">(<span class="number">1</span>) 可以流f是最大流</span><br><span class="line">(<span class="number">2</span>) 可行流f的残留网络中不存在增广路</span><br><span class="line">(<span class="number">3</span>) 存在某个割[S, T]，|f| = <span class="built_in">c</span>(S, T)</span><br><span class="line"><span class="number">1.6</span>. 算法<span class="number">1.6</span><span class="number">.1</span> EK <span class="built_in">O</span>(nm^<span class="number">2</span>)</span><br><span class="line"><span class="number">1.6</span><span class="number">.2</span> Dinic <span class="built_in">O</span>(n^<span class="number">2</span>m)</span><br><span class="line"><span class="number">1.7</span> 应用</span><br><span class="line"><span class="number">1.7</span><span class="number">.1</span> 二分图</span><br><span class="line">(<span class="number">1</span>) 二分图匹配</span><br><span class="line">(<span class="number">2</span>) 二分图多重匹配</span><br><span class="line"><span class="number">1.7</span><span class="number">.2</span> 上下界网络流</span><br><span class="line">(<span class="number">1</span>) 无源汇上下界可行流</span><br><span class="line">(<span class="number">2</span>) 有源汇上下界最大流</span><br><span class="line">(<span class="number">3</span>) 有源汇上下界最小流</span><br><span class="line"><span class="number">1.7</span><span class="number">.3</span> 多源汇最大流</span><br></pre></td></tr></table></figure>

<h3 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a><strong>Dinic算法</strong></h3><ol>
<li><p>在残量网络上 BFS 求出节点的层次，构造分层图</p>
</li>
<li><p>在分层图上 DFS 寻找增广路，在回溯时同时更新边权</p>
</li>
</ol>
<p><strong>代码实现 固定风格</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">200010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], ne[M], idx; <span class="comment">// f[N] 为 容量</span></span><br><span class="line"><span class="type">int</span> q[N], d[N], cur[N]; <span class="comment">// 队列 深度 当前弧</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">e[idx] = a, f[idx] = <span class="number">0</span>, ne[idx] = h[b], h[b] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (d[ver] == <span class="number">-1</span> &amp;&amp; f[i]) &#123;</span><br><span class="line">d[ver] = d[t] + <span class="number">1</span>;</span><br><span class="line">cur[ver] = h[ver];</span><br><span class="line"><span class="keyword">if</span> (ver == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[ ++ tt] = ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == T) <span class="keyword">return</span> limit;</span><br><span class="line"><span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;</span><br><span class="line">cur[u] = i; <span class="comment">// 当前弧优化</span></span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (d[ver] == d[u] + <span class="number">1</span> &amp;&amp; f[i]) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">find</span>(ver, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line"><span class="keyword">if</span> (!t) d[ver] = <span class="number">-1</span>;</span><br><span class="line">f[i] -= t, f[i ^ <span class="number">1</span>] += t, flow += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> r = <span class="number">0</span>, flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123; <span class="comment">// 存在增广路时循环继续</span></span><br><span class="line"><span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF)) r += flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dinic</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大流模板题"><a href="#最大流模板题" class="headerlink" title="最大流模板题"></a>最大流模板题</h3><p>参考题解</p>
<p><strong>最小割</strong></p>
<p><img src="https://i.postimg.cc/jjwJm64s/1ac825e5ccc9522ec3584582b196aa00.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这片管网由 n 行 m 列节点（红色，图中 n=<span class="number">5</span>，m=<span class="number">6</span>），横向管道（紫色）和纵向管道（橙色）构成。</span><br><span class="line">行和列分别用 <span class="number">1</span> 到 n 的整数和 <span class="number">1</span> 到 m 的整数表示。</span><br><span class="line">第 <span class="number">1</span> 行的任何一个节点均可以抽取湖水，湖水到达第 n 行的任何一个节点即算作引入了城市。</span><br><span class="line">除第一行和最后一行外，横向相邻或纵向相邻的两个节点之间一定有一段管道，每一段管道都有各自的最大的</span><br><span class="line">抽水速率，并需要根据情况选择抽水还是放水。</span><br><span class="line">对于纵向的管道（橙色），允许从上方向下方抽水或从下方向上方放水；如果从图中的上方向下方抽水，那么</span><br><span class="line">单位时间内能通过的水量不能超过管道的最大速率；如果从下方向上方放水，因为下方海拔较高，因此可以允</span><br><span class="line">许有任意大的水量。</span><br><span class="line">对于横向的管道（紫色），允许从左向右或从右向左抽水，不允许放水，两种情况下单位时间流过的水量都不</span><br><span class="line">能超过管道的最大速率。</span><br><span class="line">现在 MF 城市的水务负责人想知道，在已知每个管道单位时间容量的情况下，MF 城每单位时间最多可以引入</span><br><span class="line">多少的湖水</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大流 -&gt; 平面图最小割 -&gt; 最短路 -&gt; 分层图最短路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5050</span>;</span><br><span class="line"><span class="type">int</span> n, m, A, B, Q, X;</span><br><span class="line"><span class="type">int</span> r[N][N], c[N][N];</span><br><span class="line">LL d[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;A, &amp;B, &amp;Q, &amp;X);</span><br><span class="line"><span class="comment">// 边权</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">    c[i][j] = X = ((LL)A * X + B) % Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">1</span>; j ++ )</span><br><span class="line">r[i][j] = X = ((LL)A * X + B) % Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">d[i] += c[i][j];</span><br><span class="line"><span class="comment">// 只可能单向更新</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i ++ )</span><br><span class="line">d[i] = <span class="built_in">min</span>(d[i], d[i - <span class="number">1</span>] + r[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i; i -- )</span><br><span class="line">d[i] = <span class="built_in">min</span>(d[i], d[i + <span class="number">1</span>] + r[i + <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">LL res = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ ) res = <span class="built_in">min</span>(res, d[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a><strong>无源汇上下界可行流</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">问题描述</span><br><span class="line">给定一个包含 n 个点 m 条边的有向图，每条边都有一个流量下界和流量上界。</span><br><span class="line">求一种可行方案使得在所有点满足流量平衡条件的前提下，所有边满足流量限制。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 n 和 m。接下来 m 行，每行包含四个整数 a,b,c,d 表示点 a 和 b 之间存在</span><br><span class="line">一条有向边，该边的流量下界为 c，流量上界为 d。点编号从 <span class="number">1</span> 到 n。</span><br><span class="line">输出格式</span><br><span class="line">如果存在可行方案，则第一行输出 YES，接下来 m 行，每行输出一个整数，其中第 i 行的整数表示输</span><br><span class="line">入的第 i 条边的流量。</span><br><span class="line">如果不存在可行方案，直接输出一行 NO。</span><br><span class="line">如果可行方案不唯一，则输出任意一种方案即可</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">211</span>, M = (<span class="number">10200</span> + N) * <span class="number">2</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], l[M], ne[M], idx; <span class="comment">// l[M] 存储容量下界</span></span><br><span class="line"><span class="type">int</span> q[N], d[N], cur[N], A[N]; <span class="comment">// A[N] 存储第 i 个点的出入度容量差</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> </span>&#123; <span class="comment">// c : 容量下界 d : 容量上界</span></span><br><span class="line">e[idx] = b, f[idx] = d - c, l[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, ne[idx] = h[b], h[b] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (d[ver] == <span class="number">-1</span> &amp;&amp; f[i]) &#123;</span><br><span class="line">d[ver] = d[t] + <span class="number">1</span>;</span><br><span class="line">cur[ver] = h[ver];</span><br><span class="line"><span class="keyword">if</span> (ver == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[ ++ tt] = ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == T) <span class="keyword">return</span> limit;</span><br><span class="line"><span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;</span><br><span class="line">cur[u] = i;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (d[ver] == d[u] + <span class="number">1</span> &amp;&amp; f[i]) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">find</span>(ver, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line"><span class="keyword">if</span> (!t) d[ver] = <span class="number">-1</span>;</span><br><span class="line">f[i] -= t, f[i ^ <span class="number">1</span>] += t, flow += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> r = <span class="number">0</span>, flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>()) <span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF)) r += flow;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">S = <span class="number">0</span>, T = n + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"><span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">A[a] -= c, A[b] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 注意流网络的处理 减去下界需要补边来保持流量守</span></span><br><span class="line">恒</span><br><span class="line"><span class="keyword">if</span> (A[i] &gt; <span class="number">0</span>) <span class="built_in">add</span>(S, i, <span class="number">0</span>, A[i]), tot += A[i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span>) <span class="built_in">add</span>(i, T, <span class="number">0</span>, -A[i]);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dinic</span>() != tot) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * <span class="number">2</span>; i += <span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[i ^ <span class="number">1</span>] + l[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>有源汇上下界最大流</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">问题描述</span><br><span class="line">给定一个包含 n 个点 m 条边的有向图，每条边都有一个流量下界和流量上界。</span><br><span class="line">给定源点 S 和汇点 T，求源点到汇点的最大流。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含四个整数 n,m,S,T。接下来 m 行，每行包含四个整数 a,b,c,d 表示点 a 和 b 之间存</span><br><span class="line">在一条有向边，该边的流量下界为 c，流量上界为 d。点编号从 <span class="number">1</span> 到 n。</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数表示最大流。如果无解，则输出 No Solution。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, M = (N + <span class="number">10000</span>) * <span class="number">2</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], cur[N], A[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">e[idx] = a, f[idx] = <span class="number">0</span>, ne[idx] = h[b], h[b] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (d[ver] == <span class="number">-1</span> &amp;&amp; f[i]) &#123;</span><br><span class="line">d[ver] = d[t] + <span class="number">1</span>;</span><br><span class="line">cur[ver] = h[ver];</span><br><span class="line"><span class="keyword">if</span> (ver == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[ ++ tt] = ver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == T) <span class="keyword">return</span> limit;</span><br><span class="line"><span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;</span><br><span class="line">cur[u] = i;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (d[ver] == d[u] + <span class="number">1</span> &amp;&amp; f[i]) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">find</span>(ver, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line"><span class="keyword">if</span> (!t) d[ver] = <span class="number">-1</span>;</span><br><span class="line">f[i] -= t, f[i ^ <span class="number">1</span>] += t, flow += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> r = <span class="number">0</span>, flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>()) <span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF)) r += flow;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> s, t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">S = <span class="number">0</span>, T = n + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"><span class="built_in">add</span>(a, b, d - c);</span><br><span class="line">A[a] -= c, A[b] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (A[i] &gt; <span class="number">0</span>) <span class="built_in">add</span>(S, i, A[i]), tot += A[i];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span>) <span class="built_in">add</span>(i, T, -A[i]);</span><br><span class="line"><span class="built_in">add</span>(t, s, INF); <span class="comment">// 先以 s, t 为源点(注意到这是最后增加的两条边, 输出结果时会用到这个地</span></span><br><span class="line">方)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dinic</span>() &lt; tot) <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> res = f[idx - <span class="number">1</span>];</span><br><span class="line">S = s, T = t;</span><br><span class="line">f[idx - <span class="number">1</span>] = f[idx - <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res + <span class="built_in">dinic</span>());</span><br><span class="line"><span class="comment">/* 有源汇上下界最小流 只需要修改这里即可</span></span><br><span class="line"><span class="comment">int res = f[idx - 1];</span></span><br><span class="line"><span class="comment">S = t, T = s;</span></span><br><span class="line"><span class="comment">f[idx - 1] = f[idx - 2] = 0;</span></span><br><span class="line"><span class="comment">printf(&quot;%d\n&quot;, res - dinic());</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a><strong>最大权闭合子图</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">场景</span><br><span class="line">若选择用户i，则ai,bi都必须选择，最大化点权和。这便是最大权闭合图的模型。</span><br><span class="line">最大权闭合图的解法</span><br><span class="line">新建源点S,向正权点连容量为点权的边；新建汇点T,负权点向T连容量为点权的相反数的边。图中原有的</span><br><span class="line">边容量改为正无穷。正权点点权和减去最小割即为答案。</span><br><span class="line">正确性证明</span><br><span class="line">选择用户i ⇒ ai,bi 必须选择，即必须割掉ai,bi连向T的边；放弃用户i ⇒ 割掉S连向i的边。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">问题描述</span><br><span class="line">在前期市场调查和站址勘测之后，公司得到了一共 N 个可以作为通讯信号中转站的地址，而由于这些地</span><br><span class="line">址的地理位置差异，在不同的地方建造通讯中转站需 要投入的成本也是不一样的，所幸在前期调查之后这些都</span><br><span class="line">是已知数据：</span><br><span class="line">建立第 i 个通讯中转站需要的成本为 <span class="built_in">Pi</span>(<span class="number">1</span>≤i≤N)。</span><br><span class="line">另外公司调查得出了所有期望中的用户群，一共 M 个。</span><br><span class="line">关于第 i 个用户群的信息概括为 Ai,Bi 和 Ci：这些用户会使用中转站 Ai 和中转站 Bi 进行通</span><br><span class="line">讯，公司可以获益 Ci。（<span class="number">1</span>≤i≤M,<span class="number">1</span>≤Ai,Bi≤N）</span><br><span class="line">THU 集团的 CS&amp;T 公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益</span><br><span class="line">（获益之和）。</span><br><span class="line">那么如何选择最终建立的中转站才能让公司的净获利最大呢？（净获利 = 获益之和 – 投入成本之和）</span><br><span class="line">输入格式</span><br><span class="line">第一行有两个正整数 N 和 M。第二行中有 N 个整数描述每一个通讯中转站的建立成本，依次为</span><br><span class="line">P1,P2,…,PN 。以下 M 行，第 (i+<span class="number">2</span>) 行的三个数 Ai,Bi 和 Ci 描述第 i 个用户群的信息。所有变量</span><br><span class="line">的含义可以参见题目描述。</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示公司可以得到的最大净获利。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板省略，同上</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line"><span class="built_in">add</span>(m + i, T, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(S, i, c);</span><br><span class="line"><span class="built_in">add</span>(i, m + a, INF);</span><br><span class="line">    <span class="built_in">add</span>(i, m + b, INF);</span><br><span class="line">tot += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tot - <span class="built_in">dinic</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a><strong>费用流</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">问题描述</span><br><span class="line">给定一个包含 n 个点 m 条边的有向图，并给定每条边的容量和费用，边的容量非负。</span><br><span class="line">图中可能存在重边和自环，保证费用不会存在负环。</span><br><span class="line">求从 S 到 T 的最大流，以及在流量最大时的最小费用。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含四个整数 n,m,S,T。接下来 m 行，每行三个整数 u,v,c,w，表示从点 u 到点 v 存在一</span><br><span class="line">条有向边，容量为 c，费用为 <span class="built_in">w</span>(这里费用指的是单位流量的费用)。点的编号从 <span class="number">1</span> 到 n。</span><br><span class="line">输出格式</span><br><span class="line">输出点 S 到点 T 的最大流和流量最大时的最小费用。</span><br><span class="line">如果从点 S 无法到达点 T 则输出 <span class="number">0</span> <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>, M = <span class="number">100010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ; <span class="comment">//</span></span><br><span class="line">w[idx] = -d : 退流</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">spfa</span>() &#123; <span class="comment">// 找最短增广路</span></span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="keyword">sizeof</span> incf);</span><br><span class="line">q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line"><span class="keyword">while</span> (hh != tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line">st[t] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line">    <span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (f[i] &amp;&amp; d[ver] &gt; d[t] + w[i]) &#123;</span><br><span class="line">d[ver] = d[t] + w[i];</span><br><span class="line">pre[ver] = i;</span><br><span class="line">incf[ver] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line"><span class="keyword">if</span> (!st[ver]) &#123;</span><br><span class="line">q[tt ++ ] = ver;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line">st[ver] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EK</span><span class="params">(<span class="type">int</span>&amp; flow, <span class="type">int</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">flow = cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>()) &#123;</span><br><span class="line"><span class="type">int</span> t = incf[T];</span><br><span class="line">flow += t, cost += t * d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>]) &#123;</span><br><span class="line">f[pre[i]] -= t;</span><br><span class="line">f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"><span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> flow, cost;</span><br><span class="line"><span class="built_in">EK</span>(flow, cost); <span class="comment">// flow 为 最大流 cost 为 最小费用流</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, flow, cost);</span><br><span class="line"><span class="comment">/* 若还要求最大费用流, 则先恢复图, 然后将费用取反再跑 EK, -cost 则为最大费用流</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; idx; i += 2) &#123;</span></span><br><span class="line"><span class="comment">f[i] += f[i ^ 1], f[i ^ 1] = 0;</span></span><br><span class="line"><span class="comment">w[i] = -w[i], w[i ^ 1] = -w[i ^ 1];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">EK(flow, cost);</span></span><br><span class="line"><span class="comment">printf(&quot;%d\n&quot;, -cost);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无源汇最小费用流"><a href="#无源汇最小费用流" class="headerlink" title="无源汇最小费用流"></a><strong>无源汇最小费用流</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">管道网络可以用 n 个节点 m 条边的有向图表示。机器人从 <span class="number">1</span> 号节点出发，清理完所有需要被清理的</span><br><span class="line">管道，最终回到 <span class="number">1</span> 号节点。</span><br><span class="line">管道一共有以下四种类型:</span><br><span class="line">A 类:管道需要被清理，而且可以重复经过；</span><br><span class="line">B 类:管道需要被清理，但是不能重复经过；</span><br><span class="line">C 类:管道不需要被清理，而且可以重复经过；</span><br><span class="line">D 类:管道不需要被清理，但是不能重复经过。</span><br><span class="line">一条需要清理的管道在 机器人经过它时，就会被它清理。因为管道是有向的，所以机器人只能从一端走</span><br><span class="line">到另一端不能反过来走。对于不能重复经过的管道，机器人最多只能经过它一次。因为管道网络的特殊性，如</span><br><span class="line">果把管道看成无向图，A 类和 B 类管道及其端点构成的子图是连通的，并且 <span class="number">1</span> 号节点一定在这个连通子图</span><br><span class="line">中。</span><br><span class="line">机器人能不能在约束条件下清理完所有应该清理的管道（A 类和 B 类)。机器人 每经过一条管道一次，</span><br><span class="line">就会消耗 E 个包子。如果网络能够被成功清理，少要消耗多少个包子。如果网络无法被成功清理，则直接输</span><br><span class="line">出 −<span class="number">1</span>。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含三个非负整数 T、S、E，表示数据的组数、测试点的编号和经过一条管道一次消耗的包子数</span><br><span class="line">量。</span><br><span class="line">接下来有 T 个部分，每个部分描述一组数据。对于评测数据，保证 T=<span class="number">10</span>。保证 E∈&#123;<span class="number">0</span>,<span class="number">1</span>&#125;，这 T 组</span><br><span class="line">数据的包子消耗速度相同。每个部分第一行包含两个正整数 n、m，表示管道网络的节点数和边数。节点用</span><br><span class="line"><span class="number">1</span>∼n 的整数编号。接下来 m 行，每行包含两个正整数 u,v 和一个大写字母 t，相邻两个元素之间用一个空</span><br><span class="line">格隔开，表示一条从节点 u 连向节点 v 的管道，其类型为 t。保证 <span class="number">1</span>≤u,v≤n，t 一定是 A、B、C、D 之</span><br><span class="line">一。</span><br><span class="line">输出格式</span><br><span class="line">输出 T 行，每行一个整数，表示每组数据的答案。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, M = <span class="number">2010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> din[N], dout[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ; <span class="comment">//</span></span><br><span class="line">w[idx] = -d : 退流</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">spfa</span>() &#123; <span class="comment">// 找最短增广路</span></span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="keyword">sizeof</span> incf);</span><br><span class="line">q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line"><span class="keyword">while</span> (hh != tt) &#123;</span><br><span class="line">    <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line">st[t] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (f[i] &amp;&amp; d[ver] &gt; d[t] + w[i]) &#123;</span><br><span class="line">d[ver] = d[t] + w[i];</span><br><span class="line">pre[ver] = i;</span><br><span class="line">incf[ver] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line"><span class="keyword">if</span> (!st[ver]) &#123;</span><br><span class="line">q[tt ++ ] = ver;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line">st[ver] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EK</span><span class="params">(<span class="type">int</span>&amp; flow, <span class="type">int</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">flow = cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>()) &#123;</span><br><span class="line"><span class="type">int</span> t = incf[T];</span><br><span class="line">flow += t, cost += t * d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>]) &#123;</span><br><span class="line">f[pre[i]] -= t;</span><br><span class="line">f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> Times, SS, E;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;Times, &amp;SS, &amp;E);</span><br><span class="line"><span class="keyword">while</span> (Times -- ) &#123;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(din, <span class="number">0</span>, <span class="keyword">sizeof</span> din);</span><br><span class="line"><span class="built_in">memset</span>(dout, <span class="number">0</span>, <span class="keyword">sizeof</span> dout);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">S = <span class="number">0</span>, T = n + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> down_cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %c&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="type">int</span> down, up;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span>) down = <span class="number">1</span>, up = INF, down_cost += E;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;B&#x27;</span>) down = up = <span class="number">1</span>, down_cost += E;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;C&#x27;</span>) down = <span class="number">0</span>, up = INF;</span><br><span class="line"><span class="keyword">else</span> down = <span class="number">0</span>, up = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">add</span>(a, b, up - down, E);</span><br><span class="line">din[b] += down, dout[a] += down;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// tot 用来判断是否满流</span></span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 根据入流量和出流量, 决定向源点还是汇点连边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (din[i] &gt; dout[i]) &#123;</span><br><span class="line"><span class="built_in">add</span>(S, i, din[i] - dout[i], <span class="number">0</span>);</span><br><span class="line">tot += din[i] - dout[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">add</span>(i, T, dout[i] - din[i], <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> flow, cost;</span><br><span class="line"><span class="built_in">EK</span>(flow, cost);</span><br><span class="line"><span class="keyword">if</span> (flow == tot) cost += down_cost;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cost);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-差分约束"><a href="#15-差分约束" class="headerlink" title="15 差分约束"></a><strong>15</strong> <strong>差分约束</strong></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>应用背景 1 : 求不等式的可行解</p>
<p>源点需要满足条件 : 从源点出发, 一定可以走到所有边</p>
<p>步骤(最短路)</p>
<p>先将每个不等式<br>$$<br>x_i&lt;&#x3D;x_j+c_k<br>$$</p>
<p>转化为一条从 到 的边， 边权为</p>
<p>找一个满足条件的源点</p>
<p>从源点出发求一遍最短路</p>
<p>若存在负环， 则原不等式组无解</p>
<p>否则 dist[i] 就是原不等式组的一个可行解</p>
<p>应用背景 2 : 如何求可行解的最值（变量 的最值）</p>
<p>若求最小值 , 则应该求最长路<br>$$<br>x_i&gt;&#x3D;x_j+c_k\\<br>x_i&lt;&#x3D;x_j+c_k<br>$$</p>
<p>若求最大值 , 则应该求最短路</p>
<p><strong>细节</strong></p>
<p>$$<br>转化x_i&lt;&#x3D;c_k这类不等式：建立超级源点x_0然后建立x_0到x_1长度为c_k的边<br>$$</p>
<h3 id="一道例题"><a href="#一道例题" class="headerlink" title="一道例题"></a><strong>一道例题</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">幼儿园里有 N 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。</span><br><span class="line">但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果</span><br><span class="line">的时候， 老师需要满足小朋友们的 K 个要求。</span><br><span class="line">幼儿园的糖果总是有限的，老师想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并</span><br><span class="line">且满足小朋友们所有的要求。</span><br><span class="line">输入格式</span><br><span class="line">输入的第一行是两个整数 N,K。接下来 K 行，表示分配糖果时需要满足的关系，每行 <span class="number">3</span> 个数字</span><br><span class="line">X,A,B。</span><br><span class="line">如果 X=<span class="number">1</span>．表示第 A 个小朋友分到的糖果必须和第 B 个小朋友分到的糖果一样多。</span><br><span class="line">如果 X=<span class="number">2</span>，表示第 A 个小朋友分到的糖果必须少于第 B 个小朋友分到的糖果。</span><br><span class="line">如果 X=<span class="number">3</span>，表示第 A 个小朋友分到的糖果必须不少于第 B 个小朋友分到的糖果。</span><br><span class="line">如果 X=<span class="number">4</span>，表示第 A 个小朋友分到的糖果必须多于第 B 个小朋友分到的糖果。</span><br><span class="line">如果 X=<span class="number">5</span>，表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果。</span><br><span class="line">小朋友编号从 <span class="number">1</span> 到 N。</span><br><span class="line">输出格式</span><br><span class="line">输出一行，表示老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出 −<span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line">LL dist[N];</span><br><span class="line"><span class="type">int</span> q[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">st[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="type">int</span> t = q.<span class="built_in">top</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">st[t] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="comment">// 最长路</span></span><br><span class="line"><span class="keyword">if</span> (dist[j] &lt; dist[t] + w[i]) &#123;</span><br><span class="line">dist[j] = dist[t] + w[i];</span><br><span class="line">cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt[j] &gt;= n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">st[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> x, a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>) <span class="built_in">add</span>(b, a, <span class="number">0</span>), <span class="built_in">add</span>(a, b, <span class="number">0</span>); <span class="comment">// a &gt;= b &amp;&amp; b &gt;= a</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">2</span>) <span class="built_in">add</span>(a, b, <span class="number">1</span>); <span class="comment">// b &gt;= a + 1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">3</span>) <span class="built_in">add</span>(b, a, <span class="number">0</span>); <span class="comment">// a &gt;= b</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">4</span>) <span class="built_in">add</span>(b, a, <span class="number">1</span>); <span class="comment">// a &gt;= b + 1</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">add</span>(a, b, <span class="number">0</span>); <span class="comment">// b &gt;= a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建立 x0 超级源点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res += dist[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-字符串使用手册"><a href="#16-字符串使用手册" class="headerlink" title="16 字符串使用手册"></a><strong>16</strong> <strong>字符串使用手册</strong></h2><h3 id="读入加速"><a href="#读入加速" class="headerlink" title="读入加速"></a>读入加速</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(), ::toupper);</span><br></pre></td></tr></table></figure>

<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从下标 pos 开始, 长度为 len 的子字符串被 str 替换</span></span><br><span class="line"><span class="function">basic_string&amp; <span class="title">replace</span> <span class="params">(size_type pos, size_type len, <span class="type">const</span> basic_string&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">str)</span></span>; <span class="comment">//str.replace(9,5,str2);</span></span><br><span class="line"><span class="comment">// iterator</span></span><br><span class="line"><span class="function">basic_string&amp; <span class="title">replace</span> <span class="params">(const_iterator i1, const_iterator i2, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">basic_string&amp; str)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="新字符串-替换-所有指定子字符串-自己实现的"><a href="#新字符串-替换-所有指定子字符串-自己实现的" class="headerlink" title="新字符串 替换 所有指定子字符串 (自己实现的)"></a>新字符串 替换 所有指定子字符串 (自己实现的)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">subreplace</span><span class="params">(string resource_str, string sub_str, string new_str)</span> </span>&#123;</span><br><span class="line">string::size_type pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((pos = resource_str.<span class="built_in">find</span>(sub_str)) != string::npos) &#123;</span><br><span class="line">resource_str.<span class="built_in">replace</span>(pos, sub_str.<span class="built_in">length</span>(), new_str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resource_str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除 pos 开始 长度为 len 的子字符串</span></span><br><span class="line"><span class="function">basic_string&amp; <span class="title">erase</span> <span class="params">(size_type pos = <span class="number">0</span>, size_type len = npos)</span></span>; <span class="comment">// str.erase</span></span><br><span class="line">(<span class="number">10</span>,<span class="number">8</span>);</span><br><span class="line"><span class="comment">// iterator</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>; <span class="comment">//str.erase</span></span><br><span class="line">(str.<span class="built_in">begin</span>()+<span class="number">5</span>, str.<span class="built_in">end</span>()<span class="number">-9</span>);</span><br></pre></td></tr></table></figure>

<h3 id="查找给定字符串"><a href="#查找给定字符串" class="headerlink" title="查找给定字符串"></a>查找给定字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 str 第一次出现的位置 (pos 可以指定搜索起点)</span></span><br><span class="line"><span class="function">size_type <span class="title">find</span> <span class="params">(<span class="type">const</span> basic_string&amp; str, size_type pos = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">str</span> <span class="params">(<span class="string">&quot;There are two needles in this haystack with needles.&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">str2</span> <span class="params">(<span class="string">&quot;needle&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// different member versions of find in the same order as above:</span></span><br><span class="line">std::string::size_type found = str.<span class="built_in">find</span>(str2);</span><br><span class="line"><span class="keyword">if</span> (found != std::string::npos)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;first &#x27;needle&#x27; found at: &quot;</span> &lt;&lt; found &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="取子字符串"><a href="#取子字符串" class="headerlink" title="取子字符串"></a>取子字符串</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 pos 开始, 长度为 len 的子字符串</span></span><br><span class="line"><span class="function">basic_string <span class="title">substr</span> <span class="params">(size_type pos = <span class="number">0</span>, size_type len = npos)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(ch, start = <span class="number">0</span>) 查找并返回从 start 开始的字符 ch 的位置；<span class="built_in">rfind</span>(ch) 从末尾开始，</span><br><span class="line">查找并返回第一个找到的字符 ch 的位置（皆从 <span class="number">0</span> 开始）（如果查找不到，返回 <span class="number">-1</span>）。</span><br><span class="line"><span class="built_in">substr</span>(start, len) 可以从字符串的 start（从 <span class="number">0</span> 开始）截取一个长度为 len 的字符串（缺省</span><br><span class="line">len 时代码截取到字符串末尾）。</span><br><span class="line"><span class="built_in">append</span>(s) 将 s 添加到字符串末尾。</span><br><span class="line"><span class="built_in">append</span>(s, pos, n) 将字符串 s 中，从 pos 开始的 n 个字符连接到当前字符串结尾。</span><br><span class="line"><span class="built_in">replace</span>(pos, n, s) 删除从 pos 开始的 n 个字符，然后在 pos 处插入串 s。</span><br><span class="line"><span class="built_in">erase</span>(pos, n) 删除从 pos 开始的 n 个字符。</span><br><span class="line"><span class="built_in">insert</span>(pos, s) 在 pos 位置插入字符串 s。</span><br></pre></td></tr></table></figure>

<h2 id="17-Regex-正则"><a href="#17-Regex-正则" class="headerlink" title="17 Regex 正则"></a><strong>17 Regex</strong> <strong>正则</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">string <span class="title">s</span> <span class="params">(<span class="string">&quot;subject&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">regex <span class="title">e</span> <span class="params">(<span class="string">&quot;(sub)(.*)&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">regex_match</span> (s,e))</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;string object matched\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">regex_match</span> ( s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), e ) )</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;range matched\n&quot;</span>;</span><br><span class="line">smatch sm; <span class="comment">// same as match_results&lt;string::const_iterator&gt; sm;</span></span><br><span class="line"><span class="built_in">regex_match</span> (s,sm,e);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;string object with &quot;</span> &lt;&lt; sm.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; matches\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the matches were: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">0</span>; i&lt;sm.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; sm[i] &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">string object matched</span></span><br><span class="line"><span class="comment">range matched</span></span><br><span class="line"><span class="comment">string object with 3 matches</span></span><br><span class="line"><span class="comment">the matches were: [subject] [sub] [ject]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="18-日期处理模板"><a href="#18-日期处理模板" class="headerlink" title="18 日期处理模板"></a><strong>18</strong> <strong>日期处理模板</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> month[] = &#123;</span><br><span class="line"><span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 判断 是否为 闰年</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">is_leap</span><span class="params">(<span class="type">int</span> year)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> || year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 m 月 天数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_month</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">2</span>) <span class="keyword">return</span> month[m] + <span class="built_in">is_leap</span>(y);</span><br><span class="line"><span class="keyword">return</span> month[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-最近公共祖先"><a href="#19-最近公共祖先" class="headerlink" title="19 最近公共祖先"></a><strong>19</strong> <strong>最近公共祖先</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一棵包含 n 个节点的有根无向树，节点编号互不相同，但不一定是 <span class="number">1</span>∼n。</span><br><span class="line">有 m 个询问，每个询问给出了一对节点的编号 x 和 y，询问 x 与 y 的祖孙关系。</span><br><span class="line">输入格式</span><br><span class="line">输入第一行包括一个整数 表示节点个数；</span><br><span class="line">接下来 n 行每行一对整数 a 和 b，表示 a 和 b 之间有一条无向边。如果 b 是 −<span class="number">1</span>，那么 a 就是</span><br><span class="line">树的根；</span><br><span class="line">第 n + <span class="number">2</span> 行是一个整数 m 表示询问个数；</span><br><span class="line">接下来 m 行，每行两个不同的正整数 x 和 y，表示一个询问。</span><br><span class="line">输出格式</span><br><span class="line">对于每一个询问，若 x 是 y 的祖先则输出 <span class="number">1</span>，若 y 是 x 的祖先则输出 <span class="number">2</span>，否则输出 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<h3 id="倍增查询"><a href="#倍增查询" class="headerlink" title="倍增查询"></a><strong>倍增查询</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">depth[<span class="number">0</span>] = <span class="number">0</span>, depth[root] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">q[<span class="number">0</span>] = root;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>) &#123;</span><br><span class="line">depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">q[ ++ tt] = j;</span><br><span class="line">fa[j][<span class="number">0</span>] = t;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; k ++ )</span><br><span class="line">fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line"><span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">a = fa[a][k];</span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line"><span class="keyword">if</span> (fa[a][k] != fa[b][k]) &#123;</span><br><span class="line">a = fa[a][k];</span><br><span class="line">b = fa[b][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">-1</span>) root = a;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bfs</span>(root);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line"><span class="keyword">if</span> (p == a) <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p == b) <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-有向图强连通分量-Tarjan"><a href="#20-有向图强连通分量-Tarjan" class="headerlink" title="20. 有向图强连通分量(Tarjan)"></a><strong>20.</strong> <strong>有向图强连通分量(Tarjan)</strong></h2><p>在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>。如果有向图G的每两个顶点都强</p>
<p>连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为<strong>强连通分量</strong></p>
<p>此题Targan算法主要是将 图 进行缩点。得到各个强连通分量，构成拓扑图。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">每一头牛的愿望就是变成一头最受欢迎的牛。</span><br><span class="line">现在有 N 头牛，编号从 <span class="number">1</span> 到 N，给你 M 对整数 (A,B)，表示牛 A 认为牛 B 受欢迎。</span><br><span class="line">这种关系是具有传递性的，如果 A 认为 B 受欢迎，B 认为 C 受欢迎，那么牛 A 也认为牛 C 受欢迎。</span><br><span class="line">你的任务是求出有多少头牛被除自己之外的所有牛认为是受欢迎的。</span><br><span class="line">输入格式</span><br><span class="line">第一行两个数 N,M；</span><br><span class="line">接下来 M 行，每行两个数 A,B，意思是 A 认为 B 是受欢迎的（给出的信息有可能重复，即有可能出</span><br><span class="line">现多个 A,B）。</span><br><span class="line">输出格式</span><br><span class="line">输出被除自己之外的所有牛认为是受欢迎的牛的数量。</span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">样例解释</span><br><span class="line">只有第三头牛被除自己之外的所有牛认为是受欢迎的。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line"><span class="comment">// dfn[u] : 遍历到 u 的时间戳</span></span><br><span class="line"><span class="comment">// low[u] : 从 u 出发能够遍历到的最小时间戳</span></span><br><span class="line"><span class="comment">// timestamp : 当前时间戳</span></span><br><span class="line"><span class="type">int</span> stk[N], top;</span><br><span class="line"><span class="type">bool</span> in_stk[N]; <span class="comment">// 点是否在栈中</span></span><br><span class="line"><span class="type">int</span> id[N], scc_cnt, Size[N];</span><br><span class="line"><span class="comment">// id[u] : 点u所在强连通分量编号</span></span><br><span class="line"><span class="comment">// scc_cnt : 当前强连通分量个数</span></span><br><span class="line"><span class="comment">// Size[u] : 强连通分量的大小</span></span><br><span class="line"><span class="type">int</span> dout[N]; <span class="comment">// 联通分量出度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++ timestamp;</span><br><span class="line">stk[ ++ top] = u, in_stk[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (!dfn[j]) &#123;</span><br><span class="line"><span class="built_in">tarjan</span>(j);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u], low[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">++ scc_cnt;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">y = stk[top -- ];</span><br><span class="line">in_stk[y] = <span class="literal">false</span>;</span><br><span class="line">id[y] = scc_cnt;</span><br><span class="line">Size[scc_cnt] ++ ;</span><br><span class="line">&#125; <span class="keyword">while</span> (y != u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (!dfn[i])</span><br><span class="line"><span class="built_in">tarjan</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j]) &#123;</span><br><span class="line"><span class="type">int</span> k = e[j];</span><br><span class="line"><span class="type">int</span> a = id[i], b = id[k];</span><br><span class="line"><span class="keyword">if</span> (a != b) dout[a] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> zeros = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; i ++ )</span><br><span class="line"><span class="keyword">if</span> (!dout[i]) &#123;</span><br><span class="line">zeros ++ ;</span><br><span class="line">sum += Size[i];</span><br><span class="line"><span class="keyword">if</span> (zeros &gt; <span class="number">1</span>) &#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-最长公共上升子序列"><a href="#21-最长公共上升子序列" class="headerlink" title="21. 最长公共上升子序列"></a><strong>21.</strong> <strong>最长公共上升子序列</strong></h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。</span><br><span class="line">小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子</span><br><span class="line">序列了。</span><br><span class="line">小沐沐说，对于两个数列A和B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一</span><br><span class="line">段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。</span><br><span class="line">奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。</span><br><span class="line">不过，只要告诉奶牛它的长度就可以了。</span><br><span class="line">数列A和B的长度均不超过<span class="number">3000</span>。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含一个整数N，表示数列A，B的长度。</span><br><span class="line">第二行包含N个整数，表示数列A。</span><br><span class="line">第三行包含N个整数，表示数列B。</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最长公共上升子序列的长度。</span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">3000</span>,序列中的数字均不超过<span class="number">231</span>−<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入样例：</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a><strong>问题分析</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 状态表示</span><br><span class="line">f[i][j]代表所有a[<span class="number">1</span> ~ i]和b[<span class="number">1</span> ~ j]中以b[j]结尾的公共上升子序列的集合；</span><br><span class="line">f[i][j]的值等于该集合的子序列中长度的最大值；</span><br><span class="line"><span class="number">2.</span> 状态计算</span><br><span class="line">首先依据公共子序列中是否包含a[i]，将f[i][j]所代表的集合划分成两个不重不漏的子集：</span><br><span class="line">不包含a[i]的子集，最大值是f[i - <span class="number">1</span>][j]；</span><br><span class="line">包含a[i]的子集，将这个子集继续划分，依据是子序列的倒数第二个元素在b[]中是哪个数：</span><br><span class="line">子序列只包含b[j]一个数，长度是<span class="number">1</span>；</span><br><span class="line">子序列的倒数第二个数是b[<span class="number">1</span>]的集合，最大长度是f[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>；</span><br><span class="line">…</span><br><span class="line">子序列的倒数第二个数是b[j - <span class="number">1</span>]的集合，最大长度是f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<h3 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a><strong>代码实现思路</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">&#123;</span><br><span class="line">f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> maxv = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; j; k ++ )</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; b[k])</span><br><span class="line">maxv = <span class="built_in">max</span>(maxv, f[i - <span class="number">1</span>][k] + <span class="number">1</span>);</span><br><span class="line">f[i][j] = <span class="built_in">max</span>(f[i][j], maxv);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a><strong>优化思路</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们发现每次循环求得的maxv是满足a[i] &gt; b[k] 的 f[i - <span class="number">1</span>][k] + <span class="number">1</span>的前缀最大值。</span><br><span class="line">因此可以直接将maxv提到第一层循环外面，减少重复计算，此时只剩下两重循环。</span><br><span class="line">最终答案枚举子序列结尾取最大值即可。</span><br></pre></td></tr></table></figure>

<h3 id="最终代码实现"><a href="#最终代码实现" class="headerlink" title="最终代码实现"></a><strong>最终代码实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> maxv = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">&#123;</span><br><span class="line">f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j], maxv);</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; b[j]) maxv = <span class="built_in">max</span>(maxv, f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-点分治"><a href="#22-点分治" class="headerlink" title="22. 点分治"></a><strong>22.</strong> <strong>点分治</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">给定一个有 N 个点（编号 <span class="number">0</span>,<span class="number">1</span>,…,N−<span class="number">1</span>）的树，每条边都有一个权值（不超过 <span class="number">1000</span>）。</span><br><span class="line">树上两个节点 x 与 y 之间的路径长度就是路径上各条边的权值之和。</span><br><span class="line">求长度不超过 K 的路径有多少条。</span><br><span class="line">输入格式</span><br><span class="line">输入包含多组测试用例。</span><br><span class="line">每组测试用例的第一行包含两个整数 N 和 K。</span><br><span class="line">接下来 N−<span class="number">1</span> 行，每行包含三个整数 u,v,l，表示节点 u 与 v 之间存在一条边，且边的权值为 l。</span><br><span class="line">当输入用例 N=<span class="number">0</span>，K=<span class="number">0</span> 时，表示输入终止，且该用例无需处理。</span><br><span class="line">输出格式</span><br><span class="line">每个测试用例输出一个结果。</span><br><span class="line">每个结果占一行。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> p[N], q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_size</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123; <span class="comment">// 求子树大小</span></span><br><span class="line"><span class="keyword">if</span> (st[u]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 若节点 u 已经删掉则返回 0</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (e[i] != fa) <span class="comment">// 若不往回搜</span></span><br><span class="line">res += <span class="built_in">get_size</span>(e[i], u);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_wc</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> tot, <span class="type">int</span>&amp; wc)</span> </span>&#123; <span class="comment">// 求重心(满足任意连通块大小小于 n/2 即</span></span><br><span class="line">可)</span><br><span class="line"><span class="keyword">if</span> (st[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">1</span>, ms = <span class="number">0</span>; <span class="comment">// sum : 子树大小 ms : 连通块大小的最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>; <span class="comment">// 判断是否往回搜</span></span><br><span class="line"><span class="type">int</span> t = <span class="built_in">get_wc</span>(j, u, tot, wc);</span><br><span class="line">ms = <span class="built_in">max</span>(ms, t);</span><br><span class="line">sum += t;</span><br><span class="line">&#125;</span><br><span class="line">ms = <span class="built_in">max</span>(ms, tot - sum);</span><br><span class="line"><span class="keyword">if</span> (ms &lt;= tot / <span class="number">2</span>) wc = u;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_dist</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> dist, <span class="type">int</span>&amp; qt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (st[u] || dist &gt; m) <span class="keyword">return</span>; <span class="comment">// 若 u 已经删掉则直接 return</span></span><br><span class="line">q[qt ++ ] = dist;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (e[i] != fa)</span><br><span class="line"><span class="built_in">get_dist</span>(e[i], u, dist + w[i], qt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(a, a + k);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>, j = <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line"><span class="keyword">while</span> (j + <span class="number">1</span> &lt; i &amp;&amp; a[j + <span class="number">1</span>] + a[i] &lt;= m) j ++ ;</span><br><span class="line">j = <span class="built_in">min</span>(j, i - <span class="number">1</span>);</span><br><span class="line">    res += j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (st[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_wc</span>(u, <span class="number">-1</span>, <span class="built_in">get_size</span>(u, <span class="number">-1</span>), u);</span><br><span class="line">st[u] = <span class="literal">true</span>; <span class="comment">// 删除重心</span></span><br><span class="line"><span class="comment">// 重点 ---------------------------------------------</span></span><br><span class="line"><span class="type">int</span> pt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i], qt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_dist</span>(j, <span class="number">-1</span>, w[i], qt);</span><br><span class="line">res -= <span class="built_in">get</span>(q, qt);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; qt; k ++ ) &#123;</span><br><span class="line"><span class="keyword">if</span> (q[k] &lt;= m) res ++ ;</span><br><span class="line">p[pt ++ ] = q[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res += <span class="built_in">get</span>(p, pt);</span><br><span class="line"><span class="comment">// 归并部分------------------------------------------</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) res += <span class="built_in">calc</span>(e[i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), n || m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">calc</span>(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-状态压缩DP"><a href="#23-状态压缩DP" class="headerlink" title="23. 状态压缩DP"></a><strong>23.</strong> <strong>状态压缩DP</strong></h2><h3 id="棋盘式"><a href="#棋盘式" class="headerlink" title="棋盘式"></a><strong>棋盘式</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">在 n × n 的棋盘上放 k 个国王，国王可攻击相邻的 <span class="number">8</span> 个格子，求使它们无法互相攻击的方案总数。</span><br><span class="line">输入格式</span><br><span class="line">共一行，包含两个整数 n 和 k。</span><br><span class="line">输出格式</span><br><span class="line">共一行，表示方案总数，若不能够放置则输出<span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, K = <span class="number">110</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N][K][M];</span><br><span class="line"><span class="type">int</span> cnt[M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; states;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; head[M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line"><span class="keyword">if</span> ((state &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; (state &gt;&gt; i + <span class="number">1</span> &amp; <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> state)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cnt += state &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(i)) &#123;</span><br><span class="line">states.<span class="built_in">push_back</span>(i);</span><br><span class="line">cnt[i] = <span class="built_in">get</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; states.<span class="built_in">size</span>(); i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; states.<span class="built_in">size</span>(); j ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a = states[i], b = states[j];</span><br><span class="line"><span class="keyword">if</span> ((a &amp; b) == <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(a | b))</span><br><span class="line">head[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; states.<span class="built_in">size</span>(); a ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> b : head[a]) &#123;</span><br><span class="line"><span class="type">int</span> c = cnt[states[a]];</span><br><span class="line"><span class="keyword">if</span> (j &gt;= c) &#123;</span><br><span class="line">f[i][j][a] += f[i - <span class="number">1</span>][j - c][b];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; f[n + <span class="number">1</span>][m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="棋盘式-矩阵乘法-快速幂"><a href="#棋盘式-矩阵乘法-快速幂" class="headerlink" title="棋盘式 + 矩阵乘法 + 快速幂"></a><strong>棋盘式</strong> <strong>+</strong> <strong>矩阵乘法</strong> <strong>+</strong> <strong>快速幂</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">给出一个 n×m 的方格图，现在要用如下 L 型的积木拼到这个图中，使得方格图正好被拼满，请问总共</span><br><span class="line">有多少种拼法。</span><br><span class="line">其中，方格图的每一个方格正好能放积木中的一块。</span><br><span class="line">积木可以任意旋转。</span><br><span class="line">输入格式</span><br><span class="line">输入的第一行包含两个整数 n,m，表示方格图的大小。</span><br><span class="line">输出格式</span><br><span class="line">输出一行，表示可以放的方案数，由于方案数可能很多，所以请输出方案数除以 <span class="number">109</span>+<span class="number">7</span> 的余数。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">130</span>, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">LL n;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="comment">// 这里将原 n * m 方格 看为 m * n 方格, 便于理解</span></span><br><span class="line"><span class="comment">// x 为 当前列状态, y 为 下一列状态, u 为当前列枚举到的方格 index</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == m) w[x][y] ++ ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &gt;&gt; u &amp; <span class="number">1</span>) <span class="built_in">dfs</span>(x, y, u + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 由于 列 从左往右, u(行) 从下往上 枚举, 因此共有四种转移方式</span></span><br><span class="line"><span class="keyword">if</span> (u &amp;&amp; !(y &gt;&gt; u &amp; <span class="number">1</span>) &amp;&amp; !(y &gt;&gt; u - <span class="number">1</span> &amp; <span class="number">1</span>))</span><br><span class="line">    <span class="built_in">dfs</span>(x, y + (<span class="number">1</span> &lt;&lt; u) + (<span class="number">1</span> &lt;&lt; u - <span class="number">1</span>), u + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (u + <span class="number">1</span> &lt; m &amp;&amp; !(y &gt;&gt; u &amp; <span class="number">1</span>) &amp;&amp; !(y &gt;&gt; u + <span class="number">1</span> &amp; <span class="number">1</span>))</span><br><span class="line"><span class="built_in">dfs</span>(x, y + (<span class="number">1</span> &lt;&lt; u) + (<span class="number">1</span> &lt;&lt; u + <span class="number">1</span>), u + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (u + <span class="number">1</span> &lt; m &amp;&amp; !(x &gt;&gt; u + <span class="number">1</span> &amp; <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(y &gt;&gt; u &amp; <span class="number">1</span>)) <span class="built_in">dfs</span>(x, y + (<span class="number">1</span> &lt;&lt; u), u + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (!(y &gt;&gt; u + <span class="number">1</span> &amp; <span class="number">1</span>)) <span class="built_in">dfs</span>(x, y + (<span class="number">1</span> &lt;&lt; u + <span class="number">1</span>), u + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 矩阵乘法模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> c[][N], <span class="type">int</span> a[][N], <span class="type">int</span> b[][N])</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> tmp[N][N];</span><br><span class="line"><span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; m; j ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; m; k ++ )</span><br><span class="line">tmp[i][j] = (tmp[i][j] + (LL)a[i][k] * b[k][j]) % MOD;</span><br><span class="line"><span class="built_in">memcpy</span>(c, tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="comment">// 构造转移矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i ++ )</span><br><span class="line"><span class="built_in">dfs</span>(i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> res[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">res[<span class="number">0</span>][(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="built_in">mul</span>(res, res, w);</span><br><span class="line"><span class="built_in">mul</span>(w, w, w);</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res[<span class="number">0</span>][(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="0-1-覆盖问题"><a href="#0-1-覆盖问题" class="headerlink" title="0 1 覆盖问题"></a><strong>0 1</strong> <strong>覆盖问题</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">T 市有 N 个酒店，这些酒店由 N−<span class="number">1</span> 条双向道路连接，所有酒店和道路构成一颗树。</span><br><span class="line">不同的道路可能有不同的长度，运输车通过该道路所需要的时间受道路的长度影响。在 T 市，一共有 K</span><br><span class="line">种主流食材。莱莱公司有 K 辆车，每辆车负责一种食材的配送，不存在多辆车配送相同的食材。</span><br><span class="line">由于不同酒店的特点不同，因此不同酒店对食材的需求情况也不同，比如可能 <span class="number">1</span> 号酒店只需要第 <span class="number">1</span>,<span class="number">5</span></span><br><span class="line">种食材， <span class="number">2</span> 号酒店需要全部的 K 种食材.莱莱公司每天给这些公司运输食材。对于运输第 i 种食材的车</span><br><span class="line">辆，这辆车可以从任意酒店出发，然后将食材运输到所有需要第 i 种食材的酒店.为了提高配送效率，这 K</span><br><span class="line">辆车可以从不同的酒店出发。但是由于 T 市对于食品安全特别重视，因此每辆车在配送之前需要进行食品安</span><br><span class="line">全检查。鉴于进行食品安全检查的人手不足，最多可以设置 M 个检查点。</span><br><span class="line">现在莱莱公司需要你制定一个运输方案：选定不超过 M 个酒店设立食品安全检查点，确定每辆运输车从</span><br><span class="line">哪个检查点出发，规划每辆运输车的路线.假设所有的食材运输车在进行了食品安全检查之后同时出发，请制定</span><br><span class="line">一个运输方案，使得所有酒店的等待时间的最大值最小。酒店的等待时间从运输车辆出发时开始计算，到该酒</span><br><span class="line">店所有需要的食材都运输完毕截至。</span><br><span class="line">如果一个酒店不需要任何食材，那么它的等待时间为 <span class="number">0</span>。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含 <span class="number">3</span> 个正整数 N,M,K，含义见题目描述。</span><br><span class="line">接下来 N 行，每行包含 K 个整数。每行输入描述对应酒店对每种食材的需求情况，<span class="number">1</span> 表示需要对应的</span><br><span class="line">食材， <span class="number">0</span> 表示不需要。</span><br><span class="line">接下来 N−<span class="number">1</span> 行，每行包含 <span class="number">3</span> 个整数 u,v,w，表示存在一条通行时间为 w 的双向道路连接 u 号酒店</span><br><span class="line">和 v 号酒店。</span><br><span class="line">保证输入数据是一颗树，酒店从 <span class="number">1</span> 编号到 N。</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示在你的方案中，所有酒店的等待时间的最大值。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, M = <span class="number">10</span>, S = <span class="number">1</span> &lt;&lt; M;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> need[N][M];</span><br><span class="line"><span class="type">int</span> h[N], e[N * <span class="number">2</span>], w[N * <span class="number">2</span>], ne[N * <span class="number">2</span>], idx;</span><br><span class="line"><span class="type">int</span> d[N][M];</span><br><span class="line"><span class="type">int</span> f[S], state[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PII <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="function">PII <span class="title">res</span><span class="params">(<span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (need[u][v]) res.y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">dfs</span>(j, u, v);</span><br><span class="line"><span class="keyword">if</span> (t.y != <span class="number">-1</span>) &#123;</span><br><span class="line">res.x += t.x + w[i] * <span class="number">2</span>;</span><br><span class="line">res.y = <span class="built_in">max</span>(res.y, t.y + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(state, <span class="number">0</span>, <span class="keyword">sizeof</span> state);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j ++ )</span><br><span class="line"><span class="keyword">if</span> (d[i][j] &lt;= mid) <span class="comment">// 构建 0 1 矩阵(共 n 行, k 列)</span></span><br><span class="line">state[i] |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; k; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">f[i | state[j]] = <span class="built_in">min</span>(f[i | state[j]], f[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> f[(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>] &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j ++ )</span><br><span class="line">cin &gt;&gt; need[i][j];</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以第 i 个店为起点, 到满足所有第 j 种食材的供应所需最小距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j ++ ) &#123;</span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">dfs</span>(i, <span class="number">-1</span>, j);</span><br><span class="line"><span class="keyword">if</span> (t.y != <span class="number">-1</span>) d[i][j] = t.x - t.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">2e8</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-状态机DP"><a href="#24-状态机DP" class="headerlink" title="24. 状态机DP"></a><strong>24.</strong> <strong>状态机DP</strong></h2><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a><strong>KMP</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">你现在需要设计一个密码 S，S 需要满足：</span><br><span class="line">S 的长度是 N；</span><br><span class="line">S 只包含小写英文字母；</span><br><span class="line">S 不包含子串 T；</span><br><span class="line">例如：abc 和 abcde 是 abcde 的子串，abd 不是 abcde 的子串。</span><br><span class="line">请问共有多少种不同的密码满足要求？</span><br><span class="line">由于答案会非常大，请输出答案模 <span class="number">109</span>+<span class="number">7</span> 的余数。</span><br><span class="line">输入格式</span><br><span class="line">第一行输入整数N，表示密码的长度。</span><br><span class="line">第二行输入字符串T，T中只包含小写字母。</span><br><span class="line">    输出格式</span><br><span class="line">输出一个正整数，表示总方案数模 <span class="number">109</span>+<span class="number">7</span> 后的结果。</span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">50</span>,</span><br><span class="line"><span class="number">1</span>≤|T|≤N，|T|是T的长度。</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; str + <span class="number">1</span>;</span><br><span class="line">m = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ ) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; str[i] != str[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line"><span class="keyword">if</span> (str[i] == str[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> k = <span class="string">&#x27;a&#x27;</span>; k &lt;= <span class="string">&#x27;z&#x27;</span>; k ++ ) &#123;</span><br><span class="line"><span class="type">int</span> u = j;</span><br><span class="line"><span class="keyword">while</span> (u &amp;&amp; k != str[u + <span class="number">1</span>]) u = ne[u];</span><br><span class="line"><span class="keyword">if</span> (k == str[u + <span class="number">1</span>]) u ++ ;</span><br><span class="line"><span class="keyword">if</span> (u &lt; m) f[i + <span class="number">1</span>][u] = (f[i + <span class="number">1</span>][u] + f[i][j]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) res = (res + f[n][i]) % mod;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC****自动机"></a><strong>AC****自动机</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">DNA看作是一个由’A’, ‘G’ , ‘C’ , ‘T’构成的字符串。修复技术就是通过改变字符串中的一些字</span><br><span class="line">符，从而消除字符串中包含的致病片段。</span><br><span class="line">例如，我们可以通过改变两个字符，将DNA片段”AAGCAG”变为”AGGCAC”，从而使得DNA片段中不再包含</span><br><span class="line">致病片段”AAG”，”AGC”，”CAG”，以达到修复该DNA片段的目的。需注意，被修复的DNA片段中，仍然只能包</span><br><span class="line">含字符’A’, ‘G’ , ‘C’ , ‘T’。</span><br><span class="line">请你帮助生物学家修复给定的DNA片段，并且修复过程中改变的字符数量要尽可能的少。</span><br><span class="line">输入格式</span><br><span class="line">输入包含多组测试数据。每组数据第一行包含整数N，表示致病DNA片段的数量。</span><br><span class="line">接下来N行，每行包含一个长度不超过<span class="number">20</span>的非空字符串，字符串中仅包含字符’A’, ‘G’ , ‘C’ ,</span><br><span class="line">‘T’，用以表示致病DNA片段,再一行，包含一个长度不超过<span class="number">1000</span>的非空字符串，字符串中仅包含字符’A’,</span><br><span class="line">‘G’ , ‘C’ , ‘T’，用以表示待修复DNA片段。</span><br><span class="line">最后一组测试数据后面跟一行，包含一个<span class="number">0</span>，表示输入结束。</span><br><span class="line">输出格式</span><br><span class="line">每组数据输出一个结果，每个结果占一行。输入形如”Case x: y”，其中x为测试数据编号（从<span class="number">1</span>开</span><br><span class="line">始），y为修复过程中所需改变的字符数量的最小值，如果无法修复给定DNA片段，则y为”<span class="number">-1</span>”。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">4</span>], dar[N], idx;</span><br><span class="line"><span class="type">int</span> q[N], ne[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;T&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;G&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">get</span>(str[i]);</span><br><span class="line"><span class="keyword">if</span> (tr[p][t] == <span class="number">0</span>) tr[p][t] = ++ idx;</span><br><span class="line">p = tr[p][t];</span><br><span class="line">&#125;</span><br><span class="line">dar[p] = <span class="number">1</span>; <span class="comment">// 终结符标识</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line"><span class="keyword">if</span> (tr[<span class="number">0</span>][i])</span><br><span class="line">q[ ++ tt] = tr[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> p = tr[t][i];</span><br><span class="line"><span class="keyword">if</span> (!p) tr[t][i] = tr[ne[t]][i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ne[p] = tr[ne[t]][i];</span><br><span class="line">q[ ++ tt] = p;</span><br><span class="line">dar[p] |= dar[ne[p]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n) &#123;</span><br><span class="line"><span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line"><span class="built_in">memset</span>(dar, <span class="number">0</span>, <span class="keyword">sizeof</span> dar);</span><br><span class="line"><span class="built_in">memset</span>(ne, <span class="number">0</span>, <span class="keyword">sizeof</span> ne);</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"><span class="built_in">insert</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">m = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= idx; j ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++ ) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">get</span>(str[i + <span class="number">1</span>]) != k;</span><br><span class="line"><span class="type">int</span> p = tr[j][k];</span><br><span class="line"><span class="keyword">if</span> (!dar[p]) f[i + <span class="number">1</span>][p] = <span class="built_in">min</span>(f[i + <span class="number">1</span>][p], f[i][j] + t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i ++ ) res = <span class="built_in">min</span>(res, f[m][i]);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">0x3f3f3f3f</span>) res = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, T ++, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">小明最近在研究一门新的语言，叫做 QQ 语言。</span><br><span class="line">QQ 语言单词和文章都可以用且仅用只含有小写英文字母的字符串表示，任何由这些字母组成的字符串也都是</span><br><span class="line">一篇合法的 QQ 语言文章。</span><br><span class="line">在 QQ 语言的所有单词中，小明选出了他认为最重要的 n 个。使用这些单词，小明可以评价一篇 QQ 语言文</span><br><span class="line">章的“重要度”。</span><br><span class="line">文章“重要度”的定义为：在该文章中，所有重要的 QQ 语言单词出现次数的总和。其中多次出现的单词，不论</span><br><span class="line">是否发生包含、重叠等情况，每次出现均计算在内。</span><br><span class="line">例如，假设 n=<span class="number">2</span>n=<span class="number">2</span>，小明选出的单词是 `gvagv` 和 `agva`。</span><br><span class="line">在文章 `gvagvagvagv` 中，`gvagv` 出现了 <span class="number">3</span> 次，`agva` 出现了 <span class="number">2</span> 次，因此这篇文章的重要度为</span><br><span class="line"><span class="number">3</span>+<span class="number">2</span>=<span class="number">5</span></span><br><span class="line">现在，小明想知道，一篇由 m 个字母组成的 QQ 语言文章，重要度最高能达到多少。</span><br><span class="line">#### 输入格式</span><br><span class="line">输入的第一行包含两个整数 n,m表示小明选出的单词个数和最终文章包含的字母个数。</span><br><span class="line">接下来 n 行，每行包含一个仅由英文小写字母构成的字符串，表示小明选出的这 n 个单词。</span><br><span class="line">#### 输出格式</span><br><span class="line">输出一行一个整数，表示由 m 个字母组成的 QQ 语言文章中，重要度最高的文章的重要度。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL m;</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">26</span>], cnt[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line">LL ans[N][N], w[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!tr[p][u]) tr[p][u] = ++ idx;</span><br><span class="line">p = tr[p][u];</span><br><span class="line">&#125;</span><br><span class="line">cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line"><span class="keyword">if</span> (tr[<span class="number">0</span>][i])</span><br><span class="line">q[ ++ tt] = tr[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ ) &#123;</span><br><span class="line">    <span class="type">int</span> p = tr[t][i];</span><br><span class="line"><span class="keyword">if</span> (!p) tr[t][i] = tr[ne[t]][i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ne[p] = tr[ne[t]][i];</span><br><span class="line"><span class="comment">// 本题需要存一下当前节点是多少模式串的终点</span></span><br><span class="line">cnt[p] += cnt[ne[p]];</span><br><span class="line">q[ ++ tt] = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(LL c[][N], LL a[][N], LL b[][N])</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> LL tmp[N][N];</span><br><span class="line"><span class="built_in">memset</span>(tmp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= idx; j ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= idx; k ++ )</span><br><span class="line">tmp[i][j] = <span class="built_in">max</span>(tmp[i][j], a[i][k] + b[k][j]);</span><br><span class="line"><span class="built_in">memcpy</span>(c, tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="keyword">while</span> (n -- ) &#123;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"><span class="built_in">insert</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>();</span><br><span class="line"><span class="built_in">memset</span>(w, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> w);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j ++ ) &#123;</span><br><span class="line"><span class="type">int</span> k = tr[i][j];</span><br><span class="line">w[i][k] = <span class="built_in">max</span>(w[i][k], (LL)cnt[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= idx; i ++ ) ans[<span class="number">0</span>][i] = -INF;</span><br><span class="line"><span class="keyword">while</span> (m) &#123;</span><br><span class="line"><span class="keyword">if</span> (m &amp; <span class="number">1</span>) <span class="built_in">mul</span>(ans, ans, w);</span><br><span class="line"><span class="built_in">mul</span>(w, w, w);</span><br><span class="line">m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i ++ ) res = <span class="built_in">max</span>(res, ans[<span class="number">0</span>][i]);</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="25-欧拉路径"><a href="#25-欧拉路径" class="headerlink" title="25. 欧拉路径"></a><strong>25.</strong> <strong>欧拉路径</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于无向图：</span><br><span class="line">欧拉路径存在的充分必要条件：度数为奇数的点个数为<span class="number">2</span>个或<span class="number">0</span>个</span><br><span class="line">欧拉回路存在的充分必要条件：度数为奇数的点个数为<span class="number">0</span>个</span><br><span class="line">度数为奇数的点有<span class="number">2</span>个时，起点的度数不能是偶数：</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">城市中有 n 个交叉路口，m 条街道连接在这些交叉路口之间，每条街道的首尾都正好连接着一个交叉路</span><br><span class="line">口。除开街道的首尾端点，街道不会在其他位置与其他街道相交。每个交叉路口都至少连接着一条街道，有的</span><br><span class="line">交叉路口可能只连接着一条或两条街道。</span><br><span class="line">小明希望设计一个方案，从编号为 <span class="number">1</span> 的交叉路口出发，每次必须沿街道去往街道另一端的路口，再从新</span><br><span class="line">的路口出发去往下一个路口，直到所有的街道都经过了正好一次。</span><br><span class="line">输入格式</span><br><span class="line">输入的第一行包含两个整数 n,m，表示交叉路口的数量和街道的数量，交叉路口从 <span class="number">1</span> 到 n 标号。</span><br><span class="line">接下来 m 行，每行两个整数 a,<span class="built_in">b</span>(a≠b)，表示和标号为 a 的交叉路口和标号为 b 的交叉路口之间有</span><br><span class="line">一条街道，街道是双向的，小明可以从任意一端走向另一端。两个路口之间最多有一条街道。</span><br><span class="line">输出格式</span><br><span class="line">如果小明可以经过每条街道正好一次，则输出一行包含 m+<span class="number">1</span> 个整数 p1,p2,p3,…,pm+<span class="number">1</span>，表示小明经</span><br><span class="line">过的路口的顺序，相邻两个整数之间用一个空格分隔。如果有多种方案满足条件，则输出字典序最小的一种方</span><br><span class="line">案，即首先保证 p1 最小，p1 最小的前提下再保证 p2 最小，依此类推。如果不存在方案使得小明经过每条</span><br><span class="line">街道正好一次，则输出一个整数 −<span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> ans[M], top;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录一种走法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (g[u].<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="type">int</span> t = *g[u].<span class="built_in">begin</span>();</span><br><span class="line">g[u].<span class="built_in">erase</span>(t), g[t].<span class="built_in">erase</span>(u);</span><br><span class="line"><span class="built_in">dfs</span>(t);</span><br><span class="line">&#125;</span><br><span class="line">ans[ ++ top] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">g[a].<span class="built_in">insert</span>(b), g[b].<span class="built_in">insert</span>(a);</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(i) != <span class="built_in">find</span>(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (g[i].<span class="built_in">size</span>() % <span class="number">2</span>) s ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存在欧拉路径 则 奇顶点个数为 0 或 2 且 如果为2，则起点度数为奇数</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span> &amp;&amp; s != <span class="number">2</span> || s == <span class="number">2</span> &amp;&amp; g[<span class="number">1</span>].<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = top; i; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-AC自动机"><a href="#26-AC自动机" class="headerlink" title="26. AC自动机"></a><strong>26. AC自动机</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">给定 n 个模式串 s_i 和一个文本串 t，求有多少个不同的模式串在文本串里出现过。</span><br><span class="line">两个模式串不同当且仅当他们编号不同。</span><br><span class="line">输入格式</span><br><span class="line">第一行是一个整数，表示模式串的个数 n。</span><br><span class="line">第 <span class="number">2</span> 到第 (n + <span class="number">1</span>) 行，每行一个字符串，第 (i + <span class="number">1</span>) 行的字符串表示编号为 i 的模式串 s_i</span><br><span class="line">最后一行是一个字符串，表示文本串 t。</span><br><span class="line">输出格式</span><br><span class="line">输出一行一个整数表示答案。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span><span class="comment">//字典树</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="type">int</span> fail;<span class="comment">//失配指针</span></span><br><span class="line"><span class="type">int</span> son[<span class="number">26</span>];<span class="comment">//子节点的位置</span></span><br><span class="line"><span class="type">int</span> end;<span class="comment">//标记有几个单词以这个节点结尾</span></span><br><span class="line">&#125;AC[<span class="number">1000010</span>];<span class="comment">//Trie树</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//Trie的指针</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Build</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;<span class="comment">//字典树的当前指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)<span class="comment">//构造Trie树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(AC[now].son[s[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)<span class="comment">//Trie树没有这个子节点</span></span><br><span class="line">AC[now].son[s[i]-<span class="string">&#x27;a&#x27;</span>]= ++cnt;<span class="comment">//构造出来</span></span><br><span class="line">now = AC[now].son[s[i]-<span class="string">&#x27;a&#x27;</span>];<span class="comment">//向下构造</span></span><br><span class="line">&#125;</span><br><span class="line">AC[now].end += <span class="number">1</span>;<span class="comment">//标记单词结尾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_fail</span><span class="params">()</span><span class="comment">//构造fail指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;<span class="comment">//队列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;<span class="comment">//第二层的fail指针提前处理一下</span></span><br><span class="line"><span class="keyword">if</span>(AC[<span class="number">0</span>].son[i] != <span class="number">0</span>) &#123;</span><br><span class="line">AC[AC[<span class="number">0</span>].son[i]].fail = <span class="number">0</span>;<span class="comment">//指向根节点</span></span><br><span class="line">Q.<span class="built_in">push</span>(AC[<span class="number">0</span>].son[i]);<span class="comment">//压入队列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()) &#123;<span class="comment">//BFS求fail指针</span></span><br><span class="line"><span class="type">int</span> u = Q.<span class="built_in">front</span>();</span><br><span class="line">Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>; ++i) &#123;<span class="comment">//枚举所有子节点(仅有小写字母 26个)</span></span><br><span class="line"><span class="keyword">if</span>(AC[u].son[i] != <span class="number">0</span>) &#123; <span class="comment">//存在这个子节点</span></span><br><span class="line">AC[AC[u].son[i]].fail=AC[AC[u].fail].son[i];</span><br><span class="line"><span class="comment">//子节点的fail指针指向当前节点的</span></span><br><span class="line"><span class="comment">//fail指针所指向的节点的相同子节点</span></span><br><span class="line">Q.<span class="built_in">push</span>(AC[u].son[i]);<span class="comment">//压入队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> AC[u].son[i] = AC[AC[u].fail].son[i];</span><br><span class="line"><span class="comment">//当前节点的这个子节点指向当</span></span><br><span class="line"><span class="comment">//前节点fail指针的这个子节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span><span class="comment">//AC自动机匹配</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> l = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; ++i)</span><br><span class="line">&#123;</span><br><span class="line">now = AC[now].son[s[i]-<span class="string">&#x27;a&#x27;</span>];<span class="comment">//向下一层</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t = now; t &amp;&amp; AC[t].end != <span class="number">-1</span>; t = AC[t].fail)<span class="comment">//循环求解</span></span><br><span class="line">&#123;</span><br><span class="line">ans += AC[t].end;</span><br><span class="line">AC[t].end = <span class="number">-1</span>;</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="built_in">Build</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">AC[<span class="number">0</span>].fail=<span class="number">0</span>;<span class="comment">//结束标志</span></span><br><span class="line"><span class="built_in">Get_fail</span>();<span class="comment">//求出失配指针</span></span><br><span class="line">cin &gt;&gt; s;<span class="comment">//文本串</span></span><br><span class="line">cout&lt;&lt; <span class="built_in">query</span>(s) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-区间DP"><a href="#27-区间DP" class="headerlink" title="27. 区间DP"></a><strong>27.</strong> <strong>区间DP</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">题目描述</span><br><span class="line">将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。</span><br><span class="line">规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。</span><br><span class="line">请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算：</span><br><span class="line">选择一种合并石子的方案，使得做 n−<span class="number">1</span> 次合并得分总和最大。</span><br><span class="line">选择一种合并石子的方案，使得做 n−<span class="number">1</span> 次合并得分总和最小。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 n，表示共有 n 堆石子。</span><br><span class="line">第二行包含 n 个整数，分别表示每堆石子的数量。</span><br><span class="line">输出格式</span><br><span class="line">输出共两行：</span><br><span class="line">第一行为合并得分总和最小值，</span><br><span class="line">第二行为合并得分总和最大值。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">410</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N], g[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) a[i] = a[i - n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line"><span class="type">int</span> l = i, r = i + len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">f[l][r] = g[l][r] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt; r; k ++) &#123;</span><br><span class="line">f[l][r] = <span class="built_in">min</span>(f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>], f[l]</span><br><span class="line">[r]);</span><br><span class="line">g[l][r] = <span class="built_in">max</span>(g[l][k] + g[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>], g[l]</span><br><span class="line">[r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mi = <span class="number">0x3f3f3f3f</span>, ma = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++) &#123;</span><br><span class="line">mi = <span class="built_in">min</span>(f[l][l + n - <span class="number">1</span>], mi);</span><br><span class="line">ma = <span class="built_in">max</span>(g[l][l + n - <span class="number">1</span>], ma);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mi &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ma &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-树型DP"><a href="#28-树型DP" class="headerlink" title="28.树型DP"></a><strong>28.树型DP</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">有一座城市，城市中有 N 个公交站，公交站之间通过 N−<span class="number">1</span> 条道路连接，每条道路有相应的长度。</span><br><span class="line">保证所有公交站两两之间能够通过一唯一的通路互相达到。两个公交站之间路径长度定义为两个公交站之间路</span><br><span class="line">径上所有边的边权和。</span><br><span class="line">现在要对城市进行规划，将其中 M 个公交站定为“重要的”。</span><br><span class="line">现在想从中选出 K 个节点，使得这 K 个公交站两两之间路径长度总和最小。输出路径长度总和即可（节点编</span><br><span class="line">号从 <span class="number">1</span> 开始）。</span><br><span class="line">输入格式</span><br><span class="line">第 <span class="number">1</span> 行包含三个正整数 N，M 和 K 分别表示树的节点数，重要的节点数，需要选出的节点数。</span><br><span class="line">第 <span class="number">2</span> 行包含 M 个正整数，表示 M 个重要的节点的节点编号。</span><br><span class="line">接下来 N–<span class="number">1</span> 行，每行包含三个正整数 a，b，c，表示编号为 a 的节点与编号为 b 的节点之间有一条</span><br><span class="line">权值为 c 的无向边。</span><br><span class="line">每行中相邻两个数之间用一个空格分隔。</span><br><span class="line">输出格式</span><br><span class="line">输出只有一行，包含一个整数表示路径长度总和的最小值。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n, m, K;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="comment">// f[i][j] 表示以 i 为 根的树中选 j 个点, 该子树所有边对答案的贡献值</span></span><br><span class="line">LL f[N][<span class="number">110</span>];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="comment">// 记录子树大小</span></span><br><span class="line"><span class="type">int</span> sz[N];</span><br><span class="line">LL ans = <span class="number">1e18</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (st[u]) f[u][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">sz[u] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 分组背包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) <span class="comment">// 枚举物品组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="comment">// 父节点不搜</span></span><br><span class="line"><span class="keyword">if</span> (ver == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(ver, u);</span><br><span class="line">sz[u] += sz[ver];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">min</span>(sz[u], K); j &gt;= <span class="number">0</span>; j -- ) <span class="comment">// 枚举体积</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="built_in">min</span>(j, sz[ver]); k ++ ) <span class="comment">// 枚举决策</span></span><br><span class="line">f[u][j] = <span class="built_in">min</span>(f[u][j], f[u][j - k] + f[ver][k] + (LL)w[i] * k *</span><br><span class="line">(K - k));</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">min</span>(ans, f[u][K]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;K);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">st[x] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="comment">// 第二个参数记录父节点, 无向图避免往回搜</span></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          Donate
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://nagoriyuki0408.github.io/2024/08/10/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A8%A1%E6%9D%BF/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2024/08/10/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            算法：字符串
          
        </div>
      </a>
    
    
      <a href="/2024/08/08/Gal-%E7%A5%9E%E5%92%92%E7%A5%9E%E5%A8%81%E7%A5%9E%E4%B9%90/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Gal:神咒神威神乐</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.staticfile.org/valine/1.4.16/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    appid: "NE1hi2bwLBi5TmvHcJqkvMj4-MdYXbMMI",
    appkey: "tlaS1mHTwUo374IsMy8CwE2j",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "给我的文章加点评论吧~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
   
  
    
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2025
        <i class="ri-heart-fill heart_icon"></i> SHIOKOU
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="柳瀬しおこうの夢"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://x.com/tsumugi0408">推特</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://bangumi.tv/">番组</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>帮我买张OST吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->
 
    
        <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.15.1/katex.min.css">
        <script src="https://cdn.staticfile.org/KaTeX/0.15.1/katex.min.js"></script>
        <script src="https://cdn.staticfile.org/KaTeX/0.15.1/contrib/auto-render.min.js"></script>
        
            <script src="https://cdn.staticfile.org/KaTeX/0.15.1/contrib/copy-tex.min.js"></script>
            <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.15.1/contrib/copy-tex.min.css">
        
    
 
<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=28699497&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    
<script>
  const password = "22360408";
  const lock_password = window.sessionStorage.getItem("lock_password");
  console.log(password, lock_password);
  if (lock_password !== password) {
    Swal.fire({
      title: "Please enter password",
      input: "text",
      inputAttributes: {
        autocapitalize: "off",
      },
      showCancelButton: false,
      showLoaderOnConfirm: true,
      allowOutsideClick: false,
      confirmButtonText: "Ok",
    }).then((result) => {
      console.log(result);
      if (result.isConfirmed) {
        console.log(password);
        if (result.value === password) {
          window.sessionStorage.setItem("lock_password", result.value);
        } else {
          Swal.fire({
            icon: "error",
            title: "Incorrect password, please try again",
            confirmButtonText: "Ok",
            allowOutsideClick: false,
          }).then(() => {
            window.location.reload();
          });
        }
      }
    });
  }
</script>


  </div>
</body>

</html>