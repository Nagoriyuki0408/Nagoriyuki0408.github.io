<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> SHIOKOU</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://live.bilibili.com/25622556?live_from=82002&amp;spm_id_from=333.1007.top_right_bar_window_dynamic.content.click"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover2.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">SHIOKOU</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['空想の毒が自我を飲み込む', '私はここにいる', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-数组,指针与字符串"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/05/29/%E6%95%B0%E7%BB%84,%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"
    >数组</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/05/29/%E6%95%B0%E7%BB%84,%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-date">
  <time datetime="2024-05-29T05:01:45.000Z" itemprop="datePublished">2024-05-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="数组的定义与使用"><a href="#数组的定义与使用" class="headerlink" title="数组的定义与使用"></a>数组的定义与使用</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型说明符 数组名[常量表达式][常量表达式]</span><br></pre></td></tr></table></figure>

<p>数组名的构成方法一般与变量名相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.例如：int a[10];</span><br><span class="line">表示a为整型数组，有10个元素：a[0]……a[9]</span><br><span class="line">2.例如：int a[5][3];</span><br><span class="line">表示a为整型二维数组，其中第一维有5个下标（0~4），第二维有三个下标（0~2），数组的元素个数为15，可以用于存放5行3列的整型数据表格。</span><br></pre></td></tr></table></figure>

<h3 id="数组元素的使用"><a href="#数组元素的使用" class="headerlink" title="数组元素的使用"></a>数组元素的使用</h3><blockquote>
<p>数组必须先定义，后使用</p>
<p>可以逐个引用数组元素</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[0]=a[5]+a[7]-a[2*3];</span><br><span class="line">b[1][2]=a[2][3]/2;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a[10],b[10];</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=i*2-1;</span><br><span class="line">b[10-i-1]=a[i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;a[&quot;&lt;&lt;i&lt;&lt;&quot;]=&quot;&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">cout&lt;&lt;&quot;b[&quot;&lt;&lt;i&lt;&lt;&quot;]=&quot;&lt;&lt;b[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-数据的共享和保护"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/05/29/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E4%BF%9D%E6%8A%A4/"
    >（5）数据的共享和保护</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/05/29/%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E4%BF%9D%E6%8A%A4/" class="article-date">
  <time datetime="2024-05-29T01:06:14.000Z" itemprop="datePublished">2024-05-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="标识符的作用域和可见性"><a href="#标识符的作用域和可见性" class="headerlink" title="标识符的作用域和可见性"></a>标识符的作用域和可见性</h2><h3 id="函数原型作用域"><a href="#函数原型作用域" class="headerlink" title="函数原型作用域"></a>函数原型作用域</h3><p>函数原型中的参数</p>
<p>其作用域始于“(”,终于”)”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double area(double radius);</span><br><span class="line">//radius的作用域仅在此处，不能用于程序正文其他地方</span><br></pre></td></tr></table></figure>

<h3 id="局部作用域（块作用域）"><a href="#局部作用域（块作用域）" class="headerlink" title="局部作用域（块作用域）"></a>局部作用域（块作用域）</h3><ul>
<li>函数的形参，在块中声明的标识符</li>
<li>作用域自声明处起，限于块中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void fun(int a)</span><br><span class="line">&#123;int b=a;</span><br><span class="line">cin&gt;&gt;b;</span><br><span class="line">if(b&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">int c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h3><ul>
<li>类的对象具有类作用域</li>
</ul>
<p>其范围包括类体和成员函数体。</p>
<ul>
<li>在类作用域以外访问类的成员：<ol>
<li>静态成员：通过类名，或者该类的对象名，对象引用访问。</li>
<li>非静态成员：通过类名，或者该类的对象名，对象引用，对象指针访问。</li>
</ol>
</li>
</ul>
<h3 id="文件作用域"><a href="#文件作用域" class="headerlink" title="文件作用域"></a>文件作用域</h3><ul>
<li>不在前述各个作用域中出现的声明，就具有文件作用域。</li>
<li>其作用域开始于声明点，结束于文件尾。</li>
</ul>
<blockquote>
<p>可见性：</p>
<ul>
<li>可见性是从对标识符的引用的角度来谈的概念</li>
<li>可见性表示从内层作用域向外层作用域“看”时能看见声明。</li>
<li>如果标识在某处可见，就可以在该处引用此标识符。</li>
<li>如果某个标识符在外层中声明，且在内层中没有同一个标识符的声明，则该标识符在内层可见。</li>
<li>对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层的标识符在内层不可见。</li>
</ul>
</blockquote>
<h3 id="命名空间作用域"><a href="#命名空间作用域" class="headerlink" title="命名空间作用域"></a>命名空间作用域</h3><blockquote>
<p>可见性：</p>
<ul>
<li>可见性是从对标识符的引用的角度来谈的概念</li>
<li>可见性表示从内层作用域向外层作用域“看”时能看见声明。</li>
<li>如果标识在某处可见，就可以在该处引用此标识符。</li>
<li>如果某个标识符在外层中声明，且在内层中没有同一个标识符的声明，则该标识符在内层可见。</li>
<li>对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层的标识符在内层不可见。</li>
</ul>
</blockquote>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int i;//全局变量，文件作用域</span><br><span class="line">int main()</span><br><span class="line">i=5;//为全局变量赋值</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">i=7;</span><br><span class="line">cout&lt;&lt;&quot;i=&quot;&lt;&lt;i&lt;&lt;endl;//输出7，内层会屏蔽外层作用变量</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;i=&quot;&lt;&lt;i&lt;&lt;endl;//输出5</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的生存期"><a href="#对象的生存期" class="headerlink" title="对象的生存期"></a>对象的生存期</h2><h3 id="静态生存区"><a href="#静态生存区" class="headerlink" title="静态生存区"></a>静态生存区</h3><ul>
<li>这种生存期与程序的运行期相同。</li>
<li>在文件作用域中声明的对象具有这种生存期。</li>
<li>在函数内部声明静态生存期对象，要冠以关键字static。</li>
</ul>
<h3 id="非静态生存区"><a href="#非静态生存区" class="headerlink" title="非静态生存区"></a>非静态生存区</h3><ul>
<li>开始于程序执行到声明点时，结束于该标识符的作用域结束处。</li>
<li>块作用域中声明的，没有用static修饰的对象，是动态生存区的对象（习惯称我为局部生存期对象）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std</span><br><span class="line">int i=1;//i为全局变量</span><br><span class="line">void other()</span><br><span class="line">&#123;</span><br><span class="line">static int a=2;</span><br><span class="line">static int b;</span><br><span class="line">//a，b为静态局部变量，具有全局寿命，局部可见。</span><br><span class="line">//只第一次进入函数时被初始化。</span><br><span class="line">int c=10;</span><br><span class="line">//c为局部变量，具有动态生存期</span><br><span class="line">//每次进入函数时都被初始化</span><br><span class="line">a+=2;i+=32;c+=5;</span><br><span class="line">cout&lt;&lt;&quot;--OTHER--\n&quot;;</span><br><span class="line">cout&lt;&lt;&quot;i:&quot;&lt;&lt;i&lt;&lt;&quot;a:&quot;&lt;&lt;a&lt;&lt;&quot;b:&quot;&lt;&lt;b&lt;&lt;&quot;c:&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">b=a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">static int a;</span><br><span class="line">//a静态局部变量，有全局寿命，局部可见</span><br><span class="line">int b=-10;</span><br><span class="line">int c=0;</span><br><span class="line">//b，c为局部变量，具有动态生存期</span><br><span class="line">cout&lt;&lt;&quot;--MAIN--\n&quot;;</span><br><span class="line">cout&lt;&lt;&quot; i:&quot;&lt;&lt;i&lt;&lt;&quot; a:&quot;&lt;&lt;a&lt;&lt;&quot; b:&quot;&lt;&lt;b&lt;&lt;&quot; c:&quot;&lt;&lt;c;</span><br><span class="line">c+=8;other();</span><br><span class="line">cout&lt;&lt;&quot;--MAIN--\n&quot;;</span><br><span class="line">cout&lt;&lt;&quot; i:&quot;&lt;&lt;i&lt;&lt;&quot; a:&quot;&lt;&lt;a&lt;&lt;&quot; b:&quot;&lt;&lt;b&lt;&lt;&quot; c:&quot;&lt;&lt;c;</span><br><span class="line">i+=10;</span><br><span class="line">other();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">运行结果</span><br><span class="line">--MAIN--</span><br><span class="line">i:1 a:0 b:-10 c:0</span><br><span class="line">--OTHER--</span><br><span class="line">i:33 a:4 b:0 c:15</span><br><span class="line">--MAIN--</span><br><span class="line">i:33 a:0 b:-10 c:8</span><br><span class="line">--OTHER--</span><br><span class="line">i:75 a:6 b:4 c:15</span><br></pre></td></tr></table></figure>

<h2 id="类的静态数据成员"><a href="#类的静态数据成员" class="headerlink" title="类的静态数据成员"></a>类的静态数据成员</h2><ul>
<li>用关键词static声明</li>
<li>为该类所有对象共享，静态数据成员具有静态生存期。</li>
<li>必须在类外定义和初始化，用（::）来指明所属的类。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point//Point类定义</span><br><span class="line">&#123;</span><br><span class="line">private://私有数据成员</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">static int count;//静态数据成员的定义和初始化，使用类名限定</span><br><span class="line">public://外部接口</span><br><span class="line">Point(int x=0,int y=0):x(x),y(y)//构造函数</span><br><span class="line">&#123;</span><br><span class="line">count++;//在构造函数中对count叠加，所有对象共同维护一个count</span><br><span class="line">&#125;</span><br><span class="line">int getX()&#123;return x&#125;;</span><br><span class="line">int getY()&#123;return y&#125;;</span><br><span class="line">Point (Point &amp;p)//拷贝构造函数</span><br><span class="line">&#123;</span><br><span class="line">x=p.x;</span><br><span class="line">y=p.y;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">~Point()&#123;count--;&#125;</span><br><span class="line">void showCount()//输出静态数据成员</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Object count&quot;&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Point::count=0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Point a(4,5);</span><br><span class="line">cout&lt;&lt;&quot;Point A:&quot;&lt;&lt;a.getX()&lt;&lt;&quot;,&quot;&lt;&lt;a.getY();</span><br><span class="line">a.showCount();</span><br><span class="line">Point b(a);</span><br><span class="line">cout&lt;&lt;&quot;Point B:&quot;&lt;&lt;b.getX()&lt;&lt;&quot;,&quot;&lt;&lt;b.getY();</span><br><span class="line">b.showCount();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态函数成员"><a href="#静态函数成员" class="headerlink" title="静态函数成员"></a>静态函数成员</h2><p>静态函数处理静态数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point//Point类定义</span><br><span class="line">&#123;</span><br><span class="line">private://私有数据成员</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">static int count;//静态数据成员的定义和初始化，使用类名限定</span><br><span class="line">public://外部接口</span><br><span class="line">Point(int x=0,int y=0):x(x),y(y)//构造函数</span><br><span class="line">&#123;</span><br><span class="line">count++;//在构造函数中对count叠加，所有对象共同维护一个count</span><br><span class="line">&#125;</span><br><span class="line">int getX()&#123;return x&#125;;</span><br><span class="line">int getY()&#123;return y&#125;;</span><br><span class="line">Point (Point &amp;p)//拷贝构造函数</span><br><span class="line">&#123;</span><br><span class="line">x=p.x;</span><br><span class="line">y=p.y;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">~Point()&#123;count--;&#125;</span><br><span class="line">static void showCount()//输出静态数据成员</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Object count&quot;&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Point::count=0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Point::showCount();//输出对象个数</span><br><span class="line">Point a(4,5);//声明对象a，其构造函数使count+1</span><br><span class="line">cout&lt;&lt;&quot;Point A:&quot;&lt;&lt;a.getX()&lt;&lt;&quot;,&quot;&lt;&lt;a.getY();</span><br><span class="line">Point::showCount();</span><br><span class="line">Point b(a);//声明对象b，其复制函数使count+1</span><br><span class="line">cout&lt;&lt;&quot;Point B:&quot;&lt;&lt;b.getX()&lt;&lt;&quot;,&quot;&lt;&lt;b.getY();</span><br><span class="line">Point::showCount();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的友元"><a href="#类的友元" class="headerlink" title="类的友元"></a>类的友元</h2><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><ul>
<li>友元时c++提供的一种破坏数据封装和数据隐藏的机制。</li>
<li>提供将一个模板声明为另一个模板的友元，一个模板能够引用到另一个模板中本是被隐藏的信息。</li>
<li>可以声明友元函数和友元类</li>
<li>为了确保数据的完整性，及数据封装于隐藏的原则，建议慎重使用友元。</li>
</ul>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><ul>
<li>友元函数是在类声明中由关键字friend修饰的说明的非成员函数，在它的函数体中能够通过对象名访问private和protected成员。</li>
<li>作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择</li>
<li>访问对象中的成员必须通过对象名。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Point(int x,int y):x(x),y(y)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">Point(Point&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">x=p.x;</span><br><span class="line">y=p.y;</span><br><span class="line">&#125;</span><br><span class="line">int getX()&#123;return x;&#125;</span><br><span class="line">int getY()&#123;return y;&#125;</span><br><span class="line">friend float dist(Point &amp;a,Point &amp;b);</span><br><span class="line">static int showCOUNT()&#123;return count;&#125;</span><br><span class="line">private:</span><br><span class="line">int x,y;</span><br><span class="line">static int count;</span><br><span class="line">&#125;;</span><br><span class="line">float dist(Point&amp; a,Point&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">double x=a.x-b.x;</span><br><span class="line">double y=a.y-b.y;</span><br><span class="line">//有修改原本数据的隐患</span><br><span class="line">//避免每次用对象的x，y都要调用一次函数</span><br><span class="line">return </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><ul>
<li><p>若一个类为另一个类的友元，则此类的所有成员，都能访问对方类的私有成员。</p>
</li>
<li><p>声明语法：将友元类名放在另一个类中使用friend修饰说明。</p>
</li>
<li><p>友元关系是单向的，数据成员的开放也就是单向的。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">friend class B;</span><br><span class="line">public:</span><br><span class="line">void display()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int x;</span><br><span class="line">&#125;;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void set(int i);</span><br><span class="line">void display();</span><br><span class="line">private:</span><br><span class="line">A a;</span><br><span class="line">&#125;</span><br><span class="line">void B::set(int i)</span><br><span class="line">&#123;</span><br><span class="line">a.x=i;</span><br><span class="line">&#125;</span><br><span class="line">void B::display()</span><br><span class="line">&#123;</span><br><span class="line">a.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享数据的保护"><a href="#共享数据的保护" class="headerlink" title="共享数据的保护"></a>共享数据的保护</h2><h3 id="常类型"><a href="#常类型" class="headerlink" title="常类型"></a>常类型</h3><h4 id="常对象：必须进行初始化，不能被更新。const-类名-对象名；"><a href="#常对象：必须进行初始化，不能被更新。const-类名-对象名；" class="headerlink" title="常对象：必须进行初始化，不能被更新。const 类名 对象名；"></a>常对象：必须进行初始化，不能被更新。const 类名 对象名；</h4><ul>
<li>用const修饰的对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">A(int i,int j):x(i),y(j)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">A const a(3,4);//a是常对象，不能被更新</span><br></pre></td></tr></table></figure>



<h4 id="常成员：用const进行修饰的类成员：常数据成员和常函数成员。"><a href="#常成员：用const进行修饰的类成员：常数据成员和常函数成员。" class="headerlink" title="常成员：用const进行修饰的类成员：常数据成员和常函数成员。"></a>常成员：用const进行修饰的类成员：常数据成员和常函数成员。</h4><ul>
<li>常成员函数</li>
<li>使用const关键字说明的函数</li>
<li>常成员函数不更新对象的数据成员</li>
<li>常成员函数说明格式：</li>
</ul>
<blockquote>
<p>类型说明符 函数名（参数表) const；这里，const是函数类型的一个组成部分，因此在实现部分也要带const关键字。</p>
</blockquote>
<ul>
<li>const关键字可以被用于参与对重载函数的区分</li>
<li>通过常对象只能调用它的常成员函数</li>
<li>常数据成员：使用const说明的数据成员</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class R</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">R(int r1,int r2):r1(r1),r2(r2)&#123;&#125;</span><br><span class="line">void print();</span><br><span class="line">void print() const;</span><br><span class="line">private:</span><br><span class="line">int r1,r2;</span><br><span class="line">&#125;;</span><br><span class="line">void R::print()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;r1&lt;&lt;&quot;:&quot;&lt;&lt;r2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void R::print()const</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;r1&lt;&lt;&quot;:&quot;&lt;&lt;r2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">R a(5,4);</span><br><span class="line">a.print();</span><br><span class="line">const R b(20,53);</span><br><span class="line">b.print();//调用void print const()</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">A(int i):</span><br><span class="line">void print();</span><br><span class="line">private:</span><br><span class="line">const int a;</span><br><span class="line">static const int b;//静态常数据对象</span><br><span class="line">&#125;;</span><br><span class="line">const int A::b=10;</span><br><span class="line">A::A(int i):a(i)&#123;&#125;</span><br><span class="line">void A::print()&#123;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;&quot;:&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A a1(100),a2(0);</span><br><span class="line">a1.print();</span><br><span class="line">a2.print();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="常引用：被引用的对象不能被更新。const-类型说明符号-引用名"><a href="#常引用：被引用的对象不能被更新。const-类型说明符号-引用名" class="headerlink" title="常引用：被引用的对象不能被更新。const 类型说明符号 &amp;引用名"></a>常引用：被引用的对象不能被更新。const 类型说明符号 &amp;引用名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Point(int x=0,int y=0):x(x),y(y)&#123;&#125;</span><br><span class="line">int getX()&#123;return x;&#125;</span><br><span class="line">int getY()&#123;return y;&#125;</span><br><span class="line">friend float dist(const Point &amp;p1,const Point &amp;p2);</span><br><span class="line">private x,y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在友元函数中用常引用做参数，既能获得较高的执行效率，又能保证实参的安全性。</p>
</blockquote>
<h4 id="常数组：数组元素不能被更新。类型说明符-const-数组名-大小"><a href="#常数组：数组元素不能被更新。类型说明符-const-数组名-大小" class="headerlink" title="常数组：数组元素不能被更新。类型说明符 const 数组名[大小]"></a>常数组：数组元素不能被更新。类型说明符 const 数组名[大小]</h4><h4 id="常指针：指向常量的指针。"><a href="#常指针：指向常量的指针。" class="headerlink" title="常指针：指向常量的指针。"></a>常指针：指向常量的指针。</h4><h2 id="多文件结构"><a href="#多文件结构" class="headerlink" title="多文件结构"></a>多文件结构</h2><h3 id="C-的一般组织结构"><a href="#C-的一般组织结构" class="headerlink" title="C++的一般组织结构"></a>C++的一般组织结构</h3><h4 id="一个工程可以分为多个源文件，例如："><a href="#一个工程可以分为多个源文件，例如：" class="headerlink" title="一个工程可以分为多个源文件，例如："></a>一个工程可以分为多个源文件，例如：</h4><ul>
<li>类声明文件（.h文件）</li>
<li>类实现文件（.cpp文件）</li>
<li>类的使用文件（main()所在的.cpp文件)</li>
</ul>
<h4 id="利用多个工程来组合各个文件"><a href="#利用多个工程来组合各个文件" class="headerlink" title="利用多个工程来组合各个文件"></a>利用多个工程来组合各个文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//文件1，类的定义，Point.h</span><br><span class="line">class Point//Point类定义</span><br><span class="line">&#123;</span><br><span class="line">private://私有数据成员</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">static int count;//静态数据成员的定义和初始化，使用类名限定</span><br><span class="line">public://外部接口</span><br><span class="line">Point(int x=0,int y=0):x(x),y(y)//构造函数</span><br><span class="line">&#123;</span><br><span class="line">count++;//在构造函数中对count叠加，所有对象共同维护一个count</span><br><span class="line">&#125;</span><br><span class="line">int getX()&#123;return x&#125;;</span><br><span class="line">int getY()&#123;return y&#125;;</span><br><span class="line">Point (Point &amp;p)//拷贝构造函数</span><br><span class="line">&#123;</span><br><span class="line">x=p.x;</span><br><span class="line">y=p.y;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">~Point()&#123;count--;&#125;</span><br><span class="line">static void showCount()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//文件2，point.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&quot;Point.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int Point::count=0;</span><br><span class="line">Point::Point(const Point &amp;p):x(p.x),y(p.y)</span><br><span class="line">&#123;count++;&#125;</span><br><span class="line">void Point::showCount()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Object count=&quot;&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">//文件3，主函数 5_10.cpp</span><br><span class="line">#include&quot;Point.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Point(4,5);</span><br><span class="line">cout&lt;&lt;&quot;Point A&quot;&lt;&lt;a.getX()&lt;&lt;&quot;,&quot;&lt;&lt;a.getY();</span><br><span class="line">Point::showCount();</span><br><span class="line">Point b(a);</span><br><span class="line">cout&lt;&lt;&quot;Point B:&quot;&lt;&lt;b.getX()&lt;&lt;&quot;,&quot;&lt;&lt;b.getY();</span><br><span class="line">Point::showCount();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h3><ul>
<li>除了在定义它的源文件中可以使用外，还能被其他文件使用。</li>
<li>文件作用域中定义的变量，默认情况下都是外部变量。</li>
<li>在其他文件中如果需要使用的化，需要用extern关键字声明。</li>
<li>在所有类的之外声明的函数（也就是非成员函数），都具有文件作用域的。</li>
<li>这样的函数都可以在不同的编译单元中被调用</li>
<li>只要在调用之前进行，引用性声明（即声明函数原型）即可。</li>
</ul>
<blockquote>
<p>将变量和函数限制在编译单元内</p>
<ul>
<li>将匿名命名空间中定义的变量和函数，都不会暴露给其他的编译单元</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace</span><br><span class="line">&#123;</span><br><span class="line">//匿名的命名空间</span><br><span class="line">int n;</span><br><span class="line">void f()</span><br><span class="line">&#123;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标准c-库"><a href="#标准c-库" class="headerlink" title="标准c++库"></a>标准c++库</h2><blockquote>
<p>标准c++类库是一个及其灵活且可拓展的可重用软件模块的集合。</p>
</blockquote>
<h3 id="输入-输出类"><a href="#输入-输出类" class="headerlink" title="输入&#x2F;输出类"></a>输入&#x2F;输出类</h3><h3 id="容器类和抽象数据类型"><a href="#容器类和抽象数据类型" class="headerlink" title="容器类和抽象数据类型"></a>容器类和抽象数据类型</h3><h3 id="存储管理类"><a href="#存储管理类" class="headerlink" title="存储管理类"></a>存储管理类</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h3 id="运行环境支持"><a href="#运行环境支持" class="headerlink" title="运行环境支持"></a>运行环境支持</h3><h2 id="编译预处理"><a href="#编译预处理" class="headerlink" title="编译预处理"></a>编译预处理</h2><h3 id="include包含指令"><a href="#include包含指令" class="headerlink" title="#include包含指令"></a>#include包含指令</h3><ul>
<li>将一个源文件嵌入到当前源文件中该点处。<ol>
<li>#include&lt;文件名&gt;：按标准模式搜索，文件位于c++系统目录的include子目录下</li>
<li>#include“文件名”：首先在当前目录中搜索，若没有，在按标准方式搜索。</li>
</ol>
</li>
</ul>
<h3 id="define-宏定义指令"><a href="#define-宏定义指令" class="headerlink" title="#define 宏定义指令"></a>#define 宏定义指令</h3><ul>
<li>定义符号常量，很多情况已经被const定义语句取代。</li>
<li>定义带参数宏，已经被内联函数取代。</li>
</ul>
<h3 id="undif"><a href="#undif" class="headerlink" title="#undif"></a>#undif</h3><ul>
<li>删除由#define定义的宏，使之不再起作用</li>
</ul>
<h3 id="条件编译指令——-if和-endif"><a href="#条件编译指令——-if和-endif" class="headerlink" title="条件编译指令——#if和#endif"></a>条件编译指令——#if和#endif</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if 常量表达式</span><br><span class="line">//当“常量表达式”非零时编译</span><br><span class="line">程序正文</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="条件编译指令——-else"><a href="#条件编译指令——-else" class="headerlink" title="条件编译指令——#else"></a>条件编译指令——#else</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if 常量表达式</span><br><span class="line">//当“常量表达式”非零时编译</span><br><span class="line">程序正文1</span><br><span class="line">#else</span><br><span class="line">//当“常量表达式”为零时编译</span><br><span class="line">程序正文2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="条件编译指令——-elif"><a href="#条件编译指令——-elif" class="headerlink" title="条件编译指令——#elif"></a>条件编译指令——#elif</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if 常量表达式1</span><br><span class="line">程序正文1//当“常量表达式1”非零时编译</span><br><span class="line">#elif 常量表达式2</span><br><span class="line">程序正文2//当“常量表达式2”非零时编译</span><br><span class="line">#else</span><br><span class="line">程序正文3//其他情况下编译</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="条件编译指令"><a href="#条件编译指令" class="headerlink" title="条件编译指令"></a>条件编译指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef 标识符</span><br><span class="line">程序段1</span><br><span class="line">#else</span><br><span class="line">程序段2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果“标识符”经#define定义过，且未经undef删除，则编译程序段1；否则编译程序段2.</p>
</blockquote>
<h2 id="第五章小结"><a href="#第五章小结" class="headerlink" title="第五章小结"></a>第五章小结</h2><ul>
<li>对象的生存期，作用域与可见性。</li>
<li>类的静态成员。</li>
<li>数据的共享和保护。</li>
<li>友元</li>
<li>编译预处理指令</li>
<li>多文件结构与工程</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-社会主义发展史问题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/05/27/%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E5%8F%91%E5%B1%95%E5%8F%B2%E9%97%AE%E9%A2%98/"
    >社会主义发展史问题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/05/27/%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E5%8F%91%E5%B1%95%E5%8F%B2%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2024-05-26T17:18:48.000Z" itemprop="datePublished">2024-05-27</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="托马斯-cdot-莫尔的《乌托邦》为什么会是乌托邦？"><a href="#托马斯-cdot-莫尔的《乌托邦》为什么会是乌托邦？" class="headerlink" title="托马斯$\cdot$莫尔的《乌托邦》为什么会是乌托邦？"></a>托马斯$\cdot$莫尔的《乌托邦》为什么会是乌托邦？</h2><p>​	乌托邦，本意是“没有的地方”或者“好地方“。<strong>延伸拓展为还有理想，不可能完成的好事情</strong>，其中文翻译可以理解为”物“是没有，”托“是寄托，”邦“是国家，”乌托邦“三个字合起来的意思即是”空想的国家“。</p>
<p>​	《乌托邦》一书是<strong>欧洲第一本空想社会主义</strong>著作，它第一次完整地描述了空想社会主义的图景。在社会主义思想史上，首次批判了<strong>资本原始积累的罪恶</strong>，提出了<strong>以组织生产，普遍劳动为基础的公有制和平等的原则</strong>，奠定了空想社会主义的根基，为以后<strong>社会主义的发展</strong>提供了可贵的<strong>思想资料</strong>。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B9%AF%E7%91%AA%E6%96%AF%C2%B7%E6%91%A9%E7%88%BE">摩尔</a>的《乌托邦》一书与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9F%8F%E6%8B%89%E5%9B%BE">柏拉图</a>的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%90%86%E6%83%B3%E5%9B%BD">理想国</a>有很大联系[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E4%B9%8C%E6%89%98%E9%82%A6#cite_note-2">2]</a>。这是一个理想、完美的共和国（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E7%A4%BE%E4%BC%9A%E5%B9%B3%E7%AD%89%E4%B8%BB%E4%B9%89%E8%80%85&action=edit&redlink=1">社会平等主义者</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%92%8C%E5%B9%B3%E4%B8%BB%E4%B9%89%E8%80%85">和平主义者</a>的观点），虽然他的子民们也要为此而工作而奋斗。但是社会上的一切丑恶现象，如贫穷、歧视、不公和苦难，都远离这个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%96%E5%A4%96%E6%A1%83%E6%BA%90">世外桃源</a>。这里只有几条<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B3%95%E5%BE%8B">法律</a>规定，没有<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%8B%E5%B8%88">律师</a>。并且没有<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%9F%8E%E6%B0%91&action=edit&redlink=1">城民</a>愿意发动<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%88%98%E4%BA%89">战争</a>。但是他们从周边的好战国家雇来雇<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%82%AD%E5%85%B5">佣兵</a>（他们让这些雇佣兵面对威胁，是因为他们希望所有好战的人都在战争中灭亡，最终只留下爱好和平的人）。这样的社会也以包容的心态迎接各种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AE%97%E6%95%99">宗教</a>流派。一些<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%BB%E8%80%85">读者</a>认为摩尔想以此来作为国家建设的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%93%9D%E6%9C%AC&action=edit&redlink=1">蓝本</a>，而其他一些人认为摩尔其实没有这样的打算。一些人立场坚定地认为，摩尔的《乌托邦》的作用其实是用一个理想的社会来讽刺摩尔身处时代的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%8B%B1%E6%A0%BC%E5%85%B0%E7%A4%BE%E4%BC%9A&action=edit&redlink=1">英格兰社会</a>。这种看法也顺理成章的解释了这本书和这个国家名字的意义。乌托邦在希腊语中的读音在“没有的地方”和“好地方”间含糊不清：乌托邦是由音节ou-（意为“不”）和topos（意为“地方”）而组成的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%8D%E5%90%88%E8%AF%8D">复合词</a>，但是他又与由同音前缀eu-（意为“好”）组成的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E8%AF%8D%E5%90%8C%E9%9F%B3&action=edit&redlink=1">词同音</a>。这样其实也是在暗示：“没有地方”是真正“完美的地方”。</p>
<p>乌托邦概念的另一个版本来自于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%8A%B9%E5%B8%8C%E8%BF%88%E7%BD%97%E6%96%AF">犹希迈罗斯</a>公元前3世纪所著的《<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%9C%A3%E7%A5%9E%E7%9A%84%E5%8E%86%E5%8F%B2&action=edit&redlink=1">圣神的历史</a>》（Sacred History）中记载的Panchaea岛。</p>
</blockquote>
<h2 id="托马斯-cdot-康帕内拉的”教育雨生产劳动相结合“是指”劳动教育“吗？"><a href="#托马斯-cdot-康帕内拉的”教育雨生产劳动相结合“是指”劳动教育“吗？" class="headerlink" title="托马斯$\cdot $康帕内拉的”教育雨生产劳动相结合“是指”劳动教育“吗？"></a>托马斯$\cdot $康帕内拉的”教育雨生产劳动相结合“是指”劳动教育“吗？</h2><p>​	康帕内拉在《太阳城》中首次提出了劳动光荣以及脑力劳动和体力劳动相结合的思想，对脑体对立的思想进行了扬弃。他主张的教育与生产劳动相结合的思想影响深远。教育与生产劳动相结合的实际是劳动教育与生产劳动之间相互影响，相互作用和相互促进的关系。它有很多形式，劳动教育也是它的形式之一。</p>
<blockquote>
<p>康帕内拉虚拟了一名<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%83%AD%E9%82%A3%E4%BA%9A">热那亚</a>的航海家和朝圣招待所管理的对话，描绘了一个不为世人所知、按照根本不同于当时意大利和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E6%AC%A7">西欧</a>各国社会制度的原则建立起来的新型理想社会。太阳城位于赤道的一座小山上，面积和一座城市相仿，这里没有私有财产，没有剥削，人人劳动，生产和消费由被称为“形而上学者”“威力”“智慧”和“爱”的四位领导人所管理，有机构统一组织安排，产品按公民需要分配，儿童由国家抚养和教育，教育与生产相联系[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%A4%AA%E9%98%B3%E5%9F%8E_(%E8%91%97%E4%BD%9C)#cite_note-%E5%A4%AA%E9%98%B3%E5%9F%8E-1">1]</a>。</p>
</blockquote>
<h2 id="”欧洲三大空想社会主义者“是谁？"><a href="#”欧洲三大空想社会主义者“是谁？" class="headerlink" title="”欧洲三大空想社会主义者“是谁？"></a>”欧洲三大空想社会主义者“是谁？</h2><p>​	欧文（1771~1858年）：英国空想社会主义者。生于威尔士蒙特利尔的一个手工业家庭。10岁辍学当学徒，19岁成为曼彻斯特一家纱厂的经理。</p>
<p>​	圣西门（1760~1825年）：法国哲学家，经济学家，空想社会主义者。1960年10月17日生于巴黎一个贵族家庭。早年受启蒙运动影响，曾参加过北美人民反对英国殖民统治的斗争。</p>
<p>​	傅里叶（1772~1837年）：法国哲学家，经济学家，空想社会主义者。1772年4月7日生于贝桑松一个富商家庭。自学成才。1793年参加里昂联邦派起义，一度背部。1809年后再里昂，巴黎等地任职。</p>
<p><img src="https://liberal-arts-guide.com/wp-content/uploads/2020/06/utopian-socialism.jpg" alt="空想的社会主義とは】マルクス主義との違い・各思想家の議論をわかりやすく解説｜リベラルアーツガイド"></p>
<h2 id="空想社会主义为什么会诞生？"><a href="#空想社会主义为什么会诞生？" class="headerlink" title="空想社会主义为什么会诞生？"></a>空想社会主义为什么会诞生？</h2><ol>
<li>19世纪中叶，西欧的一些资本主义发展非常迅速。随着资本主义的发展，<strong>现代无产阶级形成</strong>并开展了广泛的斗争，而<strong>资本主义固有的矛盾</strong>也日益暴露了出来。</li>
<li><strong>周期性的生产过剩危机</strong>不断发生，<strong>工人们的失业和普遍贫困</strong>话现象严重。</li>
<li><strong>生产的无政府状态，生产资料的私人占有和生产的社会化之间的深刻矛盾</strong>，造成生产秩序和社会秩序的混乱。</li>
<li>贫富差距越来越大，<strong>民众的社会道德沦丧，价值观念恶化</strong>。</li>
<li>19世纪初法国的圣$\cdot $西门，傅里叶及英国的罗伯特$\cdot $欧文灯空想社会主义者的努力。</li>
</ol>
<h2 id="空想社会主义为什么只能是空想"><a href="#空想社会主义为什么只能是空想" class="headerlink" title="空想社会主义为什么只能是空想"></a>空想社会主义为什么只能是空想</h2><ol>
<li>空想社会主义者没有看到<strong>资产阶级的基本矛盾</strong>，同时他们所设想的社会主义也是建立在资产阶级统治的基础之上，这种理论与实际的矛盾使得他们的设想只能是一种空想。</li>
<li>空想者没有找到改造资本主义社会的正确途径，他们把希望寄托再统治阶级的开明人物身上，<strong>幻想通过和平道路来改造社会</strong>，这并不符合当时的社会发展，所以无法实现。</li>
<li>空想社会主义是在资本主义生产方式以及<strong>无产阶级和资产阶级之间的对立还很不发达</strong>的情况下产生的，这就决定了它只能是一个不能实现的幻想。</li>
</ol>
<h2 id="“欧洲三大工人运动”的标志性意义是什么？"><a href="#“欧洲三大工人运动”的标志性意义是什么？" class="headerlink" title="“欧洲三大工人运动”的标志性意义是什么？"></a>“欧洲三大工人运动”的标志性意义是什么？</h2><p>​	三大欧洲工人运动，即法国里昂工人起义，英国宪章运动，德国西里西亚纺织工人起义。</p>
<p>​	意义：（1）表明无产阶级登上了历史舞台，为<strong>马克思主义的诞生</strong>奠定了阶级基础。</p>
<p>​	（2）标志着现代<strong>无产阶级已经成为一支独立的政治力量</strong>登上了历史舞台，无产阶级的力量的壮大。</p>
<p>​	（3）使无产阶级加深对资本主义制度的认识，同时为<strong>无产阶级革命理论的制定、马克思主义的创立</strong>提供了丰富的实践经验。</p>
<h2 id="“马克思主义”的创立人是谁？"><a href="#“马克思主义”的创立人是谁？" class="headerlink" title="“马克思主义”的创立人是谁？"></a>“马克思主义”的创立人是谁？</h2><p>马克思和恩格斯</p>
<h2 id="《共产党宣言》的公开发表标志着什么？"><a href="#《共产党宣言》的公开发表标志着什么？" class="headerlink" title="《共产党宣言》的公开发表标志着什么？"></a>《共产党宣言》的公开发表标志着什么？</h2><p>1848年《共产党宣言》的发表标志着<strong>马克思主义的诞生</strong>。</p>
<h2 id="“两个必然”是什么？"><a href="#“两个必然”是什么？" class="headerlink" title="“两个必然”是什么？"></a>“两个必然”是什么？</h2><p>“两个必然”即<strong>资本主义必然灭亡</strong>和<strong>社会主义必然胜利</strong>，也成为“两个不可避免”</p>
<h2 id="“第一国际”与“第二国际”的异同何在？"><a href="#“第一国际”与“第二国际”的异同何在？" class="headerlink" title="“第一国际”与“第二国际”的异同何在？"></a>“第一国际”与“第二国际”的异同何在？</h2><p>相同点：①它们都是<strong>国际性的工人组织</strong>②它们的建立都处于<strong>工人运动</strong>从低潮走向高潮的阶段③<strong>马克思和恩格斯</strong>都积极参与了对<strong>两个国际的领导</strong>。</p>
<p>不同点：①第一国际由<strong>各国工人团体</strong>组成，而第二国际主要由<strong>社会主义政党</strong>组成；②参加第一国际的主要是少数欧洲国家的工人组织，第二国际参加的<strong>工人范围扩大到欧洲和北美</strong>③第一国际产生于<strong>资本主义社会矛盾激化</strong>，工人运动，民族解放运动高涨并走向联合之中，第二国际产生于<strong>资本主义相对稳定的环境</strong>中，④在组织上，第二国际不是<strong>各国党的上级组织</strong>，它通过历代代表大会的决议给各国党指明方向，第二国际<strong>内部派别斗争</strong>激烈。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-带中间铰的分析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/05/27/%E5%B8%A6%E4%B8%AD%E9%97%B4%E9%93%B0%E7%9A%84%E5%88%86%E6%9E%90/"
    >带中间铰的分析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/05/27/%E5%B8%A6%E4%B8%AD%E9%97%B4%E9%93%B0%E7%9A%84%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2024-05-26T17:03:39.000Z" itemprop="datePublished">2024-05-27</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p> 加快画弯矩图速度的原理：将弯矩当成一个没有彻底旋完的螺丝</p>
<ol>
<li><p>在铰连接处，如果没有集中力偶矩作用，其弯矩应<br>为零。</p>
</li>
<li><p>在自由端处，如果没有集中力作用，其剪力应为零;<br>如果没有集中力偶矩作用，其弯矩应为零。</p>
</li>
<li><p>对称结构承受对称荷载，其剪力图反对称，弯矩图<br>对称。</p>
</li>
<li><p>对称结构承受反对称荷载，其剪力图对称，弯矩图<br>反对称。</p>
</li>
</ol>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-洛谷P1002过河卒带来的思考"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/05/24/%E6%B4%9B%E8%B0%B7P1002%E8%BF%87%E6%B2%B3%E5%8D%92%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%9D%E8%80%83/"
    >洛谷P1002过河卒带来的思考</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/05/24/%E6%B4%9B%E8%B0%B7P1002%E8%BF%87%E6%B2%B3%E5%8D%92%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%9D%E8%80%83/" class="article-date">
  <time datetime="2024-05-23T18:18:39.000Z" itemprop="datePublished">2024-05-24</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="动态规划（Dynamic-Programing）"><a href="#动态规划（Dynamic-Programing）" class="headerlink" title="动态规划（Dynamic Programing）"></a>动态规划（Dynamic Programing）</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems.</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">斐波那契数列可以看作一个简易的DP问题</span><br><span class="line">F(n)=F(n-1)+F(n-2);(n&gt;=3)</span><br><span class="line">F(10)=F(9)+F(8);</span><br><span class="line">F(9)=F(8)+F(7);</span><br><span class="line">……</span><br><span class="line">F(3)=F(2)+F(1);</span><br></pre></td></tr></table></figure>

<p>如果是使用递归思路，那么程序需要将每一次需要的元素都重新算一次，会导致重复的运算，如果是在DP算法里面，每一次算过的数都用一个数组或者哈希表存储起来，之后就可以复用了，这样能减少运算量。</p>
<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><h4 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h4><p>F(n-1)和F(n-2)称为F(n)的最优子结构</p>
<h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>F(n)&#x3D;F(n-1)+F(n-2)就称为状态转移方程</p>
<h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h4><p>F(1) &#x3D; 1, F(2) &#x3D; 2 就是边界啦</p>
<h4 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h4><p>比如F(10)&#x3D; F(9)+F(8),F(9) &#x3D; F(8) + F(7) ,f(8)就是重叠子问题</p>
<h2 id="适用例题"><a href="#适用例题" class="headerlink" title="适用例题"></a>适用例题</h2><blockquote>
<p>如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划。</p>
</blockquote>
<p>比如一些求最值的场景，如<strong>最长递增子序列、最小编辑距离、背包问题、凑零钱问题</strong>等等，都是动态规划的经典应用场景。</p>
<p>动态规划的核心思想就是<strong>拆分子问题，记住过往，减少重复计算。</strong> 并且动态规划一般都是自底向上的，因此到这里，基于<strong>青蛙跳阶</strong>问题，我总结了一下我做动态规划的思路：</p>
<h4 id="穷举分析"><a href="#穷举分析" class="headerlink" title="穷举分析"></a>穷举分析</h4><h4 id="确定边界"><a href="#确定边界" class="headerlink" title="确定边界"></a>确定边界</h4><h4 id="找出规律，确定最优子结构"><a href="#找出规律，确定最优子结构" class="headerlink" title="找出规律，确定最优子结构"></a>找出规律，确定最优子结构</h4><h4 id="写出状态转移方程"><a href="#写出状态转移方程" class="headerlink" title="写出状态转移方程"></a>写出状态转移方程</h4><h4 id="leetcode案例分析"><a href="#leetcode案例分析" class="headerlink" title="leetcode案例分析"></a>leetcode案例分析</h4><blockquote>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<ol>
<li><p>穷举分析</p>
<p>因为动态规划，核心思想包括<strong>拆分子问题，记住过往，减少重复计算。</strong> 所以我们在思考原问题：<strong>数组num[i]的最长递增子序列长度时</strong>，可以思考下<strong>相关子问题</strong>，比如原问题是否跟<strong>子问题</strong>num[i-1]的最长递增子序列长度有关呢？</p>
</li>
<li><p>在穷举分析的时候，可以将元素写成两个数组的形式，这样便于找寻规律。</p>
</li>
<li><p>现在让我们分析一下</p>
<table>
<thead>
<tr>
<th>nums的元素数量</th>
<th>最大子序列长度</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>{10} 1</td>
</tr>
<tr>
<td>2</td>
<td>{10}||{9} 1</td>
</tr>
<tr>
<td>3</td>
<td>{10}||{9}||{2} 1</td>
</tr>
<tr>
<td>4</td>
<td>{2，5} 2</td>
</tr>
<tr>
<td>5</td>
<td>{2，3}||{2，5} 2</td>
</tr>
<tr>
<td>6</td>
<td>{2，3，7}||{2，5，7} 3</td>
</tr>
<tr>
<td>7</td>
<td>{2，3，7，101}||{2，5，7，101} 4</td>
</tr>
<tr>
<td>8</td>
<td>{2，3，7，18}||{2，5，7，18} 4</td>
</tr>
</tbody></table>
<p>可以得到，最大子序列长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dp[i]=max&#123;Dp[j]&#125;+1;</span><br><span class="line">j&gt;=0&amp;&amp;j&lt;=i-1;</span><br><span class="line">nums[i]&gt;nums[j];</span><br></pre></td></tr></table></figure>

<p>符合这样的状态转移方程</p>
<p>最优子结构：max{Dp[j]}+1.</p>
<p>状态转移方程：Dp[i]&#x3D;max{Dp[j]}+1.</p>
<p>边界：Dp[0]&#x3D;1.</p>
<p>出现了重叠子问题.</p>
<p>所以给出本题的题解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">    if(nums.size()==0)</span><br><span class="line">    &#123;return 0;&#125;</span><br><span class="line">    //保证程序的健壮性</span><br><span class="line">    int Dp[nums.size()];</span><br><span class="line">    Dp[0]=1;</span><br><span class="line">    //声明一个数组，用来存储目标值</span><br><span class="line">    for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">    for(int j=0;j&lt;i-1;j++)</span><br><span class="line">    &#123;</span><br><span class="line">    if(nums[i]&gt;nums[j])</span><br><span class="line">    &#123;</span><br><span class="line">    Dp[i]=max(Dp[j])+1;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;Dp[i]=max(Dp[j]);&#125;</span><br><span class="line">    //分类：满足飞升条件的+1，不满足的占位</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //利用双重循环遍历所列举的情况，将最终值算出来</span><br><span class="line">    return Dp[nums.size()-1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="几种不同的解决思路"><a href="#几种不同的解决思路" class="headerlink" title="几种不同的解决思路"></a>几种不同的解决思路</h1><p>下面是过河卒的集中不同思路。</p>
<h1 id="数组下标平移变换的技巧"><a href="#数组下标平移变换的技巧" class="headerlink" title="数组下标平移变换的技巧"></a>数组下标平移变换的技巧</h1> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-神树之馆汉化日志"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/05/23/%E7%A5%9E%E6%A0%91%E4%B9%8B%E9%A6%86%E6%B1%89%E5%8C%96%E6%97%A5%E5%BF%97/"
    >神树之馆汉化日志</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/05/23/%E7%A5%9E%E6%A0%91%E4%B9%8B%E9%A6%86%E6%B1%89%E5%8C%96%E6%97%A5%E5%BF%97/" class="article-date">
  <time datetime="2024-05-23T11:13:07.000Z" itemprop="datePublished">2024-05-23</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>神树之馆简要介绍</p>
<p>民俗学を専攻する大学生の主人公、工月秋成（くげつ あきなり）は、卒業論文に必要な資料を探していた。大学の友人である四ツ谷麻子（よつたに あさこ）は、四国の山中にそびえ立つ親類の那越（なごし）邸、通称「真珠邸」を工月に紹介し、2人でそこへ赴くことになった。車で真珠邸にたどり着いた2人は、館をひとり管理するメイドの知里紫織（ともさと しおり）に迎えられ、案内された書庫で資料を探し始める。<br>館の住人は紫織の他に3人。そのうちの2人である双子の少女、斎（いつき）と伊美（いみ）は、外部の人間を警戒してか工月たちに近付こうとせず、もう1人である館の主人にいたっては姿さえ現さない。<br>館に着いた夜、工月は夢の中で真珠邸の奥に囚われたアルビノの少女に出会う。そして、2人を館に閉じ込めるように降りしきる雨。工月は、この不可解な館に知らず足を踏み入れてゆくのだった。</p>
</blockquote>
<h2 id="主要人物"><a href="#主要人物" class="headerlink" title="主要人物"></a>主要人物</h2><p><strong>工月秋成（くげつ あきなり）</strong>：主人公。大学生であり卒業論文を書いている。</p>
<img src="https://lain.bgm.tv/r/400/pic/crt/l/62/f7/89831_crt_O42aS.jpg" alt="img" style="zoom:67%;">

<p><strong>四ツ谷麻子（よつたに あさこ）</strong>：主人公と同じ大学に通う学生。主人公とは友達以上、恋人未満の関係。いわゆる世話焼きヒロインタイプで、処女。しっかりしているように見られやすいが、意外ともろい部分があり、実は寂しがり屋。</p>
<img src="https://lain.bgm.tv/r/400/pic/crt/l/15/87/89832_crt_2Ee63.jpg" alt="img" style="zoom: 67%;">

<p><strong>知里紫織（ともさと しおり）</strong>：館の一切を取り仕切っているメイド。穏やかで優しい性格。書物全般に対して造詣が深い。昼は淑女、夜は娼婦、といったタイプ。性に関する技術や、男を喜ばせるテクニックに長けていて、主人公に対しては、誘惑者の役割。非処女。</p>
<img src="https://lain.bgm.tv/r/400/pic/crt/l/9d/a7/89833_crt_NN70S.jpg" alt="img" style="zoom:67%;">

<p><strong>斎（いつき）</strong>：館の住人の双子。斎は勉強が苦手で、ドジっ子。伊美はしっかり者だが、主人公に敵意を見せる。伊美が斎を守っている、といった構図。二人とも処女。最初は警戒して主人公に近寄らないが、外部の人間というのに興味があるらしく、徐々になついていく。主人公に、館から連れ出してもらうことを願っている。</p>
<img src="https://lain.bgm.tv/r/400/pic/crt/l/48/e6/89834_crt_CHc06.jpg" alt="img" style="zoom:67%;">

<p><strong>伊美（いみ）</strong>：館の住人の双子。斎は勉強が苦手で、ドジっ子。伊美はしっかり者だが、主人公に敵意を見せる。伊美が斎を守っている、といった構図。二人とも処女。最初は警戒して主人公に近寄らないが、外部の人間というのに興味があるらしく、徐々になついていく。主人公に、館から連れ出してもらうことを願っている。</p>
<img src="https://lain.bgm.tv/r/400/pic/crt/l/5a/bc/89835_crt_xHIG8.jpg" alt="img" style="zoom:67%;">

<p><strong>竜胆（りんどう）</strong>：謎の住人。透き通るほどに白い、アルビノの少女。屋敷の奥で生活しているらしく、普段、顔を出すことは滅多にない。「神樹の館」の守り神的存在。住人たちの間では、一種のタブーとして畏れ、敬われている。彼女の意思ひとつで、館はその姿を変貌させる。</p>
<img src="https://lain.bgm.tv/r/400/pic/crt/l/2b/f5/89836_crt_w3pjt.jpg" alt="img" style="zoom:67%;">

<h2 id="翻译日记"><a href="#翻译日记" class="headerlink" title="翻译日记"></a>翻译日记</h2><p>Q1：日语的连体形是否可以望文生义？</p>
<p>Q2：推量助词该怎么翻译？</p>
<p>Q3：语气词该怎么翻译？</p>
<h2 id="翻译生词"><a href="#翻译生词" class="headerlink" title="翻译生词"></a>翻译生词</h2><ol>
<li><p><a target="_blank" rel="noopener" href="https://www.weblio.jp/content/%E3%81%9F%E3%81%BE%E3%81%92%E3%82%8B">「たまげる」の意味や使い方 わかりやすく解説 Weblio辞書</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.weblio.jp/content/%E3%82%86%E3%81%8B%E3%82%8A">「ゆかり」の意味や使い方 わかりやすく解説 Weblio辞書</a></p>
<blockquote>
<p>ゆかりの花言葉は？</p>
<p>Conversation. ユカリさんは多分、紫草からかな……花言葉は<strong>「追憶」「あなたを忘れない」</strong>みたいな意味合いだし……紫は縁(ゆかり)の色ですからね……</p>
</blockquote>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.weblio.jp/content/%E6%AD%AF%E5%88%87%E3%82%8C%E3%81%8C%E6%82%AA%E3%81%84#:~:text=%E8%A8%80%E3%81%84%E6%A7%98%E3%81%8C%E3%81%AF%E3%81%A3%E3%81%8D%E3%82%8A%E3%81%97%E3%81%AA%E3%81%84%E3%81%95%E3%81%BE,%E3%81%AA%E3%81%A9%E3%82%92%E6%84%8F%E5%91%B3%E3%81%99%E3%82%8B%E8%A1%A8%E7%8F%BE%E3%80%82">「歯切れが悪い(はぎれがわるい)」の意味や … - Weblio国語辞典</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.weblio.jp/content/%E5%BC%95%E3%81%8D%E5%AF%84%E3%81%9B%E3%82%8B">「引き寄せる」の意味や使い方 わかりやすく解説 Weblio辞書</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.weblio.jp/content/%E3%81%BC%E3%81%86%E3%81%A3%E3%81%A8">「ぼうっと」の意味や使い方 わかりやすく解説 Weblio辞書</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.weblio.jp/content/%E5%83%85%E3%81%8B%E3%81%AA">「僅かな(はつかな、わずかな)」の意味や使い方 わかり …</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://dictionary.goo.ne.jp/word/%E8%A1%A3%E6%93%A6%E3%82%8C/">衣擦れ／衣摺れ（きぬずれ） とは？ 意味・読み方・使い方</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.weblio.jp/content/%E8%B8%B5%E3%82%92%E8%BF%94%E3%81%99">踵を返すの意味や使い方 わかりやすく解説 Weblio辞書</a></p>
</li>
<li><p>「おや、と思わせた」：日文中「おや」表示惊讶或疑惑的感觉，可以翻译为「让他产生疑惑」</p>
</li>
<li><p><strong>ほどなくして</strong>：这个词意为「不久之后，没过多久」。</p>
</li>
<li><p>「くるぶし」在日语中指的是「脚踝」。中文翻译为「脚踝」或「踝骨」</p>
</li>
<li><p>「据（す）わり」这个词在日语中通常有「坐」或「固定」的意思。根据具体语境可以有不同的翻译方式。</p>
</li>
<li><p>「{据:す}わりの悪さ」：此处的「すわりの悪さ」指的是一种不适感或不自然的感觉</p>
</li>
<li><p>「{釣瓶:つ　る　べ}落とし」：表示迅速下降，这个词源自一种汲水用的工具桶（釣瓶），被放入井里时会迅速下落。这里用来形容天色很快变黑。</p>
</li>
<li><p>「疲れをほぐしていて下さいな」：放松疲劳，休息一下</p>
</li>
<li><p>「なんの」：没关系，不用在意</p>
</li>
<li><p>まだお夕食まで間がある：离晚饭时间还早</p>
</li>
<li><p>「のですよ」：带有委婉语气，表示解释或提醒</p>
</li>
<li><p>「とおっしゃいましたが」：您这么说了，不过</p>
</li>
<li><p>「案内する」：引导、带路，引导的动作</p>
</li>
<li><p>「{艶:なまめ}かしい」：妩媚，富有魅力</p>
</li>
<li><p>「かえって」：反而</p>
</li>
<li><p>「膨らみ」：曲线，隆起</p>
</li>
<li><p>「地味な造り」：朴素的设计</p>
</li>
<li><p>「色合い」：色调</p>
</li>
<li><p><strong>際立つ</strong>：凸显，显得更加明显</p>
</li>
<li><p>「エプロン」：围裙</p>
</li>
<li><p>「ふっくらした」：丰满的，柔和的</p>
</li>
<li><p>「図星」：要害，弱点</p>
</li>
<li><p>「をさされ」：被戳中，被指出</p>
</li>
<li><p>「狼狽える（うろたえる）」：惊慌失措，狼狈</p>
</li>
</ol>
<h2 id="文言文"><a href="#文言文" class="headerlink" title="文言文"></a>文言文</h2><h3 id="梅圣俞诗集序"><a href="#梅圣俞诗集序" class="headerlink" title="梅圣俞诗集序"></a>梅圣俞诗集序</h3><ol>
<li><p>予闻世谓诗人少达而多穷，夫岂然哉？盖世所传诗者，多出于古穷人之辞也。凡士之蕴其所有，而不得施于世者，多喜自放于山巅水涯之外，见虫鱼草木风云鸟兽之状类，往往探其奇怪，内有忧思感愤之<strong>郁积</strong>，其兴于怨刺，以道<strong>羁臣寡妇</strong>之所叹，而写人情之难言。盖愈穷则愈工。然则非诗之能穷人，<strong>殆</strong>穷者而后工也。</p>
<blockquote>
<p>我听到世人常说：诗人仕途畅达的少，困厄的多。难道真是这样吗？大概是由于世上所流传的诗歌，多出于古代困厄之士的笔下吧。大凡胸藏才智而又不能充分施展于世的士人，大都喜爱到山头水边去放浪形骸，看见虫鱼草木风云鸟兽等事物，往往探究它们的奇特怪异之处，内心有着忧愁感慨愤激的郁积，这些情感化为诗兴，即寄托在怨恨讽刺之中，道出了逐臣寡妇的慨叹，而写出了人所难于言传的感受来。大概越困厄就越能写得工巧。如此说来，并非写诗使人穷困潦倒，大概是穷困潦倒后才能写出好诗来。</p>
</blockquote>
</li>
<li><p>予友梅圣俞，少以<strong>荫补</strong>为吏，累举进士，<strong>辄抑</strong>于有司，困于州县，凡十余年。年今五十，犹从辟书，为人之佐，郁其所蓄，不得奋见于事业。其家宛陵，幼习于诗，自为童子，出语已惊其长老。既长，学乎六经仁义之说，其为文章，<strong>简古纯粹</strong>，不求<strong>苟说</strong>于世。世之人徒知其诗而已。然时无贤愚，语诗者必求之圣俞；圣俞亦自以其不得志者，乐于诗而发之，故其平生所作，于诗尤多。世既知之矣，而未有荐于上者。昔王文康公尝见而叹曰：“二百年无此作矣！”虽知之深，亦不果荐也。若使其幸得用于朝廷，作为雅、颂，以歌咏大宋之功德，荐之清庙，而追商、周、鲁颂之作者，岂不伟欤！奈何使其老不得志，而为穷者之诗，乃徒发于虫鱼物类，羁愁感叹之言。世徒喜其工，不知其穷之久而将老也！可不惜哉！</p>
<blockquote>
<p>我的朋友梅圣俞，年轻时由于荫袭补为下级官吏，屡次考进士，总是遭到主考部门的压制，在地方上困厄了十多年。年已五十了，还要靠别人下聘书，去当人家的办事员。郁积着自己的才能智慧，不能在事业上充分地表现出来。他家乡在宛陵，幼年时就学习诗歌，从他还是个孩童时起，写出诗句来就已使得父老长辈惊异了。等到长大，学习了六经仁义的学问，他写出的文章简古纯正，不希求苟且取悦于世人，因此世人只知道他会写诗罢了。然而当时人不论贤愚，谈论诗歌必然会向圣俞请教。圣俞也把自己不得志的地方，喜欢通过诗歌来发泄，因此他平时所写的东西，其中诗歌就特别多。社会上已经知道他了，却没有人向朝廷推荐他。从前王文康公曾看到他的诗作，慨叹地说：“二百年没有这样的作品了！”虽然对他了解很深，可还是没有加以推荐。假使他有幸得到朝廷的任用，写出如《诗经》中雅、颂那样的作品，来歌颂大宋的功业恩德，献给宗庙，使他类似于商颂、周颂、鲁颂等作者，难道不是很壮伟的吗？可惜他到老也不得志，只能写困厄者的诗歌，白白地在虫鱼之类上抒发穷苦愁闷的感叹。社会上只喜爱他诗歌的工巧，却不知道他困厄已久将要老死了，这难道不值得叹息吗？</p>
</blockquote>
</li>
<li><p>圣俞诗既多，不自收拾。其妻之兄子谢景初，惧其多而易失也，取其自洛阳至于吴兴以来所作，次为十卷。予尝嗜圣俞诗，而患不能尽得之，<strong>遽喜</strong>谢氏之能类次也，<strong>辄序</strong>而藏之。</p>
<blockquote>
<p>圣俞的诗很多，自己却不收拾整理。他的内侄谢景初担心它太多容易散失，选取他从洛阳到吴兴这段时间的作品，编为十卷。我曾经酷爱圣俞的诗作，担心不能全部得到它，十分高兴谢氏能为它分类编排，就为之作序并保存起来。</p>
</blockquote>
</li>
<li><p>其后十五年，圣俞以疾卒于京师，余<strong>既</strong>哭而铭之，因索于其家，得其遗稿千余篇，并旧所藏，<strong>掇</strong>其尤者六百七十七篇，为一十五卷。呜呼！吾于圣俞诗论之详矣，故不复云。</p>
<blockquote>
<p>从那以后过了十五年，圣俞因病在京师去世，我已痛哭着为他写好了墓志铭，便向他家索求，得到他的遗稿一千多篇，连同先前所保存的，选取其中特别好的共六百七十七篇，分为十五卷。啊，我对圣俞的诗歌已经评论得很多了，所以不再重复。</p>
</blockquote>
</li>
</ol>
<h3 id="五代史宦者传论"><a href="#五代史宦者传论" class="headerlink" title="五代史宦者传论"></a>五代史宦者传论</h3><ol>
<li><p>自古宦者乱人之国，其源深于女祸。女，色而已，宦者之害，非<strong>一端</strong>也。</p>
<blockquote>
<p>自古以来，宦官扰乱国家，比女人造成的祸患还要严重。女人，只不过是使君主沉溺于美色罢了，而宦官的危害可不止一条。</p>
</blockquote>
</li>
<li><p>盖其<strong>用事</strong>也近而习，其为心也专而<strong>忍</strong>。能以小善中人之意，小信固人之心，使人主必信而亲之。待其已信，然后惧以祸福而把持之。虽有忠臣硕士列于朝廷，而人主以为去己疏远，不若起居饮食、前后左右之亲<strong>可恃</strong>也。故前后左右者日益亲，而忠臣硕士日益疏，而人主之势日益孤。势孤，则惧祸之心日益切，而把持者日益<strong>牢。安危出其喜怒，祸患伏于</strong>帷闼<strong>，则向之所谓</strong>可恃**者，乃所以为患也。</p>
<blockquote>
<p>宦官所担当的职责就是侍奉在君主身边，容易与君主形成亲密关系，他们的用心专一并且毒辣，他们能用微小的好处来迎合别人的心意，能用小忠小信获得君主的信任，使人君必然信任、亲近他们。等到获得了君主的完全信任，然后就用祸福来恐吓他、挟制他。这时候虽然有忠臣贤士在朝中，但君主认为他们和自己关系疏远，不如侍奉他起居饮食、成天在自己左右侍奉自己的亲随那样可靠。所以君主与成天在左右侍奉自己的人日益亲密，而对忠臣贤士们则日益疏远，君主便会日益变得势单力孤。势单力孤，则惧怕发生祸患的心理就更加严重。而挟持自己的人的地位就会更加牢固。君主的安危，决定于这些人的喜怒；而祸患就潜伏在他的内廷之中。于是过去认为可以依靠的人，正是现在为患的根源。</p>
</blockquote>
</li>
<li><p>患已深而觉之，欲与疏远之臣<strong>图</strong>左右之亲近，缓之则养祸而益深，急之则挟人主以为质。虽有圣智，不能与谋。谋之而不可为，为之而不可成，至其甚，则俱伤而两败。故其大者亡国，其次亡身，而使奸豪得借以为资而起，至抉其种类，尽杀以快天下之心而后已。此前史所载宦者之祸常如此者，非一世也。</p>
<blockquote>
<p>当发觉祸患已深的时候，想要和平日里疏远的大臣们一起除掉左右的亲随，行动慢了就会使祸患日益严重；操之过急，又会使那些亲随挟持自己作为人质。这时候即使是智慧再高的人，也不能与他共商对策了。就算是能够商议对策，也很难实际着手去做。即使做了，也有可能不成功，到了最严重的时候，很可能产生两败俱伤的后果。祸患大的可以亡国，次一点的会让自己丧命，并且会使世上的奸雄们以此为借口乘机而起，把宦官与其同党尽皆除掉，大快天下人之心后才算完。过去历史上记载的宦官之祸往往如此，而且不止一代。</p>
</blockquote>
</li>
<li><p>夫为人主者，非欲养祸于内，而疏忠臣硕士于外，盖其渐积而势使之然也。夫女色之惑，不幸而不悟，而祸斯及矣。使其一悟，捽而去之可也。宦者之为祸，虽欲悔悟，而势有不得而去也，唐昭宗之事是已。故曰“深于女祸者”，谓此也。可不戒哉？</p>
<blockquote>
<p>作为君主，并不是故意要在宫中养虎成患，在朝堂之上疏远忠臣贤士，这是日积月累逐步发展而成的，是形势发展使他自然而然地走入此途的。所以沉迷于女色，如果不幸一直执迷不悟，那么祸患就要随之降临了；但是一旦醒悟，把她们撵出去就行了。而宦者造成的祸患，虽然有所悔悟，但已经形成的形势使得自己没有办法把他们除掉；唐昭宗的事就是这样。所以说“比女人造成的祸患还要严重”，就是指这些，怎能不有所戒惧呢？</p>
</blockquote>
</li>
</ol>
<h2 id="中古日语"><a href="#中古日语" class="headerlink" title="中古日语"></a>中古日语</h2><table>
<thead>
<tr>
<th>活用型 （活用の種類）</th>
<th>例語</th>
<th>語幹</th>
<th>未然</th>
<th>連用</th>
<th>終止</th>
<th>連体</th>
<th>已然</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>四段</td>
<td>聞く</td>
<td>聞</td>
<td>か</td>
<td>き</td>
<td>く</td>
<td>く</td>
<td>け</td>
<td>け</td>
</tr>
<tr>
<td>上二段</td>
<td>起く</td>
<td>起</td>
<td>き</td>
<td>き</td>
<td>く</td>
<td>くる</td>
<td>くれ</td>
<td>きょ</td>
</tr>
<tr>
<td>下二段</td>
<td>受く</td>
<td>受</td>
<td>け</td>
<td>け</td>
<td>く</td>
<td>くる</td>
<td>くれ</td>
<td>けよ</td>
</tr>
<tr>
<td>上一段</td>
<td>着る</td>
<td>着</td>
<td>き</td>
<td>き</td>
<td>きる</td>
<td>きる</td>
<td>きれ</td>
<td>きよ</td>
</tr>
<tr>
<td>下一段</td>
<td>蹴る</td>
<td>蹴</td>
<td>け</td>
<td>け</td>
<td>ける</td>
<td>ける</td>
<td>けれ</td>
<td>けよ</td>
</tr>
<tr>
<td>カ行変格</td>
<td>来</td>
<td>来</td>
<td>こ</td>
<td>き</td>
<td>く</td>
<td>くる</td>
<td>くれ</td>
<td>こ$\cdot$こよ</td>
</tr>
<tr>
<td>サ行変格</td>
<td>為</td>
<td>為</td>
<td>せ</td>
<td>し</td>
<td>す</td>
<td>する</td>
<td>すれ</td>
<td>せよ</td>
</tr>
<tr>
<td>ナ行変格</td>
<td>往ぬ</td>
<td>往</td>
<td>な</td>
<td>に</td>
<td>ぬ</td>
<td>ぬる</td>
<td>ぬれ</td>
<td>ぬ</td>
</tr>
<tr>
<td>ラ行変格</td>
<td>あり</td>
<td>あ</td>
<td>ら</td>
<td>り</td>
<td>り</td>
<td>る</td>
<td>れ</td>
<td>れ</td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-线代"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/05/22/%E7%BA%BF%E4%BB%A3/"
    >线代</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/05/22/%E7%BA%BF%E4%BB%A3/" class="article-date">
  <time datetime="2024-05-22T08:34:28.000Z" itemprop="datePublished">2024-05-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第一章-线性方程组"><a href="#第一章-线性方程组" class="headerlink" title="第一章 线性方程组"></a>第一章 线性方程组</h1><h2 id="xi1-1-线性方程组高斯消元法与矩阵"><a href="#xi1-1-线性方程组高斯消元法与矩阵" class="headerlink" title="$\xi1.1$	线性方程组	高斯消元法与矩阵"></a>$\xi1.1$	线性方程组	高斯消元法与矩阵</h2><h2 id="xi1-2-行化简和阶梯形矩阵解的存在性和唯一性"><a href="#xi1-2-行化简和阶梯形矩阵解的存在性和唯一性" class="headerlink" title="$\xi1.2$	行化简和阶梯形矩阵	解的存在性和唯一性"></a>$\xi1.2$	行化简和阶梯形矩阵	解的存在性和唯一性</h2><h2 id="xi1-3-线性方程组的应用"><a href="#xi1-3-线性方程组的应用" class="headerlink" title="$\xi1.3$	线性方程组的应用"></a>$\xi1.3$	线性方程组的应用</h2><h1 id="第二章矩阵代数"><a href="#第二章矩阵代数" class="headerlink" title="第二章	矩阵代数"></a>第二章	矩阵代数</h1><h2 id="xi2-1-矩阵和向量"><a href="#xi2-1-矩阵和向量" class="headerlink" title="$\xi2.1$	矩阵和向量"></a>$\xi2.1$	矩阵和向量</h2><h2 id="xi2-2-矩阵的代数运算"><a href="#xi2-2-矩阵的代数运算" class="headerlink" title="$\xi2.2$	矩阵的代数运算"></a>$\xi2.2$	矩阵的代数运算</h2><h2 id="xi-2-3逆矩阵与矩阵的初等变换"><a href="#xi-2-3逆矩阵与矩阵的初等变换" class="headerlink" title="$\xi$2.3	逆矩阵与矩阵的初等变换"></a>$\xi$2.3	逆矩阵与矩阵的初等变换</h2><h2 id="xi-2-4转置矩阵与一些重要的方阵"><a href="#xi-2-4转置矩阵与一些重要的方阵" class="headerlink" title="$\xi$2.4	转置矩阵与一些重要的方阵"></a>$\xi$2.4	转置矩阵与一些重要的方阵</h2><h2 id="xi-2-5分块矩阵"><a href="#xi-2-5分块矩阵" class="headerlink" title="$\xi$2.5	分块矩阵"></a>$\xi$2.5	分块矩阵</h2><h1 id="第三章行列式"><a href="#第三章行列式" class="headerlink" title="第三章	行列式"></a>第三章	行列式</h1><h2 id="xi-3-1方阵的行列式"><a href="#xi-3-1方阵的行列式" class="headerlink" title="$\xi$3.1	方阵的行列式"></a>$\xi$3.1	方阵的行列式</h2><h2 id="xi-3-2行列式的主要性质"><a href="#xi-3-2行列式的主要性质" class="headerlink" title="$\xi$3.2	行列式的主要性质"></a>$\xi$3.2	行列式的主要性质</h2><h2 id="xi-3-3行列式的应用"><a href="#xi-3-3行列式的应用" class="headerlink" title="$\xi$3.3	行列式的应用"></a>$\xi$3.3	行列式的应用</h2><h1 id="第四章向量空间"><a href="#第四章向量空间" class="headerlink" title="第四章	向量空间"></a>第四章	向量空间</h1><h2 id="xi-4-1向量的定义及其运算"><a href="#xi-4-1向量的定义及其运算" class="headerlink" title="$\xi$4.1	向量的定义及其运算"></a>$\xi$4.1	向量的定义及其运算</h2><h2 id="xi-4-2向量的线性相关性"><a href="#xi-4-2向量的线性相关性" class="headerlink" title="$\xi$4.2	向量的线性相关性"></a>$\xi$4.2	向量的线性相关性</h2><h2 id="xi-4-3向量组的极大线性无关组和秩"><a href="#xi-4-3向量组的极大线性无关组和秩" class="headerlink" title="$\xi$4.3	向量组的极大线性无关组和秩"></a>$\xi$4.3	向量组的极大线性无关组和秩</h2><h2 id="xi-4-4子空间"><a href="#xi-4-4子空间" class="headerlink" title="$\xi$4.4	子空间"></a>$\xi$4.4	子空间</h2><h2 id="xi-4-5基和维数"><a href="#xi-4-5基和维数" class="headerlink" title="$\xi$4.5	基和维数"></a>$\xi$4.5	基和维数</h2><h2 id="xi-4-6矩阵的秩"><a href="#xi-4-6矩阵的秩" class="headerlink" title="$\xi$4.6	矩阵的秩"></a>$\xi$4.6	矩阵的秩</h2><h2 id="xi-4-7线性方程组的有解条件及解的结构"><a href="#xi-4-7线性方程组的有解条件及解的结构" class="headerlink" title="$\xi$4.7	线性方程组的有解条件及解的结构"></a>$\xi$4.7	线性方程组的有解条件及解的结构</h2><h2 id="xi-4-8-R-n-到-R-m-的线性映射"><a href="#xi-4-8-R-n-到-R-m-的线性映射" class="headerlink" title="$\xi$4.8	$R^n$到$R^m$的线性映射"></a>$\xi$4.8	$R^n$到$R^m$的线性映射</h2><h1 id="第五章特征值与特征向量"><a href="#第五章特征值与特征向量" class="headerlink" title="第五章	特征值与特征向量"></a>第五章	特征值与特征向量</h1><h2 id="xi-5-1矩阵的特征值与特征向量"><a href="#xi-5-1矩阵的特征值与特征向量" class="headerlink" title="$\xi$5.1	矩阵的特征值与特征向量"></a>$\xi$5.1	矩阵的特征值与特征向量</h2><h2 id="xi-5-2矩阵的相似对角化"><a href="#xi-5-2矩阵的相似对角化" class="headerlink" title="$\xi$5.2	矩阵的相似对角化"></a>$\xi$5.2	矩阵的相似对角化</h2><h2 id="xi-5-3实对称矩阵的正交相似对角化"><a href="#xi-5-3实对称矩阵的正交相似对角化" class="headerlink" title="$\xi$5.3	实对称矩阵的正交相似对角化"></a>$\xi$5.3	实对称矩阵的正交相似对角化</h2><p>​	由定理5.2.1知，一个n阶矩阵能否对角化取决于它是否有n个线性无关的特征向量.那么什么样的矩阵一定有n个线性无关的特征向量呢?下面我们就来证明任一n阶实对称矩阵一定存在n个线性无关的特征向量,从而可以对角化.也就是说,存在可逆阵$P$，使得$P^{-1}AP&#x3D;\Lambda$为对角阵。进一步，我们还可证明存在正交矩阵$Q$,使得$Q^T AQ&#x3D;\Lambda$为对角阵.为此，我们先引人如下概念.</p>
<p>​	定义 5.3.1	设$\alpha&#x3D;[a_1,a_2.\cdots,a_n]^T,\beta&#x3D;[b_1,b_2,\cdots,b_n]^T$称<br>$$<br>(\alpha,\beta)&#x3D;\alpha^T\cdot\beta&#x3D;\sum_{i&#x3D;i}^na_ib_i<br>$$<br>为向量$\alpha,\beta$的内积，显然，$(\alpha,\alpha)&gt;&#x3D;0$,当且仅当$\alpha&#x3D;0$时等号成立，关于向量内积，还有如下性质：<br>$$<br>(1)(\alpha,\beta)&#x3D;(\beta,\alpha),\\<br>(2)(\alpha+\beta,\gamma)&#x3D;(\alpha,\gamma)+(\alpha,\gamma),\\<br>(3)k\alpha,\beta)&#x3D;k(\alpha,\beta),k\in R.\\<br>(4)(0,\alpha)&#x3D;(\alpha,0)&#x3D;0.\\<br>(5)(\sum_{i&#x3D;1}^{n}k_i\alpha_i,\alpha)&#x3D;\sum_{i&#x3D;1}^{n}k_i(\alpha_i,\alpha),k_i\in R,i&#x3D;1,\cdots,n.\\<br>$$<br>​	定义 5.3.2 称$|\alpha|&#x3D;\sqrt{(\alpha,\alpha)}$为向量$\alpha$的长度（或范数），长度为1的向量成为单位向量（unit vector）。</p>
<p>​	一个向量$\alpha $的长度代表了n维空间中与$\alpha $所对应的点到原点（零向量所对应的点）的“距离”。因此，对于任意两个n维向量$\alpha,\beta $所对应的n维空间的两个点之间的距离可以表示为$|\alpha-\beta|$.</p>
<p>​	关于向量长度，有如下性质：<br>$$<br>设\alpha\in R^n,\beta \in R^n,k \in R\\<br>(1)非负性：|k\alpha|&#x3D;|k||\alpha|\\<br>(2)正齐性：|k\alpha|&#x3D;|k||\alpha|\\<br>(3)柯西—许瓦兹不等式：|(\alpha,\beta)|&lt;&#x3D;|\alpha||\beta|\\<br>(4)三角不等式|\alpha|+|\beta|&gt;&#x3D;|\alpha-\beta|&gt;&#x3D;||\alpha|-|\beta||\\<br>我们仅就性质(3),(4)证明\\<br>$$</p>
<p>$$<br>证明(3)\forall t\in R,构造关于t的二次多项式\\<br>0&lt;&#x3D;(\alpha+t\beta,\alpha+t\beta)&#x3D;(\alpha,\alpha)+2(\alpha,\alpha)t+(\beta,\beta)t^2\\<br>所以\\<br>\Delta&#x3D;4(\alpha,\beta)^2-4(\alpha,\alpha)(\beta,\beta)&lt;&#x3D;0.\\<br>即\\<br>（\alpha,\beta）^2&lt;&#x3D;(\alpha,\alpha)(\beta,\beta)&#x3D;|\alpha|^2\cdot|\beta|^2,\\<br>所以\\<br>|(\alpha,\beta)|&lt;&#x3D;|\alpha|\cdot|\beta|<br>$$</p>
<p>$$<br>(4)|\alpha-\beta|^2&#x3D;(\alpha-\beta,\alpha-\beta)&#x3D;|\alpha|^2-2(\alpha,\beta)+|\beta|^2\\</p>
<blockquote>
<p>&#x3D;|\alpha|^2-2|\alpha||\beta|+|\beta|^2\\<br>&#x3D;(|\alpha|-|\beta|)^2\\<br>故\\<br>|\alpha-\beta|&gt;&#x3D;||\alpha|-|\beta||\\<br>(|\alpha|+|\beta|)^2&#x3D;|\alpha|^2+2|\alpha||\beta|+|\beta|^2\\<br>&#x3D;|\alpha|^2-2(\alpha,\beta)+|\beta|^2\\<br>&#x3D;(\alpha-\beta,\alpha-\beta)\\<br>&#x3D;|\alpha-\beta|^2.<br>$$</p>
</blockquote>
<h1 id="第六章二次型"><a href="#第六章二次型" class="headerlink" title="第六章	二次型"></a>第六章	二次型</h1><h2 id="xi-6-1二次型及其矩阵表示"><a href="#xi-6-1二次型及其矩阵表示" class="headerlink" title="$\xi$6.1	二次型及其矩阵表示"></a>$\xi$6.1	二次型及其矩阵表示</h2><h2 id="xi-6-2二次型化位标准型"><a href="#xi-6-2二次型化位标准型" class="headerlink" title="$\xi$6.2	二次型化位标准型"></a>$\xi$6.2	二次型化位标准型</h2><h2 id="xi-6-3正定二次型"><a href="#xi-6-3正定二次型" class="headerlink" title="$\xi$6.3	正定二次型"></a>$\xi$6.3	正定二次型</h2><h2 id="xi-6-4二次型的应用"><a href="#xi-6-4二次型的应用" class="headerlink" title="$\xi$6.4	二次型的应用"></a>$\xi$6.4	二次型的应用</h2><h1 id="第七章线性空间与线性变换"><a href="#第七章线性空间与线性变换" class="headerlink" title="第七章	线性空间与线性变换"></a>第七章	线性空间与线性变换</h1><h2 id="xi-7-1线性空间"><a href="#xi-7-1线性空间" class="headerlink" title="$\xi$7.1	线性空间"></a>$\xi$7.1	线性空间</h2><h2 id="xi-7-2线性变换"><a href="#xi-7-2线性变换" class="headerlink" title="$\xi$7.2	线性变换"></a>$\xi$7.2	线性变换</h2><h2 id="xi-7-3线性变换的矩阵表示"><a href="#xi-7-3线性变换的矩阵表示" class="headerlink" title="$\xi$7.3	线性变换的矩阵表示"></a>$\xi$7.3	线性变换的矩阵表示</h2><h2 id="xi-7-4线性变换的特征值与特征向量"><a href="#xi-7-4线性变换的特征值与特征向量" class="headerlink" title="$\xi$7.4	线性变换的特征值与特征向量"></a>$\xi$7.4	线性变换的特征值与特征向量</h2><h2 id="xi-7-5欧几里得空间简介"><a href="#xi-7-5欧几里得空间简介" class="headerlink" title="$\xi$7.5	欧几里得空间简介"></a>$\xi$7.5	欧几里得空间简介</h2><h1 id="MATLAB在线性代数中的作用"><a href="#MATLAB在线性代数中的作用" class="headerlink" title="MATLAB在线性代数中的作用"></a>MATLAB在线性代数中的作用</h1><h2 id="xi-8-1MATLAB简介"><a href="#xi-8-1MATLAB简介" class="headerlink" title="$\xi$8.1	MATLAB简介"></a>$\xi$8.1	MATLAB简介</h2><h2 id="xi-8-2MATLAB的基本操作"><a href="#xi-8-2MATLAB的基本操作" class="headerlink" title="$\xi$8.2	MATLAB的基本操作"></a>$\xi$8.2	MATLAB的基本操作</h2><h2 id="xi-8-3向量的生成与运算"><a href="#xi-8-3向量的生成与运算" class="headerlink" title="$\xi$8.3	向量的生成与运算"></a>$\xi$8.3	向量的生成与运算</h2><h2 id="xi-8-4矩阵的生成与运算"><a href="#xi-8-4矩阵的生成与运算" class="headerlink" title="$\xi$8.4	矩阵的生成与运算"></a>$\xi$8.4	矩阵的生成与运算</h2><h2 id="xi-8-5常用的矩阵函数"><a href="#xi-8-5常用的矩阵函数" class="headerlink" title="$\xi$8.5	常用的矩阵函数"></a>$\xi$8.5	常用的矩阵函数</h2><h2 id="xi-8-6线性方程组求解"><a href="#xi-8-6线性方程组求解" class="headerlink" title="$\xi$8.6	线性方程组求解"></a>$\xi$8.6	线性方程组求解</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-c-模板"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/05/22/c-%E6%A8%A1%E6%9D%BF/"
    >c++模板</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/05/22/c-%E6%A8%A1%E6%9D%BF/" class="article-date">
  <time datetime="2024-05-22T05:55:56.000Z" itemprop="datePublished">2024-05-22</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>s</p>
<h2 id="什么是模板"><a href="#什么是模板" class="headerlink" title="什么是模板"></a>什么是模板</h2><p>想象你在厨房里准备做各种不同类型的三明治。你不想每次都按照不同的配方来做，而是希望有一个通用的做三明治的方法。模板就像是这个通用的方法，它告诉你如何做三明治，而不关心具体的材料。</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">T makeSandwich(T ingredient1, T ingredient2) &#123;</span><br><span class="line">    // 假装做三明治的步骤</span><br><span class="line">    return ingredient1 + &quot; and &quot; + ingredient2 + &quot; sandwich&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你使用这个食谱时，你可以指定不同的材料：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; makeSandwich(&quot;Ham&quot;, &quot;Cheese&quot;) &lt;&lt; std::endl; // 输出 &quot;Ham and Cheese sandwich&quot;</span><br><span class="line">std::cout &lt;&lt; makeSandwich(&quot;Peanut Butter&quot;, &quot;Jelly&quot;) &lt;&lt; std::endl; // 输出 &quot;Peanut Butter and Jelly sandwich&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>类模板就像是一个通用的三明治机器，这个机器可以根据你给的材料，做出不同类型的三明治。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class SandwichMaker &#123;</span><br><span class="line">private:</span><br><span class="line">    T ingredient1;</span><br><span class="line">    T ingredient2;</span><br><span class="line">public:</span><br><span class="line">    SandwichMaker(T a, T b) : ingredient1(a), ingredient2(b) &#123;&#125;</span><br><span class="line">    void make() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Making a &quot; &lt;&lt; ingredient1 &lt;&lt; &quot; and &quot; &lt;&lt; ingredient2 &lt;&lt; &quot; sandwich.&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用这个三明治机器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SandwichMaker&lt;std::string&gt; hamCheeseMaker(&quot;Ham&quot;, &quot;Cheese&quot;);</span><br><span class="line">hamCheeseMaker.make(); // 输出 &quot;Making a Ham and Cheese sandwich.&quot;</span><br><span class="line"></span><br><span class="line">SandwichMaker&lt;std::string&gt; pbjMaker(&quot;Peanut Butter&quot;, &quot;Jelly&quot;);</span><br><span class="line">pbjMaker.make(); // 输出 &quot;Making a Peanut Butter and Jelly sandwich.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h2><p>有时候，你的三明治机器需要对某些特殊的材料有特别的处理方法。比如说，如果你要做一个“冰淇淋三明治”，步骤可能会和普通的三明治不一样。这时，你可以用模板特化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class SandwichMaker &#123;</span><br><span class="line">public:</span><br><span class="line">    void make(T ingredient1, T ingredient2) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Making a &quot; &lt;&lt; ingredient1 &lt;&lt; &quot; and &quot; &lt;&lt; ingredient2 &lt;&lt; &quot; sandwich.&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 特化冰淇淋三明治</span><br><span class="line">template&lt;&gt;</span><br><span class="line">class SandwichMaker&lt;std::string&gt; &#123;</span><br><span class="line">public:</span><br><span class="line">    void make(std::string ingredient1, std::string ingredient2) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Making a special &quot; &lt;&lt; ingredient1 &lt;&lt; &quot; and &quot; &lt;&lt; ingredient2 &lt;&lt; &quot; ice cream sandwich.&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用特化后的三明治机器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SandwichMaker&lt;std::string&gt; iceCreamSandwichMaker;</span><br><span class="line">iceCreamSandwichMaker.make(&quot;Chocolate&quot;, &quot;Vanilla&quot;); // 输出 &quot;Making a special Chocolate and Vanilla ice cream sandwich.&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h2><p>模板元编程就像是在做三明治之前，提前在脑子里计划好步骤。例如，你要计算你需要准备多少片面包来做一系列的三明治。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int N&gt;</span><br><span class="line">struct BreadSlices &#123;</span><br><span class="line">    static const int value = N * 2; // 每个三明治需要两片面包</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;To make 5 sandwiches, you need &quot; &lt;&lt; BreadSlices&lt;5&gt;::value &lt;&lt; &quot; slices of bread.&quot; &lt;&lt; std::endl; // 输出 &quot;To make 5 sandwiches, you need 10 slices of bread.&quot;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-jqv"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/05/21/jqv/"
    >jqv</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/05/21/jqv/" class="article-date">
  <time datetime="2024-05-20T17:29:02.000Z" itemprop="datePublished">2024-05-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
  
</article>

    
    <article
  id="post-第六章 杆件的内力"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2024/05/20/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%9D%86%E4%BB%B6%E7%9A%84%E5%86%85%E5%8A%9B/"
    >第六章杆件的内力</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2024/05/20/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%9D%86%E4%BB%B6%E7%9A%84%E5%86%85%E5%8A%9B/" class="article-date">
  <time datetime="2024-05-20T07:11:49.000Z" itemprop="datePublished">2024-05-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer">

<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h3 id="杆件的内力"><a href="#杆件的内力" class="headerlink" title="杆件的内力"></a>杆件的内力</h3><h3 id="6-1-内力的定义及其符号规定"><a href="#6-1-内力的定义及其符号规定" class="headerlink" title="6.1 内力的定义及其符号规定"></a>6.1 内力的定义及其符号规定</h3><p>​	如何考察承受外载荷的杆件中的内力呢？可以想象用一个横截面将杆件截开，移走一部分，留下一部分作为考察对象，如图6.2所示。那么一走部分对留下部分一定存在着力学作用，由于外荷载作用的复杂性，截面上各部分的力的大小和方向都可能时不相同的，因而这种力学作用时一种分布力系。但是，无论这个分布力系多么复杂，总是可以将其简化为形心上沿坐标轴方向的三个主矢和主矩分量。</p>
<p><img src="https://p.sda1.dev/17/90260dae0de07e66c510844895cb082c/QQ%E6%88%AA%E5%9B%BE20240520183919.png"></p>
<blockquote>
<p>就是说，将外界的力分为不同的段，这样来便于研究不同的力的作用效果，后面的剪力图，弯矩图都是为了这一步而存在的。</p>
</blockquote>
<p>​	坐标系时这样建立的：坐标系的原点就放在形心处，x轴沿着杆件的轴线方向。可以看出，这三个主矢和主矩分量对于横截面的作用效果时不同的。</p>
<p>​	沿着x轴的主矢分量$F_x$有着使横截面沿x轴方向平移的趋势，如图6.3（a）所示。称这个主矢分量为<strong>轴力（axial force）</strong>，记为$F_N$.</p>
<p>​	沿着y轴的主矢分量$F_y$有着使横截面沿y轴方向错切的趋势，如图6.3（b）所示。称这个主矢分量为<strong>剪力（shearing force）</strong>，记为$F_S$.沿着y方向的剪力记为$F_{sy}$​容易看出，沿着z轴的主矢量也是一种剪力，如图6.3(c)，因而记为$F_{sz}$。<br>​	矢量方向沿着x轴的主矩分量$M_x$有着使横截面绕着x轴旋转的趋势。如图6.4(a)所示，称这个主矩分量为**扭矩(torque)**，记为T。</p>
<p>​	矢量方向沿着y轴的主矩分量有着使横截面绕着y轴转动的趋势，如图6.4(b)所示，称这样的主矩分量为**弯矩(bending moment)**，记为 $M_y$。矢量方向沿着v轴的弯矩记为$M$。容易看出，矢量方向沿着z轴的主矩分量也是一种弯矩，如图6.4(c)所示，因而记为 $M_z$​。</p>
<p><img src="https://p.sda1.dev/17/e3f1b59a1e7405bfafb84f1e35181f31/QQ%E6%88%AA%E5%9B%BE20240520183951.png"></p>
<p><img src="https://p.sda1.dev/17/aef937c109cce221c1da9caa8e559234/QQ%E6%88%AA%E5%9B%BE20240520184001.png"></p>
<blockquote>
<p>这里讲解了主矢和主矩的一些关系，按照这里建立的坐标系来区分，</p>
</blockquote>
<table>
<thead>
<tr>
<th>矢量类型</th>
<th>x轴</th>
<th>y轴</th>
<th>z轴</th>
</tr>
</thead>
<tbody><tr>
<td>主矢</td>
<td>$F_N$:axial force</td>
<td>$F_{sy}$:shearing force</td>
<td>$F_{sz}$:shearing force</td>
</tr>
<tr>
<td>主矩</td>
<td>$T$:torque</td>
<td>$M_y$:bending moment</td>
<td>$M_z$:bending moment</td>
</tr>
</tbody></table>
<p>​	这样，横截面形心处的三个主矢和三个主矩分量便可以按照它们对横截面及其附近区域变形的影响划分为<strong>轴力、剪力、扭矩和弯矩</strong>四种类型。这四种类型的作用统称为<strong>杆件横截面上的内力</strong>。<br>​	容易看出，对于承受外荷载作用的直杆，如果发生拉伸或压缩变形，横截面上一般都存在着轴力。如果发生扭转变形，则存在着扭矩。当杆件发生弯曲变形时，一般都存在着弯矩:在相当多的情况下，还存在着剪力。</p>
<blockquote>
<p>直杆的受力情况</p>
</blockquote>
<p>​	应该注意，在上面图中，<strong>内力不仅仅是作用在图中所标示出的断面上的，而且也是作用在被移走部分的断面上的</strong>，如图6.5中的轴力。这“两个”轴力事实上是同一个横截面上的轴力。虽然人们在这两个断面上观察这同一个轴力有相反的方向，但是它们使断面连同邻近区段的伸长变形趋势是相同的。这样，人们在定义某种内力的符号时，在同一个截面只定义个符号。同时，该符号是根据它所引起的截面附近微元区段的变形趋势而确定的。注意这<br>种方式与外力的符号定义方式是不同的。</p>
<blockquote>
<p>同一个符号其实对两边都起作用，就是对这个未切割前的截面起作用</p>
</blockquote>
<p>​	在横截面处取杆件的一个微元长度区段，如图6.6所示。图中的 4、B 两面与图 6.5中的4、8面相对应。如果把这个微元区段看成一个实体，那么图中的”方向就是这个区段两个端面的外法线方向。</p>
<p><img src="https://p.sda1.dev/17/40e0a8ce3ec1548db1aa2b16c254f7ca/QQ%E6%88%AA%E5%9B%BE20240520184009.png"></p>
<p>​	图6.7将截面上的四个内力分量的正负号规定表示了出来。图中上面一行均为正内力,<br>下面一行均为负内力。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>正向</th>
<th>逆向</th>
</tr>
</thead>
<tbody><tr>
<td>轴力</td>
<td>拉长</td>
<td>压缩</td>
</tr>
<tr>
<td>扭矩</td>
<td>右手大拇指背离截面</td>
<td>指向截面</td>
</tr>
<tr>
<td>剪力</td>
<td>顺时针</td>
<td>逆时针</td>
</tr>
<tr>
<td>弯矩</td>
<td>变凹趋势</td>
<td>变凸趋势</td>
</tr>
</tbody></table>
<p>​	人们规定，使微元区段有伸长趋势的轴力为正，使微元区段有缩短趋势的轴力为负，即拉为正，压为负，如图6.7(a)所示。这一规定也可以用数学的形式表示为:与微元区段两端面的外法线方向相同的轴力为正，与外法线方向相反的轴力为负。<br>​	使微元区段侧面母线有变为右手螺旋线趋势的扭矩为正;反之，变为左手螺旋线的趋势为负，如图6.7(b)所示。扭矩的正负号规定还可表述为:按矩的天量方向考虑，与微元区段两端面的外法线方向相同的扭矩为正，与外法线方向相反的扭矩为负。<br>​	使微元区段有左上右下错动趋势的剪力为正;反之，使微元区段有左下右上错动趋势的剪力为负，如图6.7(c)所示。这一规定也可以表述为:对微元区段内任意点有顺时针方向矩的剪力为正，有逆时针方向矩的剪力为负。利用上定为x小相先求规定立项<br>​	使微元区段有变凹趋势的弯矩为正，使微元区段有变凸趋势的弯矩为负，如图6.7(d)所示 。<br>​	应当指出，上述剪力和弯矩的正负规定与观察者的方位有关。</p>
<blockquote>
<p>这边说明了各种力的正向与反向</p>
</blockquote>
<h3 id="6-2-内力方程与内力图"><a href="#6-2-内力方程与内力图" class="headerlink" title="6.2    内力方程与内力图"></a>6.2    内力方程与内力图</h3><p>​	在一个杆件处于平衡状态时，它的任意一个区段都处于平衡状态。根据这一点，可以利用<strong>截面法</strong>来求出任意指定截面的内力。<br>​	例如，图6.8(a)所示的圆轴在轴向承受着分布荷载，在横向(注意:本书中杆件的“横向”固定地指垂直于杆件的轴线方向，而不是指水平方向;与此类似，杆件的“纵向”固定地表示沿着杆件的轴线方向，而不是指直方向)承受着<strong>集中力、分布荷载和集中力偶矩</strong>，此外，圆轴还承受使轴产生扭转趋势的转矩。<br>​	另外一方面，轴的两端存在着支承。它们对轴的支反力或支反力偶矩对轴而言仍然是一种外力。</p>
<blockquote>
<p>对这样的一个圆轴进行受内力和外力的总分析</p>
</blockquote>
<p>​	如果希望求出A截面处的内力，那么就可以想象用一个截面在处将轴切开，将其中一部分移走，留下另一部分。留下作为研究对象的这部分称为脱离体，也称自由体。显然，移走部分对脱离体的作用就体现为A截面上的内力，如图6.8(b)所示。</p>
<p><img src="https://p.sda1.dev/17/f2a37440edaef26a898feb0a1cfe624c/QQ%E6%88%AA%E5%9B%BE20240520184016.png"></p>
<p>​	脱离体的所有外力和内力一起构成平衡力系，即有<br>$$<br>\sum F_x&#x3D;0,\sum F_y&#x3D;0,\sum F_z&#x3D;0\\<br>\tag{6.1a}<br>$$</p>
<p>$$<br>\sum M_x&#x3D;0,\sum M_y&#x3D;0,\sum M_z&#x3D;0<br>\tag{6.1b}<br>$$</p>
<p>利用上述平衡方程，便可求解出相应的内力。一般地对于直杆，总是将件的轴线方向确定为x方向，内力表达为坐标x的函数，这就是内力方程。</p>
<p>​	显然，保留杆件左边部分所得出的内力与保留右边部分所得出的内力，<strong>各对应项应是大小相等、符号相同的</strong>。如果所保留的部分包含约束(铰、固定端等)，必须在用截面截开之前先求出约束反力，并将其作为外力的一个组成部分。</p>
<p>​	在许多情况下，可能无法预见内力的实际符号，这时不妨按照6.2节所建立的内力符号规定预先假定这些内力都是正的。例如，图6.8(b)中剪力$F_s$​就假定为箭头向下。</p>
<blockquote>
<p>这里我有一个问题，为什么前面讲到的是单位体的剪力顺时针时，符号为正，这边只有一个截面，该怎么判断截面的剪力是否为正。</p>
</blockquote>
<p>​	建立平衡式时，所有的外力和内力则应按照统一的符号规定写进方程之中。例如，在建立平衡方程$\sum F_y&#x3D;0$时,如果遵循作用力向上为正向下为负的规定,上一段落提到的剪力$F_s$项前面的符号就应为负。</p>
<blockquote>
<p>重新读了一下前面的解释，这边给到的微元区段时，其实模拟了两个截面，A、B两个面其实相互对应，这里的话，是左边的面，根据左上右下的规则，这里一定是负号。</p>
</blockquote>
<p>​	通过平衡方程式的求解，即可得到所求的内力。当然，如果方程解答的结果中内力为负值，那就表明截面的内力的实际作用方向与假设相反<br>​	根据内力方程，便可以画出相应的内力与杆件轴向坐标之间关系的图形，这就是内力图<br>下面举例说明内力方程的建立和相应内力图的绘制。<br>【例6.1】如图6.9的圆柱形等截面空心塔的材料密度为p，塔中瞭望台总重为P，塔体外径为D，内径<br>为d，求横截面上的内力。</p>
<blockquote>
<p>解:塔体可视为杆件。塔体是等截面的，因此，塔体的自重可简化为轴线方向上的均布荷载，这个均布<br>荷载的大小 $q&#x3D;\frac{1}{4}\rho g\pi(D^2-d^2)$。而瞭望台的重量可认为是在距上端h处加在轴线上的集中力。这样，塔体<br>可简化为图6.9(b)所示的力学模型。同时可以确认，截面上只存在着轴力。</p>
</blockquote>
<p>以塔顶处为原点，坐标x以竖直向下为正，建立如图6.9(b)的坐标系。用截面法求解此问题时，可选择<br>截面上方塔体为脱离体。注意到在离坐标原点h处即瞭望台处有一集中力P，因此截面取在瞭望台上方时脱<br>离体将不包含P，而截面取在瞭望台下方时脱离体将包含P。因此，应该分段建立轴力方程。<br>    第一步，先将截面取在瞭望台上方，如图6.9(c)所示。设轴力F为正，故方向向下。根据竖直方向上<br>的力平衡，可得<br>$$<br>F_{N1}+\frac{1}{4}(D^2-d^2)\pi\rho gx&#x3D;0<br>$$<br><img src="https://p.sda1.dev/17/351b15dad0693d76fe01e73dea9f861c/QQ%E6%88%AA%E5%9B%BE20240520184023.png"></p>
<p>由此可得<br>$$<br>F_{N1}&#x3D;-\frac{1}{4}(D^2-d^2)\pi\rho gx\tag{0&lt;&#x3D;x&lt;h}<br>$$<br>第二步，将截面放在瞭望台下方，如图6.9（d）所示。此时轴力记为$F_{N2}$,并有力平衡方程<br>$$<br>F_{N2}+\frac{1}{4}(D^2-d^2)\pi\rho gx+P&#x3D;0<br>$$</p>
<p>$$<br>F_{N2}&#x3D;-\frac{1}{4}(D^2-d^2)\pi\rho gx-P\tag{h&lt;x&lt;&#x3D;H}<br>$$</p>
<p>上面所得到的$F_{N1}$和$F_{N2}$​表达式便是本例中的轴力方程。根据这两个方程，可以画出相应的轴力图，如图6.9(e)所示。轴力图的x轴沿着塔体轴向，另一个与之垂直的轴用以表示轴力。注意到在坐标h处，即瞭望台位置处，轴力有一个突变，即集中力加载位置之前与之后轴力的绝对值增加了，增加的幅度就是集中力户的大小。</p>
<blockquote>
<p>就是利用每一个位置的小平衡</p>
</blockquote>
<p>【例6.2】 如图6.10(a)所示，使用丝锥时每手用力10N，假定各锥齿上受力相等，尺寸如图。试画出<br>丝锥的扭矩图。</p>
<blockquote>
<p>解:丝锥承受纯扭转作用，横截面上的内力只有扭矩。两手通过把手对丝锥的扭转作用可视为集中力偶<br>矩的作用。由于锥齿上所受的阻力可以视为均匀分布的,因此加工件对丝锥的作用可视为均布力偶矩的作用。<br>这样，丝锥可简化为如图6.10(b)所示的力学模型。</p>
</blockquote>
<p>作用在丝锥顶部的力偶矩<br>$$<br>m&#x3D;2\times 150\times10&#x3D;3000 Nmm<br>$$</p>
<p>由于丝锥所受的全部外荷载构成平衡力系，所以作用在齿部的分布力偶矩<br>$$<br>t&#x3D;\frac{3000}{20}&#x3D;150Nmm&#x2F;mm<br>$$<br>​	可以根据上述数据列出扭矩方程，再画出扭矩图，也可以直接考虑扭矩图。先在AB区间内任意取一个截面，取左边部分为脱离体，那么这个截面上的扭矩T都与m平衡，因此，在这个区段内的扭矩是常数。对应的扭矩图轮廓线是平行于横轴的直线。而且，截面上的扭矩的旋向与左端m的旋向相反因此其扭矩为负值。从B到C的区间内，仍取左边部分为离体，随着反向的均布力偶矩的逐渐加入，扭矩绝对值必定会逐渐地成比例地减小，因而相应的扭矩图必定是斜直线。在锥右端C截面处，全部外力已构成平衡力系，因而扭矩为<br>由此 ，便可画出构件的扭矩图，如图6.11所示。</p>
<p><img src="https://p.sda1.dev/17/4b6b03cd57e84632500a98c0aae13924/QQ%E6%88%AA%E5%9B%BE20240520184029.png">)</p>
<blockquote>
<p>类比载荷力，力矩也是可以载荷分布的，作用于整个物体就是全为一个数，如果由整个面作用，就是按长度分布的。</p>
</blockquote>
<p><img src="https://p.sda1.dev/17/af0fd4d26c32346d9d115f19e3ae8bb0/QQ%E6%88%AA%E5%9B%BE20240520184035.png"></p>
<p>【例6.3】求图6.12(a)所示的承受均布荷载的简支梁内力方程，并画出相应的剪力图和弯矩图。</p>
<blockquote>
<p>解:把坐标系原点取在梁的左端。</p>
</blockquote>
<blockquote>
<p>先求出支反力，易于看出，左右两端铰处的支反力均为$\frac{1}{2}ql.$</p>
<p>在坐标为x处作截面，取左段为脱离体。在截面处，假设有正的剪力$F_s$和正的弯矩$M$，如图6.12(b)所示，然后建立平衡方程。</p>
</blockquote>
<p>​	由$\sum F_x&#x3D;0$ 可得<br>$$<br>\frac{1}{2}qL-qx-F_s(x)&#x3D;0<br>$$<br>即河得剪力方程<br>$$<br>F_s(x)&#x3D;\frac{1}{2}ql-qx\tag{1}<br>$$<br>​	对截面取矩，由$\sum m&#x3D;0$可得<br>$$<br>\frac{1}{2}qx^2-\frac{1}{2}qLx+M(x)&#x3D;0<br>$$<br>即可以得到弯矩方程<br>$$<br>M(x)&#x3D;\frac{1}{2}qx（L-x）\tag{2}<br>$$</p>
<blockquote>
<p>以中点取矩<br>$$<br>\frac{1}{2}<br>$$</p>
</blockquote>
<p>​	注意到剪力方程①中，剪力是坐标x的线性函数，因此相应的剪力曲线是一条直线。在这种情况下，可以由两点来确定这条直线。例如，在x&#x3D;0处$F_s&#x3D;\frac{1}{2}qL$;在x&#x3D;L处$F_s&#x3D;-\frac{1}{2}qL$由此即可画出相应的剪力图，如图6.13(a)所示。<img src="https://p.sda1.dev/17/766c739787dd1415f99ba7697fd2d5c4/QQ%E6%88%AA%E5%9B%BE20240520184042.png"></p>
<p>​	弯矩方程②中，</p>
<p>弯矩$M$是坐标x的二次函数，因此弯矩曲线是一条抛物线，此时可以由两端和中点这三点的弯矩值来确定这条曲线，如图6.13（b)所示。</p>
<p>​	从上例可以得出这样的结论:直梁某截面上的剪力在数值上等于该截面左端(如果脱离体取为左端部分)或者右端(如果脱离体取为右端部分)所有向力(包括支反力)的代数和。代数和中各项的符号可以这样确定:与所求剪力方向相同的横向力取负，方向相反的<br>向力取正。<br>​	与此类似，直梁某截面上的弯矩在数值上等于该截面左端(如果脱离体取为左端部分)或者右端(如果脱离体取为右端部分)所有横向力(包括支反力)对于该截面的矩，以及所有力偶矩的代数和。代数和中各项的符号可以这样确定:与所求弯矩方向相同的矩取负，方向相反的矩取正。<br>​	利用上述性质，可以很快地确定梁中某指定截面的剪力和弯矩。<br>​	应充分重视和熟悉约束处内力的性质。图6.14中画出了一些常见的约束情况(上一排)</p>
<p><img src="https://p.sda1.dev/17/f768a2fcfca1bf1c24c00ce2c441792d/QQ%E6%88%AA%E5%9B%BE20240520184047.png"></p>
<p>及其相应的简化图形(下一排)。读者可自行对这些约束处的内力特点进行分析。例如，在图6.14(b)、(c)、(d)中，如果铰附近没有集中力偶矩作用，则该处弯矩为零。<br>    在例6.3中，分别用了一个式子，就表示了全梁的剪力方程和弯矩方程。但是，梁弯曲的绝大多数情况并非如此简单。例如图6.15(a)所表示的外伸梁,如果在图6.15(b)和图 6.15(c)这两种不同位置取截面，可以看出，图6.15()的脱离体多出一个集中力作用;同时，在B截面右面，不再有均布荷载作用，因此，AB区段和BC区段的剪力弯矩方程必定是不同的。同理，BC区段和CD区段的剪力弯矩方程也是不同的，所以，这个梁的方程应分三个区段建立。其脱离体一般可以按图6.15(b)、(c)、(d)三种情况截取。</p>
<p><img src="https://p.sda1.dev/17/d6eb6b71591c8d0fb0dc33a347fedccc/QQ%E6%88%AA%E5%9B%BE20240520184054.png"></p>
<p>【例6.4】如图6.16(a)所示的曲梁是四分之一圆，求这个曲梁的内力。</p>
<blockquote>
<p>解:对于曲梁，把截面形心处的主矢和主矩按照截面的法线方向和切面方向定义为轴力、剪力、扭矩和<br>弯矩。在本例的曲梁中，外力F就作用在曲梁所在的平面中，因此截面上的内力应该包含轴力、剪力和弯矩<br>这三种。<br>同样可用截面法求解这一问题。如图6.16(b)所示，在与过圆心0的竖直线成α角的方位上取截面，把<br>截下的右上部作为脱离体。在截面上，分别假设轴力(沿截面法向)、剪力(沿截面切向)和弯矩的作用方<br>向如图6.16(b)所示，然后将轴力、剪力和弯矩分别表示为a的函数，即内力方程。</p>
</blockquote>
<p>根据脱离体的平衡可得<br>轴力:				$F_N&#x3D;F\cos\alpha$<br>剪力:				$F_s&#x3D;F\sin\alpha$<br>弯矩:				$M&#x3D;-FR(1-\cos\alpha)$</p>
<p><img src="https://p.sda1.dev/17/973ed8f965ae686e90957884e3f958a2/QQ%E6%88%AA%E5%9B%BE20240520184100.png"></p>
<p>上面式中各内力的符号可采用与直梁类似的规定，只不过观察者应进入曲梁所包围的区域之内。在曲梁中任取一个截面，保留左边部分，在截面上均为正号的轴力、剪力、弯矩如图6.17(a)所示。图6.17(b)则表示了保留右边部分均取正号的各内力方向。</p>
<h2 id="梁的平衡微分方程及其应用"><a href="#梁的平衡微分方程及其应用" class="headerlink" title="梁的平衡微分方程及其应用"></a>梁的平衡微分方程及其应用</h2><p>​	由于梁弯曲问题的重要性，在本小节中，将专门讨论梁的弯曲内力，即剪力和弯矩。在<br>上小节中，用截面法可以建立剪力和弯矩的方程，由此可以画出剪力图和弯矩图，并可以进<br>一步确定人们所关心的关键截面上的剪力和弯矩值。但是，如果梁中存在着不同荷载形式时，<br>必须分段讨论建立方程，这是比较繁琐的。有没有可能更快速便捷地画出内力图，得到关键<br>截面的内力值呢?这便是本小节要解决的主要问题。显然，当梁承受横向荷载产生弯曲变形<br>时，其内力是由外荷载引起的，因此剪力和弯矩必定与外荷载之间存在着某种函数关系。本<br>小节将分别讨论几种典型荷载作用下的这种关系，然后再利用这种关系，根据外荷载直接画<br>出剪力弯矩图。</p>
<h3 id="6-3-1-梁的平衡微分方程"><a href="#6-3-1-梁的平衡微分方程" class="headerlink" title="6.3.1 梁的平衡微分方程"></a>6.3.1 梁的平衡微分方程</h3><p>​	首先考虑在分布力作用的情况下，荷载9、剪力F和弯矩M之间存在的关系。<br>​	在有分布力 $q(x)$作用的梁上取出一个微元长度区段，其长度为$dx$，如图6.18所示。坐<br>标系$x$轴正向水平向右，$y$轴竖直向上。荷载$q$向上为正。由于$dx$很小，故可认为在微元区<br>段内$q$为常数。微元段左侧面有剪力$F$和弯矩$F$。在右侧面,由于所在的坐标比左侧面多出 $dx$,<br>因而剪力弯矩都有了增量而分别成为$F_s+dF_s$和$M+dM$。由v方向上力的平衡可得<br>$$<br>F_s+qdx-(F_s+dF_s)&#x3D;0<br>$$<br>由之可知<br>$$<br>q&#x3D;\frac{dF_s}{dx}<br>$$<br>再对微元区段右截面中点取矩可得<br>$$<br>M+dM-M-F_sdx-\frac{1}{2}q(dx)^2&#x3D;0<br>$$<br>注意到上式中的$(dx)^2$是二阶微量，因而可以忽略不计，由此可得<br>$$<br>F_S&#x3D;\frac{dM}{dx}<br>$$<br>两个式子都称作梁的平衡微分方程(differential equations of equibrium).</p>
<p>​	由梁的平衡微分方程可以导出，在梁的A截面到B截面之间（B截面在A截面右边），如果只有分布力作用。那么便有。<br>$$<br>F_s(B)&#x3D;F_s(A)+\int_{A}^{B}q(x)dx\\<br>M(B)&#x3D;M(A)+\int_{A}^{B}F_s(x)dx<br>$$<br>由式(6.3a)可知，从 A截面到B截面剪力的增量等于 AB区段内横向分布力的总量。或者说，<br>等于 AB区段内分布荷载图的面积，即图6.19中灰色区域的面积。显然，如果在 AB区段内q<br>是常数，式(6.3a)便可进一步简化为</p>
<p>同样，由式(6.3b)可知，从A截面到B截面弯矩的增量等于AB区段内剪力图的面积<br>此处应注意，剪力图在横轴下方的部分，其“面积”应是负数。<br>由式(6.2)和式(6.3)，还可以得到一系列有意义的结论。<br>如果在 AB区段内没有任何荷载作用，那么剪力在此区段内必定是常数，因而相应的剪力<br>图线必定是平行于x轴的直线:而弯矩必然是x的线性函数，弯矩图线必定是斜直线。进一<br>步地，如果这个区段内剪力图线位于横轴上方，即剪力为正，则对应的弯矩图线向右上倾斜:<br>反之，如果剪力图线位于横轴下方，即剪力为负，则弯矩图线向右下倾斜:如果剪力在此区<br>段内恒等于零，则对应的弯矩图转化为平直线了，如图6.20所示。<br>如果从A截面到B截面有均布荷载g的作用，那么剪力函数必定是x的线性函数，因而</p>
<p>6.3.2 梁承受集中荷载的情况<br>应该注意，梁的平衡微分方程只是在梁的微元长度段上承受分布力的情况下导出的。如<br>果出现其他形式的荷载，则可以根据微元的力平衡和力矩平衡推导出其他形式的方程。<br>集中力和集中力偶矩作用，是梁中经常出现的情况。下面将考虑它们对剪力和弯矩的影<br>响。如图6.21(a)所示，梁中A处有集中力F的作用。在A处取微元区段x，将集中力作用<br>点的左侧面的剪力记为F，右侧面的剪力记为。根据力平衡即可得<br>F*&#x3D;F+F<br>(6.4)<br>这就是说，集中力F的作用使剪力在其作用处产生一个大小为F的增量。因此，如果从左到<br>右地考虑集中力作用处剪力图的变化，那么剪力图在此处将会产生一个跃变，跃变的方向与<br>作用力方向相同，跃变的幅度就是作用力的大小，如图6.21(b)所示。<br>另一方面，由于在集中力作用点以前和以后的区段内剪力数值有了差异，也就是作为弯<br>矩导数的数值有了差异，因而弯矩图线在该点处的斜率有了差异。这样，弯矩图线在该处必<br>定会出现一个不光滑点，即尖角。尖角的朝向与集中力方向相反，如图6.21(c)所示。</p>
<p>用同样的方式考察集中力偶矩对弯矩的影响，如图6.22(a)所示。设在A处有顺时针方向<br>作用的集中力偶矩m，而把A偏左截面的弯矩记为M，偏右截面的弯矩记为M<em>，根据矩<br>的平衡可得<br>M</em>&#x3D;M-+m<br>(6.5)<br>这说明，集中力偶矩m使得其作用点处的弯矩产生了一个大小为m的增量。如果从左到右地<br>观察相应弯矩图的变化就会发现，若力偶矩作用是顺时针方向的，弯矩图则向上跃变，如图<br>6.22(b)所示;若力偶矩作用是逆时针方向，弯矩图则向下跃变;跃变的幅度就是m。<br>由于力偶矩的作用不直接影响作用点处微元段处力的平衡，因此作用点处左右两侧面的<br>剪力值不会因为力偶矩的作用而产生差异。<br>要注意上述规律是与一定的坐标系相对应的。这个坐标系就是:x轴正向水平向右，纵轴<br>剪力和弯矩都取向上为正。有的教材和文献规定弯矩图纵轴正向朝下，那么上述有关弯矩图</p>
<p>的规律便刚好相反，这一点请读者注意。同时，上面所叙述的规律都是按图形从左到右的顺<br>序得到的，如果从右到左地观察图形，这些规律也应相应地予以修正。<br>6.3.3<br>根据外荷载画剪力弯矩图<br>利用上两小节所得到的一系列结论，便可以根据外荷载直接画出梁的剪力弯矩图。一般<br>总是把坐标原点放在梁的最左端。在画图时应注意以下的要点。<br>①首先求出约束处的支反力及支反力偶矩。求出之后，支反力及支反力偶矩便与其他外<br>荷载同等看待。<br>②根据各个荷载作用的位置将梁划分为若干个区段，从左到右依次画出连续的图线<br>③ 应根据荷载、剪力、弯矩之间的微分关系明确图线的走向,并根据式(6.3)~式(6.5)确<br>定各荷载作用处剪力和弯矩的数值。<br>4图形最左端应从原点开始，右端的结束点应该在横轴上。<br>⑤注意标出图形转折点和局部极值点的数值。<br>下面便用一个实例来说明剪力弯矩图的画法。<br>图6.23(a)是一个长度为2a的简支梁，前半段承受向下的均布荷载q，中点处承受顺时针<br>方向的集中力偶矩 qa。<br>先求支反力。对左端铰A取矩，即可求出C处的支反力为向上作用的ga。对右端铰C取<br>即可求出A处的支反力为向上作用的-ga。这两个支反力已用虚线标注在图6.23(a)中了。<br>矩，<br>画出剪力图的坐标系后即可开始画剪力图，如图6.23(b)所示。原点对应着左端面A。首<br>先注意到，4处有向上的集中力一ga，因此剪<br>力图线有一个向上的跃变,从而使剪力值从零升<br>至qa。从A到B之间有向下的均布力，因而<br>da主A<br>剪力图线应向右下倾斜。由于AB间向下的均布<br>力作用总量为qa，因此其剪力值也应下降qa，<br>即从-ga下降到–qa。容易看出，这条倾斜<br>qd:<br>的剪力图线在离A点-a处穿越了横轴。<br>3qa&#x2F;4<br>(a)<br>A&#x2F;A<br>(6)<br>在B处有一个集中力偶矩的作用，但它并不<br>直接影响剪力图的走势。从B到C之间没有任何<br>荷载作用，因此剪力图线保持水平直线直到C。</p>
<p>程中肯定存在错误;或者，在开始时支反力的求解就有错误，<br>建立弯矩图的坐标系后即可开始画弯矩图，如图6.23(c)所示。在左端 A 处结构为铰，<br>而且没有集中力偶矩作用，因此A处弯矩是零。从A到B之间剪力图向右下倾斜，故弯矩<br>线为凸的抛物线。由于A点偏右处剪力值为正数ga，因而弯矩图线从A处开始时应向着右上<br>方倾斜延伸。<br>注意到剪力图在距左端-a处穿越横轴，因此抛物线将在该处达到局部极大值之后转而<br>向右下倾斜延伸。由于左端铰处弯矩为零,这个局部极大值就等于零到-a处剪力图的面积<br>也就是<br>329a<br>B处的弯矩值应为AB之间剪力图面积的代数和，注意横轴下方的面积为负值，因而B<br>处的弯矩值是–qa’。抛物线在这个位置上达到了它的终点。<br>由于B处有一个顺时针方向的集中力偶矩，因而该处弯矩图线有一个向上的跃变。跃变<br>的幅度即力偶矩的大小 qa’，因此弯矩数值从–qa’升至 qa’。<br>从B到C，由于相应区段的剪力图线是横轴下方的一条平直线，因而弯矩图线应该是向<br>右下方倾斜的直线。在此区间，弯矩值下降的幅度等于此区间内剪力图的面积，即二ga’。这<br>使得弯矩图线结束在横轴上。由于C处梁为铰支承，而且没有集中力偶矩作用，因而弯矩应<br>该是零，这一点印证了所画出的弯矩图的正确性。<br>上面的例子详细地说明了剪力弯矩图的作法。在计算各处剪力弯矩值时，上面用到了式<br>(6.3)所表述的“几何”的方法;同时，计算也可以采用上节中所表述的“力学”的方法(即<br>“直梁某截面上的剪力在数值上等于该截面左端所有横向力的代数和”等)。这两类方法可以<br>视情况灵活地交替使用。<br>在实际作图过程中，除了熟练地应用上两小节所叙述的一系列图线走向的规律之外，还<br>应熟练掌握梁的支承处的剪力弯矩特点。<br>同时，还应观察结构及其受力特点。例如在图6.24(a)中，形成了对称结构承受对称<br>荷载的情况。画出内力图后就会发现，它的剪力图是关于中点反对称的，而弯矩图则是<br>关于中点对称的。这一特点可以这样定性地说明:如果荷载是关于中点对称的，那么，<br>若以中点为原点，荷载便可以表达为一个偶函数。通过式(6.3a)和式(6.3b)的积分，<br>剪力便是奇函数，弯矩便是偶函数。这样，剪力图便关于中点反对称，弯矩图便关于中</p>
<p>点对称。<br>根据同样的理由，如图6.24(b)所表示的那样，对称结构承受反对称荷载，其剪力图对称<br>而弯矩图反对称。<br>6.3.4 弯矩的峰值<br>由于弯矩在梁的强度计算中将起到很重要的作用，因此本小节将特别讨论弯矩的局部极<br>值，也就是弯矩的峰值。在弯矩图中，这些峰值应特别地标示出其数值，如图6.23(c)中的三<br>个弯矩值。</p>
<p>容易看出，弯矩的峰值一般会出现在下面几种情况下:在有分布荷载作用的区段，若某<br>截面的剪力为零，则该截面处就会出现弯矩的局部极值，如图6.23中距左端处，就有弯<br>32:在集中力作用处(包括支座)，弯矩图会出现尖点，这些尖点就可能构成弯矩<br>矩峰值 ga<br>的峰值:同时，在集中力偶矩作用处，弯矩会产生跃变，跃变前后的弯矩值也都会成为弯知<br>的峰值。<br>在全梁上考虑绝对值最大的弯矩时，梁的端点处也是值得注意的地方，例如图6.25中承<br>受均布荷载的简支梁，由于其两端作用有集中力偶矩，其绝对值最大的弯矩并没有出现在剪<br>力为零处，而是出现在左端面，如图6.26所示。</p>
<p>对于更为复杂的问题，则需要将各方面的因素综合加以考虑。下面用两个例子来说明。<br>【例6.5】如图6.27所示的承受均布荷载的简支梁长度为L，为了提高它的承载能力，可以考虑它的两<br>个支座关于中截面对称地向中点移动，记移动的距离为图中的a。欲使梁中绝对值最大的弯矩为最小，求a<br>与L之比:并求这样移动后,梁中绝对值最大的弯矩所下降的百分数。<br>解:由于结构关于中点对称，因此两个支座的支反力均为只要两个支座不靠近中点，梁的弯矩图就具有图6.28(a)的形式。其中<br>在D截面具有最大的负弯矩M，中截面C处具有最大的正弯矩Mc。<br>它们构成两个弯矩峰值。D截面的弯矩就是AD长度上均布荷载对D截面的矩，故有而C截面的弯矩是AC长度上均荷载q对C截面的矩与支座反力对C截面矩的代数和，因而有显然，Mc和M的数值随着a的变化而变化。为了了解这两个弯矩峰值关于a的变化规律，图6.28(b)中画出了它们关于a的函数图像。从图中可以看出，随着a的增加，M的绝对值趋于增加，而M趋于减小。因此，要使梁中绝对值最大的弯矩为最小，应取两条弯矩曲线的交点处的弯矩，即两个弯矩峰值的绝对值应该相等，故取</p>
<p>由之可解出</p>
<p>​	支座移动前，其最大弯矩为M…–qL。按上述比例移动后，最大弯矩</p>
<p>故弯矩降低的比例</p>
<p>个降低的百分比是很高的</p>
<p>【例6.6】如图6.29所示，自重$W&#x3D;20kN$的简易起重机两轮间距为16m，起重机自身重心位于两轮中点。起重机可在跨度为$5m$的简支梁上来回运行，求起吊重量$F&#x3D;5kN$时梁中的最大弯矩。<br>    解:起重机与起吊重物对横梁的作用体现为两轮C和D处对横梁的集中力P和P2，如图6.30(a)所示。<br>以起重机为研究对象，分别对C和D取矩可得(为方便计算，本题中长度的单位取m，力的单位取kN)<br>$$<br>P&#x3D;6.25kN，P&#x3D;18.75 kN<br>$$<br>由于横梁上只有集中力$P_1$和$P_2$作用，因而其弯矩图必定为图$6.30(b)$所示的形状，且峰值一定出现在C、D两个截面处。</p>
<p>​	由于起重机可移动，因此梁中的弯矩将随着起重机的移动而发生连续的变化。针对这种情况，可引入一个表示起重机位置的参量，并将弯矩峰值表达为该参量的函数。假定起重机左轮C处与梁左端铰的距离为x，如图6.30(a)所示。对B取矩，便可得左端铰处的支反力<br>Ã &#x3D;-[6.25x(5-x)+18.75x(5-x-1.6)]<br>R,&#x3D;19-5x(kN)<br>良萨<br>由此可得C、D两个截面处的弯矩<br>Mc&#x3D;Rx&#x3D;19x-5x(kN.m)<br>M,&#x3D;R(x+1.6)-1.6P<br>&#x3D;20.4+11x-5x(kN.m)<br>R<br>800<br>800<br>5 m<br>图 6.29<br>起重机简图<br>P<br>P<br>1.6 m<br>5 m<br>(a)<br>Ms<br>M<br>(b)<br>图6.30 梁中的弯矩使C截面弯矩取极值的x应满足<br>dM&#x3D;19-10x&#x3D;0，即x&#x3D;19m<br>dx<br>Mc&#x3D;19x1.9-5x1.9’&#x3D;18.05 kN.m<br>使D截面弯矩取极值的x应满足<br>dM2&#x3D;11-10x&#x3D;0，即x&#x3D;11m<br>dr<br>M&#x3D;20.4+11x1.1-5x1.1&#x3D;26.45 kN·m<br>由此可知，当起重机左轮C与简支梁左端铰的距离为1.1m时，起重机右轮D处截面的弯矩值<br>26.45kN·m是起重机移动过程中梁中产生的最大弯矩。<br>故有<br>故有<br>下面将上面的问题做一个更加一般性的讨论。如图6.31所示,简支梁承受一组集中移动荷载(E,F,…<br>F)的作用，这些力的间距不变。求这个梁的绝对值最大的弯矩。<br>F<br>F<br>a&#x2F;2a&#x2F;2<br>L&#x2F;2<br>L12<br>图6.31 移动荷载作用<br>在(F，尸，…，F)作用下，无论荷载在梁上的任何位置，弯矩图的峰值点总是发生在集中荷载的作<br>用点，由此可以认为绝对最大弯矩一定发生在某一荷载作用截面。下面先任选某一个集中荷载，来讨论移动<br>荷载处于什么位置时，该荷载的作用截面的弯矩达到最大值。由于移动荷载个数是有限的，就可求出各荷载<br>作用截面的最大弯矩，从而确定绝对最大弯矩。设F与A点的距离为x，梁上荷载的合力F与F 的作用线<br>之间的距离为 a。<br>由M。&#x3D;0得<br>F &#x3D;F l-x-a<br>L<br>当F位于F的左侧时，则F作用截面的弯矩为<br>M&#x3D;F x-M &#x3D;£(-x-@)x-M<br>式中，M，表示F，以左梁上的所有荷载对F、作用点的力矩总和，它是一个与x无关的常数。根据极<br>值条件，有<br>由式①可得绝对最大弯矩的位置，即<br>dMF(L-2x-a)<br>&#x3D;0<br>Ax<br>a<br>N<br>4<br>巴</p>
<p>同理，当只 位于后的右侧时，可求得x&#x3D;-+”为发生绝对最大弯矩的位置。故简支梁发生绝对最大<br>弯矩所在截面由下式确定<br>x之巧<br>式 ③ 表明，当F 与荷载合力尸 对称于跨中截面时，F,作用点的截面上弯矩为最大值，其值为<br>M.–(LFa)-M<br>4</p>
<p>在应用式③和式④计算荷载作用处截面最大弯矩时，应该注意的是:<br>①F在F右方时，a取正值:F在F左方时，a取负值。<br>②F 是实际荷载的合力。在F 和F对称于跨中截面时，可能有的荷载不再位于梁上，或有新的荷载<br>进入梁上，这时应重新计算合力和作用位置。<br>按上述方法可算出每一个荷载作用处截面的最大弯矩，并加以比较，其中最大者就是绝对最大弯矩</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
   
  
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2024
        <i class="ri-heart-fill heart_icon"></i> SHIOKOU
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="SHIOKOU"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2024/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>帮我买张OST吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->
 <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js"></script>
<script src="https://cdn.staticfile.org/mathjax/2.7.7/config/TeX-AMS-MML_HTMLorMML-full.js"></script>
<script>
  var ayerConfig = {
    mathjax: true,
  };
</script>

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=756277&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    
<script>
  const password = "22360408";
  const lock_password = window.sessionStorage.getItem("lock_password");
  console.log(password, lock_password);
  if (lock_password !== password) {
    Swal.fire({
      title: "Please enter password",
      input: "text",
      inputAttributes: {
        autocapitalize: "off",
      },
      showCancelButton: false,
      showLoaderOnConfirm: true,
      allowOutsideClick: false,
      confirmButtonText: "Ok",
    }).then((result) => {
      console.log(result);
      if (result.isConfirmed) {
        console.log(password);
        if (result.value === password) {
          window.sessionStorage.setItem("lock_password", result.value);
        } else {
          Swal.fire({
            icon: "error",
            title: "Incorrect password, please try again",
            confirmButtonText: "Ok",
            allowOutsideClick: false,
          }).then(() => {
            window.location.reload();
          });
        }
      }
    });
  }
</script>


  </div>
</body>

</html>