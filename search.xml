<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MIT 6.006 Introduction to Algorithms</title>
    <url>/2025/01/17/Algorithms/</url>
    <content><![CDATA[<p><strong>Lecture Overview</strong></p>
<p>•	 Administrivia </p>
<p>•	Course Overview </p>
<p>•	“Peak finding” problem — 1D and 2D versions</p>
<p><strong>Course Overview</strong></p>
<p>This course covers: </p>
<ol>
<li><p>Efficient procedures for solving problems on large inputs (Ex: U.S. Highway Map, Human Genome) </p>
</li>
<li><p>Scalability </p>
</li>
<li><p>Classic data structures and elementary algorithms (CLRS text) </p>
</li>
<li><p>Real implementations in Python </p>
</li>
<li><p>Fun problem sets!</p>
</li>
</ol>
<p>The course is divided into 8 modules — <strong>each of which has a motivating problem and problem set(s) (except for the last module)</strong>. Tentative module topics and motivating problems are as described below:</p>
<ol>
<li>Algorithmic Thinking: Peak Finding</li>
<li>Sorting &amp; Trees: Event Simulation</li>
<li>Hashing: Genome Comparison</li>
<li>Numerics:  RSA Encryption</li>
<li>Graphs: Rubik’s Cube</li>
<li>Shortest Paths: Caltech → MIT</li>
<li>Dynamic Programming: Image Compression</li>
<li>Advanced Topics</li>
</ol>
<p><strong>Peak Finder</strong></p>
<p><strong>One-dimensional Version</strong></p>
<p>Position 2 is a peak if and only if b ≥ a and b ≥ c. Position 9 is a peak if i ≥ h.</p>
]]></content>
      <tags>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Github:Git操作</title>
    <url>/2022/06/23/Github%EF%BC%9AGit%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h2><p>一般工作流程</p>
<ul>
<li>克隆Git资源作为工作目录。</li>
<li>在克隆的资源上添加或修改文件</li>
<li>如果其他人修改了，你可以更新资源</li>
<li>在提交前查看修改</li>
<li>提交修改</li>
<li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li>
</ul>
<p><img src="https://p.sda1.dev/18/2fd9786efda6a8c9caa00586196f4d11/d04c8f15892553dd9f987d55ae96596d.png"></p>
<h2 id="Git工作区、暂存区和版本区"><a href="#Git工作区、暂存区和版本区" class="headerlink" title="Git工作区、暂存区和版本区"></a>Git工作区、暂存区和版本区</h2><ul>
<li>工作区：就是你在电脑里能看到的目录。</li>
<li>暂存区（stage or index）；一般存放在.git目录下的index文件中，所以我们把暂存区有时也叫作索引（index）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.git/index</span><br></pre></td></tr></table></figure>

<ul>
<li>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="工作区、版本库的暂存区和版本库之间的关系"></p>
<ul>
<li>左侧为工作区，右侧为版本库。在版本库中标记为“index”的区域是暂存区（stage&#x2F;index），标记为“master”的是master分支所代表的目录树。</li>
<li>图中我们可以看出此时“HEAD”实际上是指向master分支的一个“游标”。所以图中的HEAD可以用master来替换。</li>
</ul>
<ul>
<li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git&#x2F;objects” 目录下，里面包含了创建的各种对象及内容。</li>
<li>当对工作区修改（或新增）的文件执行 <strong>git add</strong> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li>
<li>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li>
<li>当执行 <strong>git reset HEAD</strong> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li>
<li>当执行 <strong>git rm –cached <file></file></strong> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li>
<li>当执行 <strong>git checkout .</strong> 或者 <strong>git checkout – <file></file></strong> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。</li>
<li>当执行 <strong>git checkout HEAD .</strong> 或者 <strong>git checkout HEAD <file></file></strong> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2015/02/git-command.jpg" alt="img"></p>
<h1 id="Git创建仓库"><a href="#Git创建仓库" class="headerlink" title="Git创建仓库"></a>Git创建仓库</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<p>Git使用该命令来初始化一个Git仓库，Git的很多命令都需要在Git的仓库中运行。</p>
<p>在进行完这步操作之后，Git仓库会生成一个.git目录，该目录包含了资源的所有元数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init newrepo</span><br></pre></td></tr></table></figure>

<p>这一步是将指定的目录作为Git仓库。而我们想要存入文件，以及将它们纳入版本控制就需要下面这样操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &#x27;初始化项目版本&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注：</strong> 在 Linux 系统中，commit 信息使用单引号 **’**，Windows 系统，commit 信息使用双引号 **”**。</p>
<p>所以在 git bash 中 <strong>git commit -m ‘提交说明’</strong> 这样是可以的，在 Windows 命令行中就要使用双引号 **git commit -m “提交说明”**。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone</span><br></pre></td></tr></table></figure>

<p>我们使用git clone的命令从现有Git仓库中拷贝项目（类似swn checkout）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone &lt;repo&gt;</span><br></pre></td></tr></table></figure>

<p>如果需要指定目录，则指令为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure>

<p>例子：比如我们要克隆hexo的小插件的Git代码仓库，可以用下面的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/theme-next/hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p>git的配置使用<strong>git config</strong>的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">credential.helper=osxkeychain</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=true</span><br><span class="line">core.bare=false</span><br><span class="line">core.logallrefupdates=true</span><br><span class="line">core.ignorecase=true</span><br><span class="line">core.precomposeunicode=true</span><br></pre></td></tr></table></figure>

<p>编辑git配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config -e#正对当前仓库</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config -e --global#针对系统上所有仓库 </span><br></pre></td></tr></table></figure>

<p>设置提交代码时的用户的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name&quot;shiokou&quot;</span><br><span class="line">$ git config --global user.email shiokou0408@gmail.com</span><br></pre></td></tr></table></figure>

<p>如果去掉–global参数只对目前仓库有效。</p>
<h1 id="GIT操作"><a href="#GIT操作" class="headerlink" title="GIT操作"></a>GIT操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add</span><br><span class="line">$ git commit</span><br></pre></td></tr></table></figure>

<ul>
<li>git init:初始化仓库</li>
<li>git add：添加文件到暂$存区</li>
<li>git commit：将暂存区内容添加到仓库中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clone</span><br></pre></td></tr></table></figure>

<p>拷贝一份远程仓库，也就是下载一个项目</p>
<h2 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h2><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p>
<p>下表列出了有关创建与提交你的项目的快照的命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git add</code></td>
<td align="left">添加文件到暂存区</td>
</tr>
<tr>
<td align="left"><code>git status</code></td>
<td align="left">查看仓库当前的状态，显示有变更的文件。</td>
</tr>
<tr>
<td align="left"><code>git diff</code></td>
<td align="left">比较文件的不同，即暂存区和工作区的差异。</td>
</tr>
<tr>
<td align="left"><code>git commit</code></td>
<td align="left">提交暂存区到本地仓库。</td>
</tr>
<tr>
<td align="left"><code>git reset</code></td>
<td align="left">回退版本。</td>
</tr>
<tr>
<td align="left"><code>git rm</code></td>
<td align="left">将文件从暂存区和工作区中删除。</td>
</tr>
<tr>
<td align="left"><code>git mv</code></td>
<td align="left">移动或重命名工作区文件。</td>
</tr>
<tr>
<td align="left"><code>git checkout</code></td>
<td align="left">分支切换。</td>
</tr>
<tr>
<td align="left"><code>git switch （Git 2.23 版本引入）</code></td>
<td align="left">更清晰地切换分支。</td>
</tr>
<tr>
<td align="left"><code>git restore （Git 2.23 版本引入）</code></td>
<td align="left">恢复或撤销文件的更改。</td>
</tr>
</tbody></table>
<h2 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h2><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git log</code></td>
<td align="left">查看历史提交记录</td>
</tr>
<tr>
<td align="left"><code>git blame &lt;file&gt;</code></td>
<td align="left">以列表形式查看指定文件的历史修改记录</td>
</tr>
</tbody></table>
<h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git remote</code></td>
<td align="left">远程仓库操作</td>
</tr>
<tr>
<td align="left"><code>git fetch</code></td>
<td align="left">从远程获取代码库</td>
</tr>
<tr>
<td align="left"><code>git pull</code></td>
<td align="left">下载远程代码并合并</td>
</tr>
<tr>
<td align="left"><code>git push</code></td>
<td align="left">上传远程代码并合并</td>
</tr>
</tbody></table>
<h2 id="Git分支管理"><a href="#Git分支管理" class="headerlink" title="Git分支管理"></a>Git分支管理</h2><p>分支代表一条独立的开发线，分支有以下优势。</p>
<ul>
<li>可以从开发主线上分离</li>
<li>不影响主线的同时工作</li>
</ul>
<p><img src="https://static.jyshare.com/images/svg/git-brance.svg" alt="img"></p>
<p>Git的分支更像是指向更改快照的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch(branchname)</span><br></pre></td></tr></table></figure>

<p>创建分支命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout(branchname)</span><br></pre></td></tr></table></figure>

<p>切换分支命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge</span><br></pre></td></tr></table></figure>

<p>合并分支命令：可以选择多次合并统一分支，也可以直接删除被并入的分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir gitdemo</span><br><span class="line">$ cd gitdemo/</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository...</span><br><span class="line">$ touch README</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m &#x27;第一次版本提交&#x27;</span><br><span class="line">[master (root-commit) 3b58100] 第一次版本提交</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure>

<p>测试目录</p>
<p>Git分支管理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>

<p>没有参数的时候，会显示本地分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>手动创建分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch yushio</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  yushio</span><br></pre></td></tr></table></figure>

<p>切换分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls</span><br><span class="line">README</span><br><span class="line">$ echo &#x27;runoob.com&#x27; &gt; test.txt</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m &#x27;add test.txt&#x27;</span><br><span class="line">[master 3e92c19] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br><span class="line">$ git checkout testing</span><br><span class="line">Switched to branch &#x27;testing&#x27;</span><br><span class="line">$ ls</span><br><span class="line">README</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure>

<p>创建分支并切换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -b newtest</span><br><span class="line">Switched to a new branch &#x27;newtest&#x27;</span><br><span class="line">$ git rm test.txt </span><br><span class="line">rm &#x27;test.txt&#x27;</span><br><span class="line">$ ls</span><br><span class="line">README</span><br><span class="line">$ touch runoob.php</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -am &#x27;removed test.txt、add runoob.php&#x27;</span><br><span class="line">[newtest c1501a2] removed test.txt、add runoob.php</span><br><span class="line"> 2 files changed, 1 deletion(-)</span><br><span class="line"> create mode 100644 runoob.php</span><br><span class="line"> delete mode 100644 test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        runoob.php</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建了新分支，新的分支上删除了test.txt，增加了runoob.php，但是切换回master分支之后，前者还在，后者不在。</p>
<p>删除分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d (branchname)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br><span class="line">$ git branch -d testing</span><br><span class="line">Deleted branch testing (was 85fc7e7).</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>合并分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  newtest</span><br><span class="line">$ ls</span><br><span class="line">README        test.txt</span><br><span class="line">$ git merge newtest</span><br><span class="line">Updating 3e92c19..c1501a2</span><br><span class="line">Fast-forward</span><br><span class="line"> runoob.php | 0</span><br><span class="line"> test.txt   | 1 -</span><br><span class="line"> 2 files changed, 1 deletion(-)</span><br><span class="line"> create mode 100644 runoob.php</span><br><span class="line"> delete mode 100644 test.txt</span><br><span class="line">$ ls</span><br><span class="line">README        runoob.ph</span><br></pre></td></tr></table></figure>

<p>将newtest合并到主分支上，newtest.txt没有了，合并完成之后，删除分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch -d newtest</span><br><span class="line">Deleted branch newtest (was c1501a2).</span><br></pre></td></tr></table></figure>

<p>之后就只有master分支了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>合并冲突</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">$ cat runoob.php</span><br></pre></td></tr></table></figure>

<p>将runoob.php内容改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>创建change_site分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout -b change_site</span><br><span class="line">Switched to a new branch &#x27;change_site&#x27;</span><br><span class="line">$ vim runoob.php</span><br><span class="line">$ head -3 runoob.php</span><br><span class="line">&lt;?php</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line">?&gt;</span><br><span class="line">$ git commit -am &#x27;changed the runoob.php&#x27;</span><br><span class="line">[change_site 7774248] changed the runoob.php</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure>

<p>换回master</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">$ cat runoob.php</span><br><span class="line">$ vim runoob.php    # 修改内容如下</span><br><span class="line">$ cat runoob.php</span><br><span class="line">&lt;?php</span><br><span class="line">echo 1;</span><br><span class="line">?&gt;</span><br><span class="line">$ git diff</span><br><span class="line">diff --git a/runoob.php b/runoob.php</span><br><span class="line">index e69de29..ac60739 100644</span><br><span class="line">--- a/runoob.php</span><br><span class="line">+++ b/runoob.php</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+&lt;?php</span><br><span class="line">+echo 1;</span><br><span class="line">+?&gt;</span><br><span class="line">$ git commit -am &#x27;修改代码&#x27;</span><br><span class="line">[master c68142b] 修改代码</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure>

<p>现在合并“change_site”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge change_site</span><br><span class="line">Auto-merging runoob.php</span><br><span class="line">CONFLICT (content): Merge conflict in runoob.php</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line"></span><br><span class="line">$ cat runoob.php     # 打开文件，看到冲突内容</span><br><span class="line">&lt;?php</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">echo 1;</span><br><span class="line">=======</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; change_site</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>出现冲突，手动修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim runoob.php </span><br><span class="line">$ cat runoob.php</span><br><span class="line">&lt;?php</span><br><span class="line">echo 1;</span><br><span class="line">echo &#x27;runoob&#x27;;</span><br><span class="line">?&gt;</span><br><span class="line">$ git diff</span><br><span class="line">diff --cc runoob.php</span><br><span class="line">index ac60739,b63d7d7..0000000</span><br><span class="line">--- a/runoob.php</span><br><span class="line">+++ b/runoob.php</span><br><span class="line">@@@ -1,3 -1,3 +1,4 @@@</span><br><span class="line">  &lt;?php</span><br><span class="line"> +echo 1;</span><br><span class="line">+ echo &#x27;runoob&#x27;;</span><br><span class="line">  ?&gt;</span><br></pre></td></tr></table></figure>

<p>通知Git文件冲突已经解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">UU runoob.php</span><br><span class="line">$ git add runoob.php</span><br><span class="line">$ git status -s</span><br><span class="line">M  runoob.php</span><br><span class="line">$ git commit</span><br><span class="line">[master 88afe0e] Merge branch &#x27;change_site&#x27;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode：Problems</title>
    <url>/2024/06/03/Leetcode%EF%BC%9AProblems/</url>
    <content><![CDATA[<h2 id="1103-分糖果-II"><a href="#1103-分糖果-II" class="headerlink" title="1103. 分糖果 II"></a><a href="https://leetcode.cn/problems/distribute-candies-to-people/">1103. 分糖果 II</a></h2><p>排排坐，分糖果。</p>
<p>我们买了一些糖果 <code>candies</code>，打算把它们分给排好队的 <strong><code>n = num_people</code></strong> 个小朋友。</p>
<p>给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 <code>n</code> 颗糖果。</p>
<p>然后，我们再回到队伍的起点，给第一个小朋友 <code>n + 1</code> 颗糖果，第二个小朋友 <code>n + 2</code> 颗，依此类推，直到给最后一个小朋友 <code>2 * n</code> 颗糖果。</p>
<p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p>
<p>返回一个长度为 <code>num_people</code>、元素之和为 <code>candies</code> 的数组，以表示糖果的最终分发情况（即 <code>ans[i]</code> 表示第 <code>i</code> 个小朋友分到的糖果数）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candies = 7, num_people = 4</span><br><span class="line">输出：[1,2,3,1]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[0] += 1，数组变为 [1,0,0,0]。</span><br><span class="line">第二次，ans[1] += 2，数组变为 [1,2,0,0]。</span><br><span class="line">第三次，ans[2] += 3，数组变为 [1,2,3,0]。</span><br><span class="line">第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candies = 10, num_people = 3</span><br><span class="line">输出：[5,2,3]</span><br><span class="line">解释：</span><br><span class="line">第一次，ans[0] += 1，数组变为 [1,0,0]。</span><br><span class="line">第二次，ans[1] += 2，数组变为 [1,2,0]。</span><br><span class="line">第三次，ans[2] += 3，数组变为 [1,2,3]。</span><br><span class="line">第四次，ans[0] += 4，最终数组变为 [5,2,3]。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= candies &lt;= 10^9</code></li>
<li><code>1 &lt;= num_people &lt;= 1000</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; distributeCandies(int candies, int num_people) &#123;</span><br><span class="line">        int n = num_people;</span><br><span class="line">        vector&lt;int&gt; ans(n);</span><br><span class="line">        for (int i = 0; i &lt; n * n; i++) &#123;</span><br><span class="line">            if (candies &gt;= i + 1) &#123;</span><br><span class="line">                candies -= i + 1;</span><br><span class="line">                ans[i % n] += i + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ans[i % n] += candies;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="575-分糖果"><a href="#575-分糖果" class="headerlink" title="575. 分糖果"></a><a href="https://leetcode.cn/problems/distribute-candies/">575. 分糖果</a></h2><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>提示</p>
<p>Alice 有 <code>n</code> 枚糖，其中第 <code>i</code> 枚糖的类型为 <code>candyType[i]</code> 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。</p>
<p>医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 <code>n / 2</code> 即可（<code>n</code> 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。</p>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>candyType</code> ，返回： Alice <em>在仅吃掉 <code>n / 2</code> 枚糖的情况下，可以吃到糖的 <strong>最多</strong> 种类数</em>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candyType = [1,1,2,2,3,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candyType = [1,1,2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candyType = [6,6,6,6]</span><br><span class="line">输出：1</span><br><span class="line">解释：Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == candyType.length</code></li>
<li><code>2 &lt;= n &lt;= 104</code></li>
<li><code>n</code> 是一个偶数</li>
<li><code>-105 &lt;= candyType[i] &lt;= 105</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int distributeCandies(vector&lt;int&gt;&amp; candyType) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; candyset(candyType.begin(), candyType.end());</span><br><span class="line">        return min(candyType.size() &gt;&gt; 1, candyset.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2928-给小朋友们分糖果-I"><a href="#2928-给小朋友们分糖果-I" class="headerlink" title="2928. 给小朋友们分糖果 I"></a><a href="https://leetcode.cn/problems/distribute-candies-among-children-i/">2928. 给小朋友们分糖果 I</a></h2><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>提示</p>
<p>给你两个正整数 <code>n</code> 和 <code>limit</code> 。</p>
<p>请你将 <code>n</code> 颗糖果分给 <code>3</code> 位小朋友，确保没有任何小朋友得到超过 <code>limit</code> 颗糖果，请你返回满足此条件下的 <strong>总方案数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5, limit = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：总共有 3 种方法分配 5 颗糖果，且每位小朋友的糖果数不超过 2 ：(1, 2, 2) ，(2, 1, 2) 和 (2, 2, 1) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, limit = 3</span><br><span class="line">输出：10</span><br><span class="line">解释：总共有 10 种方法分配 3 颗糖果，且每位小朋友的糖果数不超过 3 ：(0, 0, 3) ，(0, 1, 2) ，(0, 2, 1) ，(0, 3, 0) ，(1, 0, 2) ，(1, 1, 1) ，(1, 2, 0) ，(2, 0, 1) ，(2, 1, 0) 和 (3, 0, 0) 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 50</code></li>
<li><code>1 &lt;= limit &lt;= 50</code></li>
</ul>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int distributeCandies(int n, int limit) &#123;</span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0;i&lt;=limit;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for(int j=0;j&lt;=limit;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(n-i-j&lt;=limit&amp;&amp;n-i-j&gt;=0)sum++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>leetcode每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2022/07/18/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="常用公式"><a href="#常用公式" class="headerlink" title="常用公式"></a>常用公式</h2><blockquote>
<p>一般公式分为两种形式，行内公式和行间公式。行内公式是在公布代码的前后均添加一个$；</p>
</blockquote>
<blockquote>
<p>行间公式则是在公式代码块的前后均添加两个$。</p>
</blockquote>
<h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><ol>
<li><p>行内公式：$ \Gamma(z) &#x3D; \int_0^\infty t^{z-1} e^{-t}dt,. $</p>
</li>
<li><p>行间公式：$$\Gamma(z) &#x3D; \int_0^\infty t^{z-1} e^{-t}dt,.$$</p>
</li>
</ol>
<blockquote>
<p>公式排列：一般使用\binom{a}{b}或者{a\choose b}来实现a，b两个公式的排列。</p>
</blockquote>
<h4 id="数学算式"><a href="#数学算式" class="headerlink" title="数学算式"></a>数学算式</h4><p>$\binom{n+1}{2k} $​</p>
<h4 id="向量公式"><a href="#向量公式" class="headerlink" title="向量公式"></a>向量公式</h4><p>向量表示：使用\mathbf{x}来表示向量x</p>
<p>数学算式：</p>
<p>$f(\mathbf{x})&#x3D;\mathbf{w}^T\mathbf{x}$</p>
<h4 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h4><p>定义函数的时候经常需要分情况给出表达式，使用{。其中：</p>
<ul>
<li>使用\来分隔分组；</li>
<li>使用&amp;来指示需要对齐的位置；</li>
<li>使用\空格表示空格；</li>
<li>如果要使分类之间的垂直间隔变大，可以使用[nex]代替\来分隔不同的情况。</li>
</ul>
<p>数学算式：</p>
<ol>
<li><p>分段函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y=</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">-x,\quad x&lt;=0\\</span><br><span class="line">x, \quad x&gt;0</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">\tag&#123;1&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>$$<br>y&#x3D;<br>\begin{cases}<br>-x,\quad x&lt;&#x3D;0\<br>x, \quad x&gt;0<br>\end{cases}<br>\tag{1}<br>$$</p>
<ol start="2">
<li><p>方程组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\left\&#123;</span><br><span class="line">\begin&#123;array&#125;&#123;&#125;</span><br><span class="line">	a_1x+b_1y+c_1z=d_1 \\</span><br><span class="line">	a_2x+b_2y+c_2z=d_2 \\</span><br><span class="line">	a_3x+b_3y+c_3z=d_3</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right.</span><br><span class="line">\tag&#123;2&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>$$<br>\left{<br>\begin{array}{}<br>    a_1x+b_1y+c_1z&#x3D;d_1 \<br>    a_2x+b_2y+c_2z&#x3D;d_2 \<br>    a_3x+b_3y+c_3z&#x3D;d_3<br>\end{array}<br>\right.<br>\tag{2}<br>$$</p>
<ol start="3">
<li><p>均方误差</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(\theta)=\frac&#123;1&#125;&#123;2m&#125;\sum_&#123;i=1&#125;^m(y^i-h_\theta(x^i))^2</span><br></pre></td></tr></table></figure></li>
</ol>
<p>$$<br>J(\theta)&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^m(y^i-h_\theta(x^i))^2<br>$$</p>
<ol start="4">
<li><p>批量梯度下降</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\frac&#123;\partial J(\theta)&#125;&#123;\partial \theta_j&#125;=-\frac&#123;1&#125;&#123;m&#125;\sum_&#123;i=0&#125;^&#123;m&#125;(y^i-h_\theta(x^i))x^i</span><br></pre></td></tr></table></figure></li>
</ol>
<p>$$<br>\frac{\partial J(\theta)}{\partial \theta_j}&#x3D;-\frac{1}{m}\sum_{i&#x3D;0}^{m}(y^i-h_\theta(x^i))x^i<br>$$</p>
<p>推导过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\frac &#123;\partial J(\theta)&#125;&#123;\partial \theta_j&#125;=\\</span><br><span class="line">-\frac&#123;1&#125;&#123;m&#125;\sum_&#123;i=0&#125;^&#123;m&#125;(y^i-h_\theta(x^i))\frac&#123;\partial&#125;&#123;\partial \theta_j&#125;(y^i-h_\theta(x^i))</span><br><span class="line">=-\frac&#123;1&#125;&#123;m&#125;\sum_&#123;i=0&#125;^&#123;m&#125;(y^i-h_\theta(x^i))\frac&#123;\partial&#125;&#123;\partial\theta_j&#125;(\sum_&#123;j=0&#125;^&#123;n&#125;\theta_jx_j^i-y^i&#125;\\</span><br><span class="line">=\frac&#123;1&#125;&#123;m&#125;\sum_&#123;i=0&#125;^&#123;m&#125;(y^i-h_\theta(x^i))x^i_j</span><br></pre></td></tr></table></figure>


<p>$$<br>\frac {\partial J(\theta)}{\partial \theta_j}&#x3D;\\-\frac{1}{m}\sum_{i&#x3D;0}^{m}(y^i-h_\theta(x^i))\frac{\partial}{\partial \theta_j}(y^i-h_\theta(x^i))\<br>$$</p>
<p>$$<br>&#x3D;-\frac{1}{m}\sum_{i&#x3D;0}^{m}(y^i-h_\theta(x^i))\frac{\partial}{\partial\theta_j}(\sum_{j&#x3D;0}^{n}\theta_jx_j^i-y^i)\\&#x3D;\frac{1}{m}\sum_{i&#x3D;0}^{m}(y^i-h_\theta(x^i))x^i_j<br>$$</p>
<ol start="5">
<li>case环境的使用</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a=</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">\int x\,\mathrm&#123;d&#125; x\\</span><br><span class="line">b^2</span><br><span class="line">\end&#123;cases&#125;</span><br></pre></td></tr></table></figure>


<p>$$<br>a&#x3D;<br>\begin{cases}<br>\int x,\mathrm{d} x\<br>b^2<br>\end{cases}<br>$$</p>
<ol start="6">
<li><p>带方框的等式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">\boxed&#123;x^2+y^2=z^2&#125;</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>$$<br>\begin{aligned}<br>\boxed{x^2+y^2&#x3D;z^2}<br>\end{aligned}<br>$$</p>
<ol start="7">
<li><p>最大（最小）操作符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;gathered&#125;</span><br><span class="line">\operatorname&#123;arg\,max&#125;_a f(a)=\operatorname*&#123;arg\,max&#125;_b f(b)\\</span><br><span class="line">\operatorname&#123;arg\min&#125;_c f(c)=\operatorname*&#123;arg\,min&#125;_d f(d)\\</span><br><span class="line">\end&#123;gathered&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>$$<br>\begin{gathered}<br>\operatorname{arg,max}_a f(a)&#x3D;\operatorname*{arg,max}_b f(b)\<br>\operatorname{arg\min}_c f(c)&#x3D;\operatorname*{arg,min}_d f(d)\<br>\end{gathered}<br>$$</p>
<ol start="8">
<li><p>求极限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">\lim_&#123;a\to\infty&#125; \tfrac&#123;1&#125;&#123;a&#125;</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>$$<br>lim_{a\to\infty}\tfrac{1}{a}<br>$$</p>
<p>$$<br>\begin{aligned}<br>\lim_{a\to\infty} \tfrac{1}{a}<br>\end{aligned}<br>$$</p>
<ol start="9">
<li><p>求积分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1:\begin&#123;aligned&#125;</span><br><span class="line">\int_a^b x^2 \mathrm&#123;d&#125; x</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">2:\begin&#123;aligned&#125;</span><br><span class="line">\int\limits_a^b x^2 \mathrm&#123;d&#125; x</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>$$<br>\begin{aligned}<br>\int_a^b x^2 \mathrm{d} x<br>\end{aligned}<br>\tag{1}<br>$$</p>
<p>$$<br>\begin{aligned}<br>\int\limits_a^b x^2 \mathrm{d} x<br>\end{aligned}<br>\tag{2}<br>$$</p>
<blockquote>
<p>使用、[2ex]代替\使分组的垂直间隔增大</p>
</blockquote>
<ol start="10">
<li><p>数学算式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;cases&#125;</span><br><span class="line">-x,\quad x\leq 0 \\[3ex]</span><br><span class="line">x,\quad x&gt;0</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">\tag&#123;1&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>$$<br>y&#x3D;<br>\begin{cases}<br>-x,\quad x\leq 0 \\[3ex]<br>x,\quad x&gt;0<br>\end{cases}<br>\tag{1}<br>$$</p>
<p><strong>3.多行表达公式</strong></p>
<p>有时候需要将一行公式分多行进行显示，其中\begin{aligned}表示开始方程，\end{equation}表示方程结束；使用\表示公式换行。\begin{gather}表示环境设置，&amp;表示对齐的位置。</p>
<ol>
<li><p>数学算式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">J(\mathbf&#123;x&#125;)=\frac&#123;1&#125;&#123;2m&#125;\sum_&#123;i=1&#125;^&#123;m&#125;(f(x_i)-y_i)^2\\=\frac&#123;1&#125;&#123;2m&#125;\sum_&#123;i-1&#125;^&#123;m&#125;[f(x_i)]^2-2f(x_i)y_i+y_i^2\\</span><br></pre></td></tr></table></figure></li>
</ol>
<p>$$<br>J(\mathbf{x})&#x3D;\frac{1}{2m}\sum_{i&#x3D;1}^{m}(f(x_i)-y_i)^2\\&#x3D;\frac{1}{2m}\sum_{i-1}^{m}[f(x_i)]^2-2f(x_i)y_i+y_i^2<br>$$</p>
<p>常见公式环境</p>
<table>
<thead>
<tr>
<th>环境名称</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>align</td>
<td>最基本的对齐环境</td>
</tr>
<tr>
<td>multline</td>
<td>非对齐环境</td>
</tr>
<tr>
<td>gather</td>
<td>无对齐的连续方程</td>
</tr>
</tbody></table>
<blockquote>
<p>gathered 允许多行（多组）方程式在彼此之下设置并分配单个方程式编号<br>split 与align *类似，但在另一个显示的数学环境中使用<br>aligned 与align类似，可以在其他数学环境中使用。<br>alignedat 与alignat类似，同样需要一个额外的参数来指定要设置的方程列数。</p>
</blockquote>
<p>备注：如果各个方程需要在某个字符处对齐（如等号对齐），只需在所有要对齐的字符前加上&amp;符号。</p>
<p>数学算式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">\left.\begin&#123;aligned&#125;</span><br><span class="line">B&#x27;&amp;=-\partial \times E \\</span><br><span class="line">E&#x27;&amp;=\partial\times B-4paij</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">\right\&#125;</span><br><span class="line">\quad \text&#123;Maxwell&#x27;s equations&#125;</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure>


<p>$$<br>\begin{aligned}<br>\left.\begin{aligned}<br>B’&amp;&#x3D;-\partial \times E \<br>E’&amp;&#x3D;\partial\times B-4paij<br>\end{aligned}<br>\right}<br>\quad \text{Maxwell’s equations}<br>\end{aligned}<br>$$</p>
<p>$$<br>\begin{aligned}<br>\sigma_1&amp;&#x3D;x+y\quad&amp;\\ \sigma_2&amp;&#x3D;\frac{x}{y}\\<br>\sigma_1&amp;’&#x3D;\frac{\partial x+y}{\partial x}\quad&amp; \\ \sigma_2&amp;&#x3D;\frac{\partial \frac{x}{y}}{\partial x}<br>\end{aligned}\\<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">\sigma_1&amp;=x+y\quad&amp;\sigma_2&amp;=\frac&#123;x&#125;&#123;y&#125;\\</span><br><span class="line">\sigma_1&amp;&#x27;=\frac&#123;\partial x+y&#125;&#123;\partial x&#125;\quad&amp;\sigma_2&amp;=\frac&#123;\partial \frac&#123;x&#125;&#123;y&#125;&#125;&#123;\partial x&#125;</span><br><span class="line">\end&#123;aligned&#125;\\[5ex]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">a_n=\frac&#123;1&#125;&#123;pai&#125;&amp;\int_&#123;-pai&#125;^&#123;pai&#125;f(x)\cos nx\mathrm&#123;d&#125;x\\</span><br><span class="line">=\frac&#123;1&#125;&#123;pai&#125;&amp;\int_&#123;-pai&#125;^&#123;pai&#125;x^2\cos nx\mathrm&#123;d&#125;x\\</span><br><span class="line">J(\theta)=-frac&#123;1&#125;&#123;m&#125;\sum_&#123;i=1&#125;^&#123;m&#125;y_ilogh_\theta(x_i)+(1-y_i)log(1-h_\theta(x_i))</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>\begin{aligned}<br>a_n&#x3D;&amp;\frac{1}{\pi}&amp;\int_{-\pi}^{\pi}&amp;f(x)\cos nx&amp;\mathrm{d}x&amp;\<br>&#x3D;&amp;\frac{1}{\pi}&amp;\int_{-\pi}^{\pi}&amp;x^2\cos nx&amp;\mathrm{d}x&amp;\<br>J(\theta)&#x3D;&amp;-\frac{1}{m}&amp;\sum_{i&#x3D;1}^{m}&amp;y_ilogh_\theta(x_i)&amp;+(1-y_i)&amp;log(1-h_\theta(x_i))&amp;<br>\end{aligned}<br>$$</p>
<p><strong>公式编辑的编号设置</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>\tag{标号}</td>
<td>公式宏包序号设置命令，可以用于带星号公式环境中的公式行</td>
</tr>
<tr>
<td>\tag*{标号}</td>
<td>作用与\tag相同，知识标号两侧没有圆括号</td>
</tr>
</tbody></table>
<p>数学算式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x^2+y^2=z^2\tag&#123;1$&#x27;$&#125;</span><br></pre></td></tr></table></figure>


<p>$$<br>\begin{aligned}<br>x^2+y^2&#x3D;z^2<br>\end{aligned}<br>\tag{1}<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x^4+y^4=z^4\tag&#123;*&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>\begin{aligned}<br>x^4+y^4&#x3D;z^4<br>\end{aligned}<br>\tag{*}<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x^5+y^5=z^5\tag*&#123;*&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>x^5+y^5&#x3D;z^5\tag*{*}<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x^6+y^6=z^6\tag&#123;1-1&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>x^6+y^6&#x3D;z^6\tag{1-1}<br>$$</p>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>数学算式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;pmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;pmatrix&#125;\\</span><br><span class="line">\begin&#123;bmatrix&#125;1&amp;2\\3&amp;4\\ \end&#123;bmatrix&#125;\\</span><br><span class="line">\begin&#123;Bmatrix&#125;1&amp;2\\3&amp;4\\ \end&#123;Bmatrix&#125;\\</span><br><span class="line">\begin&#123;Vmatrix&#125;1&amp;2\\3&amp;4\\ \end&#123;Vmatrix&#125;\\</span><br><span class="line">\begin&#123;pmatrix&#125;1&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n\\</span><br><span class="line">1&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n&amp;\\</span><br><span class="line">\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\</span><br><span class="line">1&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_n^n</span><br><span class="line">\end&#123;pmatrix&#125;</span><br><span class="line">\tag&#123;n&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>\begin{pmatrix}1 &amp; 2 \\ 3 &amp; 4\ \end{pmatrix}\<br>$$</p>
<p>$$<br>\begin{bmatrix}1&amp;2\\3&amp;4\ \end{bmatrix}\<br>$$</p>
<p>$$<br>\begin{Bmatrix}1&amp;2\\3&amp;4\ \end{Bmatrix}\<br>$$</p>
<p>$$<br>\begin{Vmatrix}1&amp;2\\3&amp;4\ \end{Vmatrix}\<br>$$</p>
<p>$$<br>\begin{pmatrix}1&amp;a_1&amp;a_1^2&amp;\cdots&amp;a_1^n\\<br>1&amp;a_2&amp;a_2^2&amp;\cdots&amp;a_2^n&amp;\\<br>\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>1&amp;a_m&amp;a_m^2&amp;\cdots&amp;a_n^n<br>\end{pmatrix}<br>\tag{n}<br>$$</p>
<ol>
<li><p>不带括号的矩阵</p>
<p>数学算式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1&amp;2&amp;3\\</span><br><span class="line">4&amp;5&amp;6\\</span><br><span class="line">7&amp;8&amp;9</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\tag&#123;1&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>$$<br>\begin{matrix}<br>   1&amp;2&amp;3\\<br>   4&amp;5&amp;6\\<br>   7&amp;8&amp;9<br>   \end{matrix}<br>   \tag{1}<br>$$</p>
<ol start="2">
<li><p>带小括号的矩阵</p>
<p>数学算式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\left(</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1&amp;2&amp;3\\</span><br><span class="line">4&amp;5&amp;6\\</span><br><span class="line">7&amp;8&amp;9</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right)</span><br><span class="line">\tag&#123;2&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>\left(<br>\begin{matrix}<br>1&amp;2&amp;3\\<br>4&amp;5&amp;6\\<br>7&amp;8&amp;9<br>\end{matrix}<br>\right)<br>\tag{2}<br>$$</p>
</li>
<li><p>带中括号的矩阵</p>
<p>数学算式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\left\&#123;</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1&amp;2&amp;3\\</span><br><span class="line">4&amp;5&amp;6\\</span><br><span class="line">7&amp;8&amp;9</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right\&#125;</span><br><span class="line">\tag&#123;3&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>\left[<br>\begin{matrix}<br>1&amp;2&amp;3\\<br>4&amp;5&amp;6\\<br>7&amp;8&amp;9<br>\end{matrix}<br>\right]<br>\tag{3}<br>$$</p>
</li>
<li><p>带大括号的矩阵</p>
<p>数学算式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\left&#123;</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1&amp;2&amp;3\\</span><br><span class="line">4&amp;5&amp;6\\</span><br><span class="line">7&amp;8&amp;9</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right&#125;</span><br><span class="line">\tag&#123;4&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>\left{<br>\begin{matrix}<br>1&amp;2&amp;3\\<br>4&amp;5&amp;6\\<br>7&amp;8&amp;9<br>\end{matrix}<br>\right}<br>\tag{4}<br>$$</p>
</li>
<li><p>带省略号的矩阵</p>
<p>数学算式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">a&amp;b&amp;\cdots&amp;a\\</span><br><span class="line">b&amp;b&amp;\cdots&amp;b\\</span><br><span class="line">\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\</span><br><span class="line">c&amp;c&amp;\cdots&amp;c&amp;</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right]</span><br><span class="line">\tag&#123;5&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>\left[<br>\begin{matrix}<br>a&amp;b&amp;\cdots&amp;a\\<br>b&amp;b&amp;\cdots&amp;b\\<br>\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>c&amp;c&amp;\cdots&amp;c&amp;<br>\end{matrix}<br>\right]<br>\tag{5}<br>$$</p>
</li>
<li><p>带横线&#x2F;竖线分割的矩阵：</p>
<p>数学算式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\left[</span><br><span class="line">\begin&#123;array&#125;&#123;c|cc&#125;</span><br><span class="line">1&amp;2&amp;3&amp;\\</span><br><span class="line">4&amp;5&amp;6&amp;\\</span><br><span class="line">7&amp;8&amp;9&amp;</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right]</span><br><span class="line">\tag&#123;6&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>\left[<br>\begin{array}{c|cc}<br>1&amp;2&amp;3&amp;\\<br>4&amp;5&amp;6&amp;\\<br>7&amp;8&amp;9&amp;<br>\end{array}<br>\right]<br>\tag{6}<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\left[</span><br><span class="line">\begin&#123;array&#125;&#123;ccc&#125;</span><br><span class="line">1&amp;2&amp;3&amp;\\ \hline</span><br><span class="line">4&amp;5&amp;6&amp;\\</span><br><span class="line">7&amp;8&amp;9&amp;</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right]</span><br></pre></td></tr></table></figure>

<p>$$<br>\left[<br>\begin{array}{ccc}<br>1&amp;2&amp;3&amp;\\ \hline<br>4&amp;5&amp;6&amp;\\<br>7&amp;8&amp;9&amp;<br>\end{array}<br>\right]<br>$$</p>
</li>
</ol>
<h2 id="上下标符号"><a href="#上下标符号" class="headerlink" title="上下标符号"></a>上下标符号</h2><table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$a_i$,$a_{pre}$</td>
<td>a_i,a_{pre}</td>
<td>下标使用_</td>
</tr>
<tr>
<td>$a^i$,$a^{pre}$</td>
<td>a^i,a^{pre}</td>
<td>上标使用^</td>
</tr>
<tr>
<td>$\bar{a}$</td>
<td>\bar{a}</td>
<td></td>
</tr>
<tr>
<td>${a}$</td>
<td>\cute{a}</td>
<td></td>
</tr>
<tr>
<td>$\breve{a}$</td>
<td>\breve{a}</td>
<td></td>
</tr>
<tr>
<td>$\grave{a}$</td>
<td>\grave{a}</td>
<td></td>
</tr>
<tr>
<td>$\dot{a}$</td>
<td>\dot{a}</td>
<td></td>
</tr>
<tr>
<td>$\ddot{a}$</td>
<td>\ddot{a}</td>
<td></td>
</tr>
<tr>
<td>$\dot{\dot x}$</td>
<td>\dot{\dot x}</td>
<td></td>
</tr>
<tr>
<td>$\hat{a}$</td>
<td>\hat{a}</td>
<td></td>
</tr>
<tr>
<td>$\widehat{xy}$</td>
<td>\widehat{xy}</td>
<td>多字符可用</td>
</tr>
<tr>
<td>$\check{a}$</td>
<td>\check{a}</td>
<td></td>
</tr>
<tr>
<td>$\tilde{a}$</td>
<td>\tilde{a}</td>
<td></td>
</tr>
<tr>
<td>$\vec{a}$</td>
<td>\vec{a}</td>
<td>矢量使用vec{}</td>
</tr>
<tr>
<td>$\overrightarrow{xy}$</td>
<td>\overrightarow{xy}</td>
<td></td>
</tr>
<tr>
<td>$\overline{a+b+c+d}$</td>
<td>\overline{a+b+c+d}</td>
<td></td>
</tr>
<tr>
<td>$\underline{a+b+c+d}$</td>
<td>\underline{a+b+c+d}</td>
<td></td>
</tr>
<tr>
<td>$\overbrace{a+b+c+d}$</td>
<td>\overbrace{a+b+c+d}</td>
<td></td>
</tr>
<tr>
<td>$\underbrace{a+b+c+d}$</td>
<td>\underbrace{a+b+c+d}</td>
<td></td>
</tr>
<tr>
<td>$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$</td>
<td>\overbrace{a+underbrace{b+c}_1.0}+d}^{2.0}</td>
<td></td>
</tr>
</tbody></table>
<h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><p>小括号与方括号</p>
<ol>
<li><p>使用原始的()，[]得到的括号大小是固定的，如(2+3)[3+4]:</p>
</li>
<li><p>使用\left(或者\right)可以使括号大小与邻近的公式相适应（改语句适用于所有括号类型），如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\left(</span><br><span class="line">\frac&#123;x&#125;&#123;y&#125;</span><br><span class="line">\right)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>$$<br>\left(<br>\frac{x}{y}<br>\right)<br>$$</p>
<table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$(,)$</td>
<td>(,)</td>
<td></td>
</tr>
<tr>
<td>$[,]$</td>
<td>[,]</td>
<td></td>
</tr>
<tr>
<td>$&lt;,&gt;$</td>
<td>\lang,\lang</td>
<td></td>
</tr>
<tr>
<td>$</td>
<td>,</td>
<td>$</td>
</tr>
<tr>
<td>$\lvert,\rvert$</td>
<td>\lvert,\rvert</td>
<td></td>
</tr>
<tr>
<td>$\lbrace,\rbrace$</td>
<td>\lbrace,\rbiace</td>
<td></td>
</tr>
</tbody></table>
<p>增大括号的方法：</p>
<table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$(x)$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\big(x\big)$</td>
<td>\big(x\big)</td>
<td></td>
</tr>
<tr>
<td>$\Big(x\Big)$</td>
<td>\Big(x\Big)</td>
<td></td>
</tr>
<tr>
<td>$\bigg(x\bigg)$</td>
<td>\bigg(x\bigg)</td>
<td></td>
</tr>
<tr>
<td>$\Bigg(x\Bigg)$</td>
<td>\Bigg(x\Bigg)</td>
<td></td>
</tr>
<tr>
<td>$\Bigg(\bigg(\Big(\big(x\big)\Big)\bigg)\Bigg)$</td>
<td>\Bigg(\bigg(\Big(\big(x\big)\Big)\bigg)\Bigg)</td>
<td></td>
</tr>
<tr>
<td>$\Bigg[\bigg[\Big[\big[x\big]\Big]\bigg]\Bigg]$</td>
<td>\Bigg[\bigg[\Big[\big[x\big]\Big]\bigg]\Bigg]</td>
<td></td>
</tr>
</tbody></table>
<h2 id="分式与根式"><a href="#分式与根式" class="headerlink" title="分式与根式"></a>分式与根式</h2><p>分式的表示方法：</p>
<ol>
<li>使用\frac{a}{b}表示分式，比如$\frac{a+c+1}{b+c+2}$;</li>
<li>使用\over来分割一个组的前后两部分，如$\over{b+1}{a+1}$</li>
</ol>
<p>\frac 表示连分式：</p>
<p>数学算式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x=a_0+\frac&#123;1^2&#125;&#123;a_1+\frac&#123;2^2&#125;&#123;a_2+\frac&#123;3^2&#125;&#123;a_3+\frac&#123;4^2&#125;&#123;a_4+\cdots&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>$$<br>x&#x3D;a_0+\frac{1^2}{a_1+\frac{2^2}{a_2+\frac{3^2}{a_3+\frac{4^2}{a_4+\cdots}}}}<br>$$</p>
<p>\cfrac表示连分式：</p>
<table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$\frac{a}{b}$</td>
<td>\frac{a}{b}</td>
<td>分数使用\frac{分子}{分母}</td>
</tr>
<tr>
<td>$a^i,a^{pre}$</td>
<td>a^i , a^pre</td>
<td>上标使用^</td>
</tr>
</tbody></table>
<h2 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h2><table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$\sqrt{a+b}$</td>
<td>\sqrt{a+b}</td>
<td>开方使用\sqrt{}</td>
</tr>
<tr>
<td>$\sqrt[n]{a+b}$</td>
<td>\sqrt[n]{a+b}</td>
<td>开n次方使用\sqrt[n]{}</td>
</tr>
</tbody></table>
<h2 id="累加-累乘"><a href="#累加-累乘" class="headerlink" title="累加&#x2F;累乘"></a>累加&#x2F;累乘</h2><table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$\sum_{i&#x3D;0}^{n}x^2$</td>
<td>\sum_{i&#x3D;0}^{n} x^2</td>
<td>累加使用语法\sum_{下标}^{上标}</td>
</tr>
<tr>
<td>$\prod_{i&#x3D;0}^{n}x^2$</td>
<td>\prod_{i&#x3D;0}^{n} x^2</td>
<td>累乘使用\prod_{下标}^{上标}</td>
</tr>
</tbody></table>
<h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>释义</th>
</tr>
</thead>
<tbody><tr>
<td>$\sin$</td>
<td>\sin</td>
<td>正弦</td>
</tr>
<tr>
<td>$\cos$</td>
<td>\cos</td>
<td>余弦</td>
</tr>
<tr>
<td>$\tan$</td>
<td>\tan</td>
<td>正切</td>
</tr>
<tr>
<td>$\cot$</td>
<td>\cot</td>
<td>余切</td>
</tr>
<tr>
<td>$\sec $</td>
<td>\sec</td>
<td>反正弦</td>
</tr>
<tr>
<td>$\csc$</td>
<td>\csc</td>
<td>反余弦</td>
</tr>
<tr>
<td>$\bot$</td>
<td>\dot</td>
<td>垂直</td>
</tr>
<tr>
<td>$\angle$</td>
<td>\angle</td>
<td>夹角</td>
</tr>
<tr>
<td>$40^\circ$</td>
<td>40^\circ</td>
<td>度数</td>
</tr>
</tbody></table>
<h2 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h2><table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$\ln{(a+b)}$</td>
<td>\ln{(a+b)}</td>
<td>以e为底</td>
</tr>
<tr>
<td>$\log_{a}^{b}$</td>
<td>\log_{a}^{b}</td>
<td>对数函数</td>
</tr>
<tr>
<td>$\lg{(a+b)}$</td>
<td>\lg{a+b}</td>
<td>以10为底</td>
</tr>
</tbody></table>
<h2 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h2><table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$\pm$</td>
<td>\pm</td>
<td></td>
</tr>
<tr>
<td>$\mp$</td>
<td>\mp</td>
<td></td>
</tr>
<tr>
<td>$\times$</td>
<td>\times</td>
<td></td>
</tr>
<tr>
<td>$\div$</td>
<td>\div</td>
<td></td>
</tr>
<tr>
<td>$\ast$</td>
<td>\ast</td>
<td></td>
</tr>
<tr>
<td>$\star$</td>
<td>\star</td>
<td></td>
</tr>
<tr>
<td>$\mid$</td>
<td>\mid</td>
<td></td>
</tr>
<tr>
<td>$\nmid$</td>
<td>\nmid</td>
<td></td>
</tr>
<tr>
<td>$\circ$</td>
<td>\circ</td>
<td></td>
</tr>
<tr>
<td>$\bullet$</td>
<td>\bullet</td>
<td></td>
</tr>
<tr>
<td>$\cdot$</td>
<td>\cdot</td>
<td></td>
</tr>
<tr>
<td>$\wr$</td>
<td>\wr</td>
<td></td>
</tr>
<tr>
<td>$\diamond$</td>
<td>\dianmond</td>
<td></td>
</tr>
<tr>
<td>$\Diamond$</td>
<td>\Diamond</td>
<td></td>
</tr>
<tr>
<td>$\triangle$</td>
<td>\triangle</td>
<td></td>
</tr>
<tr>
<td>$\bigtriangleup$</td>
<td>\bigtriangleup</td>
<td></td>
</tr>
<tr>
<td>$\bigtriangledown$</td>
<td>\bigtriangledown</td>
<td></td>
</tr>
<tr>
<td>$\triangleleft$</td>
<td>\triangleleft</td>
<td></td>
</tr>
<tr>
<td>$\triangleright$</td>
<td>\triangleright</td>
<td></td>
</tr>
<tr>
<td>$\lhd$</td>
<td>\lhd</td>
<td></td>
</tr>
<tr>
<td>$\rhd$</td>
<td>\rhd</td>
<td></td>
</tr>
<tr>
<td>$\unlhd$</td>
<td>\unlhd</td>
<td></td>
</tr>
<tr>
<td>$\unrhd$</td>
<td>\unrhd</td>
<td></td>
</tr>
<tr>
<td>$\circ $</td>
<td>\circ</td>
<td></td>
</tr>
<tr>
<td>$\bigcirc$</td>
<td>\bigcirc</td>
<td></td>
</tr>
<tr>
<td>$\odot$</td>
<td>\odot</td>
<td></td>
</tr>
<tr>
<td>$\bigodot$</td>
<td>\bigodot</td>
<td></td>
</tr>
<tr>
<td>$\oslash$</td>
<td>\oslash</td>
<td></td>
</tr>
<tr>
<td>$\ominus$</td>
<td>\ominus</td>
<td></td>
</tr>
<tr>
<td>$\otimes$</td>
<td>\otimes</td>
<td></td>
</tr>
<tr>
<td>$\bigotimes$</td>
<td>\bigotimes</td>
<td></td>
</tr>
<tr>
<td>$\oplus$</td>
<td>\oplus</td>
<td></td>
</tr>
<tr>
<td>$\bigoplus$</td>
<td>\bigoplus</td>
<td></td>
</tr>
<tr>
<td>$\dagger$</td>
<td>\dagger</td>
<td></td>
</tr>
<tr>
<td>$\ddagger$</td>
<td>\ddagger</td>
<td></td>
</tr>
</tbody></table>
<h2 id="关系符号"><a href="#关系符号" class="headerlink" title="关系符号"></a>关系符号</h2><table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$\leq$</td>
<td>\leq</td>
<td></td>
</tr>
<tr>
<td>$\geq$</td>
<td>\geq</td>
<td></td>
</tr>
<tr>
<td>$\equiv$</td>
<td>\equiv</td>
<td></td>
</tr>
<tr>
<td>$\models$</td>
<td>\models</td>
<td></td>
</tr>
<tr>
<td>$\prec$</td>
<td>\prec</td>
<td></td>
</tr>
<tr>
<td>$\succ$</td>
<td>\succ</td>
<td></td>
</tr>
<tr>
<td>$\sim$</td>
<td>\sim</td>
<td></td>
</tr>
<tr>
<td>$\perp$</td>
<td>\perp</td>
<td></td>
</tr>
<tr>
<td>$\preceq$</td>
<td>\preceq</td>
<td></td>
</tr>
<tr>
<td>$\succeq$</td>
<td>\succeq</td>
<td></td>
</tr>
<tr>
<td>$\simeq$</td>
<td>\simeq</td>
<td></td>
</tr>
<tr>
<td>$</td>
<td>\mid</td>
<td></td>
</tr>
<tr>
<td>$\gg$</td>
<td>\gg</td>
<td></td>
</tr>
<tr>
<td>$\asymp$</td>
<td>\asymp</td>
<td></td>
</tr>
<tr>
<td>$\parallel$</td>
<td>\parallel</td>
<td></td>
</tr>
<tr>
<td>$\approx$</td>
<td>\approx</td>
<td></td>
</tr>
<tr>
<td>$\cong$</td>
<td>\cong</td>
<td></td>
</tr>
<tr>
<td>$\neq$</td>
<td>\neq</td>
<td></td>
</tr>
<tr>
<td>$\doteq$</td>
<td>\doteq</td>
<td></td>
</tr>
<tr>
<td>$\propto$</td>
<td>\propto</td>
<td></td>
</tr>
<tr>
<td>$\bowtie$</td>
<td>\bowite</td>
<td></td>
</tr>
<tr>
<td>$\Join$</td>
<td>\Join</td>
<td></td>
</tr>
<tr>
<td>$\smile$</td>
<td>\smile</td>
<td></td>
</tr>
<tr>
<td>$\frown$</td>
<td>\frown</td>
<td></td>
</tr>
<tr>
<td>$\vdash$</td>
<td>\vdash</td>
<td></td>
</tr>
<tr>
<td>$\dashv$</td>
<td>\dashv</td>
<td></td>
</tr>
</tbody></table>
<h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$\lim$</td>
<td>\ilm</td>
<td></td>
</tr>
<tr>
<td>$\rightarrow$</td>
<td>\rightarrow</td>
<td></td>
</tr>
<tr>
<td>$\infty$</td>
<td>\infty</td>
<td></td>
</tr>
<tr>
<td>$\lim_{n\rightarrow\infty}n$</td>
<td>\lim_{n\rightarrow+\infty}n</td>
<td></td>
</tr>
</tbody></table>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$\vec {a}$</td>
<td>\vec a</td>
<td></td>
</tr>
<tr>
<td>$J(\mathbf{w})$</td>
<td>J{\mathbf{w}}</td>
<td></td>
</tr>
</tbody></table>
<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a\equiv b \pmod n</span><br></pre></td></tr></table></figure>

<p>$$<br>a\equiv b \pmod n<br>$$</p>
<h2 id="箭头"><a href="#箭头" class="headerlink" title="箭头"></a>箭头</h2><table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$\uparrow$</td>
<td>\uparrow</td>
<td></td>
</tr>
<tr>
<td>$\downarrow$</td>
<td>\downarrrow</td>
<td></td>
</tr>
<tr>
<td>$\updownarrow$</td>
<td>\updownarrow</td>
<td></td>
</tr>
<tr>
<td>$\Uparrow$</td>
<td>\Uparrow</td>
<td></td>
</tr>
<tr>
<td>$\Downarrow$</td>
<td>\Downarrow</td>
<td></td>
</tr>
<tr>
<td>$\Updownarrow$</td>
<td>\Updownarrow</td>
<td></td>
</tr>
<tr>
<td>$\rightarrow$</td>
<td>\rightarrow</td>
<td></td>
</tr>
<tr>
<td>$\leftarrow$</td>
<td>\leftarrow</td>
<td></td>
</tr>
<tr>
<td>$\leftrightarrow$</td>
<td>\leftrightarrow</td>
<td></td>
</tr>
<tr>
<td>$\Rightarrow$</td>
<td>\Rightarrow</td>
<td></td>
</tr>
<tr>
<td>$\Leftarrow$</td>
<td>\Leftarrow</td>
<td></td>
</tr>
<tr>
<td>$\Leftrightarrow$</td>
<td>\Rightleftarrow</td>
<td></td>
</tr>
<tr>
<td>$\longrightarrow$</td>
<td>\longrightarrow</td>
<td></td>
</tr>
<tr>
<td>$\longleftarrow$</td>
<td>\longleftarrow</td>
<td></td>
</tr>
<tr>
<td>$\longleftrightarrow$</td>
<td>\longrightleftarrow</td>
<td></td>
</tr>
<tr>
<td>$\Longrightarrow$</td>
<td>\Longrightarrow</td>
<td></td>
</tr>
<tr>
<td>$\Longleftarrow$</td>
<td>\Longleftarrow</td>
<td></td>
</tr>
<tr>
<td>$\Longleftrightarrow$</td>
<td>\Longleftrightarrow</td>
<td></td>
</tr>
<tr>
<td>$\mapsto$</td>
<td>\mapsto</td>
<td></td>
</tr>
<tr>
<td>$\longmapsto$</td>
<td>\longmapsto</td>
<td></td>
</tr>
<tr>
<td>$\hookleftarrow$</td>
<td>\hookleftarrow</td>
<td></td>
</tr>
<tr>
<td>$\hookrightarrow$</td>
<td>\hookrightarrow</td>
<td></td>
</tr>
<tr>
<td>$\rightharpoondown$</td>
<td>\righthaipoonup</td>
<td></td>
</tr>
<tr>
<td>$\leftharpoondown$</td>
<td>\leftharpoondown</td>
<td></td>
</tr>
<tr>
<td>$\rightleftharpoons$</td>
<td>\rightleftharpoons</td>
<td></td>
</tr>
<tr>
<td>$\leftharpoonup$</td>
<td>\leftharpoonup</td>
<td></td>
</tr>
<tr>
<td>$\rightharpoondown $</td>
<td>\rightharpoondown</td>
<td></td>
</tr>
<tr>
<td>$\leadsto$</td>
<td>\leadsto</td>
<td></td>
</tr>
<tr>
<td>$\nearrow$</td>
<td>\nearrow</td>
<td></td>
</tr>
<tr>
<td>$\searrow$</td>
<td>\searrow</td>
<td></td>
</tr>
<tr>
<td>$\swarrow$</td>
<td>\swarrow</td>
<td></td>
</tr>
<tr>
<td>$\nwarrow$</td>
<td>\nwarrow</td>
<td></td>
</tr>
</tbody></table>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$\emptyset$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\varnothing$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\in$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\ni$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\notin$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\subset$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\supset$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\not\subset$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\subseteq$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\subsetneq$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\supseteq$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\cup$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\bigcup$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\cap$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\bigcap$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\uplus$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\sqsubset$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\sqsupset$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\sqcup$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\sqcap$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\sqsubseteq$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\sqsupseteq$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\vee$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\wedge$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\setminus$</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$\prime$</td>
<td></td>
<td>一阶导数</td>
</tr>
<tr>
<td>$\int$</td>
<td></td>
<td>一重积分</td>
</tr>
<tr>
<td>$\iint$</td>
<td></td>
<td>二重积分</td>
</tr>
<tr>
<td>$\iiint$</td>
<td></td>
<td>三重积分</td>
</tr>
<tr>
<td>$\oint$</td>
<td></td>
<td>曲线积分</td>
</tr>
<tr>
<td>$\nabla$</td>
<td></td>
<td>梯度</td>
</tr>
</tbody></table>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><table>
<thead>
<tr>
<th>数学算式</th>
<th>Markdown公式</th>
<th>核心语法</th>
</tr>
</thead>
<tbody><tr>
<td>$\because$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\therefore$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\forall$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\exist$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\vee $</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\wedge $</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\bigvee$</td>
<td></td>
<td></td>
</tr>
<tr>
<td>$\bigwedge$</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table>
<thead>
<tr>
<th>大写</th>
<th>Markdown公式</th>
<th>小写</th>
<th>Markdown公式</th>
</tr>
</thead>
<tbody><tr>
<td>$\Alpha$</td>
<td></td>
<td>$\alpha$</td>
<td></td>
</tr>
<tr>
<td>$\Beta$</td>
<td></td>
<td>$\beta$</td>
<td></td>
</tr>
<tr>
<td>$\Gamma$</td>
<td></td>
<td>$\gamma$</td>
<td></td>
</tr>
<tr>
<td>$\Delta$</td>
<td></td>
<td>$\delta$</td>
<td></td>
</tr>
<tr>
<td>$\Epsilon$</td>
<td></td>
<td>$\epsilon$$\varepsilon$</td>
<td></td>
</tr>
<tr>
<td>$\Zeta$</td>
<td></td>
<td>$\zeta $</td>
<td></td>
</tr>
<tr>
<td>$\Eta$</td>
<td></td>
<td>$\Eta$</td>
<td></td>
</tr>
<tr>
<td>$\Theta$</td>
<td></td>
<td>$\theta$</td>
<td></td>
</tr>
<tr>
<td>$\Iota$</td>
<td></td>
<td>$\iota$</td>
<td></td>
</tr>
<tr>
<td>$\Kappa$</td>
<td></td>
<td>$\kappa$</td>
<td></td>
</tr>
<tr>
<td>$\Lambda$</td>
<td></td>
<td>$\lambda$</td>
<td></td>
</tr>
<tr>
<td>$\Mu$</td>
<td></td>
<td>$\mu$</td>
<td></td>
</tr>
<tr>
<td>$\Nu$</td>
<td></td>
<td>$\nu$</td>
<td></td>
</tr>
<tr>
<td>$\Xi$</td>
<td></td>
<td>$\xi$</td>
<td></td>
</tr>
<tr>
<td>$\Omicron$</td>
<td></td>
<td>$\omicron$</td>
<td></td>
</tr>
<tr>
<td>$\Pi$</td>
<td></td>
<td>$\pi$</td>
<td></td>
</tr>
<tr>
<td>$\Rho$</td>
<td></td>
<td>$\rho$</td>
<td></td>
</tr>
<tr>
<td>$\Sigma$</td>
<td></td>
<td>$\sigma$</td>
<td></td>
</tr>
<tr>
<td>$\Tau$</td>
<td></td>
<td>$\tau$</td>
<td></td>
</tr>
<tr>
<td>$\Upsilon$</td>
<td></td>
<td>$\upsilon$</td>
<td></td>
</tr>
<tr>
<td>$\Phi$</td>
<td></td>
<td>$\phi$$\varphi$</td>
<td></td>
</tr>
<tr>
<td>$\Chi$</td>
<td></td>
<td>$\chi$</td>
<td></td>
</tr>
<tr>
<td>$\Psi$</td>
<td></td>
<td>$\phi$</td>
<td></td>
</tr>
<tr>
<td>$\Omega$</td>
<td></td>
<td>$\omega$</td>
<td></td>
</tr>
<tr>
<td>$$</td>
<td></td>
<td>$$</td>
<td></td>
</tr>
<tr>
<td>$$</td>
<td></td>
<td>$$</td>
<td></td>
</tr>
<tr>
<td>$$</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>$$</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><ul>
<li>实线，箭头，文字</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(汐汐)--&gt;B[汐幸]</span><br><span class="line">B[汐幸]--&gt;C&#123;是不是汐汐人&#125;</span><br><span class="line">C&#123;是不是汐汐人&#125;--&gt;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">graph TB</span><br><span class="line">A(接口请求) --&gt; B[参数校验]</span><br><span class="line">B[参数校验] --&gt; C&#123;校验通过?&#125;</span><br><span class="line">C&#123;校验通过?&#125; -- 通过 --&gt; d[处理业务逻辑]</span><br><span class="line">C&#123;校验不通过&#125; -- 不通过 --&gt; e[结束]</span><br><span class="line">d[处理业务逻辑] --&gt; e(结束)</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(接口请求) --&gt; B[参数校验]</span><br><span class="line">B[参数校验] --&gt; C&#123;校验通过?&#125;</span><br><span class="line">C&#123;校验通过?&#125; -- 通过 --&gt; d[处理业务逻辑]</span><br><span class="line">C&#123;校验不通过&#125; -- 不通过 --&gt; e[结束]</span><br><span class="line">d[处理业务逻辑] --&gt; e(结束)</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>CPP:Clang-Format的书写方式</title>
    <url>/2024/08/02/CPP-Clang-Format%E7%9A%84%E4%B9%A6%E5%86%99%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>本文在介绍使用clong-format格式化代码时，命令行参数或定义文件（.clong-format）的格式。</p>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>想要和本文实现同样的操作，请确认你的PC处于以下的环境。</p>
<ul>
<li>RHEL9.0、clang-format 15.0</li>
<li>Windows10Pro 21H2、VSCode 1.69.2、clang-format 8.0.1</li>
</ul>
<h3 id="1-指定方法和基本的格式"><a href="#1-指定方法和基本的格式" class="headerlink" title="1.指定方法和基本的格式"></a>1.指定方法和基本的格式</h3><p>有两种通用方法</p>
<p>その１．コマンドライン引数としてパラメータを指定する</p>
<p>其中之一.将参数指定为命令行参数。</p>
<p>書式例</p>
<p>书写示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">clang-format --style=<span class="string">&quot;&#123; BasedOnStyle: LLVM, IndentWidth: 4 &#125;&quot;</span> input_file_name.cpp</span><br></pre></td></tr></table></figure>

<p>その２．コマンドライン引数として設定ファイルを指定する</p>
<p>其中之二.将改动文件指定为命令行参数</p>
<p>書式例</p>
<p>书写示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">clang-format --style=file:<span class="string">&quot;~/project_dir/.clang-format&quot;</span> input_file_name.cpp</span><br></pre></td></tr></table></figure>

<p>clang-formatのコマンドオプションの詳細は以下を参照。</p>
<p>clang-format的命令行设置的详细内容请参照下方。</p>
<p>また、VSCodeで使用の際は設定ファイルより値を指定する方法となる。<br>設定ファイルは、「.clang-format」の名称で作成する。<br>作成したファイルは、ソースコード直下又はC_Cpp:Clang_format_pathにて指定したパスから読み込みを行う。</p>
<p>接着，在VSCode处使用的时候</p>
<p>C_Cpp:Clang_format_pathの設定方法は次を参照。<br><a href="https://camo.qiitausercontent.com/1c3a48578aedf5740016286a0bd9109b9869041c/68747470733a2f2f71696974612d696d6167652d73746f72652e73332e61702d6e6f727468656173742d312e616d617a6f6e6177732e636f6d2f302f313331373638382f35366333303437612d376166332d666639332d636134382d6663646535626363613536612e706e67"><img src="https://qiita-user-contents.imgix.net/https%3A%2F%2Fqiita-image-store.s3.ap-northeast-1.amazonaws.com%2F0%2F1317688%2F56c3047a-7af3-ff93-ca48-fcde5bcca56a.png?ixlib=rb-4.0.0&auto=format&gif-q=60&q=75&s=c8f9e6806285ab0a911268defcb9165b" alt="無題.png"></a></p>
<p>設定ファイルはYAML形式で記載を行う。</p>
<p>例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">キー<span class="number">1</span>: 値<span class="number">1</span></span><br><span class="line">キー<span class="number">2</span>: 値<span class="number">2</span></span><br><span class="line"># コメント</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>また、言語を指定して定義を切り分けることもできる。</p>
<p>書式例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"># Language指定なし(共通定義)。</span><br><span class="line"># 既定値としてLLVMを使用、インデントをスペース4つに指定する。</span><br><span class="line">BasedOnStyle: LLVM</span><br><span class="line">IndentWidth: 4</span><br><span class="line">---</span><br><span class="line">♯ C++用の定義</span><br><span class="line">Language: Cpp</span><br><span class="line">DerivePointerAlignment: false</span><br><span class="line">PointerAlignment: Left</span><br><span class="line">---</span><br><span class="line">♯ JavaScript用の定義</span><br><span class="line">Language: JavaScript</span><br><span class="line">ColumnLimit: 100</span><br><span class="line">---</span><br><span class="line">♯ Protocol Buffers用の定義</span><br><span class="line">Language: Proto</span><br><span class="line">DisableFormat: true</span><br><span class="line">---</span><br><span class="line">♯ C#用の定義</span><br><span class="line">Language: CSharp</span><br><span class="line">ColumnLimit: 100</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>以下のコマンドを実行すると、clang-formatの既定値の定義を出力することができる。<br>(ベースファイルとして使える)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clang-format -style=llvm -dump-config &gt; .clang-format</span><br></pre></td></tr></table></figure>

<p>※styleに指定できる値は、BasedOnStyleを参照</p>
<h2 id="２-書式及びオプション"><a href="#２-書式及びオプション" class="headerlink" title="２. 書式及びオプション"></a>２. 書式及びオプション</h2><p>style及び.clang-formatファイルに指定可能な個々のフォーマットスタイルについて記載する。</p>
<p>【凡例】</p>
<ul>
<li><p>キー名(値の型) 使用可能なバージョン</p>
<p>　概要 　値の範囲 　書式例</p>
</li>
</ul>
<p>の順で記載する。<br>値の型は、</p>
<table>
<thead>
<tr>
<th align="left">型</th>
<th align="left">意味</th>
<th align="left">例</th>
<th align="left">備考</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Integer</td>
<td align="left">数値</td>
<td align="left">100,-20</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Unsigned</td>
<td align="left">正の数値</td>
<td align="left">50</td>
<td align="left">負数を指定するとエラーとなる</td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">文字列</td>
<td align="left">“(_test)?$”</td>
<td align="left">主に正規表現を指定する項目で使用</td>
</tr>
<tr>
<td align="left">List of Strings</td>
<td align="left">文字列の配列</td>
<td align="left">[‘com.example’, ‘com’, ‘org’]</td>
<td align="left">主にキーワードのリストを指定する項目で使用</td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">真偽値</td>
<td align="left">true, false</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>その他、個別の列挙型がある。<br>列挙型の一覧については、以下のドキュメントを参照</p>
<p><strong>注意</strong><br>一部のキーについてデータ型がclang-formatのバージョンによって、Booleanから列挙型に変更となっているものがあります。<br>旧のデータ型がBooleanの場合、レガシーオプションとして列挙型＋Booleanのどちらでも指定可能となっています。<br>本稿を執筆するにあたり、各キーがどのバージョンでBooleanから列挙型に変更となったかまでの調査は出来ておりません。<br>ただし、レガシーオプションが存在するキーについてはその内容も記述をおこなっています。<br>ご自身が使用する環境で列挙型での指定がエラーとなる場合、Booleanでの指定を試してください。</p>
<ul>
<li><p>BasedOnStyle(String)</p>
<p>すべてのオプションの既定値となる値を指定する。 値意味LLVM<a href="https://llvm.org/docs/CodingStandards.html">LLVMコーディング規約</a>を標準とするGoogle<a href="https://google.github.io/styleguide/cppguide.html">Google C++ スタイルガイド</a>を標準とするChromium<a href="https://chromium.googlesource.com/chromium/src/+/refs/heads/main/styleguide/styleguide.md">Chromium スタイルガイド</a>を標準とするMozilla<a href="https://firefox-source-docs.mozilla.org/code-quality/coding-style/index.html">Mozilla コーディングスタイル</a>を標準とするWebKit<a href="https://www.webkit.org/coding/coding-style.html">WebKit コードスタイル ガイドライン</a>を標準とするMicrosoft<a href="https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/code-style-rule-options?view=vs-2022">.NET コードスタイルのルールオプション</a>を標準とするGNU<a href="https://www.gnu.org/prep/standards/standards.html">GNU コーディング規約</a>を標準とするInheritParentConfig親の設定を読み込み使用する。親が見つからない場合、フォールバックとして動作する。</p>
</li>
<li><p>AccessModifierOffset(Integer) 3.3以降</p>
<p>アクセス修飾子(public等)のインデントまたはアウトデントに対する補正を指定する。 つまり、IndentWidthで指定した値にAccessModifierOffsetで指定した値を足した値が、インデントとして設定されます。 合計した値は最低0以上である必要があり、0より小さい値となる場合、AccessModifierOffsetの値は破棄されます。</p>
</li>
<li><p>AlignAfterOpenBracket(BracketAlignmentStyle) 3.8以降</p>
<p>開き括弧の後の引数の並べ方を指定する。 この指定は、丸括弧、波括弧及び角括弧に適用となる。 値意味Align開き括弧にパラメータの先頭を合わせる。DontAlign位置を合わせない。次行以降のインデントにはContinuationIndentWidthを使用する。AlwaysBreakパラメータが1行に収まらない場合、常に開き括弧の後で改行を行う。BlockIndentAlwaysBreakと同じ動作。ただし、閉じ括弧を改行する。Align<code>someLongFunction(argument1,                 argument2); </code>DontAlign<code>someLongFunction(argument1,    argument2); </code>AlwaysBreak<code>someLongFunction(    argument1, argument2); </code>BlockIndent<code>someLongFunction(    argument1, argument2 ); </code><strong>警告</strong> 現在(clang-format15.0時点)、丸括弧のみに適用されます。</p>
</li>
<li><p>AlignArrayOfStructures(ArrayInitializerAlignmentStyle) 13以降</p>
<p>構造体配列の初期化子について、整列方向を指定する。 値意味Left配列の初期化リストを左寄せに整列する。Right配列の初期化リストを右寄せに整列する。None配列の初期化リストを整列を行わない。Left<code>// 配列の初期化リストを左寄せに整列する struct test demo[] = &#123;    &#123;56, 23,    &quot;hello&quot;&#125;,    &#123;-1, 93463, &quot;world&quot;&#125;,    &#123;7,  5,     &quot;!!&quot;   &#125; &#125;; </code>Right<code>// 配列の初期化リストを右寄せに整列する struct test demo[] = &#123;    &#123;56,    23, &quot;hello&quot;&#125;,    &#123;-1, 93463, &quot;world&quot;&#125;,    &#123; 7,     5,    &quot;!!&quot;&#125; &#125;; </code></p>
</li>
<li><p>AlignConsecutiveAssignments(AlignConsecutiveStyle) 3.8以降</p>
<p>連続した代入の揃え方を指定する。 指定した値により、次のパラメータの値を決定する。 　・Enabled 　・AcrossEmptyLines 　・AcrossComments 　・AlignCompound 　・PadOperators パラメータの意味については後述する。 ※公式ドキュメントの記述に誤りがある。公式の例にある個別パラメータへの真偽値の設定は出来ない。 値 \ パラメータEnabledAcrossEmptyLinesAcrossCommentsAlignCompoundPadOperatorsNonefalsefalsefalsefalsetrueConsecutivetruefalsefalsefalsetrueAcrossEmptyLinestruetruefalsefalsetrueAcrossCommentstruefalsetruefalsetrueAcrossEmptyLinesAndCommentstruetruetruefalsetruetruetruefalsefalsefalsetruefalsefalsefalsefalsefalsetrue※AlignCompoundがtrueとなる値は存在しない。 　値にtrueを指定した場合、Consecutiveと同じ動作となる。同様にfalseを指定した場合、Noneと同じ動作となる。各パラメータの設定値により、次の動作を行う。Enabled(Boolean)アライメントを有効とするかを指定する。true<code>// アライメントを有効にする int a            = 1; int somelongname = 2; double c         = 3; </code>false<code>// アライメントを無効とする int a = 1; int somelongname = 2; double c = 3; </code>AcrossEmptyLines(Boolean)空白行を挟んだ要素を整列するかを指定する。true<code>// 空白行を挟んだ要素も整列を行う int a            = 1; int somelongname = 2; double c         = 3; </code>false<code>// 空白行を挟んだ要素は別で整列を行う int a            = 1; int somelongname = 2; double c = 3; </code>AcrossComments(Boolean)コメント行を挟んだ要素を整列するかを指定する。true<code>// コメント行を挟んだ要素も整列を行う int a            = 1; int somelongname = 2; /* コメント */ double c         = 3; </code>false<code>// コメント行を挟んだ要素は別で整列を行う int a            = 1; int somelongname = 2; /* コメント */ double c = 3; </code>AlignCompound(Boolean)複合した演算子についての整列方法を指定する。 このフラグはAlignConsecutiveAssignmentsに対してのみ有効となる。true<code>// 演算子と複合の=について、演算子を加味した位置に調整を行う a   &amp;= 2; bbb  = 2; </code>false<code>// 演算子と複合の=について、演算子を加味しない位置に調整を行う a &amp;= 2; bbb = 2; </code>PadOperators(Boolean)長い演算子と短い演算子についての整列方法を指定する。 このフラグはAlignConsecutiveAssignmentsに対してのみ有効となる。true<code>// 演算子と複合の=について、演算子を加味した位置に調整を行う // 演算子の幅も加味して=の位置を調整する a   &gt;&gt;= 2; bbb   = 2; a     = 2; bbb &gt;&gt;= 2; </code>false<code>// =の位置を軸として調整を行う a &gt;&gt;= 2; bbb = 2; a     = 2; bbb &gt;&gt;= 2; </code></p>
</li>
<li><p>AlignConsecutiveBitFields(AlignConsecutiveStyle) 11以降</p>
<p>連続したビットフィールドの揃え方を指定する。 指定可能な値の範囲はAlignConsecutiveAssignmentsと同じのため、そちらを参照のこと。</p>
</li>
<li><p>AlignConsecutiveDeclarations(AlignConsecutiveStyle) 3.8以降</p>
<p>連続した宣言の揃え方を指定する。 指定可能な値の範囲はAlignConsecutiveAssignmentsと同じのため、そちらを参照のこと。</p>
</li>
<li><p>AlignConsecutiveMacros(AlignConsecutiveStyle) 9以降</p>
<p>連続したマクロ定義の揃え方を指定する。 指定可能な値の範囲はAlignConsecutiveAssignmentsと同じのため、そちらを参照のこと。</p>
</li>
<li><p>AlignEscapedNewlines(EscapedNewlineAlignmentStyle) 5以降</p>
<p>エスケープ文字された改行文字の揃え方を指定する。 値意味DontAlignエスケープされた改行文字を揃えないLeftエスケープされた改行文字をできるだけ左に揃えるRightエスケープされた改行文字を右端の列に揃えるDontAlign<code>// エスケープされた改行文字を揃えない(各行左詰めにする) #define A \  int aaaa; \  int b; \  int dddddddddd; </code>Left<code>// エスケープされた改行文字をできるだけ左に揃える #define A   \  int aaaa; \  int b;    \  int dddddddddd; </code>Right<code>// ColumnLimitで指定した値の位置にエスケープ文字を合わせる。 // ColumnLimitが0(無制限)の場合、Leftと同じ動作となる。 #define A                                                                      \  int aaaa;                                                                    \  int b;                                                                       \  int dddddddddd; </code></p>
</li>
<li><p>AlignOperands(OperandAlignmentStyle) 3.5以降</p>
<p>2項式及び3項式のオペランドの位置を指定する。 値意味DontAlignオペランドの整列を行わない。改行した行は行頭からContinuationIndentWidth分のスペースがインデントされる。Align水平に揃えるAlignAfterOperator水平に揃える。Alignとの差はBreakBeforeBinaryOperatorsを指定した場合の動作だけとなる。trueAlignと同じ動作。(レガシーオプション)falseDontAlignと同じ動作。(レガシーオプション)Align及びAlignAfterOperator(BreakBeforeBinaryOperatorsがNone又は未指定)<code>// オペランドは行末に付与され、改行後は変数名等を先頭に整列が行われる int aaa = bbbbbbbbbbbbbbb +          ccccccccccccccc; </code>Align(BreakBeforeBinaryOperatorsが指定あり)<code>// オペランドは改行後の先頭に付与され、オペランドの位置は先頭行の変数の頭に整列される int aaa = bbbbbbbbbbbbbbb          + ccccccccccccccc; </code>AlignAfterOperator(BreakBeforeBinaryOperatorsが指定あり)<code>// オペランドは改行後の先頭に付与され、オペランドの位置は先頭行のオペランドに整列される int aaa = bbbbbbbbbbbbbbb        + ccccccccccccccc; </code></p>
</li>
<li><p>AlignTrailingComments(Boolean) 3.7以降</p>
<p>コメントの整列方法を指定する。 true<code>// コメントの位置を整列する int a;     // comment a int b = 2; // comment b </code>false<code>// コメントの位置を整列しない(スペース1個分の位置まで詰める) int a; // comment a int b = 2; // comment b </code></p>
</li>
<li><p>AllowAllArgumentsOnNextLine(Boolean) 9以降</p>
<p>関数の引数や初期化リストが1行に収まらない場合の動作を指定する。BinPackArgumentsにfalseを指定している場合でもこの処理は動作する。 true<code>// 関数の引数を1行で記載する callFunction(    a, b, c, d); </code>false<code>// 関数の引数を複数行で記載する callFunction(a,             b,             c,             d); </code><strong>メモ書き</strong> 筆者環境にて動作が確認できず。(RHEL9.0、clang-format15) –style&#x3D;{ BreakBeforeBraces: Linux, BinPackArguments: true&#x2F;false, AllowAllArgumentsOnNextLine: true&#x2F;false }で4パターン試行して、どの指定でも変換が行われなかった。</p>
</li>
<li><p>AllowAllConstructorInitializersOnNextLine(Boolean) 9以降</p>
<p>非推奨なオプション。PackConstructorInitializersのNextLineを参照すること。 </p>
</li>
<li><p>AllowShortBlocksOnASingleLine(ShortBlockStyle) 3.5以降</p>
<p>短いwhile文( while (true) { continue; } )の並べ方を指定する。 ※ステートメントを波括弧で囲んでいる場合の動作。波括弧を付与しない場合、AllowShortLoopsOnASingleLineにより指定を行う。 値意味Neverブロックを1行に並べない。Empty空のブロックだけ1行に並べる。Always短いブロックは1行に並べる。trueAlwaysと同じ動作となる。(レガシーオプション)falseNeverと同じ動作となる。(レガシーオプション)Never<code>// 短いwhile文も必ず折り返す while (true) &#123; &#125; while (true) &#123;  continue; &#125; </code>Empty<code>// 空のwhile文は1行に纏める while (true) &#123;&#125; while (true) &#123;  continue; &#125; </code>Always<code>// while文を1行に纏める while (true) &#123;&#125; while (true) &#123; continue; &#125; </code></p>
</li>
<li><p>AllowShortCaseLabelsOnASingleLine(Boolean) 3.6以降</p>
<p>短いcase文のまとめ方を指定する。 true<code>// caseラベルとその処理を1行にまとめる switch (a) &#123; case 1: x = 1; break; case 2: return; &#125; </code>false<code>// caseラベルとその処理を1行にまとめない switch (a) &#123; case 1:  x = 1;  break; case 2:  return; </code></p>
</li>
<li><p>AllowShortEnumsOnASingleLine(Boolean) 11以降</p>
<p>短い列挙型のまとめ方を指定する。 true<code>// 列挙型を1行にまとめる enum &#123; A, B &#125; myEnum; &#125; </code>false<code>// 列挙型を1行にまとめない enum &#123;  A,  B &#125; myEnum; </code></p>
</li>
<li><p>AllowShortFunctionsOnASingleLine(ShortFunctionStyle) 3.5以降</p>
<p>短い関数(処理が1行以下)の纏め方を指定する。 値意味None関数を1行に纏めない。InlineOnlyクラス内で定義した関数だけ1行に纏める。Inlineと同じ動作だが、空の関数についてのみ動作が異なる。Empty空の関数は1行に纏める。Inlineクラス内で定義した関数だけ1行に纏める。Allすべての関数を1行に纏めるtrueAllと同じ動作となる。(レガシーオプション)falseNoneと同じ動作となる。(レガシーオプション)InlineOnly<code>// クラスメソッドは1行に纏められる。 class Foo &#123;  void f1() &#123; foo(); &#125; &#125;; void f2() &#123;  foo(); &#125; // Inlineと異なる箇所 void f3() &#123; &#125; </code>Empty<code>class Foo &#123;  void f1() &#123;    foo();  &#125; &#125;; void f2() &#123;  foo(); &#125; // 空のメソッドだけ1行に纏める void f3() &#123;&#125; </code>Inline<code>// クラスメソッドと空のメソッドが1行に纏められる。 class Foo &#123;  void f1() &#123; foo(); &#125; &#125;; void f2() &#123;  foo(); &#125; void f3() &#123;&#125; </code>All<code>// すべて1行に纏める。 class Foo &#123;  void f1() &#123; foo(); &#125; &#125;; void f2() &#123; foo(); &#125; void f3() &#123;&#125; </code></p>
</li>
<li><p>AllowShortIfStatementsOnASingleLine(ShortIfStyle) 3.3以降</p>
<p>短いif及びelseの纏め方を指定する。 値意味Never短いifを同じ行に並べない。WithoutElseelse文がない場合のみ、短いifを同じ行に並べる。OnlyFirstIf短いifだけを並べる。else ifやelse文は並べない。AllIfsAndElse短いif、else if及びelse文を同じ行に並べる。AlwaysOnlyFirstIfと同じ動作となる。(レガシーオプション)trueWithoutElseと同じ動作となる。(レガシーオプション)falseNeverと同じ動作となる。(レガシーオプション)Never<code>if (a)  return; if (b)  return; else  return; if (c)  return; else &#123;  return; &#125; </code>WithoutElse<code>// ifだけの場合、1行に纏める。 if (a) return; if (b)  return; else  return; if (c)  return; else &#123;  return; &#125; </code>AllIfsAndElse<code>// すべて1行に纏める。 if (a) return; if (b) return; else return; if (c) return; else &#123;  return; &#125; </code></p>
</li>
<li><p>AllowShortIfStatementsOnASingleLine(ShortLambdaStyle) 9以降</p>
<p>短いラムダ式の纏め方を指定する。 値意味None短いラムダ式を同じ行に並べない。Empty空のラムダ式だけ1行に並べる。Inline関数の引数として指定したラムダ式だけ1行に並べる。Allすべての短いラムダ式を1行に並べる。trueAllと同じ動作となる。(レガシーオプション)falseNoneと同じ動作となる。(レガシーオプション)Empty<code>// 空のラムダ式だけ1行に並べる。 auto lambda = [](int a) &#123;&#125;; auto lambda2 = [](int a) &#123;  return a; &#125;; sort(vct.begin(), vct.end(), [](int x, int y) &#123;  return x &lt; y; &#125;); </code>Inline<code>auto lambda = [](int a) &#123; &#125;; auto lambda2 = [](int a) &#123;  return a; &#125;; // 関数の引数として指定したラムダ式だけ1行に並べる。 sort(vct.begin(), vct.end(), [](int x, int y) &#123; return x &lt; y; &#125;); </code>All<code>// すべての短いラムダ式を1行に並べる。 auto lambda = [](int a) &#123;&#125;; auto lambda2 = [](int a) &#123; return a; &#125;; sort(vct.begin(), vct.end(), [](int x, int y) &#123; return x &lt; y; &#125;); </code></p>
</li>
<li><p>AllowShortLoopsOnASingleLine(Boolean) 3.7以降</p>
<p>短いwhile文( while (true) continue; )の並べ方を指定する。 ※ステートメントを波括弧で囲んでいない場合の動作。波括弧を付与する場合、AllowShortBlocksOnASingleLine により指定を行う。true<code>while (true) &#123; continue; &#125; </code>false<code>while (true) &#123;  continue; &#125; </code></p>
</li>
<li><p>AlwaysBreakAfterDefinitionReturnType(DefinitionReturnTypeBreakingStyle) 3.7以降</p>
<p>非推奨なオプション。</p>
</li>
<li><p>AlwaysBreakAfterReturnType(ReturnTypeBreakingStyle) 3.8以降</p>
<p>関数の戻り値の改行スタイルを指定する。 値意味None戻り値を改行しない。All戻り値の後で必ず改行する。TopLevelトップレベルの関数だけ、戻り値の後で改行する。AllDefinitions関数の実体定義だけ、戻り値の後で改行する。TopLevelDefinitionsトップレベルの関数の実体定義だけ、戻り値の後で改行する。trueAllと同じ動作となる。(レガシーオプション)falseNoneと同じ動作となる。(レガシーオプション)None<code>class B &#123;  int f() &#123; return 0; &#125;; &#125;; int f(); int f() &#123; return 1; &#125; </code>All<code>class B &#123;  int  f() &#123;    return 0;  &#125;; &#125;; int f(); int f() &#123;  return 1; &#125; </code>TopLevel<code>class B &#123;  int f() &#123; return 0; &#125;; &#125;; // トップレベルのメソッド(クラススコープのメソッドではない？)は改行する。 int f(); int f() &#123;  return 1; &#125; </code>AllDefinitions<code>// 関数の実体定義がある場合は改行する。 class B &#123;  int  f() &#123;    return 0;  &#125;; &#125;; int f(); int f() &#123;  return 1; &#125; </code></p>
</li>
<li><p>AlwaysBreakBeforeMultilineStrings(Boolean) 3.4以降</p>
<p>文字列リテラルの並べ方を指定する。 ContinuationIndentWidthが未指定の場合だけ、このフラグが有効となる。true<code>const char *sz =    &quot;aaaa&quot;    &quot;bbbb&quot;; </code>false<code>const char *sz = &quot;aaaa&quot;                 &quot;bbbb&quot;; </code></p>
</li>
<li><p>AlwaysBreakTemplateDeclarations(BreakTemplateDeclarationsStyle) 3.4以降</p>
<p>テンプレート宣言の改行スタイルを指定する。 値意味Noテンプレート宣言の後に改行を行わない。MultiLineテンプレート宣言の後が複数行になる場合だけ改行を行うYes必ずテンプレート宣言の後に改行を行う。falseMultiLineと同じ動作となる。(レガシーオプション)trueYesと同じ動作となる。(レガシーオプション)No<code>template &lt;typename T&gt; T foo() &#123; &#125; template &lt;typename T&gt; T foo(int aaaaaaaaaaaaaaaaaaaaa,                            int bbbbbbbbbbbbbbbbbbbbb) &#123; &#125; </code>MultiLine<code>template &lt;typename T&gt; T foo() &#123; &#125; // テンプレート宣言の後ろに複数行ある場合だけ改行を行う template &lt;typename T&gt; T foo(int aaaaaaaaaaaaaaaaaaaaa,      int bbbbbbbbbbbbbbbbbbbbb) &#123; &#125; </code>Yes<code>// テンプレート宣言の後は必ず改行する template &lt;typename T&gt; T foo() &#123; &#125; template &lt;typename T&gt; T foo(int aaaaaaaaaaaaaaaaaaaaa,      int bbbbbbbbbbbbbbbbbbbbb) &#123; </code></p>
</li>
<li><p>AttributeMacros(List of Strings) 12以降</p>
<p>識別子ではなく、属性&#x2F;修飾子として解釈されるべき文字列のリストを指定する。 つまり、このリストで指定したキーワードは属性&#x2F;修飾子としてフォーマットが行われる。  .clang-format 設定ファイルでは、次の様に設定することができる。<code>AttributeMacros: [&#39;__capability&#39;, &#39;__output&#39;, &#39;__ununsed&#39;] </code></p>
</li>
<li><p>BinPackArguments(Boolean) 3.7以降</p>
<p>関数の引数の並べ方を指定する。 true<code>// 1行の最大文字数を基準に折り返しを行う void f() &#123;  f(aaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaa,    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa); &#125; </code>false<code>// 引数を各1行ずつに折り返す void f() &#123;  f(aaaaaaaaaaaaaaaaaaaa,    aaaaaaaaaaaaaaaaaaaa,    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa); &#125; </code></p>
</li>
<li><p>BinPackParameters(Boolean) 3.7以降</p>
<p>関数宣言や関数定義の引数の並べ方を指定する。 true<code>// 1行の最大文字数を基準に折り返しを行う void f(int aaaaaaaaaaaaaaaaaaaa, int aaaaaaaaaaaaaaaaaaaa,       int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) &#123;&#125; </code>false<code>// 引数を各1行ずつに折り返す void f(int aaaaaaaaaaaaaaaaaaaa,       int aaaaaaaaaaaaaaaaaaaa,       int aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) &#123;&#125; </code></p>
</li>
<li><p>BitFieldColonSpacing(BitFieldColonSpacingStyle) 12以降</p>
<p>テンプレート宣言の改行スタイルを指定する 値意味Bothコロンの前後にスペースを挿入する。Noneコロンの前後にスペースを挿入しない。Beforeコロンの前だけスペースを挿入する。Afterコロンの後ろだけスペースを挿入する。Both<code>unsigned bf : 2; </code>None<code>unsigned bf:2; </code>Before<code>unsigned bf :2; </code>After<code>unsigned bf: 2; </code></p>
</li>
<li><p>BraceWrapping (BraceWrappingFlags) 3.8以降</p>
<p>括弧の個別制御を指定する。このフラグはBreakBeforeBracesがBS_Customに設定されている場合だけ有効で、それ以外の場合は無視される。.clang-formatの書式例<code>BreakBeforeBraces: Custom BraceWrapping:  AfterEnum: true  AfterStruct: false  SplitEmptyFunction: false </code>各設定フラグについては以下のとおり。AfterCaseLabel(Boolean)caseラベルに対する括弧の制御方法を指定する。true<code> // caseラベルの後ろの括弧は改行する  switch (foo) &#123;    case 1:    &#123;      bar();      break;    &#125;    default:    &#123;      plop();    &#125;  &#125;</code>false<code> // caseラベルの後ろの括弧は改行しない  switch (foo) &#123;    case 1: &#123;      bar();      break;    &#125;    default: &#123;      plop();    &#125;  &#125;</code>AfterClass(Boolean)クラス定義に対する括弧の制御方法を指定する。true<code>// 後ろの括弧は改行する class foo &#123;&#125;; </code>false<code>// 後ろの括弧は改行しない class foo &#123;&#125;; </code><strong>メモ書き</strong> 公式ドキュメントに誤記あり。 trueとfalseの動作が逆に記載されている。AfterControlStatement(BraceWrappingAfterControlStatementStyle)ステートメント(if、for、while、switch等)に対する括弧の制御方法を指定する。 値意味Never制御文の後の波括弧を改行しない。MultiLine複数行の制御文の後の波括弧だけ改行する。Always制御文の後の波括弧を改行する。falseNeverと同じ動作となる。(レガシーオプション)trueAlwaysと同じ動作となる。(レガシーオプション)Never<code> // 制御文の後の波括弧を改行しない。  if (foo()) &#123;  &#125; else &#123;  &#125;  for (int i = 0; i &lt; 10; ++i) &#123;  &#125;</code>MultiLine<code> // 複数行の制御文の後の波括弧だけ改行する。  if (foo &amp;&amp; bar &amp;&amp;      baz)  &#123;    quux();  &#125;  while (foo || bar) &#123;  &#125;</code>Always<code> // 制御文の後の波括弧を改行する。  if (foo())  &#123;  &#125; else  &#123;&#125;  for (int i = 0; i &lt; 10; ++i)  &#123;&#125;</code>AfterEnum(Boolean)列挙型に対する括弧の制御方法を指定する。true<code>// 後ろの括弧は改行する enum X : int &#123;  B &#125;; </code>false<code>// 後ろの括弧は改行しない enum X : int &#123; B &#125;; </code>AfterFunction(Boolean)関数に対する括弧の制御方法を指定する。true<code>// 後ろの括弧は改行する void foo() &#123;  bar();  bar2(); &#125; </code>false<code>// 後ろの括弧は改行しない void foo() &#123;  bar();  bar2(); &#125; </code>AfterNamespace(Boolean)名前空間に対する括弧の制御方法を指定する。true<code>// 後ろの括弧は改行する namespace &#123; int foo(); int bar(); &#125; </code>false<code>// 後ろの括弧は改行しない namespace &#123; int foo(); int bar(); &#125; </code>AfterObjCDeclaration(Boolean)Objective-Cの定義(@interface、@implementation等)、@autoreleasepool及び@synchronizedに対する括弧の制御方法を指定する。true<code>// 後ろの括弧は改行する @interface MyObject : NSObject &#123;  int val; &#125; </code>false<code>// 後ろの括弧は改行しない @interface MyObject : NSObject &#123;  int val; &#125; </code>AfterStruct(Boolean)構造体に対する括弧の制御方法を指定する。true<code>// 後ろの括弧は改行する struct foo &#123;  int x; &#125;; </code>false<code>// 後ろの括弧は改行しない struct foo &#123;  int x; &#125;; </code>AfterUnion(Boolean)共用体に対する括弧の制御方法を指定する。true<code>// 後ろの括弧は改行する union foo &#123;  int x; &#125; </code>false<code>// 後ろの括弧は改行しない union foo &#123;  int x; &#125; </code>AfterExternBlock(Boolean)外部結合ブロック(extern)に対する括弧の制御方法を指定する。true<code>// 後ろの括弧は改行する extern &quot;C&quot; &#123;  int foo(); &#125; </code>false<code>// 後ろの括弧は改行しない extern &quot;C&quot; &#123; int foo(); &#125; </code>BeforeCatch(Boolean)catch句の前方の括弧の制御方法を指定する。true<code>// 前方の括弧は改行する try &#123;  foo(); &#125; catch () &#123; &#125; </code>false<code>// 前方の括弧は改行しない try &#123;  foo(); &#125; catch () &#123; &#125; </code>BeforeElse(Boolean)else句の前方の括弧の制御方法を指定する。true<code>// 前方の括弧は改行する if (foo()) &#123; &#125; else &#123; &#125; </code>false<code>// 前方の括弧は改行しない if (foo()) &#123; &#125; else &#123; &#125; </code>BeforeLambdaBody(Boolean)ラムダ式の前方の括弧の制御方法を指定する。true<code>// 前方の括弧は改行する(キャプチャとラムダ導入子も改行される？) connect(  []()  &#123;    foo();    bar();  &#125;); </code>false<code>// 前方の括弧は改行しない connect([]() &#123;  foo();  bar(); &#125;); </code>BeforeWhile(Boolean)do～whileの前方の括弧の制御方法を指定する。true<code>// 前方の括弧は改行する do &#123;  foo(); &#125; while (1); </code>false<code>// 前方の括弧は改行しない do &#123;  foo(); &#125; while (1); </code>IndentBraces(Boolean)折り返した波括弧のインデントの可否を指定する。true<code>// 折り返した波括弧をインデントする if (a) &#123;    foo(a,b); &#125; else &#123;  &#125; for (int i = 0; i &lt; 10; ++i) &#123;  &#125; </code>false<code>// 折り返した波括弧をインデントしない if (a) &#123;  foo(a, b); &#125; else &#123; &#125; for (int i = 0; i &lt; 10; ++i) &#123; &#125; </code>SplitEmptyFunction(Boolean)空の関数本体を1行に纏めるかを指定する。このオプションはAllowShortFunctionsOnASingleLine にNone、AfterFunctionにtrueを指定している場合のみ適用されます。true<code>// 空の関数の括弧を1行に並べない。 int f() &#123; &#125; </code>false<code>// 空の関数の括弧を1行に並べる。 int f() &#123;&#125; </code>SplitEmptyRecord(Boolean)空のクラス本体を1行に纏めるかを指定する。AfterClassにtrueを指定している場合のみ適用されます。true<code>// 空のクラスの括弧を1行に並べない。 class Foo &#123; &#125; </code>false<code>// 空のクラスの括弧を1行に並べる。 class Foo &#123;&#125; </code>SplitEmptyNamespace(Boolean)空の名前空間本体を1行に纏めるかを指定する。AfterNamespaceにtrueを指定している場合のみ適用されます。true<code>// 空のクラスの括弧を1行に並べない。 namespace Foo &#123; &#125; </code>false<code>// 空のクラスの括弧を1行に並べる。 namespace Foo &#123;&#125; </code></p>
</li>
<li><p>BreakAfterJavaFieldAnnotations(Boolean) 3.8以降</p>
<p>Javaファイルのアノテーションの改行を指定する。true<code>// アノテーションで改行する @Partial @Mock DataLoad loader; </code>false<code>// アノテーションで改行しない @Partial @Mock DataLoad loader; </code></p>
</li>
<li><p>BreakBeforeBinaryOperators(BinaryOperatorStyle) 3.6以降</p>
<p>二項演算子の並べ方を指定する。 値意味None演算子の後で改行する。NonAssignment代入ではない演算子の前で改行する。All演算子の前で改行する。trueAllと同じ動作。falseNoneと同じ動作。None<code>// 演算子の後で改行する。 LooooooooooongType loooooooooooooooooooooongVariable =    someLooooooooooooooooongFunction(); bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa +                     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ==                 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &amp;&amp;             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa &gt;                 ccccccccccccccccccccccccccccccccccccccccc; </code>NonAssignment<code>// 代入ではない演算子の後で改行する。 LooooooooooongType loooooooooooooooooooooongVariable =    someLooooooooooooooooongFunction(); bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                     + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                 == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa             &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                    &gt; ccccccccccccccccccccccccccccccccccccccccc; </code>All<code>// 演算子の前で改行する。 LooooooooooongType loooooooooooooooooooooongVariable    = someLooooooooooooooooongFunction(); bool value = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                     + aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                 == aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa             &amp;&amp; aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa                    &gt; ccccccccccccccccccccccccccccccccccccccccc; </code><strong>メモ書き</strong> NonAssignmentとAllの挙動が理解できない。改行位置はわかるがインデントはどうしてこの動作になるのか。(実動作を確認の結果、記載のインデントになる)</p>
</li>
<li><p>BreakBeforeBraces(BraceBreakingStyle) 3.7以降</p>
<p>括弧の制御を一括で指定する。 値意味Attach文脈の後に括弧を並べる。LinuxAttachと同様。ただし関数、名前空間、クラス定義(C#のレコード型を含む)の括弧は改行する。MozillaAttachと同様。ただし列挙型、関数、名前空間、クラス定義(C#のレコード型を含む)の括弧は改行する。StroustrupAttachと同様。ただし関数定義、catch、elseの前の括弧は改行する。Allman文脈の後の括弧を改行する。WhitesmithsAllmanと同様。ただし波括弧にインデントを付ける。GNUAllmanと同様。ただし制御文の波括弧にインデントを付ける。WebKitAttachと同様。ただし関数の括弧は改行する。CustomBraceWrappingフラグにより個々の改行ルールを決定する。(BraceWrappingの項を参照)Attach<code>namespace N &#123; enum E &#123;  E1,  E2, &#125;; class C &#123; public:  C(); &#125;; bool baz(int i) &#123;  try &#123;    do &#123;      switch (i) &#123;      case 1: &#123;        foobar();        break;      &#125;      default: &#123;        break;      &#125;      &#125;    &#125; while (--i);    return true;  &#125; catch (...) &#123;    handleError();    return false;  &#125; &#125; void foo(bool b) &#123;  if (b) &#123;    baz(2);  &#125; else &#123;    baz(5);  &#125; &#125; void bar() &#123; foo(true); &#125; &#125; // namespace N </code>Linux<code>namespace N &#123; enum E &#123;  E1,  E2, &#125;; class C &#123; public:  C(); &#125;; bool baz(int i) &#123;  try &#123;    do &#123;      switch (i) &#123;      case 1: &#123;        foobar();        break;      &#125;      default: &#123;        break;      &#125;      &#125;    &#125; while (--i);    return true;  &#125; catch (...) &#123;    handleError();    return false;  &#125; &#125; void foo(bool b) &#123;  if (b) &#123;    baz(2);  &#125; else &#123;    baz(5);  &#125; &#125; void bar() &#123; foo(true); &#125; &#125; // namespace N </code>Mozilla<code>namespace N &#123; enum E &#123;  E1,  E2, &#125;; class C &#123; public:  C(); &#125;; bool baz(int i) &#123;  try &#123;    do &#123;      switch (i) &#123;      case 1: &#123;        foobar();        break;      &#125;      default: &#123;        break;      &#125;      &#125;    &#125; while (--i);    return true;  &#125; catch (...) &#123;    handleError();    return false;  &#125; &#125; void foo(bool b) &#123;  if (b) &#123;    baz(2);  &#125; else &#123;    baz(5);  &#125; &#125; void bar() &#123; foo(true); &#125; &#125; // namespace N </code>Stroustrup<code>namespace N &#123; enum E &#123;  E1,  E2, &#125;; class C &#123; public:  C(); &#125;; bool baz(int i) &#123;  try &#123;    do &#123;      switch (i) &#123;      case 1: &#123;        foobar();        break;      &#125;      default: &#123;        break;      &#125;      &#125;    &#125; while (--i);    return true;  &#125;  catch (...) &#123;    handleError();    return false;  &#125; &#125; void foo(bool b) &#123;  if (b) &#123;    baz(2);  &#125;  else &#123;    baz(5);  &#125; &#125; void bar() &#123; foo(true); &#125; &#125; // namespace N </code>Allman<code>namespace N &#123; enum E &#123;  E1,  E2, &#125;; class C &#123; public:  C(); &#125;; bool baz(int i) &#123;  try  &#123;    do    &#123;      switch (i)      &#123;      case 1:      &#123;        foobar();        break;      &#125;      default:      &#123;        break;      &#125;      &#125;    &#125; while (--i);    return true;  &#125;  catch (...)  &#123;    handleError();    return false;  &#125; &#125; void foo(bool b) &#123;  if (b)  &#123;    baz(2);  &#125;  else  &#123;    baz(5);  &#125; &#125; void bar() &#123; foo(true); &#125; &#125; // namespace N </code>Whitesmiths<code>namespace N  &#123; enum E  &#123;  E1,  E2,  &#125;; class C  &#123; public:  C();  &#125;; bool baz(int i)  &#123;  try    &#123;    do      &#123;      switch (i)        &#123;        case 1:        &#123;        foobar();        break;        &#125;        default:        &#123;        break;        &#125;        &#125;      &#125; while (--i);    return true;    &#125;  catch (...)    &#123;    handleError();    return false;    &#125;  &#125; void foo(bool b)  &#123;  if (b)    &#123;    baz(2);    &#125;  else    &#123;    baz(5);    &#125;  &#125; void bar() &#123; foo(true); &#125;  &#125; // namespace N </code>GNU<code>namespace N &#123; enum E &#123;  E1,  E2, &#125;; class C &#123; public:  C(); &#125;; bool baz(int i) &#123;  try    &#123;      do        &#123;          switch (i)            &#123;            case 1:              &#123;                foobar();                break;              &#125;            default:              &#123;                break;              &#125;            &#125;        &#125;      while (--i);      return true;    &#125;  catch (...)    &#123;      handleError();      return false;    &#125; &#125; void foo(bool b) &#123;  if (b)    &#123;      baz(2);    &#125;  else    &#123;      baz(5);    &#125; &#125; void bar() &#123; foo(true); &#125; &#125; // namespace N </code>WebKit<code>namespace N &#123; enum E &#123;  E1,  E2, &#125;; class C &#123; public:  C(); &#125;; bool baz(int i) &#123;  try &#123;    do &#123;      switch (i) &#123;      case 1: &#123;        foobar();        break;      &#125;      default: &#123;        break;      &#125;      &#125;    &#125; while (--i);    return true;  &#125; catch (...) &#123;    handleError();    return false;  &#125; &#125; void foo(bool b) &#123;  if (b) &#123;    baz(2);  &#125; else &#123;    baz(5);  &#125; &#125; void bar() &#123; foo(true); &#125; &#125; // namespace N </code></p>
</li>
<li><p>BreakBeforeConceptDeclarations(BreakBeforeConceptDeclarationsStyle) 12以降</p>
<p>コンセプトに対する括弧の制御方法を指定する。 値意味Neverテンプレート宣言とコンセプトを並べる。Allowed他のフラグ指定に従い、テンプレート宣言の後に改行を行うことが可能。指定がない場合、テンプレート宣言とコンセプトを並べる。Alwaysコンセプトの前で改行する。trueAlwaysと同じ動作。(レガシーオプション)falseAllowedと同じ動作。(レガシーオプション)Never<code>template &lt;class T&gt; concept Foo = requires(T &amp;x) &#123;&#125;; </code>Always<code>template &lt;class T&gt; concept Foo = requires(T &amp;x) &#123;&#125;; </code></p>
</li>
<li><p>BreakBeforeTernaryOperators(Boolean) 3.7以降</p>
<p>1行に収まらない三項演算子に対する括弧の制御方法を指定する。true<code>// 演算子の前で改行を行う veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription    ? firstValue    : SecondValueVeryVeryVeryVeryLong; </code>false<code>// 演算子の後で改行を行う veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ?    firstValue :    SecondValueVeryVeryVeryVeryLong; </code></p>
</li>
<li><p>BreakConstructorInitializers(BreakConstructorInitializersStyle) 5以降</p>
<p>コンストラクタの初期化リストに対する制御方法を指定する。 値意味BeforeColonコロンの前とカンマの後で改行する。BeforeCommaコロンとカンマの前で改行し、コロンとカンマの位置を合わせる。AfterColonコロンとカンマの後で改行する。BeforeColon<code>Constructor()    : initializer1(),      initializer2() </code>BeforeComma<code>Constructor()    : initializer1()    , initializer2() </code>AfterColon<code>Constructor() :    initializer1(),    initializer2() </code></p>
</li>
<li><p>BreakInheritanceList(BreakInheritanceListStyle) 7以降</p>
<p>継承リストに対する制御方法を指定する。 値意味BeforeColonコロンの前とカンマの後で改行する。BeforeCommaコロンとカンマの前で改行し、コロンとカンマの位置を合わせる。AfterColonコロンとカンマの後で改行する。AfterCommaカンマの後で改行する。BeforeColon<code>class Foo    : Base1,      Base2 &#123;&#125;; </code>BeforeComma<code>class Foo    : Base1    , Base2 &#123;&#125;; </code>AfterColon<code>class Foo :    Base1,    Base2 &#123;&#125;; </code>AfterComma<code>class Foo : Base1,            Base2 &#123;&#125;; </code></p>
</li>
<li><p>BreakStringLiterals(Boolean) 3.9以降</p>
<p>1行に収まらない文字列リテラルに対する制御方法を指定する。true<code>// 1行の最大文字数で文字列リテラルを分割する const char* x = &quot;veryVeryVeryVeryVeryVe&quot;                &quot;ryVeryVeryVeryVeryVery&quot;                &quot;VeryLongString&quot;; </code>false<code>// 文字列リテラルを分割しない const char* x =  &quot;veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongString&quot;; </code><strong>メモ書き</strong> 一度、BreakStringLiteralsをtrueに指定し文字列リテラルを整形したのち、falseを指定してフォーマットしなおした場合、分割された文字列リテラルは自動で繋がらない。(元に戻らない)</p>
</li>
<li><p>ColumnLimit(Unsigned) 3.7以降</p>
<p>1行の最大文字数を指定する。 0を指定した場合、ステートメント内で他のルールと矛盾しない限り無制限となる。</p>
</li>
<li><p>CommentPragmas(String) 3.7以降</p>
<p>行分割してはいけないコメントを、正規表現で指定する。 例<code>// CommentPragmas: &#39;^ FOOBAR pragma:&#39; // 上記の値を指定した場合、以下の行は改行されない。 #include &lt;vector&gt; // FOOBAR pragma: keep </code></p>
</li>
<li><p>CompactNamespaces(boolean) 5以降</p>
<p>連続した名前空間に対する制御方法を指定する。 true<code>// 連続した名前空間を改行しない。 namespace Foo &#123; namespace Bar &#123; &#125;&#125; // ただし、1行に収まらない場合、改行が行われる。 namespace Foo &#123; namespace Bar &#123; namespace Extra &#123; &#125;&#125;&#125; </code>false<code>// 連続した名前空間を改行する。 namespace Foo &#123; namespace Bar &#123; &#125; &#125; </code></p>
</li>
<li><p>ConstructorInitializerAllOnOneLineOrOnePerLine(Boolean) 3.7以降</p>
<p>非推奨のオプション。CurrentLine又はPackConstructorInitializersを参照。 </p>
</li>
<li><p>ConstructorInitializerIndentWidth(Unsigned) 3.7以降</p>
<p>コンストラクタの初期化リスト及び継承リストのインデントを指定する。 </p>
</li>
<li><p>ContinuationIndentWidth(Unsigned) 3.7以降</p>
<p>連続する行のインデントを指定する。 例<code>// ContinuationIndentWidth: 2 を指定した場合、連続した記述についてインデントが2ずつ付与される。 int i =         //  VeryVeryVeryVeryVeryLongComment  longFunction( // Again a long comment    arg); </code></p>
</li>
<li><p>Cpp11BracedListStyle(Boolean) 3.4以降</p>
<p>C++11の初期化リストのフォーマットを指定する。 【重要な相違点】 trueを指定した場合、 ・波括弧付きリストの内部に空白を入れない。 ・閉じ波括弧の前に改行しない。 ・ブロック・インデントではなく、継続インデントでインデントする。 となる。  基本的に、C++11 の初期化リストは、関数呼び出しと全く同じ書式で記述されます。初期化リストが名前（例えば型名や変数名）の後にある場合、clang-formatは{}をその名前を持つ関数呼び出しの括弧であるかのようにフォーマットします。もし名前がなければ、長さ0の名前と見なします。true<code>// 初期化リストの開き括弧の後と閉じ括弧の前に空白を挿入しない。 vector&lt;int&gt; x&#123;1, 2, 3, 4&#125;; vector&lt;T&gt; x&#123;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&#125;; f(MyMap[&#123;composite, key&#125;]); new int[3]&#123;1, 2, 3&#125;; </code>false<code>// 初期化リストの開き括弧の後と閉じ括弧の前に空白を挿入する。 vector&lt;int&gt; x&#123; 1, 2, 3, 4 &#125;; vector&lt;T&gt; x&#123; &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125; &#125;; f(MyMap[&#123; composite, key &#125;]); new int[3]&#123; 1, 2, 3 &#125;; </code></p>
</li>
<li><p>DeriveLineEnding(Boolean) 10以降</p>
<p>改行コードをCR+LF又はLFに統一する。 DeriveLineEndingにtrueを指定した場合、ファイル内で一番多い改行コードでファイルの改行を統一する。 DeriveLineEndingにfalseを指定した場合、UseCRLFがtrueであればファイルの改行コードをCR+LFで統一し、UseCRLFがfalseであればDeriveLineEndingにtrueを指定した場合と同じ動作となる。</p>
</li>
<li><p>DerivePointerAlignment(Boolean) 3.7以降</p>
<p>参照(&amp;)及びポインタ(*)の位置を統一する。 trueを指定した場合、ファイル内で一番記述の参照及びポインタの書式に統一する。 falseを指定した場合、PointerAlignmentで指定した値に従い書式を変更する。PointerAlignmentの指定がない場合、trueと同じ動作となる。例<code>int* p1 = NULL; // データ型に*が寄せられている int &amp;r1 = d;    // 変数名に&amp;が寄せられている int *p2 = NULL; // 変数名に*が寄せられている ↓ // DerivePointerAlignment: true を指定した場合 int *p1 = NULL; // 多数決(2対1)で変数名に寄せているパターンが多いので変数名側に統一される。 int &amp;r1 = d; int *p2 = NULL; </code></p>
</li>
<li><p>DisableFormat(Boolean) 3.7以降</p>
<p>フォーマットを無効にする。 </p>
</li>
<li><p>EmptyLineAfterAccessModifier(EmptyLineAfterAccessModifierStyle) 13以降</p>
<p>アクセス修飾子の後に対する制御方法を指定する。 値意味Neverアクセス修飾子の後の空行をすべて削除する。Leaveアクセス修飾子の後の空行を削除しない。代わりにMaxEmptyLinesToKeepによる制御が行われる。Alwaysアクセス修飾子の後の空行を追加する。MaxEmptyLinesToKeepによる制御も同時に適用される。Never<code>struct foo &#123; private:  int i; protected:  int j;  /* comment */ public:  foo() &#123;&#125; private: protected: &#125;; </code>Always<code>struct foo &#123; private:   int i; protected:   int j;  /* comment */ public:   foo() &#123;&#125; private: protected: &#125;; </code></p>
</li>
<li><p>EmptyLineBeforeAccessModifier(EmptyLineBeforeAccessModifierStyle) 12以降</p>
<p>アクセス修飾子の前に対する制御方法を指定する。 値意味Neverアクセス修飾子の前の空行をすべて削除する。Leaveアクセス修飾子の前の空行を削除しない。LogicalBlockアクセス修飾子が新しい論理ブロックを開始する場合だけ、空行を追加する。論理ブロックとは1つ以上のフィールド又は関数からなるグループのことを指す。Alwaysアクセス修飾子がクラスや構造体の先頭にある場合を除き、アクセス修飾子の前に空行を追加する。Never<code>struct foo &#123; private:  int i; protected:  int j;  /* comment */ public:  foo() &#123;&#125; private: protected: &#125;; </code>LogicalBlock<code>struct foo &#123; private:  int i; protected:  int j;  /* comment */ public:  foo() &#123;&#125; private: protected: &#125;; </code>Always<code>struct foo &#123; private:  int i; protected:  int j;  /* comment */ public:  foo() &#123;&#125; private: protected: &#125;; </code></p>
</li>
<li><p>ExperimentalAutoDetectBinPacking(Boolean) 3.7以降</p>
<p>trueの場合、clang-formatは関数呼び出しと定義が1行に1つのパラメータでフォーマットされているかどうかを検出します。  各呼び出しはbin-packed、1行ごと、または決定的でないことができます。もし結論が出ない場合、例えば完全に一行で、しかし決定を下す必要がある場合、clang-formatは入力ファイルに他のbin-packedケースがあるかどうかを分析し、それに応じて行動します。 <strong>注意</strong> これは実験的なフラグであり、削除されたり名前が変更されたりする可能性があります。設定ファイルなどでは使用しないでください。ご自身の責任で使用してください。<strong>メモ書き</strong> 記述内容及び挙動が理解できなかった為、直訳のみ。</p>
</li>
<li><p>FixNamespaceComments(Boolean) 5以降</p>
<p>名前空間の終了に自動でコメントを挿入するかを指定する。 true<code>namespace a &#123; foo(); bar(); &#125; // namespace a // ↑上記のコメントが自動で挿入される。 </code>false<code>namespace a &#123; foo(); bar(); &#125; // コメントの挿入が行われない。 </code><strong>メモ書き</strong> falseを指定しても既存のコメントが削除となるわけではない。逆にtrueを指定した場合、既存で独自にコメントを記載していても自動挿入で上書きされてしまう。</p>
</li>
<li><p>ForEachMacros(List of Strings) 3.7以降</p>
<p>foreachとして解釈されるべきマクロ名のリストを指定する。 例<code>// FOREACHマクロがforeachとして動作する FOREACH(&lt;variable-declaration&gt;, ...)  &lt;loop-body&gt; </code>.clang-format 設定ファイルでは、次の様に設定することができる。<code>ForEachMacros: [&#39;RANGES_FOR&#39;, &#39;FOREACH&#39;, &#39;BOOST_FOREACH&#39;] </code></p>
</li>
<li><p>IfMacros(List of Strings) 13以降</p>
<p>ifとして解釈されるべきマクロ名のリストを指定する。 例<code>IF(...)  &lt;conditional-body&gt; else IF(...)  &lt;conditional-body&gt; </code>.clang-format 設定ファイルでは、次の様に設定することができる。<code>ForEachMacros: [&#39;IF&#39;, &#39;KJ_IF_MAYBE&#39;] </code></p>
</li>
<li><p>IncludeBlocks(IncludeBlocksStyle) 6以降</p>
<p>#include定義の並び順を決定する。 値意味Preserveブロック単位でソートを行う。Mergeブロックを結合し、ソートを行う。Regroupブロックを結合し、ソートを行う。その後、カテゴリの優先順位に基づいてグループを分割する。IncludeCategoriesを参照。参考：ソート前<code>#include &quot;b.h&quot; #include &lt;lib/main.h&gt; #include &quot;a.h&quot;  </code>Preserve<code>#include &quot;b.h&quot; #include &quot;a.h&quot;  #include &lt;lib/main.h&gt; </code>Merge<code>#include &quot;a.h&quot;  #include &quot;b.h&quot; #include &lt;lib/main.h&gt; </code>Regroup<code>#include &quot;a.h&quot;  #include &quot;b.h&quot; #include &lt;lib/main.h&gt; </code></p>
</li>
<li><p>IncludeBlocks(List of IncludeCategories) 3.8以降</p>
<p>インクルードの順序付けに使用される、さまざまな #include カテゴリを示す正規表現です。 正規表現の表記はPOSIXに準拠する。 これらの正規表現は、インクルードのファイル名(&lt;&gt;または””を含む)の順に照合されます。最初にマッチした正規表現に属する優先順位が割り当てられ、#includeは、優先順位及びカテゴリ内でアルファベット順にソートされます。  どの正規表現にも一致しない場合、INT_MAXがカテゴリーとして割り当てられます。ソースファイルのメインヘッダは自動的にカテゴリ0になります。そのため、一般的には#includesの先頭に置かれます。しかし、常に最初に来る必要があるヘッダーがある場合は、負の優先順位を割り当てることもできます。  3番目のオプションフィールドにSortPriorityがあります。これは、IncludeBlocksにRegroupを指定した場合、有効となり、#includesを並べる優先順位を定義することができます。Priorityの値は、#includeブロックの順序を定義し、また、異なる優先順位の#includeをグループ化することができます。SortPriorityが指定されていない場合、Priorityの値がデフォルトとして設定されます。  各正規表現は、CaseSensitiveフィールドで大文字と小文字を区別するようにマークすることができますが、デフォルトではそうではありません。 .clang-format ファイルで設定するには、次のようにします。<code>IncludeCategories:  - Regex:           &#39;^&quot;(llvm|llvm-c|clang|clang-c)/&#39;    Priority:        2    SortPriority:    2    CaseSensitive:   true  - Regex:           &#39;^((&lt;|&quot;)(gtest|gmock|isl|json)/)&#39;    Priority:        3  - Regex:           &#39;&lt;[[:alnum:].]+&gt;&#39;    Priority:        4  - Regex:           &#39;.*&#39;    Priority:        1    SortPriority:    0 </code><strong>メモ書き</strong> SortPriority及びCaseSensitiveについては、古いバージョンでは指定ができない。(少なくとも8.0.1では使用ができなかった。)。いつ段階から実装されたかについては未調査。</p>
</li>
<li><p>IncludeIsMainRegex(String) 3.9以降</p>
<p>file-to-main-include のマッピングで許可されるサフィックスの正規表現を指定します。 ある#includeが「メイン」includeであるかどうかを推測する場合（カテゴリ0を割り当てるため、上記を参照）、ヘッダーステムに許容される接尾辞のこの正規表現を使用します。部分マッチが行われ、次のようになります。- “” は “任意のサフィックス” を意味します - “$” は “サフィックスなし” を意味します。  例えば、”(_test)?$” と設定した場合、ヘッダ a.h は a.cc と a_test.cc の両方で “main” include とみなされるでしょう。 <strong>メモ書き</strong> 記述内容が明確に理解できなかった為、直訳。 以下、見解。 IncludeCategoriesの動作でソースファイルに対応するメインヘッダを判定するための正規表現を指定する。つまり、”(_test)?$”という正規表現を指定した場合、a.ccというソースファイルのヘッダファイルはa.hと判断し、インクルードの記述をソートする際に、(負の優先度を持つヘッダを除いて)一番先頭に配置される。</p>
</li>
<li><p>IncludeIsMainSourceRegex(String) 10以降</p>
<p>フォーマットされるファイルのうち、file-to-main-includeマッピングで “main “とみなすことが許されるファイルの正規表現を指定します。  デフォルトでは、clang-formatはファイルが以下のように終わるときだけ “main “と見なします。.c, .cc, .cpp, .c++, .cxx, .m, .mm の拡張子で終わる場合のみ、clang-format はファイルを “main” と見なします。これらのファイルでは、「main」インクルードの推測が行われます（カテゴリ0を割り当てるには、上記を参照してください）。このオプションは、”main “とみなされるファイルのサフィックスと拡張子を追加することができます。  例えば、このオプションを (Impl.hpp)$ に設定すると、ClassImpl.hpp が “main” と見なされ (Class.c, Class.cc, Class.cpp などに加えて)、”main include file” ロジックが実行されます (IncludeIsMainRegex 設定も後のフェーズで尊重される)。このオプションが設定されていないと、ClassImpl.hppは他のどのincludeよりも先にmain include fileをトップに置くことができません。 <strong>メモ書き</strong> 記述内容が明確に理解できなかった為、直訳。 以下、見解。 IncludeIsMainRegexのソースファイル版。ソースファイルをインクルードした場合にメインとなるソースを判定する為の正規表現を指定する。</p>
</li>
<li><p>IndentAccessModifiers(Boolean) 13以降</p>
<p>アクセス修飾子が独自のインデントレベルを持つかどうかを指定します。 trueの場合、アクセス修飾子は独自のインデント・レベルを取得します。その結果、アクセス修飾子の有無にかかわらず、レコードのメンバは常にレコードの下の2つのレベルにインデントされます。AccessModifierOffsetの値は無視されます。 false の場合、アクセス修飾子はAccessModifierOffsetに従ってレコード・メンバから相対的にインデント (またはアウトデント)されます。レコード・メンバーはレコードの1レベル下にインデントされます。 true<code>class C &#123;    class D &#123;        void bar();      protected:        D();    &#125;;  public:    C(); &#125;; void foo() &#123;  return 1; &#125; </code>false<code>class C &#123;  class D &#123;    void bar();  protected:    D();  &#125;; public:  C(); &#125;; void foo() &#123;  return 1; &#125; </code></p>
</li>
<li><p>IndentCaseBlocks(Boolean) 11以降</p>
<p>ケースラベルブロックをケースラベルから1レベルインデントします。 trueの場合、ブロックはスコープブロックとしてインデントされます。 false の場合、ケースラベルに続くブロックはケースラベルと同じインデントレベルを使用し、ケースラベルは if 文と同じように扱われます。 true<code>switch (fool) &#123; case 1:  &#123;    bar();  &#125;  break; default:  &#123;    plop();  &#125; &#125; </code>false<code>switch (fool) &#123; case 1: &#123;  bar(); &#125; break; default: &#123;  plop(); &#125; &#125; </code></p>
</li>
<li><p>IndentCaseLabels(Boolean) 3.3以降</p>
<p>switch文のケースラベルのインデントを指定する。 trueの場合、ケースラベルはswitch文よりも一段インデントされます。 falseの場合、ケースラベルはswitch文と同じインデントレベルを使用します。 ステートメント本体は常にケースラベルよりも一段インデントされます。 true<code>switch (fool) &#123;  case 1:    bar();    break;  default:    plop(); &#125; </code>false<code>switch (fool) &#123; case 1:  bar();  break; default:  plop(); &#125; </code></p>
</li>
<li><p>IndentExternBlock(IndentExternBlockStyle) 11以降</p>
<p>外部結合ブロックのインデントの種類を指定する。 値意味AfterExternBlockBraceWrapping.AfterExternBlockの動作に従う。(AfterExternBlockの項を参照)NoIndent外部結合ブロックのインデントを行わない。Indent外部結合ブロックのインデントを行う。trueIndentと同じ動作となる。(レガシーオプション)falseNoIndentと同じ動作となる。(レガシーオプション)NoIndent<code>extern &quot;C&quot; &#123; void foo(); &#125; </code>Indent<code>extern &quot;C&quot; &#123;  void foo(); &#125; </code></p>
</li>
<li><p>IndentGotoLabels(Boolean) 10以降</p>
<p>gotoラベルのインデントを指定する。 true<code>// gotoラベルはステートメント内で左寄せになる int f() &#123;  if (foo()) &#123;  label1:    bar();  &#125; label2:  return 1; &#125; </code>false<code>// gotoラベルは左寄せになる int f() &#123;  if (foo()) &#123; label1:    bar();  &#125; label2:  return 1; &#125; </code></p>
</li>
<li><p>IndentPPDirectives(IndentExternBlockStyle) 6以降</p>
<p>プリプロセッサ・ディレクティブのインデントの種類を指定する。 値意味Noneプリプロセッサ・ディレクティブのインデントを行わない。AfterHashハッシュの後についてインデントを行う。BeforeHashハッシュを含めてインデントを行う。None<code>#if FOO #if BAR #include &lt;foo&gt; #endif #endif </code>AfterHash<code>#if FOO #  if BAR #    include &lt;foo&gt; #  endif #endif </code>BeforeHash<code>#if FOO  #if BAR    #include &lt;foo&gt;  #endif #endif </code></p>
</li>
<li><p>IndentRequiresClause(Boolean) 15以降</p>
<p>テンプレート定義のrequires節のインデントを指定する。 これは、RequiresClausePositionがOwnLine又はWithFollowingの場合にのみ適用されます。 備考 名前が変更されています。clang-format 12～14では、IndentRequiresという名前でした。true<code>template &lt;typename It&gt;  requires Iterator&lt;It&gt; void sort(It begin, It end) &#123;  //.... &#125; </code>false<code>template &lt;typename It&gt; requires Iterator&lt;It&gt; void sort(It begin, It end) &#123;  //.... &#125; </code></p>
</li>
<li><p>IndentWidth(Unsigned) 3.7以降</p>
<p>インデントに使用する値を指定する </p>
</li>
<li><p>IndentWrappedFunctionNames(Boolean) 3.7以降</p>
<p>関数定義や宣言が1行に収まらない場合、次行をインデントするか指定する。 true<code>// 次の行をインデントする LoooooooooooooooooooooooooooooooooooooooongReturnType    LoooooooooooooooooooooooooooooooongFunctionDeclaration(); </code>false<code>// 次の行をインデントしない LoooooooooooooooooooooooooooooooooooooooongReturnType    LoooooooooooooooooooooooooooooooongFunctionDeclaration(); </code></p>
</li>
<li><p>InsertBraces(Boolean) 15以降</p>
<p>C++の制御文（if, else, for, do, while）の後に波括弧を入れる。ただし、制御文がマクロ定義の中にあるか、波括弧がプリプロセッサー指令を囲んでしまう場合は除く。 警告 このオプションを true に設定すると、clang-format の完全なセマンティック情報の欠如により、不正なコードフォーマットになる可能性があります。そのため、このオプションで変更されたコードをレビューする際には、特に注意が必要です。true<code>// 波括弧を省略しているステートメントについて自動で波括弧を付与する if (isa&lt;FunctionDecl&gt;(D)) &#123;  handleFunctionDecl(D); &#125; else if (isa&lt;VarDecl&gt;(D)) &#123;  handleVarDecl(D); &#125; else &#123;  return; &#125; while (i--) &#123;  for (auto *A : D.attrs()) &#123;    handleAttr(A);  &#125; &#125; do &#123;  --i; &#125; while (i); </code>false<code>// 波括弧を省略しているステートメントについて何もしない if (isa&lt;FunctionDecl&gt;(D))  handleFunctionDecl(D); else if (isa&lt;VarDecl&gt;(D))  handleVarDecl(D); else  return; while (i--)  for (auto *A : D.attrs())    handleAttr(A); do  --i; while (i); </code><strong>メモ書き</strong> 既に波括弧を付与しているファイルに対してfalseを指定しても、波括弧の削除は行われない。</p>
</li>
<li><p>InsertTrailingCommas(TrailingCommaStyle) 11以降</p>
<p>複数行にまたがるコンテナリテラル(配列とオブジェクト)の末尾のカンマを付与を指定する。 Clang-Format15の段階ではJavaScriptのみ使用可能で、デフォルトはNoneで無効となっている。 また、BinPackArgumentsと同時に使用することは出来ません。 値意味None末尾にカンマを挿入しない。Wrapped末尾にカンマを挿入する。Wrapped<code>const someArray = [ aaaaaaaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaaaaaa, aaaaaaaaaaaaaaaaaaaaaaaaaa, //                        ^ inserted ] </code></p>
</li>
<li><p>InsertTrailingCommas(List of Strings) 8以降</p>
<p>Javaのimport宣言のグループ化の接頭辞を指定する。 一致する接頭辞が複数ある場合、最長の接頭辞を優先する。グループ内は辞書順にソートされる。静的なインポートは別でグループ化され、同じルールが適用となる。デフォルトでは静的なインポート宣言は非静的なインポート宣言の前に配置される。この動作はSortJavaStaticImportにより変更が可能である。 .clang-format ファイルで次の設定をした場合、Javaのインポート宣言は以下のように並びます。<code>JavaImportGroups: [&#39;com.example&#39;, &#39;com&#39;, &#39;org&#39;] </code>Javaソースの例<code>import static com.example.function1; import static com.test.function2; import static org.example.function3; import com.example.ClassA; import com.example.Test; import com.example.a.ClassB; import com.test.ClassC; import org.example.ClassD; </code></p>
</li>
<li><p>JavaScriptQuotes(JavaScriptQuoteStyle) 3.9以降</p>
<p>JavaScriptの文字列のクォートを指定する。 値意味Leave文字列のクォートは変更しない。Single常にシングルクォートを使用する。Double常にダブルクォートを使用する。Leave<code>string1 = &quot;foo&quot;; string2 = &#39;bar&#39;; </code>Single<code>string1 = &#39;foo&#39;; string2 = &#39;bar&#39;; </code>Single<code>string1 = &quot;foo&quot;; string2 = &quot;bar&quot;; </code></p>
</li>
<li><p>JavaScriptWrapImports(Boolean) 3.9以降</p>
<p>JavaScriptのimport&#x2F;export文をラップ方法を指定する。 true<code>import &#123;    VeryLongImportsAreAnnoying,    VeryLongImportsAreAnnoying,    VeryLongImportsAreAnnoying, &#125; from &#39;some/module.js&#39; </code>false<code>import &#123;VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying, VeryLongImportsAreAnnoying,&#125; from &quot;some/module.js&quot; </code></p>
</li>
<li><p>KeepEmptyLinesAtTheStartOfBlocks(Boolean) 3.7以降</p>
<p>ブロックの先頭の空白の扱いを指定する。 true<code>// ブロックの先頭の空白を維持する if (foo) &#123;   bar(); &#125; </code>false<code>// ブロックの先頭の空白を削除する if (foo) &#123;  bar(); &#125; </code><strong>メモ書き</strong> 維持であり、挿入ではない。trueを指定しても空白行の挿入は行われない。</p>
</li>
<li><p>LambdaBodyIndentation(LambdaBodyIndentationKind) 13以降</p>
<p>ラムダ式の本体の改行ルールを指定する。 コールバックの多いコードではOuterScopeを使用してシグネチャを2段階インデントした方が可読性が高くなる場合がある。(<a href="https://github.com/capnproto/capnproto/blob/master/style-guide.md">KJ Style guide</a>ではOuterScopeを必須としています) 値意味Signatureラムダ式の本体をシグネチャのインデントレベルに対して1段下げる。OuterScopeラムダ式の本体を親スコープのインデントレベルに対して1段下げる。Signature<code>someMethod(    [](SomeReallyLongLambdaSignatureArgument foo) &#123;      return;    &#125;); </code>OuterScope<code>someMethod(    [](SomeReallyLongLambdaSignatureArgument foo) &#123;  return; &#125;); </code></p>
</li>
<li><p>Language(LanguageKind) 3.5以降</p>
<p>対象となる言語を指定する。 値意味CppC言語及びC++に使用する。CSharpC♯に使用する。JavaJavaに使用する。JavaScriptJavaScriptに使用する。JsonJsonに使用する。ObjCObjective-C及びObjective-C++に使用する。ProtoProtocol Buffersに使用する。(<a href="https://developers.google.com/protocol-buffers/)TableGenTableGen%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%80%82TextProto%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E5%BD%A2%E5%BC%8F%E3%81%AEProtocol">https://developers.google.com/protocol-buffers/)TableGenTableGenに使用する。TextProtoテキスト形式のProtocol</a> Buffersに使用する。(<a href="https://developers.google.com/protocol-buffers/)VerilogVerilog%E5%8F%8A%E3%81%B3SystemVerilog%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%80%82">https://developers.google.com/protocol-buffers/)VerilogVerilog及びSystemVerilogに使用する。</a>(<a href="https://standards.ieee.org/ieee/1800/6700/">https://standards.ieee.org/ieee/1800/6700/</a> <a href="https://sci-hub.st/10.1109/IEEESTD.2018.8299595)**%E3%83%A1%E3%83%A2%E6%9B%B8%E3%81%8D">https://sci-hub.st/10.1109/IEEESTD.2018.8299595)**メモ書き</a>** 公式にはNoneが使用不可で記載されている。プログラム上、LanguageKindにNoneの定義が無いので指定するとyamlの解析でエラーになる。(使用不可というかそもそも使えない、レガシー？)例<code>--- # 各言語の共通設定を記述する BasedOnStyle: LLVM IndentWidth: 4 --- # C++固有の設定を書く Language: Cpp ... # ここまでC++固有の設定 --- # JavaScript固有の設定を書く Language: JavaScript ... # ここまでJavaScript固有の設定 --- # 以下同様に必要な言語の設定を記載していく ... </code></p>
</li>
<li><p>MacroBlockBegin(String) 3.7以降 MacroBlockEnd(String) 3.7以降</p>
<p>ブロックの先頭及び末尾となるマクロを正規表現で指定する。 記述例<code>MacroBlockBegin: &quot;^NS_MAP_BEGIN|NS_TABLE_HEAD$&quot; MacroBlockEnd: &quot;^NS_MAP_END|NS_TABLE_.*_END$&quot; </code>実行例(MacroBlockBegin及びMacroBlockEndを指定しない場合)<code>// マクロで開始終了を内包するようなパターンの場合 #deinfe NS_MAP_BEGIN if( x ) &#123; #deinfe NS_MAP_END   &#125; // 開始/終了のマクロが判断できないため、本体部分の処理が前寄せになる。 NS_MAP_BEGIN foo(); NS_MAP_END </code>実行例(MacroBlockBegin及びMacroBlockEndを指定した場合)<code>// 開始/終了のマクロが正規表現で判定出来たため、本体部分の処理にインデントが付与される。 NS_MAP_BEGIN  foo(); NS_MAP_END </code></p>
</li>
<li><p>MaxEmptyLinesToKeep(String) 3.7以降 </p>
<p>空行の最大保持数を指定する。 変更前<code>int f() &#123;   int i = 1;   i = foo();   return i;  &#125; </code>MaxEmptyLinesToKeep : 0 を指定した場合<code>int f() &#123;  int i = 1;  i = foo();  return i; &#125; </code>MaxEmptyLinesToKeep : 1 を指定した場合<code>int f() &#123;   int i = 1;   i = foo();   return i; &#125; // ↑ステートメントの終了前の空白は必ずすべて削除される。 </code><strong>メモ書き</strong> MaxEmptyLinesToKeepにNを指定しても最大N行の空白行が残るだけで、N行の空白が挿入となるわけではない。</p>
</li>
<li><p>NamespaceIndentation(NamespaceIndentationKind) 3.7以降</p>
<p>名前空間のインデントを指定する。 コールバックの多いコードではOuterScopeを使用してシグネチャを2段階インデントした方が可読性が高くなる場合がある。(<a href="https://github.com/capnproto/capnproto/blob/master/style-guide.md">KJ Style guide</a>ではOuterScopeを必須としています) 値意味None名前空間にインデントを行わない。Innerネストした名前空間だけインデントを行う。Allすべての名前空間をインデントする。None<code>namespace out &#123; int i; namespace in &#123; int i; &#125; &#125; </code>Inner<code>namespace out &#123; int i; namespace in &#123;  int i; &#125; &#125; </code>All<code>namespace out &#123;  int i;  namespace in &#123;    int i;  &#125; &#125; </code></p>
</li>
<li><p>NamespaceMacros(List of Strings) 9以降 </p>
<p>名前空間の開始となるマクロのリストを指定する。 記述例<code>NamespaceMacros: [&#39;NAMESPACE&#39;, &#39;TESTSUITE&#39;] </code>実行例<code>NAMESPACE(&lt;namespace-name&gt;, ...) &#123;  &lt;namespace-content&gt; &#125; </code></p>
</li>
<li><p>ObjCBinPackProtocolList(BinPackStyle) 9以降</p>
<p>Objective-Cプロトコル準拠のリスト項目がColumnLimitを超えた場合の改行の制御を指定する。 値意味AutoBinPackParametersの指定に従う。BinPackParametersがtrueの場合、Alwaysと同じ動作となる。falseの場合、Neverと同じ動作となる。AlwaysColumnLimitに収まる最小の行に纏める。Never個々の行に纏める。Always(又はAutoかつBinPackParametersがtrue)<code>@interface ccccccccccccc () &lt;    ccccccccccccc, ccccccccccccc,    ccccccccccccc, ccccccccccccc&gt; &#123; &#125; </code>Never(又はAutoかつBinPackParametersがfalse)<code>@interface ddddddddddddd () &lt;    ddddddddddddd,    ddddddddddddd,    ddddddddddddd,    ddddddddddddd&gt; &#123; &#125; </code></p>
</li>
<li><p>ObjCBlockIndentWidth(Unsigned) 3.7以降</p>
<p>Objective-Cブロックのインデントの値を指定する。 </p>
</li>
<li><p>ObjCBreakBeforeNestedBlockParam(Boolean) 11以降</p>
<p>Objective-Cの関数呼び出し時にブロックパラメータがネストしている場合の、パラメータリストの記載方法について指定する。 true<code>- (void)_aMethod &#123;  [self.test1 t:self              w:self       callback:^(typeof(self) self, NSNumber *u, NSNumber *v) &#123;           u = c;       &#125;] &#125; </code>false<code>- (void)_aMethod &#123;  [self.test1 t:self w:self       callback:^(typeof(self) self, NSNumber *u, NSNumber *v) &#123;           u = c;       &#125;] &#125; </code></p>
</li>
<li><p>ObjCSpaceAfterProperty(Boolean) 3.7以降</p>
<p>Objective-Cの@propertyの後にスペースを入れるかを指定する。 true<code>@property (readonly) NSString* foo;  </code>false<code>@property(readonly) NSString* foo;  </code></p>
</li>
<li><p>ObjCSpaceBeforeProtocolList(Boolean) 3.7以降</p>
<p>Objective-Cのプロトコルリストの前にスペースを入れるかを指定する。 true<code>@protocol Foo &lt;NSObject&gt; </code>false<code>@protocol Foo&lt;NSObject&gt; </code></p>
</li>
<li><p>PPIndentWidth(Integer) 13以降</p>
<p>プリプロセッサのインデントの値を指定する。 -1を指定した場合、IndentWidthの値が使用される。PPIndentWidth: 1 の場合<code>#ifdef __linux__ # define FOO #else # define BAR #endif </code></p>
</li>
<li><p>PackConstructorInitializers(PackConstructorInitializersStyle) 14以降</p>
<p>コンストラクタの初期化リストの並べ方について指定する。 値意味Never初期化リストは1行ずつ改行する。BinPackColumnLimitに収まる最小の行に纏める。CurrentLineすべての初期化リストが1行に収まる場合、1行に纏める。1行に収まらない場合、Neverと同じ動作となる。NextLineCurrentLineと同じ動作。ただし、コンストラクタの開始行にすべての要素が収まらない場合、次の行に収まるようにする。Never<code>Constructor()    : a(),      b() </code>BinPack<code>Constructor()    : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(),      cccccccccccccccccccc() </code>CurrentLine<code>Constructor() : a(), b() // すべての要素が1行で収まらない場合、Neverと同じ動作をする Constructor()    : aaaaaaaaaaaaaaaaaaaa(),      bbbbbbbbbbbbbbbbbbbb(),      ddddddddddddd() </code>NextLine<code>// コンストラクタと同じ行に収まる場合、その行にすべての要素を出力する。 Constructor() : a(), b() // コンストラクタと同じ行に収まらない場合、次の行に収まるように整形する。 Constructor()    : aaaaaaaaaaaaaaaaaaaa(), bbbbbbbbbbbbbbbbbbbb(), ddddddddddddd() // 次の行にも収まらない長さの場合、Neverと同じ動作をする。 Constructor()    : aaaaaaaaaaaaaaaaaaaa(),      bbbbbbbbbbbbbbbbbbbb(),      cccccccccccccccccccc() </code></p>
</li>
<li><p>PenaltyBreakAssignment(Unsigned) 5以降</p>
<p>代入演算子関連の改行に対するペナルティ <strong>メモ書き</strong> 以降Penalty～について、用途が理解できなかった為、直訳のみ。 ただし、BasedOnStyleの各定義を見ると値を設定しているため、必要な数値である模様。</p>
</li>
<li><p>PenaltyBreakBeforeFirstCallParameter(Unsigned) 3.7以降</p>
<p>関数呼び出し後の改行に対するペナルティ </p>
</li>
<li><p>PenaltyBreakComment(Unsigned) 3.7以降</p>
<p>コメント内での改行に対するペナルティ </p>
</li>
<li><p>PenaltyBreakFirstLessLess(Unsigned) 3.7以降</p>
<p>最初の左シフトの前の改行に対するペナルティ </p>
</li>
<li><p>PenaltyBreakOpenParenthesis(Unsigned) 14以降</p>
<p>’(’の後の改行に対するペナルティ </p>
</li>
<li><p>PenaltyBreakString(Unsigned) 3.7以降</p>
<p>文字列リテラル内の改行に対するペナルティ </p>
</li>
<li><p>PenaltyBreakTemplateDeclaration(Unsigned) 7以降</p>
<p>テンプレート宣言の後の改行に対するペナルティ </p>
</li>
<li><p>PenaltyExcessCharacter(Unsigned) 3.7以降</p>
<p>行の最大文字数を超過した場合の文字の改行に対するペナルティ </p>
</li>
<li><p>PenaltyIndentedWhitespace(Unsigned) 12以降</p>
<p>空白文字のインデント1文字あたりのペナルティ(非ホワイトスペースの先頭列からの相対値でカウントされる)。 </p>
</li>
<li><p>PenaltyReturnTypeOnItsOwnLine(Unsigned) 3.7以降</p>
<p>関数の戻り値の型を関数と同一行とした場合のペナルティ。 </p>
</li>
<li><p>PointerAlignment(PointerAlignmentStyle) 3.7以降</p>
<p>ポインタ及び参照のアライメントについて指定する。 値意味Left左に寄せる。Right右に寄せる。Middle中央に寄せる。trueLeftと同じ動作。(レガシーオプション)falseRightと同じ動作。(レガシーオプション)Left<code>int* a; </code>Right<code>int *a; </code>Middle<code>int * a; </code></p>
</li>
<li><p>QualifierAlignment(QualifierAlignmentStyle) 14以降</p>
<p>指定子や修飾子の並べ方を指定する(例：const&#x2F;volatile)。 <strong>警告</strong> QualifierAlignmentをLeave以外に設定すると、clang-formatsが完全な意味情報を持っていないため、間違った判断を下してしまい、コードが正しくフォーマットされない可能性があります。そのため、このオプションを使って変更されたコードをレビューする際には、特別な注意を払う必要があります。値意味Leave変更しない。Left指定子及び修飾子を左に寄せる。Right指定子及び修飾子を右に寄せる。CustomQualifierOrderで指定した値に従う。Leave<code>int const a; const int *a; </code>Left<code>const int a; const int *a; </code>Right<code>int const a; int const *a; </code>QualifierOrderの指定(Custom用)<code>QualifierOrder: [&#39;inline&#39;, &#39;static&#39; , &#39;type&#39;, &#39;const&#39;] </code>Custom<code>// 修飾子及び型がQualifierOrderで指定した順序(&#39;type&#39;, &#39;const&#39;)の順に並ぶ int const a; int const *a; </code></p>
</li>
<li><p>QualifierOrder(List of Strings) 14以降</p>
<p>型、指定子及び修飾子の並び順を文字列リストで指定する。 この値はQualifierAlignmentにCustomを指定した場合、使用される。 指定する文字列リストは必ず’type’を含む必要がある。 指定可能なキーワードは以下のとおり。 ・const ・inline ・static ・constexpr ・volatile ・restrict ・type ※typeはデータ型を意味する(例えばint)例<code>QualifierOrder: [&#39;inline&#39;, &#39;static&#39; , &#39;type&#39;, &#39;const&#39;] </code></p>
</li>
<li><p>RawStringFormats(List of RawStringFormats) 6以降</p>
<p>変換対象のファイルの内容がどの言語のコードブロックであるか判断するための定義を指定する。 デリミタが一致するか、関数名が一致する文字列を検出した場合、.clang-formatでその言語用に指定した定義によりフォーマットを行う。特定言語に対しての定義が見つからない場合、BasedOnStyleで指定したフォーマットに従い再変換を行う。BasedOnStyleが見つからない場合、llvmのフォーマットに基づき変換を行う。 マッチする言語は区切り文字にマッチするものが関数にマッチするものよりも優先されます。 例<code>RawStringFormats:  - Language: TextProto  # Language参照      Delimiters: # 拡張子        - &#39;pb&#39;        - &#39;proto&#39;      EnclosingFunctions: # 一致する関数等        - &#39;PARSE_TEXT_PROTO&#39;      BasedOnStyle: google # 一致した場合のフォーマット  - Language: Cpp      Delimiters:        - &#39;cc&#39;        - &#39;cpp&#39;      BasedOnStyle: llvm      CanonicalDelimiter: &#39;cc&#39; </code></p>
</li>
<li><p>ReferenceAlignment(ReferenceAlignmentStyle) 13以降</p>
<p>参照のアライメントについて指定する。(参照についてPointerAlignmentの指定を上書きする) 値意味PointerPointerAlignmentの指定に従う。Left左に寄せる。Right右に寄せる。Middle中央に寄せる。Left<code>int&amp; a; </code>Right<code>int &amp;a; </code>Middle<code>int &amp; a; </code></p>
</li>
<li><p>ReflowComments(ReferenceAlignmentStyle) 4以降</p>
<p>1行の最大文字数を超えたコメントの折り返しについて指定する。 true<code>// ColumnLimitを超えるコメントを自動で改行する // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of // information /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of * information */ </code>false<code>// ColumnLimitを超えるコメントの改行を行わない // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */ </code></p>
</li>
<li><p>RemoveBracesLLVM(Boolean) 14以降</p>
<p>LLVMコーディングスタイルに従って、C++の制御文（if, else, for, while）のオプションの波括弧を削除する。 <strong>警告</strong> このオプションは名称を変更し、他のスタイルにも対応できるように拡張する予定です。<strong>警告</strong> このオプションを true に設定すると、clang-format の完全なセマンティック情報の欠如により、不正なコードフォーマットになる可能性があります。そのため、このオプションで変更されたコードをレビューする際には、特に注意が必要です。true<code>// 省略が可能な波括弧について削除する if (isa&lt;FunctionDecl&gt;(D))  handleFunctionDecl(D); else if (isa&lt;VarDecl&gt;(D))  handleVarDecl(D); if (isa&lt;VarDecl&gt;(D)) &#123;  for (auto *A : D.attrs())    if (shouldProcessAttr(A))      handleAttr(A); &#125; if (isa&lt;FunctionDecl&gt;(D))  for (auto *A : D.attrs())    handleAttr(A); if (auto *D = (T)(D)) &#123;  if (shouldProcess(D))    handleVarDecl(D);  else    markAsIgnored(D); &#125; if (a)  b(); else if (c)  d(); else  e(); </code>false<code>// 波括弧を特に変更しない if (isa&lt;FunctionDecl&gt;(D)) &#123;  handleFunctionDecl(D); &#125; else if (isa&lt;VarDecl&gt;(D)) &#123;  handleVarDecl(D); &#125; if (isa&lt;VarDecl&gt;(D)) &#123;  for (auto *A : D.attrs()) &#123;    if (shouldProcessAttr(A)) &#123;      handleAttr(A);    &#125;  &#125; &#125; if (isa&lt;FunctionDecl&gt;(D)) &#123;  for (auto *A : D.attrs()) &#123;    handleAttr(A);  &#125; &#125; if (auto *D = (T)(D)) &#123;  if (shouldProcess(D)) &#123;    handleVarDecl(D);  &#125; else &#123;    markAsIgnored(D);  &#125; &#125; if (a) &#123;  b(); &#125; else &#123;  if (c) &#123;    d();  &#125; else &#123;    e();  &#125; &#125; </code></p>
</li>
<li><p>RequiresClausePosition(RequiresClausePositionStyle) 15以降</p>
<p>requires句の改行について指定する。 値意味OwnLine必ず改行する。WithPreceding宣言と同じ行となるようにする。クラス又は関数のテンプレート宣言の場合、テンプレート宣言に従う。関数宣言の場合、引数リストに従う。WithFollowingクラスや関数の宣言と同じにする。SingleLine可能な限り1行に記載する。1行で記載できない場合、改行する。OwnLine<code>template &lt;typename T&gt; requires C&lt;T&gt; struct Foo &#123;... template &lt;typename T&gt; requires C&lt;T&gt; void bar(T t) &#123;... template &lt;typename T&gt; void baz(T t) requires C&lt;T&gt; &#123;... </code>WithPreceding<code>template &lt;typename T&gt; requires C&lt;T&gt; struct Foo &#123;... template &lt;typename T&gt; requires C&lt;T&gt; void bar(T t) &#123;... template &lt;typename T&gt; void baz(T t) requires C&lt;T&gt; &#123;... </code>WithFollowing<code>template &lt;typename T&gt; requires C&lt;T&gt; struct Foo &#123;... template &lt;typename T&gt; requires C&lt;T&gt; void bar(T t) &#123;... template &lt;typename T&gt; void baz(T t) requires C&lt;T&gt; &#123;... </code>SingleLine<code>// 1行で収まる場合 template &lt;typename T&gt; requires C&lt;T&gt; struct Foo &#123;... template &lt;typename T&gt; requires C&lt;T&gt; void bar(T t) &#123;... template &lt;typename T&gt; void bar(T t) requires C&lt;T&gt; &#123;... // 1行で収まらない場合 template &lt;typename LongName&gt; requires C&lt;LongName&gt; struct Foo &#123;... template &lt;typename LongName&gt; requires C&lt;LongName&gt; void bar(LongName ln) &#123; template &lt;typename LongName&gt; void bar(LongName ln)    requires C&lt;LongName&gt; &#123; </code></p>
</li>
<li><p>SeparateDefinitionBlocks(SeparateDefinitionStyle) 14以降</p>
<p>クラス、構造体、列挙型、関数などの定義ブロックの区切りに、空行を挿入するかを指定する。 値意味Leave変更しない。Always定義ブロックの区切りに改行を挿入する。Never定義ブロックの区切りの改行を削除する。Always<code>#include &lt;cstring&gt; struct Foo &#123;  int a, b, c; &#125;; namespace Ns &#123; class Bar &#123; public:  struct Foobar &#123;    int a;    int b;  &#125;; private:  int t;   int method1() &#123;    // ...  &#125;   enum List &#123;    ITEM1,    ITEM2  &#125;;   template &lt;typename T&gt; int method2(T x) &#123;    // ...  &#125;   int i, j, k;   int method3(int par) &#123;    // ...  &#125; &#125;; class C &#123;&#125;; &#125; </code>Never<code>#include &lt;cstring&gt; struct Foo &#123;  int a, b, c; &#125;; namespace Ns &#123; class Bar &#123; public:  struct Foobar &#123;    int a;    int b;  &#125;; private:  int t;  int method1() &#123;    // ...  &#125;  enum List &#123;    ITEM1,    ITEM2  &#125;;  template &lt;typename T&gt; int method2(T x) &#123;    // ...  &#125;  int i, j, k;  int method3(int par) &#123;    // ...  &#125; &#125;; class C &#123;&#125;; &#125; </code></p>
</li>
<li><p>ShortNamespaceLines(Unsigned) 13以降</p>
<p>短い名前空間は何行以下であるかについて、行数を指定する。デフォルトは1。 この値はFixNamespaceCommentsがtrueの場合、終了コメントを追加するために使用する。ShortNamespaceLines: 0 を指定した場合<code>// どちらの名前空間も0行より大きいので、FixNamespaceCommentsの動作により名前空間の末尾にコメントを挿入する。 namespace a &#123;  int foo; &#125; // namespace a namespace b &#123;  int foo;  int bar; &#125; // namespace b </code>ShortNamespaceLines: 1 を指定した場合<code>// 名前空間aは1行以下なのでコメントの挿入を行わない。bは1行より大きいのでコメントの挿入を行う。 namespace a &#123;  int foo; &#125; namespace b &#123;  int foo;  int bar; &#125; // namespace b </code></p>
</li>
<li><p>SortIncludes(SortIncludesOptions) 4以降</p>
<p>インクルート文のソート条件について指定する。 値意味Neverソートしない。CaseSensitive大文字と小文字を区別してアスキーコード順にソートを行う。CaseInsensitive大文字と小文字を区別せずアルファベット順にソートを行う。trueCaseSensitiveと同じ動作。(レガシーオプション)falseNeverと同じ動作。(レガシーオプション)Never<code>#include &quot;B/A.h&quot; #include &quot;A/B.h&quot; #include &quot;a/b.h&quot; #include &quot;A/b.h&quot; #include &quot;B/a.h&quot; </code>CaseSensitive<code>#include &quot;A/B.h&quot; #include &quot;A/b.h&quot; #include &quot;B/A.h&quot; #include &quot;B/a.h&quot; #include &quot;a/b.h&quot; </code>CaseInsensitive<code>#include &quot;A/B.h&quot; #include &quot;A/b.h&quot; #include &quot;a/b.h&quot; #include &quot;B/A.h&quot; #include &quot;B/a.h&quot; </code></p>
</li>
<li><p>SortJavaStaticImport(SortJavaStaticImportOptions) 12以降</p>
<p>Javaのインポート文の並び順について指定する。 値意味Before静的なインポートを非静的なインポートの前に置く。After静的なインポートを非静的なインポートの後に置く。Before<code>import static org.example.function1; import org.example.ClassA; </code>After<code>import org.example.ClassA; import static org.example.function1; </code><strong>メモ書き</strong> 公式ドキュメントに不備あり。JavaStaticImportAfterImportについてはSortJavaStaticImportの誤記の理解。</p>
</li>
<li><p>SortUsingDeclarations(Boolean) 5以降</p>
<p>using宣言のソート方法を指定する。 ソートは名前空間の単位で行う。また、ソートは大文字小文字を区別せず、アルファベット順で行う。true<code>using foo::bar; using std::cin; using std::cout; using ABC::DEF::GHI; using ABC::XYZ::GHI; </code>false<code>using std::cout; using std::cin; using foo::bar; using ABC::XYZ::GHI; using ABC::DEF::GHI; </code></p>
</li>
<li><p>SpaceAfterCStyleCast(Boolean) 3.5以降</p>
<p>C言語キャストの後のスペースを指定する。 true<code>// C言語キャストの後にスペースを挿入する (int) i;  </code>false<code>// C言語キャストの後にスペースを挿入しない (int) i;  </code></p>
</li>
<li><p>SpaceAfterLogicalNot(Boolean) 9以降</p>
<p>論理否定の後のスペースを指定する。 true<code>// 論理否定の後にスペースを挿入する ! someExpression(); </code>false<code>// 論理否定の後にスペースを挿入しない !someExpression(); </code></p>
</li>
<li><p>SpaceAfterTemplateKeyword(Boolean) 4以降</p>
<p>テンプレートキーワードの後のスペースを指定する。 true<code>// テンプレートキーワードの後にスペースを挿入する template &lt;int&gt; void foo(); </code>false<code>// テンプレートキーワードの後にスペースを挿入しない template&lt;int&gt; void foo(); </code></p>
</li>
<li><p>SpaceAroundPointerQualifiers(SpaceAroundPointerQualifiersStyle) 12以降</p>
<p>ポインタ修飾子(const&#x2F;volatile)の前後の空白を指定する。 また、PointerAlignmentの動作とは別で空白の挿入が行われる。 値意味DefaultPointerAlignmentで指定した動作とする。Beforeポインタ修飾子の前に空白を挿入する。Afterポインタ修飾子の後に空白を挿入する。Bothポインタ修飾子の前後に空白を挿入する。Default(PointerAlignment: Leftの場合)<code>void* const* x = NULL; </code>Default(PointerAlignment: Rightの場合)<code>void *const *x = NULL; </code>Before(PointerAlignment: Leftの場合)<code>void* const* x = NULL; </code>Before(PointerAlignment: Rightの場合)<code>void * const * x = NULL; </code>After(PointerAlignment: Leftの場合)<code>void* const * x = NULL; </code>After(PointerAlignment: Rightの場合)<code>void *const *x = NULL; </code>Both(PointerAlignment: Leftの場合)<code>void* const * x = NULL; </code>Both(PointerAlignment: Rightの場合)<code>void * const *x = NULL; </code></p>
</li>
<li><p>SpaceBeforeAssignmentOperators(Boolean) 3.7以降</p>
<p>代入演算子の前のスペースを指定する。 true<code>// 代入演算子の前にスペースを挿入する。 int a = 5; a += 42; </code>false<code>// 代入演算子の前のスペースを削除する。 int a= 5; a+= 42; </code></p>
</li>
<li><p>SpaceBeforeCaseColon(Boolean) 12以降</p>
<p>caseラベルのコロンの前のスペースを指定する。 true<code>// caseラベルのコロンの前にスペースを挿入する。 switch (x) &#123;  case 1 : break; &#125; </code>false<code>// caseラベルのコロンの前のスペースを削除する。 switch (x) &#123;  case 1: break; &#125; </code></p>
</li>
<li><p>SpaceBeforeCpp11BracedList(Boolean) 7以降</p>
<p>C++11の初期化リストの前のスペースを指定する。 true<code>// 初期化リストの前にスペースを挿入する。 Foo foo &#123; bar &#125;; Foo &#123;&#125;; vector&lt;int&gt; &#123; 1, 2, 3 &#125;; new int[3] &#123; 1, 2, 3 &#125;; </code>false<code>// 初期化リストの前のスペースを削除する。 Foo foo&#123; bar &#125;; Foo&#123;&#125;; vector&lt;int&gt;&#123; 1, 2, 3 &#125;; new int[3]&#123; 1, 2, 3 &#125;; </code></p>
</li>
<li><p>SpaceBeforeCtorInitializerColon(Boolean) 7以降</p>
<p>コンストラクタの初期化リストのコロンの前のスペースを指定する。 true<code>// コロンの前にスペースを挿入する。 Foo::Foo() : a(a) &#123;&#125;  </code>false<code>// コロンの前のスペースを削除する。 Foo::Foo(): a(a) &#123;&#125; </code></p>
</li>
<li><p>SpaceBeforeInheritanceColon(Boolean) 7以降</p>
<p>クラス宣言の継承リストのコロンの前のスペースを指定する。 true<code>// コロンの前にスペースを挿入する。 class Foo : Bar &#123;&#125; </code>false<code>// コロンの前のスペースを削除する。 class Foo: Bar &#123;&#125;  </code></p>
</li>
<li><p>SpaceBeforeParens(SpaceBeforeParensStyle) 3.5以降</p>
<p>丸括弧の前にスペースを挿入する条件を指定する。 値意味Never丸括弧の前の空白を削除する。ControlStatements制御文のキーワード(for&#x2F;if&#x2F;while等)の後のみ、丸括弧の前に空白を挿入する。ControlStatementsExceptControlMacrosControlStatementsと同じ動作。ただし、ForEachMacros及びIfMacrosにて指定したマクロ名には適用されない。NonEmptyParentheses括弧内が空ではない場合、丸括弧の前に空白を挿入する。Always構文規約で禁止されている(関数マクロの定義等)又は他のスタイル規則で決められている場合を除き、丸括弧の前に空白を挿入する。CustomSpaceBeforeParensOptionsにより、個別に指定を行う。falseNeverと同じ動作。(レガシーオプション)trueControlStatementsと同じ動作。(レガシーオプション)ControlStatementsExceptForEachMacrosControlStatementsExceptControlMacrosと同じ動作。(レガシーオプション)Never<code>void f() &#123;  if(true) &#123;    f();  &#125; &#125; </code>ControlStatements<code>void f() &#123;  if (true) &#123;    f();  &#125; &#125; </code>ControlStatementsExceptControlMacros<code>void f() &#123;  Q_FOREACH(...) &#123;    f();  &#125; &#125; </code>NonEmptyParentheses<code>void() &#123;  if (true) &#123;    f();    g (x, y, z);  &#125; &#125; </code>Always<code>void f () &#123;  if (true) &#123;    f ();  &#125; &#125; </code></p>
</li>
<li><p>SpaceBeforeParensOptions(SpaceBeforeParensCustom) 14以降</p>
<p>丸括弧の前にスペース制御を個別に指定する。 SpaceBeforeParensがCustomに指定されている場合、SpaceBeforeParensOptionsで指定した値に従い、スペースの制御を行います。SpaceBeforeParensがCustom以外の場合、この値は無視されます。記述例<code>SpaceBeforeParens: Custom SpaceBeforeParensOptions:  AfterControlStatements: true  AfterFunctionDefinitionName: true </code>AfterControlStatements(Boolean)制御文のキーワード(for&#x2F;if&#x2F;while等)と開始括弧の間のスペースを指定する。true<code>// スペースを挿入する if (...) &#123;&#125; </code>false<code>// スペースを削除する if(...) &#123;&#125; </code>AfterForeachMacros(Boolean)ForEachMacrosで指定したマクロと開始括弧の間のスペースを指定する。true<code>// スペースを挿入する FOREACH (...)  &lt;loop-body&gt; </code>false<code>// スペースを削除する FOREACH(...)  &lt;loop-body&gt; </code>AfterFunctionDeclarationName(Boolean)関数宣言と開始括弧の間のスペースを指定する。true<code>// スペースを挿入する void f (); </code>false<code>// スペースを削除する void f(); </code>AfterFunctionDefinitionName(Boolean)関数定義と開始括弧の間のスペースを指定する。true<code>// スペースを挿入する void f () &#123;&#125;; </code>false<code>// スペースを削除する void f() &#123;&#125;; </code>AfterIfMacros(Boolean)IfMacrosで指定したマクロと開始括弧の間のスペースを指定する。true<code>// スペースを挿入する IF (...)  &lt;conditional-body&gt; </code>false<code>// スペースを削除する IF(...)  &lt;conditional-body&gt; </code>AfterIfMacros(Boolean)演算子のオーバーロードと開始括弧の間のスペースを指定する。true<code>// スペースを挿入する void operator++ (int a); object.operator++ (10);  </code>false<code>// スペースを削除する void operator++(int a); object.operator++(10);  </code>AfterRequiresInClause(Boolean)requires句と開始括弧の間のスペースを指定する。true<code>// スペースを挿入する template&lt;typename T&gt; requires (A&lt;T&gt; &amp;&amp; B&lt;T&gt;) ... </code>false<code>// スペースを削除する template&lt;typename T&gt; requires(A&lt;T&gt; &amp;&amp; B&lt;T&gt;) ... </code>AfterRequiresInExpression(Boolean)requires式と開始括弧の間のスペースを指定する。true<code>// スペースを挿入する template&lt;typename T&gt; concept C = requires (T t) &#123;              ...            &#125; </code>false<code>// スペースを削除する template&lt;typename T&gt; concept C = requires(T t) &#123;              ...            &#125; </code>BeforeNonEmptyParentheses(Boolean)括弧内が空ではない場合の、開始括弧の間のスペースを指定する。true<code>// 括弧内が空白ではない場合、スペースを挿入する void f (int a); f (a); </code>false<code>// スペースを削除する void f(); f(); </code></p>
</li>
<li><p>SpaceBeforeRangeBasedForLoopColon(Boolean) 7以降</p>
<p>範囲指定でのfor文のコロンの前のスペースを指定する。 true<code>// コロンの前にスペースを挿入する。 for (auto v : values) &#123;&#125; </code>false<code>// コロンの前のスペースを削除する。 for (auto v: values) &#123;&#125; </code><strong>メモ書き</strong> 公式の例ではforの前のスペースについても変更されているが、誤記の理解。(clang-format8.0.1及び15で確認の結果、変更されない)</p>
</li>
<li><p>SpaceBeforeSquareBrackets(Boolean) 10以降</p>
<p>角括弧の前のスペースを指定する。ただし、ラムダ式についてはこの指定の影響を受けない。 true<code>// 角括弧の前にスペースを挿入する。 int a [5]; int a [5][5]; </code>false<code>// 角括弧の前のスペースを削除する。 int a[5]; int a[5][5]; </code></p>
</li>
<li><p>SpaceInEmptyBlock(Boolean) 10以降</p>
<p>空白の波括弧の間のスペースを指定する。 true<code>// 空白の波括弧の間にスペースを挿入する。 void f() &#123; &#125; while (true) &#123; &#125; </code>false<code>// 空白の波括弧の間のスペースを削除する。 void f() &#123;&#125; while (true) &#123;&#125; </code></p>
</li>
<li><p>SpaceInEmptyParentheses(Boolean) 3.7以降</p>
<p>空白の丸括弧の間のスペースを指定する。 true<code>// 空白の丸括弧の間にスペースを挿入する。 void f( ) &#123;  int x[] = &#123;foo( ), bar( )&#125;;  if (true) &#123;    f( );  &#125; &#125; </code>false<code>// 空白の丸括弧の間のスペースを削除する。 void f() &#123;  int x[] = &#123;foo(), bar()&#125;;  if (true) &#123;    f();  &#125; &#125; </code></p>
</li>
<li><p>SpacesBeforeTrailingComments(Unsigned) 3.7以降</p>
<p>行コメント(&#x2F;&#x2F;)の前のスペースの数を指定する。 SpacesBeforeTrailingComments: 3 の場合<code>// 空白の丸括弧の間にスペースを挿入する。 void f() &#123;  if (true) &#123;   // スペース3個分空白が開く    f();        // 上に合わせる  &#125;             // foo &#125; </code></p>
</li>
<li><p>SpacesInAngles(SpacesInAnglesStyle) 3.4以降</p>
<p>テンプレートの引数リストの前後の空白を指定する。 値意味Never&lt; の後と &gt; の前のスペースを削除する。Always&lt; の後と &gt; の前にスペースを挿入する。Leave&lt; の後と &gt; の前にスペースがあった場合、スペースを1つずつ残す。StandardにCpp03を指定している場合、そちらを優先する。trueAlwaysと同じ動作。(レガシーオプション)falseNeverと同じ動作。(レガシーオプション)Never<code>// 引数リストの前後のスペースを削除する。 static_cast&lt;int&gt;(arg); std::function&lt;void(int)&gt; fct; </code>Always<code>// 引数リストの前後にスペースを挿入する。 static_cast&lt; int &gt;(arg); std::function&lt; void(int) &gt; fct; </code></p>
</li>
<li><p>SpacesInCStyleCastParentheses(Boolean) 3.7以降</p>
<p>C言語キャストの丸括弧内のスペースを指定する。 true<code>// 開き丸括弧の後及び閉じ丸括弧の前にスペースを挿入する。 x = ( int32 )y; </code>false<code>// 開き丸括弧の後及び閉じ丸括弧の前のスペースを削除する。 x = (int32)y; </code></p>
</li>
<li><p>SpacesInConditionalStatement(Boolean) 10以降</p>
<p>制御文(if, for, switch, while)の丸括弧内のスペースを指定する。 true<code>// 開き丸括弧の後及び閉じ丸括弧の前にスペースを挿入する。 if ( a )  &#123; ... &#125; while ( i &lt; 5 )  &#123; ... &#125; </code>false<code>// 開き丸括弧の後及び閉じ丸括弧の前のスペースを削除する。 if (a)  &#123; ... &#125; while (i &lt; 5)  &#123; ... &#125; </code></p>
</li>
<li><p>SpacesInContainerLiterals(Boolean) 3.7以降</p>
<p>コンテナ・リテラル(Objective-CやJavascriptの配列やdictリテラルなど)内のスペースを指定する。 true<code>// コンテナ・リテラル内にスペースを挿入する。 var arr = [ 1, 2, 3 ]; f(&#123;a : 1, b : 2, c : 3&#125;); </code>false<code>// コンテナ・リテラル内のスペースを削除する。 var arr = [1, 2, 3]; f(&#123;a: 1, b: 2, c: 3&#125;); </code></p>
</li>
<li><p>SpacesInLineCommentPrefix(SpacesInLineComment) 13以降</p>
<p>行頭のコメントで許容されるスペースの数の最大値及び最小値を指定する。 最大値に―1を指定した場合、最大値は無効となる。それ以外の場合、最大値が最小値より優先される。書式例<code>SpacesInLineCommentPrefix:  Minimum: 1  Maximum: -1 </code>Minimum: 2、Maximum: -1の場合<code>//  //の後に2文字スペースが挿入される //  if (b) &#123; //    return true; //  &#125;          </code>Minimum: 2、Maximum: 1の場合<code>// //の後に1文字スペースが挿入される(最小は2だが最大が1の為、最大数を設定となる) // if (b) &#123; //   return true; // &#125;          </code></p>
</li>
<li><p>SpacesInParentheses(Boolean) 3.7以降</p>
<p>丸括弧内の前後のスペースを指定する。 true<code>// 開き丸括弧の後及び閉じ丸括弧の前にスペースを挿入する。 t f( Deleted &amp; ) &amp; = delete; </code>false<code>// 開き丸括弧の後及び閉じ丸括弧の前のスペースを削除する。 t f(Deleted &amp;) &amp; = delete; </code></p>
</li>
<li><p>SpacesInSquareBrackets(Boolean) 3.7以降</p>
<p>角括弧内の前後のスペースを指定する。ただしラムダ式と値の無い角括弧のブロックについては対象外とする。 true<code>// 開き角括弧の後及び閉じ角括弧の前にスペースを挿入する。 int a[ 5 ]; std::unique_ptr&lt;int[]&gt; foo() &#123;&#125; // 値の無い角括弧は対象外 </code>false<code>// 開き角括弧の後及び閉じ角括弧の前のスペースを削除する。 int a[5]; </code></p>
</li>
<li><p>Standard(LanguageStandard) 3.7以降</p>
<p>対象とするC++の規格を指定する。 値意味c++03 C++03 Cpp03C++03を指定する。c++11 Cpp11C++11を指定する。c++14C++17を指定する。c++17C++14を指定する。c++20C++20を指定する。LatestLatestを指定する。動作としてはC++11と同じになる。Auto自動で判別を行う。</p>
</li>
<li><p>StatementAttributeLikeMacros(List of Strings) 12以降</p>
<p>識別子として解釈させず、属性と同じように無視されるキーワードを指定する。 Qtのemitなどを識別子として処理させないための定義である。 書式例<code>StatementAttributeLikeMacros: [&#39;emit&#39;, &#39;Q_EMIT&#39;] </code>StatementAttributeLikeMacros: [] を指定した場合<code>unsigned char data = &#39;x&#39;; emit          signal(data); // emitを識別子と勘違いしてしまい、おかしな並び方になる </code>StatementAttributeLikeMacros: [‘emit’] を指定した場合<code>unsigned char data = &#39;x&#39;; emit signal(data); // emitを識別子と認識させない </code></p>
</li>
<li><p>StatementMacros(List of Strings) 8以降</p>
<p>完全な式として解釈されるべきマクロを指定する。 書式例<code>StatementMacros: [&#39;Q_UNUSED&#39;, &#39;QT_REQUIRE_VERSION&#39;] </code></p>
</li>
<li><p>TabWidth(Unsigned) 3.7以降</p>
<p>タブ文字の数を指定する。 </p>
</li>
<li><p>TypenameMacros(List of Strings) 9以降</p>
<p>関数呼び出しとしてではなく、型宣言として解釈されるべきマクロを指定する。 書式例<code>TypenameMacros: [&#39;STACK_OF&#39;, &#39;LIST&#39;] </code></p>
</li>
<li><p>UseCRLF(Unsigned) 10以降</p>
<p>ファイル内の改行コードを指定する。 trueを指定した場合、ファイルの改行コードをCR+LFで統一する。DeriveLineEndingにtrueの場合、このフラグは無効となる。 </p>
</li>
<li><p>UseTab(UseTabStyle) 3.7以降</p>
<p>変換結果のファイルでのタブの使用について指定する。 値意味Neverタブを使用しない。ForIndentationインデントについてのみタブを使用する。ForContinuationAndIndentation先頭の空白はすべてタブで埋め、行内に現れるアライメント(連続した代入や宣言など)にはスペースを使用する。AlignWithSpaces行の継続とインデントにはタブを使用し、整列にはスペースを使用します。Always少なくとも1つのタブストップから次のタブストップまでの空白を埋める必要がある場合は、タブを使用します。trueAlwaysと同じ動作を行う。(レガシーオプション)falseNeverと同じ動作を行う。(レガシーオプション)</p>
</li>
<li><p>WhitespaceSensitiveMacros(List of Strings) 11以降</p>
<p>ホワイトスペースが影響する変更をかけてはいけないマクロを指定する。 書式例<code>WhitespaceSensitiveMacros: [&#39;STRINGIZE&#39;, &#39;PP_STRINGIZE&#39;] </code></p>
</li>
</ul>
<h2 id="３-書式例"><a href="#３-書式例" class="headerlink" title="３. 書式例"></a>３. 書式例</h2><p>Clang-Format15でのLLVMの既定値を以下に示す。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">Language:        Cpp</span><br><span class="line"># BasedOnStyle:  LLVM</span><br><span class="line">AccessModifierOffset: -2</span><br><span class="line">AlignAfterOpenBracket: Align</span><br><span class="line">AlignArrayOfStructures: None</span><br><span class="line">AlignConsecutiveMacros: None</span><br><span class="line">AlignConsecutiveAssignments: None</span><br><span class="line">AlignConsecutiveBitFields: None</span><br><span class="line">AlignConsecutiveDeclarations: None</span><br><span class="line">AlignEscapedNewlines: Right</span><br><span class="line">AlignOperands:   Align</span><br><span class="line">AlignTrailingComments: true</span><br><span class="line">AllowAllArgumentsOnNextLine: true</span><br><span class="line">AllowAllConstructorInitializersOnNextLine: true</span><br><span class="line">AllowAllParametersOfDeclarationOnNextLine: true</span><br><span class="line">AllowShortEnumsOnASingleLine: true</span><br><span class="line">AllowShortBlocksOnASingleLine: Never</span><br><span class="line">AllowShortCaseLabelsOnASingleLine: false</span><br><span class="line">AllowShortFunctionsOnASingleLine: All</span><br><span class="line">AllowShortLambdasOnASingleLine: All</span><br><span class="line">AllowShortIfStatementsOnASingleLine: Never</span><br><span class="line">AllowShortLoopsOnASingleLine: false</span><br><span class="line">AlwaysBreakAfterDefinitionReturnType: None</span><br><span class="line">AlwaysBreakAfterReturnType: None</span><br><span class="line">AlwaysBreakBeforeMultilineStrings: false</span><br><span class="line">AlwaysBreakTemplateDeclarations: MultiLine</span><br><span class="line">AttributeMacros:</span><br><span class="line">  - __capability</span><br><span class="line">BinPackArguments: true</span><br><span class="line">BinPackParameters: true</span><br><span class="line">BraceWrapping:</span><br><span class="line">  AfterCaseLabel:  false</span><br><span class="line">  AfterClass:      false</span><br><span class="line">  AfterControlStatement: Never</span><br><span class="line">  AfterEnum:       false</span><br><span class="line">  AfterFunction:   false</span><br><span class="line">  AfterNamespace:  false</span><br><span class="line">  AfterObjCDeclaration: false</span><br><span class="line">  AfterStruct:     false</span><br><span class="line">  AfterUnion:      false</span><br><span class="line">  AfterExternBlock: false</span><br><span class="line">  BeforeCatch:     false</span><br><span class="line">  BeforeElse:      false</span><br><span class="line">  BeforeLambdaBody: false</span><br><span class="line">  BeforeWhile:     false</span><br><span class="line">  IndentBraces:    false</span><br><span class="line">  SplitEmptyFunction: true</span><br><span class="line">  SplitEmptyRecord: true</span><br><span class="line">  SplitEmptyNamespace: true</span><br><span class="line">BreakBeforeBinaryOperators: None</span><br><span class="line">BreakBeforeConceptDeclarations: true</span><br><span class="line">BreakBeforeBraces: Attach</span><br><span class="line">BreakBeforeInheritanceComma: false</span><br><span class="line">BreakInheritanceList: BeforeColon</span><br><span class="line">BreakBeforeTernaryOperators: true</span><br><span class="line">BreakConstructorInitializersBeforeComma: false</span><br><span class="line">BreakConstructorInitializers: BeforeColon</span><br><span class="line">BreakAfterJavaFieldAnnotations: false</span><br><span class="line">BreakStringLiterals: true</span><br><span class="line">ColumnLimit:     80</span><br><span class="line">CommentPragmas:  &#x27;^ IWYU pragma:&#x27;</span><br><span class="line">CompactNamespaces: false</span><br><span class="line">ConstructorInitializerAllOnOneLineOrOnePerLine: false</span><br><span class="line">ConstructorInitializerIndentWidth: 4</span><br><span class="line">ContinuationIndentWidth: 4</span><br><span class="line">Cpp11BracedListStyle: true</span><br><span class="line">DeriveLineEnding: true</span><br><span class="line">DerivePointerAlignment: false</span><br><span class="line">DisableFormat:   false</span><br><span class="line">EmptyLineAfterAccessModifier: Never</span><br><span class="line">EmptyLineBeforeAccessModifier: LogicalBlock</span><br><span class="line">ExperimentalAutoDetectBinPacking: false</span><br><span class="line">FixNamespaceComments: true</span><br><span class="line">ForEachMacros:</span><br><span class="line">  - foreach</span><br><span class="line">  - Q_FOREACH</span><br><span class="line">  - BOOST_FOREACH</span><br><span class="line">IfMacros:</span><br><span class="line">  - KJ_IF_MAYBE</span><br><span class="line">IncludeBlocks:   Preserve</span><br><span class="line">IncludeCategories:</span><br><span class="line">  - Regex:           &#x27;^&quot;(llvm|llvm-c|clang|clang-c)/&#x27;</span><br><span class="line">    Priority:        2</span><br><span class="line">    SortPriority:    0</span><br><span class="line">    CaseSensitive:   false</span><br><span class="line">  - Regex:           &#x27;^(&lt;|&quot;(gtest|gmock|isl|json)/)&#x27;</span><br><span class="line">    Priority:        3</span><br><span class="line">    SortPriority:    0</span><br><span class="line">    CaseSensitive:   false</span><br><span class="line">  - Regex:           &#x27;.*&#x27;</span><br><span class="line">    Priority:        1</span><br><span class="line">    SortPriority:    0</span><br><span class="line">    CaseSensitive:   false</span><br><span class="line">IncludeIsMainRegex: &#x27;(Test)?$&#x27;</span><br><span class="line">IncludeIsMainSourceRegex: &#x27;&#x27;</span><br><span class="line">IndentAccessModifiers: false</span><br><span class="line">IndentCaseLabels: false</span><br><span class="line">IndentCaseBlocks: false</span><br><span class="line">IndentGotoLabels: true</span><br><span class="line">IndentPPDirectives: None</span><br><span class="line">IndentExternBlock: AfterExternBlock</span><br><span class="line">IndentRequires:  false</span><br><span class="line">IndentWidth:     2</span><br><span class="line">IndentWrappedFunctionNames: false</span><br><span class="line">InsertTrailingCommas: None</span><br><span class="line">JavaScriptQuotes: Leave</span><br><span class="line">JavaScriptWrapImports: true</span><br><span class="line">KeepEmptyLinesAtTheStartOfBlocks: true</span><br><span class="line">LambdaBodyIndentation: Signature</span><br><span class="line">MacroBlockBegin: &#x27;&#x27;</span><br><span class="line">MacroBlockEnd:   &#x27;&#x27;</span><br><span class="line">MaxEmptyLinesToKeep: 1</span><br><span class="line">NamespaceIndentation: None</span><br><span class="line">ObjCBinPackProtocolList: Auto</span><br><span class="line">ObjCBlockIndentWidth: 2</span><br><span class="line">ObjCBreakBeforeNestedBlockParam: true</span><br><span class="line">ObjCSpaceAfterProperty: false</span><br><span class="line">ObjCSpaceBeforeProtocolList: true</span><br><span class="line">PenaltyBreakAssignment: 2</span><br><span class="line">PenaltyBreakBeforeFirstCallParameter: 19</span><br><span class="line">PenaltyBreakComment: 300</span><br><span class="line">PenaltyBreakFirstLessLess: 120</span><br><span class="line">PenaltyBreakString: 1000</span><br><span class="line">PenaltyBreakTemplateDeclaration: 10</span><br><span class="line">PenaltyExcessCharacter: 1000000</span><br><span class="line">PenaltyReturnTypeOnItsOwnLine: 60</span><br><span class="line">PenaltyIndentedWhitespace: 0</span><br><span class="line">PointerAlignment: Right</span><br><span class="line">PPIndentWidth:   -1</span><br><span class="line">ReferenceAlignment: Pointer</span><br><span class="line">ReflowComments:  true</span><br><span class="line">ShortNamespaceLines: 1</span><br><span class="line">SortIncludes:    CaseSensitive</span><br><span class="line">SortJavaStaticImport: Before</span><br><span class="line">SortUsingDeclarations: true</span><br><span class="line">SpaceAfterCStyleCast: false</span><br><span class="line">SpaceAfterLogicalNot: false</span><br><span class="line">SpaceAfterTemplateKeyword: true</span><br><span class="line">SpaceBeforeAssignmentOperators: true</span><br><span class="line">SpaceBeforeCaseColon: false</span><br><span class="line">SpaceBeforeCpp11BracedList: false</span><br><span class="line">SpaceBeforeCtorInitializerColon: true</span><br><span class="line">SpaceBeforeInheritanceColon: true</span><br><span class="line">SpaceBeforeParens: ControlStatements</span><br><span class="line">SpaceAroundPointerQualifiers: Default</span><br><span class="line">SpaceBeforeRangeBasedForLoopColon: true</span><br><span class="line">SpaceInEmptyBlock: false</span><br><span class="line">SpaceInEmptyParentheses: false</span><br><span class="line">SpacesBeforeTrailingComments: 1</span><br><span class="line">SpacesInAngles:  Never</span><br><span class="line">SpacesInConditionalStatement: false</span><br><span class="line">SpacesInContainerLiterals: true</span><br><span class="line">SpacesInCStyleCastParentheses: false</span><br><span class="line">SpacesInLineCommentPrefix:</span><br><span class="line">  Minimum:         1</span><br><span class="line">  Maximum:         -1</span><br><span class="line">SpacesInParentheses: false</span><br><span class="line">SpacesInSquareBrackets: false</span><br><span class="line">SpaceBeforeSquareBrackets: false</span><br><span class="line">BitFieldColonSpacing: Both</span><br><span class="line">Standard:        Latest</span><br><span class="line">StatementAttributeLikeMacros:</span><br><span class="line">  - Q_EMIT</span><br><span class="line">StatementMacros:</span><br><span class="line">  - Q_UNUSED</span><br><span class="line">  - QT_REQUIRE_VERSION</span><br><span class="line">TabWidth:        8</span><br><span class="line">UseCRLF:         false</span><br><span class="line">UseTab:          Never</span><br><span class="line">WhitespaceSensitiveMacros:</span><br><span class="line">  - STRINGIZE</span><br><span class="line">  - PP_STRINGIZE</span><br><span class="line">  - BOOST_PP_STRINGIZE</span><br><span class="line">  - NS_SWIFT_NAME</span><br><span class="line">  - CF_SWIFT_NAME</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOC（10）：泛型程序设计与C++标准模板库</title>
    <url>/2024/08/13/SPOC(10)%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8EC-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
    <content><![CDATA[<h2 id="泛型程序设计的基本概念"><a href="#泛型程序设计的基本概念" class="headerlink" title="泛型程序设计的基本概念"></a>泛型程序设计的基本概念</h2><ul>
<li>编写不依赖于<strong>具体数据类型</strong>的程序</li>
<li>将算法从特定的<strong>数据结构</strong>中抽象出来，成为了<strong>通用</strong>的</li>
<li>C++的模板为<strong>泛型程序设计</strong>奠定了关键的基础</li>
</ul>
<h3 id="术语：概念"><a href="#术语：概念" class="headerlink" title="术语：概念"></a>术语：概念</h3><ul>
<li>用来界定具备一定功能的数<strong>据类型</strong></li>
</ul>
<ol>
<li><p>将 “ <strong>可 以 比 大 小</strong> 的 所 有 数 据 类 型 （ 有 比 较 运 算 符 ）” 这 一 概 念 记 为<strong>Comparable</strong></p>
</li>
<li><p>将“具有<strong>公有的复制构造函数</strong>并可以<strong>用‘&#x3D;’赋值</strong>的数据类型”这一概念记为Assignable</p>
</li>
<li><p>将“可以<strong>比大小</strong>、具有<strong>公有的复制构造函数</strong>并可以<strong>用‘&#x3D;’赋值</strong>的所有数据类型”这个概念记作Sortable。</p>
</li>
</ol>
<ul>
<li>对于两个不同的概念A和B，如果概念A所需要的<strong>所有功能</strong>也是概念B<strong>所需求的功能</strong>，那么就说概念B是概念A的子概念。例如：</li>
</ul>
<p>Sortable既是Comparable的子概念，也是Assignable的子概念</p>
<h3 id="术语：模型"><a href="#术语：模型" class="headerlink" title="术语：模型"></a>术语：模型</h3><ul>
<li>模型（model）：<strong>符合一个概念的数据类型</strong>称为该概念的模型，例如：</li>
</ul>
<ol>
<li><p>int型是Comparable概念的模型。</p>
</li>
<li><p>静态数组类型不是Assignable概念的模型（无法用“&#x3D;”给整个静态数组赋值）</p>
</li>
</ol>
<h3 id="用概念做模板参数名"><a href="#用概念做模板参数名" class="headerlink" title="用概念做模板参数名"></a>用概念做模板参数名</h3><ul>
<li><p>很多STL的实现代码就是使用<strong>概念来命名模板参数</strong>的。</p>
</li>
<li><p>为概念赋予一个名称，并使用该名称作为<strong>模板参数名</strong>。</p>
</li>
<li><p>例如</p>
</li>
</ul>
<ol>
<li><p>表示insertionSort这样一个函数模板的原型：</p>
</li>
<li><p>template <class sortable></class></p>
</li>
<li><p>void insertionSort(Sortable a[], int n);</p>
</li>
</ol>
<h2 id="STL-简介"><a href="#STL-简介" class="headerlink" title="STL 简介"></a>STL 简介</h2><p>标准模板库（Standard Template Library，简称STL）提供了一些非常常用的数据结构和算法</p>
<h3 id="STL-简介-1"><a href="#STL-简介-1" class="headerlink" title="STL 简介"></a>STL 简介</h3><ul>
<li><p>标准模板库（Standard Template Library，简称STL）定义了一套概念体系，为泛型程序设计提供了逻辑基础</p>
</li>
<li><p>STL中的各个类模板、函数模板的参数都是用这个体系中的概念来规定的。</p>
</li>
<li><p>使用STL的模板时，类型参数既可以是C++标准库中已有的类型，也可以是自定义的类型——只要这些类型是所要求概念的模型。</p>
</li>
</ul>
<h3 id="STL-的基本组件"><a href="#STL-的基本组件" class="headerlink" title="STL 的基本组件"></a>STL 的基本组件</h3><ul>
<li><p>容器（container）</p>
</li>
<li><p>迭代器（iterator）</p>
</li>
<li><p>函数对象（function object）</p>
</li>
<li><p>算法（algorithms）</p>
</li>
</ul>
<h3 id="STL-的基本组件间的关系"><a href="#STL-的基本组件间的关系" class="headerlink" title="STL 的基本组件间的关系"></a>STL 的基本组件间的关系</h3><ul>
<li>Iterators（迭代器）是<strong>算法和容器的桥梁</strong>。</li>
</ul>
<ol>
<li>将迭代器作为<strong>算法的参数</strong>、通过迭代器<strong>来访问容器</strong>而不是把容器直接作为<strong>算法的参数</strong>。</li>
</ol>
<ul>
<li><p>将<strong>函数对象</strong>作为<strong>算法的参数</strong>而不是将函数所执行的运算作为算法的一部分。</p>
</li>
<li><p>使用STL中提供的或自定义的迭代器和函数对象，配合STL的算法，可以组合出各种各样的功能。</p>
</li>
</ul>
<p><img src="https://i.postimg.cc/DfjktKxc/33b0c9e6efcf36164beda0525394a156.png" alt="STL"></p>
<h3 id="STL-的基本组件——容器（container）"><a href="#STL-的基本组件——容器（container）" class="headerlink" title="STL 的基本组件——容器（container）"></a>STL 的基本组件——容器（container）</h3><ul>
<li><p>容纳、包含一组元素的<strong>对象</strong>。</p>
</li>
<li><p>基本容器类模板</p>
</li>
</ul>
<ol>
<li><p><strong>顺序容器</strong></p>
</li>
<li><p>array（数组）、vector（向量）、deque（双端队列）、forward_list（单链表）、list（列表）</p>
</li>
<li><p>(<strong>有序)关联容器</strong></p>
</li>
<li><p>set（集合）、multiset（多重集合）、map（映射）、multimap（多重映射）</p>
</li>
<li><p><strong>无序关联容器</strong></p>
</li>
<li><p>unordered_set （无序集合）、unordered_multiset（无序多重集合）</p>
</li>
<li><p>unordered_map（无序映射）、unorder_multimap（无序多重映射）</p>
</li>
</ol>
<ul>
<li><strong>容器适配器</strong></li>
</ul>
<ol>
<li>stack（栈）、queue（队列）、priority_queue（优先队列）</li>
</ol>
<ul>
<li>使用容器，需要包含对应的头文件</li>
</ul>
<h3 id="STL-的基本组件——迭代器（iterator）"><a href="#STL-的基本组件——迭代器（iterator）" class="headerlink" title="STL 的基本组件——迭代器（iterator）"></a>STL 的基本组件——迭代器（iterator）</h3><ul>
<li><p>迭代器是<strong>泛化的指针</strong>，提供了<strong>顺序访问容器</strong>中每个元素的方法</p>
</li>
<li><p>提供了顺序访问容器中每个元素的方法；</p>
</li>
<li><p>可以使用“++”运算符来<strong>获得指向下一个元素的迭代器</strong>；</p>
</li>
<li><p>可以<strong>使用“*”运算符访问一个迭代器所指向的元素</strong>，如果元素类型是<strong>类或结构体</strong>，还可以使用“-&gt;”运算符直接访问该元素的一个成员；</p>
</li>
<li><p>有些迭代器还支持通过“–”运算符获得指向上一个元素的迭代器；</p>
</li>
<li><p>迭代器是泛化的指针：指针也具有同样的特性，因此指针本身就是一种迭代器；</p>
</li>
<li><p>使用独立于<strong>STL容器的迭代器</strong>，需要包含头文件<iterator>。</iterator></p>
</li>
</ul>
<h3 id="STL-的基本组件——函数对象（function-object）"><a href="#STL-的基本组件——函数对象（function-object）" class="headerlink" title="STL 的基本组件——函数对象（function object）"></a>STL 的基本组件——函数对象（function object）</h3><ul>
<li><p>一个<strong>行为类似函数</strong>的对象，对它可以像调用函数一样调用。</p>
</li>
<li><p>函数对象是<strong>泛化的函数</strong>：任何普通的函数和任何重载了“()” 运算符的类的对象都可以作为函数对象使用</p>
</li>
<li><p>使用STL的函数对象，需要包含头文件<functional></functional></p>
</li>
</ul>
<h3 id="STL-的基本组件——算法（algorithms）"><a href="#STL-的基本组件——算法（algorithms）" class="headerlink" title="STL 的基本组件——算法（algorithms）"></a>STL 的基本组件——算法（algorithms）</h3><ul>
<li>STL包括70多个算法</li>
</ul>
<ol>
<li>例如：排序算法，消除算法，计数算法，比较算法，变换算法，置换算法和</li>
</ol>
<p>容器管理等</p>
<ul>
<li><p>可以广泛用于<strong>不同的对象</strong>和<strong>内置的数据类型</strong>。</p>
</li>
<li><p>使用STL的算法，需要包含头文件<algorithm>。</algorithm></p>
</li>
<li><p>例10-1从标准输入读入几个整数，存入向量容器，输出它们的相反数</p>
</li>
</ul>
<h3 id="例-10-1：STL-程序实例"><a href="#例-10-1：STL-程序实例" class="headerlink" title="例 10-1：STL 程序实例"></a>例 10-1：STL 程序实例</h3><ul>
<li>transform算法</li>
</ul>
<ol>
<li>transform算法的一种实现：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>, <span class="keyword">class</span> <span class="title class_">UnaryFunction</span>&gt;</span><br><span class="line"><span class="function">OutputIterator <span class="title">transform</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (;first != last; ++first, ++result)</span><br><span class="line">*result = <span class="built_in">op</span>(*first);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>transform算法<strong>顺序遍历first和last两个迭代器所指向</strong>的元素；</p>
</li>
<li><p>将每个元素的值作为<strong>函数对象op</strong>的参数；</p>
</li>
<li><p>将op的返回值通过<strong>迭代器result</strong>顺序输出；</p>
</li>
<li><p>遍历完成后result迭代器指向的是输出的最后一个元素的下一个位置，transform会将该迭代器返回</p>
</li>
</ol>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>迭代器是算法和容器的桥梁</li>
</ul>
<ol>
<li>迭代器用作访问容器中的元素</li>
<li>算法不直接操作容器中的数据，而是通<strong>过迭代器间接操作</strong></li>
</ol>
<ul>
<li>算法和容器独立</li>
</ul>
<ol>
<li><p>增加新的算法，无需影响容器的实现</p>
</li>
<li><p>增加新的容器，原有的算法也能适用</p>
</li>
</ol>
<h3 id="输入流迭代器和输出流迭代器"><a href="#输入流迭代器和输出流迭代器" class="headerlink" title="输入流迭代器和输出流迭代器"></a>输入流迭代器和输出流迭代器</h3><ul>
<li>输入流迭代器</li>
</ul>
<p>istream_iterator<T></T></p>
<ol>
<li><p>以<strong>输入流（如cin）</strong>为参数构造</p>
</li>
<li><p>*<em>可用</em>(p++)**获得下一个输入的元素</p>
</li>
</ol>
<ul>
<li>输出流迭代器</li>
</ul>
<p>ostream_iterator<T></T></p>
<ol>
<li><p>构造时需要提供输出流（如cout）</p>
</li>
<li><p>可用(*p++) &#x3D; x将x输出到输出流</p>
</li>
</ol>
<ul>
<li>二者都属于适配器</li>
</ul>
<ol>
<li><p>适配器是用来为已有<strong>对象提供新的接口的对象</strong></p>
</li>
<li><p>输入流适配器和输出流适配器为<strong>流对象</strong>提供了迭代器的接口</p>
</li>
</ol>
<h3 id="例-10-2-从标准输入读入几个实数，分别将它们的平方输出"><a href="#例-10-2-从标准输入读入几个实数，分别将它们的平方输出" class="headerlink" title="例 10-2 从标准输入读入几个实数，分别将它们的平方输出"></a>例 10-2 从标准输入读入几个实数，分别将它们的平方输出</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//10_2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//求平方的函数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//从标准输入读入若干个实数，分别将它们的平方输出</span></span><br><span class="line"> <span class="built_in">transform</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">double</span>&gt;(cin), <span class="built_in">istream_iterator</span>&lt;<span class="type">double</span>&gt;(),</span><br><span class="line"><span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout, <span class="string">&quot;\t&quot;</span>), square);</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器的分类"><a href="#迭代器的分类" class="headerlink" title="迭代器的分类"></a>迭代器的分类</h3><p><img src="https://i.postimg.cc/0Nz1kXrw/60ee0dff11d1d4065b50330cd32adcd7.png"></p>
<h3 id="迭代器支持的操作"><a href="#迭代器支持的操作" class="headerlink" title="迭代器支持的操作"></a>迭代器支持的操作</h3><ul>
<li>迭代器是<strong>泛化的指针</strong>，提供了类似指针的操作（诸如++、*、-&gt;运算符）</li>
</ul>
<ol>
<li><p>输入迭代器</p>
<p>可以用来从序列中<strong>读取数据</strong>，如<strong>输入流迭代器</strong></p>
</li>
<li><p>输出迭代器</p>
<p>允许向序列中<strong>写入数据</strong>，如<strong>输出流迭代器</strong></p>
</li>
<li><p>前向迭代器</p>
<p>既是输入迭代器又是输出迭代器，并且可以<strong>对序列进行单向的遍历</strong></p>
</li>
<li><p>双向迭代器</p>
<p>与前向迭代器相似，但是在<strong>两个方向上</strong>都可以对数据遍历</p>
</li>
<li><p>随机访问迭代器</p>
<p>也是双向迭代器，但能够在序列中的<strong>任意两个位置</strong>之间进行跳转，如指针、使用vector的begin()、end()函数得到的迭代器</p>
</li>
</ol>
<h3 id="迭代器的区间"><a href="#迭代器的区间" class="headerlink" title="迭代器的区间"></a>迭代器的区间</h3><ul>
<li><p>两个<strong>迭代器</strong>表示一个区间：[p1, p2)</p>
</li>
<li><p>STL算法常以迭代器的区间作为<strong>输入，传递输入数据</strong></p>
</li>
<li><p><strong>合法的区间</strong></p>
</li>
<li><p>p1经过n次(n &gt; 0)自增(++)操作后<strong>满足p1 &#x3D;&#x3D; p2</strong></p>
</li>
<li><p>区间<strong>包含p1</strong>，但<strong>不包含p2</strong></p>
</li>
</ul>
<h3 id="例-10-3-综合运用几种迭代器的示例"><a href="#例-10-3-综合运用几种迭代器的示例" class="headerlink" title="例 10-3 综合运用几种迭代器的示例"></a>例 10-3 综合运用几种迭代器的示例</h3><p>程序涉及到<strong>输入迭代器、输出迭代器、随机访问迭代器</strong>这三个迭代器概念，并且以前两个概念为基础编写了一个通用算法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//10_3.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//将来自输入迭代器的n个T类型的数值排序，将结果通过输出迭代器result输出</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">InputIterator</span>, <span class="keyword">class</span> <span class="title class_">OutputIterator</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过输入迭代器将输入数据存入向量容器s中</span></span><br><span class="line">vector&lt;T&gt; s;</span><br><span class="line"><span class="keyword">for</span> (;first != last; ++first)</span><br><span class="line">s.<span class="built_in">push_back</span>(*first);</span><br><span class="line"><span class="comment">//对s进行排序，sort函数的参数必须是随机访问迭代器</span></span><br><span class="line"> <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>()); </span><br><span class="line"><span class="built_in">copy</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), result); <span class="comment">//将s序列通过输出迭代器输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//将s数组的内容排序后输出</span></span><br><span class="line"><span class="type">double</span> a[<span class="number">5</span>] = &#123; <span class="number">1.2</span>, <span class="number">2.4</span>, <span class="number">0.8</span>, <span class="number">3.3</span>, <span class="number">3.2</span> &#125;;</span><br><span class="line"><span class="built_in">mySort</span>&lt;<span class="type">double</span>&gt;(a, a + <span class="number">5</span>, <span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//从标准输入读入若干个整数，将排序后的结果输出</span></span><br><span class="line"><span class="built_in">mySort</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(cin), <span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(), </span><br><span class="line"><span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0.8</span> <span class="number">1.2</span> <span class="number">2.4</span> <span class="number">3.2</span> <span class="number">3.3</span></span><br><span class="line"><span class="number">2</span> <span class="number">-4</span> <span class="number">5</span> <span class="number">8</span> <span class="number">-1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">-5</span></span><br><span class="line"><span class="number">-5</span> <span class="number">-4</span> <span class="number">-1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器的辅助函数"><a href="#迭代器的辅助函数" class="headerlink" title="迭代器的辅助函数"></a>迭代器的辅助函数</h3><ul>
<li>advance(p, n)</li>
</ul>
<p>对p执行<strong>n次自增操作</strong></p>
<ul>
<li>distance(first, last)</li>
</ul>
<p>计算两个迭代器<strong>first和last的距离</strong>，即对first执行多少次“++”操作后能够使得first &#x3D;&#x3D; last</p>
<h2 id="容器的基本功能与分类"><a href="#容器的基本功能与分类" class="headerlink" title="容器的基本功能与分类"></a>容器的基本功能与分类</h2><ul>
<li><p>容器类是<strong>容纳、包含一组元素或元素集合</strong>的对象。</p>
</li>
<li><p>基于容器中元素的组织方式：<strong>顺序容器、关联容器</strong></p>
</li>
<li><p>按照与容器所关联的迭代器类型划分：<strong>可逆容器</strong> <strong>随机访问容器</strong></p>
</li>
</ul>
<h3 id="容器的基本功能与分类-1"><a href="#容器的基本功能与分类-1" class="headerlink" title="容器的基本功能与分类"></a>容器的基本功能与分类</h3><ul>
<li>容器</li>
</ul>
<ol>
<li><strong>顺序</strong>容器</li>
</ol>
<p>array（数组）、vector（向量）、deque（双端队列）、forward_list（单链表）、list（列表）</p>
<ol start="2">
<li><strong>(有序)关联</strong>容器</li>
</ol>
<p>set（集合）、multiset（多重集合）、map（映射）、multimap（多重映射）</p>
<ol start="3">
<li><strong>无序关联</strong>容器</li>
</ol>
<p>unordered_set （无序集合）、unordered_multiset（无序多重集合）</p>
<p>unordered_map（无序映射）、unorder_multimap（无序多重映射）</p>
<h3 id="容器的分类"><a href="#容器的分类" class="headerlink" title="容器的分类"></a>容器的分类</h3><p><img src="https://i.postimg.cc/Ss808X6Q/abdc044a9a2dc26fc478d24d8ce1db1f.png"></p>
<p><img src="https://i.postimg.cc/8cV2b14R/049c148163a903ba980087b8738a3323.png"></p>
<h3 id="容器的通用功能"><a href="#容器的通用功能" class="headerlink" title="容器的通用功能"></a>容器的通用功能</h3><ul>
<li>容器的<strong>通用</strong>功能</li>
</ul>
<ol>
<li><p>用默认构造函数构造空容器</p>
</li>
<li><p>支持关系运算符：&#x3D;&#x3D;、!&#x3D;、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;</p>
</li>
<li><p>begin()、end()：获得容器首、尾迭代器</p>
</li>
<li><p>clear()：将容器清空</p>
</li>
<li><p>empty()：判断容器是否为空</p>
</li>
<li><p>size()：得到容器元素个数</p>
</li>
<li><p>s1.swap(s2)：将s1和s2两容器内容交换</p>
</li>
<li><p>相关数据类型（S表示容器类型）</p>
</li>
<li><p>S::iterator：指向容器元素的迭代器类型</p>
</li>
<li><p>S::const_iterator：常迭代器类型</p>
</li>
</ol>
<h4 id="对可逆容器的访问"><a href="#对可逆容器的访问" class="headerlink" title="对可逆容器的访问"></a>对可逆容器的访问</h4><ul>
<li><p>STL为每个可逆容器都提供了逆向迭代器，逆向迭代器可以通过下面的成员函数得到：</p>
<ol>
<li>rbegin() ：指向容器尾的逆向迭代器</li>
<li>rend()：指向容器首的逆向迭代器</li>
</ol>
</li>
<li><p>逆向迭代器的类型名的表示方式如下：</p>
</li>
<li><ol>
<li>S::reverse_iterator：逆向迭代器类型</li>
<li>S::const_reverse_iterator：逆向常迭代器类型</li>
</ol>
</li>
</ul>
<h3 id="随机访问容器"><a href="#随机访问容器" class="headerlink" title="随机访问容器"></a>随机访问容器</h3><ul>
<li><p>随机访问容器支持对容器的元素进行随机访问</p>
</li>
<li><p>s[n]：获得容器s的第n个元素</p>
</li>
</ul>
<h2 id="顺序容器的基本功能"><a href="#顺序容器的基本功能" class="headerlink" title="顺序容器的基本功能"></a>顺序容器的基本功能</h2><h3 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h3><ol>
<li><p>向量（vector）</p>
</li>
<li><p>双端队列（deque）</p>
</li>
<li><p>列表（list）</p>
</li>
<li><p>单向链表（forward_list）</p>
</li>
<li><p>数组（array）</p>
</li>
<li><p>元素线性排列，可以随时在指定位置插入元素和删除元素。</p>
</li>
</ol>
<p> 必须符合<strong>Assignable</strong>这一概念（即具有公有的拷贝构造函数并可以用“&#x3D;”赋值）。</p>
<p>array对象的<strong>大小固定</strong>，forward_list有<strong>特殊的添加和删除操作</strong></p>
<h3 id="顺序容器的接口（不包含单向链表（forward-list）和数组（array））"><a href="#顺序容器的接口（不包含单向链表（forward-list）和数组（array））" class="headerlink" title="顺序容器的接口（不包含单向链表（forward_list）和数组（array））"></a>顺序容器的接口（不包含单向链表（forward_list）和数组（array））</h3><ol>
<li><p>构造函数</p>
</li>
<li><p>赋值函数</p>
</li>
<li><p>assign</p>
</li>
</ol>
<ul>
<li>插入函数</li>
</ul>
<p>insert， push_front（只对list和deque）， push_back，emplace，</p>
<p>emplace_front</p>
<ul>
<li>删除函数</li>
</ul>
<p>erase ， clear ， pop_front （只对 list 和 deque ） ， pop_back ，</p>
<p>emplace_back</p>
<ul>
<li>首尾元素的直接访问</li>
</ul>
<p>front，back</p>
<p>在逻辑上可看作是一个长度可扩展的数组</p>
<p>改变大小</p>
<p>resize</p>
<h3 id="例-10-4-顺序容器的基本操作"><a href="#例-10-4-顺序容器的基本操作" class="headerlink" title="例 10-4 顺序容器的基本操作"></a>例 10-4 顺序容器的基本操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//10_4.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="comment">//输出指定的顺序容器的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printContainer</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">const</span> T&amp; s)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; msg &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line"><span class="built_in">copy</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//从标准输入读入10个整数，将它们分别从s的头部加入</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">s.<span class="built_in">push_front</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printContainer</span>(<span class="string">&quot;deque at first&quot;</span>, s);</span><br><span class="line"><span class="comment">//用s容器的内容的逆序构造列表容器l</span></span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(s.rbegin(), s.rend())</span></span>;</span><br><span class="line"><span class="built_in">printContainer</span>(<span class="string">&quot;list at first&quot;</span>, l);</span><br><span class="line">例<span class="number">10</span><span class="number">-4</span> 顺序容器的基本操作</span><br><span class="line"><span class="comment">//将列表容器l的每相邻两个元素顺序颠倒</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator iter = l.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (iter != l.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="type">int</span> v = *iter;</span><br><span class="line">iter = l.<span class="built_in">erase</span>(iter);</span><br><span class="line">l.<span class="built_in">insert</span>(++iter, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printContainer</span>(<span class="string">&quot;list at last&quot;</span>, l);</span><br><span class="line"><span class="comment">//用列表容器l的内容给s赋值，将s输出</span></span><br><span class="line">s.<span class="built_in">assign</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printContainer</span>(<span class="string">&quot;deque at last&quot;</span>, s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">9</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line">deque at first: <span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span></span><br><span class="line">list at first: <span class="number">0</span> <span class="number">9</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line">list at last: <span class="number">9</span> <span class="number">0</span> <span class="number">6</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">deque at last: <span class="number">9</span> <span class="number">0</span> <span class="number">6</span> <span class="number">8</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="顺序容器的特性"><a href="#顺序容器的特性" class="headerlink" title="顺序容器的特性"></a>顺序容器的特性</h2><p>顺序容器：向量、双端队列、列表、单向链表、数组</p>
<h3 id="向量（Vector）"><a href="#向量（Vector）" class="headerlink" title="向量（Vector）"></a>向量（Vector）</h3><ul>
<li>特点</li>
</ul>
<ol>
<li><p>一个可以扩展的动态数组</p>
</li>
<li><p>随机访问、在尾部插入或删除元素快</p>
</li>
<li><p>在中间或头部插入或删除元素慢</p>
</li>
</ol>
<ul>
<li>向量的容量</li>
</ul>
<ol>
<li><p>容量(capacity)：实际分配空间的大小</p>
</li>
<li><p>s.capacity() ：返回当前容量</p>
</li>
<li><p>s.reserve(n)：若容量小于n，则对s进行扩展，使其容量至少为n</p>
</li>
</ol>
<h3 id="双端队列（deque）"><a href="#双端队列（deque）" class="headerlink" title="双端队列（deque）"></a>双端队列（deque）</h3><ul>
<li>特点</li>
</ul>
<ol>
<li><p>在两端插入或删除元素快</p>
</li>
<li><p>在中间插入或删除元素慢</p>
</li>
<li><p>随机访问较快，但比向量容器慢</p>
</li>
</ol>
<h3 id="例-10-5-奇偶排序"><a href="#例-10-5-奇偶排序" class="headerlink" title="例 10-5 奇偶排序"></a>例 10-5 奇偶排序</h3><p>先按照从大到小顺序输出奇数，再按照从小到大顺序输出偶数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头部分省略</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">i1</span><span class="params">(cin)</span>, i2</span>; <span class="comment">//建立一对输入流迭代器</span></span><br><span class="line"> <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s1</span><span class="params">(i1, i2)</span></span>; <span class="comment">//通过输入流迭代器从标准输入流中输入数据</span></span><br><span class="line"> <span class="built_in">sort</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>()); <span class="comment">//将输入的整数排序</span></span><br><span class="line"> deque&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"> <span class="comment">//以下循环遍历s1</span></span><br><span class="line"> <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = s1.<span class="built_in">begin</span>(); iter != s1.<span class="built_in">end</span>(); ++iter) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span> (*iter % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">//偶数放到s2尾部</span></span><br><span class="line"> s2.<span class="built_in">push_back</span>(*iter);</span><br><span class="line"> <span class="keyword">else</span> <span class="comment">//奇数放到s2首部</span></span><br><span class="line"> s2.<span class="built_in">push_front</span>(*iter);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//将s2的结果输出</span></span><br><span class="line"> <span class="built_in">copy</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h3><ul>
<li>特点</li>
</ul>
<ol>
<li><p>在<strong>任意位置插入和删除元素</strong>都很快</p>
</li>
<li><p>不支持<strong>随机</strong>访问</p>
</li>
<li><p>接合(splice)操作</p>
</li>
<li><p>s1.splice(p, s2, q1, q2)：将s2中[q1, q2)移动到<strong>s1中p所指向元素之前</strong></p>
</li>
</ol>
<p>&#x2F;&#x2F; 头部分省略</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string names1[] = &#123; <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Helen&quot;</span>, <span class="string">&quot;Lucy&quot;</span>, <span class="string">&quot;Susan&quot;</span> &#125;;</span><br><span class="line">string names2[] = &#123; <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="string">&quot;Levin&quot;</span>, <span class="string">&quot;Mike&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//用names1数组的内容构造列表s1</span></span><br><span class="line"> <span class="function">list&lt;string&gt; <span class="title">s1</span><span class="params">(names1, names1 + <span class="number">4</span>)</span></span>; </span><br><span class="line"><span class="comment">//用names2数组的内容构造列表s2</span></span><br><span class="line"> <span class="function">list&lt;string&gt; <span class="title">s2</span><span class="params">(names2, names2 + <span class="number">4</span>)</span></span>; </span><br><span class="line"><span class="comment">//将s1的第一个元素放到s2的最后</span></span><br><span class="line"> s2.<span class="built_in">splice</span>(s2.<span class="built_in">end</span>(), s1, s1.<span class="built_in">begin</span>());</span><br><span class="line"> list&lt;string&gt;::iterator iter1 = s1.<span class="built_in">begin</span>(); <span class="comment">//iter1指向s1首</span></span><br><span class="line"> <span class="built_in">advance</span>(iter1, <span class="number">2</span>); <span class="comment">//iter1前进2个元素，它将指向s1第3个元素</span></span><br><span class="line"> list&lt;string&gt;::iterator iter2 = s2.<span class="built_in">begin</span>(); <span class="comment">//iter2指向s2首</span></span><br><span class="line"> ++iter2; <span class="comment">//iter2前进1个元素，它将指向s2第2个元素</span></span><br><span class="line"> list&lt;string&gt;::iterator iter3 = iter2; <span class="comment">//用iter2初始化iter3</span></span><br><span class="line"> <span class="built_in">advance</span>(iter3, <span class="number">2</span>); <span class="comment">//iter3前进2个元素，它将指向s2第4个元素</span></span><br><span class="line"> <span class="comment">//将[iter2, iter3)范围内的结点接到s1中iter1指向的结点前</span></span><br><span class="line"> s1.<span class="built_in">splice</span>(iter1, s2, iter2, iter3); </span><br><span class="line"> <span class="comment">//分别将s1和s2输出</span></span><br><span class="line"> <span class="built_in">copy</span>(s1.<span class="built_in">begin</span>(), s1.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="built_in">copy</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单向链表（forward-list）"><a href="#单向链表（forward-list）" class="headerlink" title="单向链表（forward_list）"></a>单向链表（forward_list）</h3><ol>
<li><p>单向链表每个结点只有指向下个结点的指针，没有简单的方法来获取一个结点的前驱；</p>
</li>
<li><p>未定义insert、emplace和erase操作，而定义了insert_after、emplace_after和erase_after操作，其参数与list的insert、emplace和erase相同，但并不是插入或删除迭代器p1所指的元素，而是对p1所指元素之后的结点进行操作；</p>
</li>
<li><p>不支持size操作。</p>
</li>
</ol>
<h3 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h3><ol>
<li><p>array是对内置数组的封装，提供了更安全，更方便的使用数组的方式</p>
</li>
<li><p>array的对象的大小是固定的，定义时除了需要指定元素类型，还需要指定容器大</p>
</li>
</ol>
<p>小。</p>
<ol start="3">
<li>不能动态地改变容器大小</li>
</ol>
<h3 id="顺序容器的比较"><a href="#顺序容器的比较" class="headerlink" title="顺序容器的比较"></a>顺序容器的比较</h3><ol>
<li>STL所提供的顺序容器各有所长也各有所短，我们在编写程序时应当根据我们对容</li>
</ol>
<p>器所需要执行的操作来决定选择哪一种容器。</p>
<ol start="2">
<li>如果需要执行<strong>大量的随机访问操作</strong>，而且当<strong>扩展容器</strong>时只需要向容器尾部加</li>
</ol>
<p>入新的元素，就应当选择向量容器vector；</p>
<ol start="3">
<li>如果需要<strong>少量的随机访问</strong>操作，需要在<strong>容器两端插入或删除元素</strong>，则应当选</li>
</ol>
<p>择<strong>双端队列容器deque</strong>；</p>
<ol start="4">
<li>如果<strong>不需要</strong>对容器<strong>进行随机访问</strong>，但是需要在中<strong>间位置插入或者删除元素</strong>，</li>
</ol>
<p>就应当选择列表容器list或forward_list；</p>
<ol start="5">
<li>如果需要数组，array相对于<strong>内置数组</strong>类型而言，是一种更安全、更容易使</li>
</ol>
<p>用的数组类型</p>
<h2 id="顺序容器的插入迭代器与适配器"><a href="#顺序容器的插入迭代器与适配器" class="headerlink" title="顺序容器的插入迭代器与适配器"></a>顺序容器的插入迭代器与适配器</h2><h3 id="顺序容器的插入迭代器"><a href="#顺序容器的插入迭代器" class="headerlink" title="顺序容器的插入迭代器"></a>顺序容器的插入迭代器</h3><ol>
<li><p>用于向容器头部、尾部或中间指定位置插入元素的迭代器</p>
</li>
<li><p>包括前插迭代器（front_inserter）、后插迭代器（back_insrter）和任意位置插入</p>
</li>
</ol>
<p>迭代器（inserter）</p>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function">back_inserter <span class="title">iter</span><span class="params">(s)</span></span>;</span><br><span class="line">*(iter++) = <span class="number">5</span>; <span class="comment">//通过iter把5插入s末尾</span></span><br></pre></td></tr></table></figure>

<h3 id="顺序容器的适配器"><a href="#顺序容器的适配器" class="headerlink" title="顺序容器的适配器"></a>顺序容器的适配器</h3><ul>
<li><p>以顺序容器为基础构建一些常用数据结构，是对<strong>顺序容器的封装</strong></p>
</li>
<li><p>栈(stack)：最先压入的元素<strong>最后被弹出</strong></p>
</li>
<li><p>队列(queue)：<strong>最先压入</strong>的元素最<strong>先被弹出</strong></p>
</li>
<li><p>优先级队列(priority_queue)：<strong>最“大”的元素</strong>最先被弹出</p>
</li>
</ul>
<h3 id="栈和队列模板"><a href="#栈和队列模板" class="headerlink" title="栈和队列模板"></a>栈和队列模板</h3><ul>
<li>栈模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = deque&lt;T&gt; &gt; <span class="keyword">class</span> stack;</span><br></pre></td></tr></table></figure>

<ul>
<li>队列模板</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">FrontInsertionSequence</span> = deque&lt;T&gt; &gt; <span class="keyword">class</span> queue;</span><br></pre></td></tr></table></figure>

<ul>
<li>栈可以用任何一种顺序容器作为基础容器，而队列只允许用前插顺序容器（双端队列或列表）</li>
</ul>
<h3 id="栈和队列共同支持的操作"><a href="#栈和队列共同支持的操作" class="headerlink" title="栈和队列共同支持的操作"></a>栈和队列共同支持的操作</h3><ul>
<li><p>s1 op s2 op可以是&#x3D;&#x3D;、!&#x3D;、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;之一，它会对两个容器适配器之间的元素按字典序进行比较</p>
</li>
<li><p>s.size()  </p>
<p>返回s的元素个数</p>
</li>
<li><p>s.empty() 返回s是否为空</p>
</li>
<li><p>s.push(t)</p>
<p>   将元素t压入到s中</p>
</li>
<li><p>s.pop() 将一个元素从s中弹出，对于栈来说，每次弹出的是最后被压入的元素，而对于队列，每次被弹出的是最先被压入的元素</p>
</li>
<li><p>不支持迭代器，因为它们不允许对任意元素进行访问</p>
</li>
</ul>
<h3 id="栈和队列不同的操作"><a href="#栈和队列不同的操作" class="headerlink" title="栈和队列不同的操作"></a>栈和队列不同的操作</h3><ul>
<li>栈的操作</li>
</ul>
<p>s.top() </p>
<p>返回栈顶元素的引用</p>
<ul>
<li>队列操作</li>
</ul>
<p>s.front() </p>
<p>获得队头元素的引用</p>
<ul>
<li>s.back()</li>
</ul>
<p>获得队尾元素的引用</p>
<h3 id="例-10-7-利用栈反向输出单词"><a href="#例-10-7-利用栈反向输出单词" class="headerlink" title="例 10-7 利用栈反向输出单词"></a>例 10-7 利用栈反向输出单词</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//10_7.cpp， 省略头部分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str; <span class="comment">//从键盘输入一个字符串</span></span><br><span class="line"><span class="comment">//将字符串的每个元素顺序压入栈中</span></span><br><span class="line"><span class="keyword">for</span> (string::iterator iter = str.<span class="built_in">begin</span>(); iter != str.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">s.<span class="built_in">push</span>(*iter);</span><br><span class="line"><span class="comment">//将栈中的元素顺序弹出并输出</span></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">top</span>();</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果如下："><a href="#运行结果如下：" class="headerlink" title="运行结果如下："></a>运行结果如下：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">congratulations</span><br><span class="line">snoitalutargnoc</span><br></pre></td></tr></table></figure>

<h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><ul>
<li>优先级队列也像栈和队列一样支持元素的压入和弹出，但元素弹出的顺序与元素的大小有关，每次弹出的总是容器中最“大”的一个元素。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Sequence</span> = vector&lt;T&gt; &gt; <span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>优先级队列的<strong>基础容器</strong>必须是支持<strong>随机访问的顺序容器</strong>。</p>
</li>
<li><p>支持栈和<strong>队列的size、empty、push、pop</strong>几个成员函数，用法与栈和队列相同。</p>
</li>
<li><p>优先级队列并<strong>不支</strong>持<strong>比较</strong>操作。</p>
</li>
<li><p>与栈类似，优先级队列提供<strong>一个top函数</strong>，可以获得下一个即将被<strong>弹出元素（即最“大”的元素）的引用</strong>。</p>
</li>
</ul>
<h3 id="例-10-8-细胞分裂模拟"><a href="#例-10-8-细胞分裂模拟" class="headerlink" title="例 10-8 细胞分裂模拟"></a>例 10-8 细胞分裂模拟</h3><p>一种细胞在诞生（即上次分裂）后会在500到2000秒内分裂为两个细胞，每个细胞又按照同样的规律继续分裂。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10.8.cpp, 头部分省略</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SPLIT_TIME_MIN = <span class="number">500</span>; <span class="comment">//细胞分裂最短时间</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SPLIT_TIME_MAX = <span class="number">2000</span>; <span class="comment">//细胞分裂最长时间</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span>;</span><br><span class="line">priority_queue&lt;Cell&gt; cellQueue;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cell</span> &#123; <span class="comment">//细胞类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count; <span class="comment">//细胞总数</span></span><br><span class="line"><span class="type">int</span> id; <span class="comment">//当前细胞编号</span></span><br><span class="line"><span class="type">int</span> time; <span class="comment">//细胞分裂时间</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cell</span>(<span class="type">int</span> birth) : <span class="built_in">id</span>(count++) &#123; <span class="comment">//birth为细胞诞生时间</span></span><br><span class="line"><span class="comment">//初始化，确定细胞分裂时间</span></span><br><span class="line">time = birth + (<span class="built_in">rand</span>() % (SPLIT_TIME_MAX - SPLIT_TIME_MIN))+ </span><br><span class="line">SPLIT_TIME_MIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> id; &#125; <span class="comment">//得到细胞编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSplitTime</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> time; &#125; <span class="comment">//得到细胞分裂时间</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Cell&amp; s) <span class="type">const</span> <span class="comment">//定义“&lt;”</span></span><br><span class="line"> &#123; <span class="keyword">return</span> time &gt; s.time; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span> </span>&#123; <span class="comment">//细胞分裂</span></span><br><span class="line"> <span class="function">Cell <span class="title">child1</span><span class="params">(time)</span>, <span class="title">child2</span><span class="params">(time)</span></span>; <span class="comment">//建立两个子细胞</span></span><br><span class="line"> cout &lt;&lt; time &lt;&lt; <span class="string">&quot;s: Cell #&quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; splits to #&quot;</span></span><br><span class="line">&lt;&lt; child1.<span class="built_in">getId</span>() &lt;&lt; <span class="string">&quot; and #&quot;</span> &lt;&lt; child2.<span class="built_in">getId</span>() &lt;&lt; endl;</span><br><span class="line"> cellQueue.<span class="built_in">push</span>(child1); <span class="comment">//将第一个子细胞压入优先级队列</span></span><br><span class="line"> cellQueue.<span class="built_in">push</span>(child2); <span class="comment">//将第二个子细胞压入优先级队列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Cell::count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span>&gt;(<span class="built_in">time</span>(<span class="number">0</span>)));</span><br><span class="line"><span class="type">int</span> t; <span class="comment">//模拟时间长度</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Simulation time: &quot;</span>;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">cellQueue.<span class="built_in">push</span>(<span class="built_in">Cell</span>(<span class="number">0</span>)); <span class="comment">//将第一个细胞压入优先级队列</span></span><br><span class="line"><span class="keyword">while</span> (cellQueue.<span class="built_in">top</span>().<span class="built_in">getSplitTime</span>() &lt;= t) &#123;</span><br><span class="line">cellQueue.<span class="built_in">top</span>().<span class="built_in">split</span>(); <span class="comment">//模拟下一个细胞的分裂</span></span><br><span class="line">cellQueue.<span class="built_in">pop</span>(); <span class="comment">//将刚刚分裂的细胞弹出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行结果如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Simulation time: <span class="number">5000</span></span><br><span class="line"><span class="number">971</span>s: Cell #<span class="number">0</span> splits to #<span class="number">1</span> <span class="keyword">and</span> #<span class="number">2</span></span><br><span class="line"><span class="number">1719</span>s: Cell #<span class="number">1</span> splits to #<span class="number">3</span> <span class="keyword">and</span> #<span class="number">4</span></span><br><span class="line"><span class="number">1956</span>s: Cell #<span class="number">2</span> splits to #<span class="number">5</span> <span class="keyword">and</span> #<span class="number">6</span></span><br><span class="line"><span class="number">2845</span>s: Cell #<span class="number">6</span> splits to #<span class="number">7</span> <span class="keyword">and</span> #<span class="number">8</span></span><br><span class="line"><span class="number">3551</span>s: Cell #<span class="number">3</span> splits to #<span class="number">9</span> <span class="keyword">and</span> #<span class="number">10</span></span><br><span class="line"><span class="number">3640</span>s: Cell #<span class="number">4</span> splits to #<span class="number">11</span> <span class="keyword">and</span> #<span class="number">12</span></span><br><span class="line"><span class="number">3919</span>s: Cell #<span class="number">5</span> splits to #<span class="number">13</span> <span class="keyword">and</span> #<span class="number">14</span></span><br><span class="line"><span class="number">4162</span>s: Cell #<span class="number">10</span> splits to #<span class="number">15</span> <span class="keyword">and</span> #<span class="number">16</span></span><br><span class="line"><span class="number">4197</span>s: Cell #<span class="number">8</span> splits to #<span class="number">17</span> <span class="keyword">and</span> #<span class="number">18</span></span><br><span class="line"><span class="number">4317</span>s: Cell #<span class="number">7</span> splits to #<span class="number">19</span> <span class="keyword">and</span> #<span class="number">20</span></span><br><span class="line"><span class="number">4686</span>s: Cell #<span class="number">13</span> splits to #<span class="number">21</span> <span class="keyword">and</span> #<span class="number">22</span></span><br><span class="line"><span class="number">4809</span>s: Cell #<span class="number">12</span> splits to #<span class="number">23</span> <span class="keyword">and</span> #<span class="number">24</span></span><br><span class="line"><span class="number">4818</span>s: Cell #<span class="number">17</span> splits to #<span class="number">25</span> <span class="keyword">and</span> #<span class="number">26</span></span><br></pre></td></tr></table></figure>

<h2 id="关联容器分类和的基本功能"><a href="#关联容器分类和的基本功能" class="headerlink" title="关联容器分类和的基本功能"></a>关联容器分类和的基本功能</h2><h3 id="关联容器的特点和接口"><a href="#关联容器的特点和接口" class="headerlink" title="关联容器的特点和接口"></a>关联容器的特点和接口</h3><ul>
<li>关联容器的特点</li>
</ul>
<p>每个关联容器都有一个键(key)</p>
<p>可以根据键高效地查找元素</p>
<ul>
<li>接口</li>
</ul>
<ol>
<li><p>插入：insert</p>
</li>
<li><p>删除：erase</p>
</li>
<li><p>查找：find</p>
</li>
<li><p>定界：lower_bound、upper_bound、equal_range</p>
</li>
<li><p>计数：count</p>
</li>
</ol>
<h3 id="关联容器概念图"><a href="#关联容器概念图" class="headerlink" title="关联容器概念图"></a>关联容器概念图</h3><p><img src="https://i.postimg.cc/6q0mLCyK/cce8c0eb52bb35bba409d63dc64ebfb8.png"></p>
<h3 id="四种关联容器"><a href="#四种关联容器" class="headerlink" title="四种关联容器"></a>四种关联容器</h3><ul>
<li>单重关联容器(set和map)</li>
</ul>
<ol>
<li>键值是唯一的，一个键值只能对应一个元素</li>
</ol>
<ul>
<li>多重关联容器(multiset和multimap)</li>
</ul>
<ol>
<li>键值是不唯一的，一个键值可以对应多个元素</li>
</ol>
<ul>
<li>简单关联容器(set和multiset)</li>
</ul>
<ol>
<li><p>容器只有一个类型参数，如set<K>、multiset<K>，表示键类型</K></K></p>
</li>
<li><p>容器的元素就是键本身</p>
</li>
</ol>
<ul>
<li>二元关联容器(map和multimap)</li>
</ul>
<ol>
<li><p>容器有两个类型参数，如map&lt;K,V&gt;、multimap&lt;K,V&gt;，分别表示键和附加数据的类型</p>
</li>
<li><p>容器的元素类型是pair&lt;K,V&gt;，即由键类型和元素类型复合而成的二元组</p>
</li>
</ol>
<h3 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h3><ul>
<li>C++11新标准中定义了4个无序关联容器</li>
</ul>
<ol>
<li>unordered_set 、 unordered_map 、 unordered_multiset 、unordered_multimap</li>
</ol>
<p> 不是使用比较运算符来组织元素的，而是通过一个哈希函数和键类型的&#x3D;&#x3D;运算符。</p>
<p> 提供了与有序容器相同的操作 可以直接定义关键字是内置类型的无序容器。</p>
<p> 不能直接定义关键字类型为自定义类的无序容器，如果需要，必须提供我们自己的hash模板。</p>
<h2 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h2><p>集合用来存储一组无重复的元素。由于集合的元素本身是有序的，可以高效地查找指</p>
<p>定元素，也可以方便地得到指定大小范围的元素在容器中所处的区间。</p>
<h3 id="例-10-9"><a href="#例-10-9" class="headerlink" title="例 10-9"></a>例 10-9</h3><p>输入一串实数，将重复的去掉，取最大和最小者的中值，分别输出小于等于此中值和</p>
<p>大于等于此中值的实数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//10_9.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">set&lt;<span class="type">double</span>&gt; s;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"> <span class="type">double</span> v;</span><br><span class="line"> cin &gt;&gt; v;</span><br><span class="line"> <span class="keyword">if</span> (v == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//输入0表示结束</span></span><br><span class="line"> <span class="comment">//尝试将v插入</span></span><br><span class="line"> pair&lt;set&lt;<span class="type">double</span>&gt;::iterator,<span class="type">bool</span>&gt; r=s.<span class="built_in">insert</span>(v); </span><br><span class="line"> <span class="keyword">if</span> (!r.second) <span class="comment">//如果v已存在，输出提示信息</span></span><br><span class="line"> cout &lt;&lt; v &lt;&lt; <span class="string">&quot; is duplicated&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//得到第一个元素的迭代器</span></span><br><span class="line">set&lt;<span class="type">double</span>&gt;::iterator iter1=s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//得到末尾的迭代器</span></span><br><span class="line">set&lt;<span class="type">double</span>&gt;::iterator iter2=s.<span class="built_in">end</span>();</span><br><span class="line"> <span class="comment">//得到最小和最大元素的中值</span></span><br><span class="line"><span class="type">double</span> medium=(*iter1 + *(--iter2)) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//输出小于或等于中值的元素</span></span><br><span class="line">cout&lt;&lt; <span class="string">&quot;&lt;= medium: &quot;</span></span><br><span class="line"><span class="built_in">copy</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">upper_bound</span>(medium), <span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout, <span class="string">&quot; </span></span><br><span class="line"><span class="string">&quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出大于或等于中值的元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;&gt;= medium: &quot;</span>;</span><br><span class="line"><span class="built_in">copy</span>(s.<span class="built_in">lower_bound</span>(medium), s.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">double</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2.5</span> <span class="number">5</span> <span class="number">3.5</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span> <span class="number">2.5</span> <span class="number">0</span></span><br><span class="line"><span class="number">5</span> is duplicated</span><br><span class="line"><span class="number">2.5</span> is duplicated</span><br><span class="line">&lt;= medium: <span class="number">1</span> <span class="number">2.5</span> <span class="number">3.5</span> <span class="number">5</span></span><br><span class="line">&gt;= medium: <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h2 id="映射（map）"><a href="#映射（map）" class="headerlink" title="映射（map）"></a>映射（map）</h2><ol>
<li>映射与集合同属于单重关联容器，它们的主要区别在于，集合的元素类型是键本身，</li>
</ol>
<p>而映射的元素类型是由键和附加数据所构成的二元组。</p>
<ol start="2">
<li>在集合中按照键查找一个元素时，一般只是用来确定这个元素是否存在，而在映射</li>
</ol>
<p>中按照键查找一个元素时，除了能确定它的存在性外，还可以得到相应的附加数据。</p>
<h3 id="例-10-10"><a href="#例-10-10" class="headerlink" title="例 10-10"></a>例 10-10</h3><p>有五门课程，每门都有相应学分，从中选择三门，输出学分总和</p>
<p>&#x2F;&#x2F;10_10.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; courses;</span><br><span class="line"><span class="comment">//将课程信息插入courses映射中</span></span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;CSAPP&quot;</span>, <span class="number">3</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++&quot;</span>, <span class="number">2</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;CSARCH&quot;</span>, <span class="number">4</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;COMPILER&quot;</span>, <span class="number">4</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;OS&quot;</span>, <span class="number">5</span>));</span><br><span class="line"><span class="type">int</span> n = <span class="number">3</span>; <span class="comment">//剩下的可选次数</span></span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//学分总和</span></span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">string name;</span><br><span class="line">cin &gt;&gt; name; <span class="comment">//输入课程名称</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::iterator iter = courses.<span class="built_in">find</span>(name);<span class="comment">//查找课程</span></span><br><span class="line"><span class="keyword">if</span> (iter == courses.<span class="built_in">end</span>()) &#123; <span class="comment">//判断是否找到</span></span><br><span class="line">cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is not available&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sum += iter-&gt;second; <span class="comment">//累加学分</span></span><br><span class="line">courses.<span class="built_in">erase</span>(iter); <span class="comment">//将刚选过的课程从映射中删除</span></span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Total credit: &quot;</span> &lt;&lt; sum &lt;&lt; endl; <span class="comment">//输出总学分</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C++</span><br><span class="line">COMPILER</span><br><span class="line">C++</span><br><span class="line">C++ is <span class="keyword">not</span> available</span><br><span class="line">CSAPP</span><br><span class="line">Total credit: <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="例-10-11"><a href="#例-10-11" class="headerlink" title="例 10-11"></a>例 10-11</h3><p>统计一句话中每个字母出现的次数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10_11.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; s; <span class="comment">//用来存储字母出现次数的映射</span></span><br><span class="line"><span class="type">char</span> c; <span class="comment">//存储输入字符</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"> cin &gt;&gt; c; <span class="comment">//输入下一个字符</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(c))&#123; <span class="comment">//判断是否是字母</span></span><br><span class="line"> c = <span class="built_in">tolower</span>(c); <span class="comment">//将字母转换为小写</span></span><br><span class="line"> s[c]++; <span class="comment">//将该字母的出现频率加1</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (c != <span class="string">&#x27;.&#x27;</span>); <span class="comment">//碰到“.”则结束输入</span></span><br><span class="line"><span class="comment">//输出每个字母出现次数</span></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;::iterator iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多重集合（multiset）与多重映射（multimap）"><a href="#多重集合（multiset）与多重映射（multimap）" class="headerlink" title="多重集合（multiset）与多重映射（multimap）"></a>多重集合（multiset）与多重映射（multimap）</h2><ul>
<li><p>多重集合是允许有重复元素的集合，多重映射是允许一个键对应多个附加数据的映射。</p>
</li>
<li><p>多重集合与集合、多重映射与映射的用法差不多，只在几个成员函数上有细微差异，其差异主要表现在去除了键必须唯一的限制。</p>
</li>
</ul>
<h3 id="例-10-12-上课时间查询"><a href="#例-10-12-上课时间查询" class="headerlink" title="例 10-12 上课时间查询"></a>例 10-12 上课时间查询</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//10_12.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">multimap&lt;string, string&gt; courses;</span><br><span class="line"><span class="keyword">typedef</span> multimap&lt;string, string&gt;::iterator CourseIter;</span><br><span class="line"><span class="comment">//将课程上课时间插入courses映射中</span></span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;2-6&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;COMPILER&quot;</span>, <span class="string">&quot;3-1&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;COMPILER&quot;</span>, <span class="string">&quot;5-2&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;OS&quot;</span>, <span class="string">&quot;1-2&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;OS&quot;</span>, <span class="string">&quot;4-1&quot;</span>));</span><br><span class="line">courses.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;OS&quot;</span>, <span class="string">&quot;5-5&quot;</span>));</span><br><span class="line"><span class="comment">//输入一个课程名，直到找到该课程为止，记下每周上课次数</span></span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">cin &gt;&gt; name;</span><br><span class="line">count = courses.<span class="built_in">count</span>(name);</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Cannot find this course!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">while</span> (count == <span class="number">0</span>);</span><br><span class="line"><span class="comment">//输出每周上课次数和上课时间</span></span><br><span class="line">cout &lt;&lt; count &lt;&lt; <span class="string">&quot; lesson(s) per week: &quot;</span>;</span><br><span class="line">pair&lt;CourseIter, CourseIter&gt; range = courses.<span class="built_in">equal_range</span>(name);</span><br><span class="line"><span class="keyword">for</span> (CourseIter iter = range.first; iter != range.second; ++iter)</span><br><span class="line">cout &lt;&lt; iter-&gt;second &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">JAVA</span><br><span class="line">Cannot find <span class="keyword">this</span> course!</span><br><span class="line">OS</span><br><span class="line"><span class="number">3</span> <span class="built_in">lesson</span>(s) per week: <span class="number">1</span><span class="number">-2</span> <span class="number">4</span><span class="number">-1</span> <span class="number">5</span><span class="number">-5</span></span><br></pre></td></tr></table></figure>

<h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><ul>
<li><p>一个行为类似函数的对象</p>
</li>
<li><p>可以没有参数，也可以带有若干参数</p>
</li>
<li><p>其功能是获取一个值，或者改变操作的状态。</p>
</li>
<li><p>例</p>
</li>
</ul>
<ol>
<li><p>普通函数就是函数对象</p>
</li>
<li><p>重载了“()”运算符的类的实例是函数对象</p>
</li>
</ol>
<h3 id="函数对象概念图"><a href="#函数对象概念图" class="headerlink" title="函数对象概念图"></a>函数对象概念图</h3><p><img src="https://i.postimg.cc/63xjkMZw/79fc9c5da64631a30a7b023715e142a7.png"></p>
<h3 id="例-10-13、例-10-14："><a href="#例-10-13、例-10-14：" class="headerlink" title="例 10-13、例 10-14："></a>例 10-13、例 10-14：</h3><ol>
<li><p>使用两种方式定义表示乘法的函数对象</p>
</li>
<li><p>通过定义普通函数（例10-13）</p>
</li>
<li><p>通过重载类的“()”运算符（例10-14）</p>
</li>
</ol>
<p>• 用到以下算法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> Type, <span class="keyword">class</span> BinaryFunction&gt;</span></span><br><span class="line"><span class="function">Type <span class="title">accumulate</span><span class="params">(InputIterator first, InputIterator last, Type val, </span></span></span><br><span class="line"><span class="params"><span class="function">BinaryFunction binaryOp)</span></span>;</span><br></pre></td></tr></table></figure>

<p> 对[first, last)区间内的数据进行累“加”，binaryOp为用二元函数对象表示的“加”运算符，val为累“加”的初值</p>
<h3 id="例-10-13"><a href="#例-10-13" class="headerlink" title="例 10-13"></a>例 10-13</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">//包含数值算法头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//定义一个普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mult</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The result by multipling all elements in a is &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">accumulate</span>(a, a + N, <span class="number">1</span>, mult)</span><br><span class="line">&lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例-10-14"><a href="#例-10-14" class="headerlink" title="例 10-14"></a>例 10-14</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//10_14.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">//包含数值算法头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultClass</span>&#123; <span class="comment">//定义MultClass类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">//重载操作符operator()</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The result by multipling all elements in a is &quot;</span></span><br><span class="line">&lt;&lt; <span class="built_in">accumulate</span>(a, a + N, <span class="number">1</span>, <span class="built_in">MultClass</span>()) <span class="comment">//将类multclass传递给通用算法</span></span><br><span class="line">&lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="STL-提供的函数对象"><a href="#STL-提供的函数对象" class="headerlink" title="STL 提供的函数对象"></a>STL 提供的函数对象</h3><ul>
<li>用于算术运算的函数对象：</li>
</ul>
<ol>
<li><p>一元函数对象(一个参数) ：negate</p>
</li>
<li><p>二元函数对象(两个参数) ：plus、minus、multiplies、divides、modulus</p>
</li>
<li><p>用于关系运算、逻辑运算的函数对象(要求返回值为bool)</p>
</li>
<li><p>一元谓词(一个参数)：logical_not</p>
</li>
<li><p>二 元 谓 词 ( 两 个 参 数 ) ： equal_to 、 not_equal_to 、 greater 、 less 、greater_equal、less_equal、logical_and、logical_or</p>
</li>
</ol>
<h3 id="例-10-15-利用-STL-标准函数对象"><a href="#例-10-15-利用-STL-标准函数对象" class="headerlink" title="例 10-15 利用 STL 标准函数对象"></a>例 10-15 利用 STL 标准函数对象</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//10_15.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">//包含数值算法头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> <span class="comment">//包含标准函数对象头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The result by multipling all elements in A is “</span></span><br><span class="line"><span class="string"> &lt;&lt; accumulate(a, a + N, 1, multiplies&lt;int&gt;())</span></span><br><span class="line"><span class="string">&lt;&lt; endl; //将标准函数对象传递给通用算法</span></span><br><span class="line"><span class="string">return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="例-10-16-利用-STL-中的二元谓词函数对象"><a href="#例-10-16-利用-STL-中的二元谓词函数对象" class="headerlink" title="例 10-16 利用 STL 中的二元谓词函数对象"></a>例 10-16 利用 STL 中的二元谓词函数对象</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10_16.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> intArr[] = &#123; <span class="number">30</span>, <span class="number">90</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(intArr, intArr + N)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;before sorting:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;after sorting:&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout,<span class="string">&quot;\t&quot;</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h2><ul>
<li>绑定适配器：bind1st、bind2nd</li>
</ul>
<ol>
<li><p>将n元函数对象的指定参数绑定为一个常数，得到n-1元函数对象</p>
</li>
<li><p>组合适配器：not1、not2</p>
</li>
<li><p>将指定谓词的结果取反</p>
</li>
<li><p>函数指针适配器：ptr_fun</p>
</li>
<li><p>将一般函数指针转换为函数对象，使之能够作为其它函数适配器的输入。</p>
</li>
<li><p>在进行参数绑定或其他转换的时候，通常需要函数对象的类型信息，例如bind1st和bind2nd要求函数对象必须继承于binary_function类型。但如果传入的是函数指针形式的函数对象，则无法获得函数对象的类型信息。</p>
</li>
<li><p>成员函数适配器：ptr_fun、ptr_fun_ref</p>
</li>
<li><p>对成员函数指针使用，把n元成员函数适配为n + 1元函数对象，该函数对象的第一个参数为调用该成员函数时的目的对象</p>
</li>
<li><p>也就是需要将“object-&gt;method()”转为“method(object)”形式。将“object-&gt;method(arg1)”转为二元函数“method(object, arg1)”。</p>
</li>
</ol>
<h3 id="绑定适配器"><a href="#绑定适配器" class="headerlink" title="绑定适配器"></a>绑定适配器</h3><ol>
<li><p>binder2nd的实例构造通常比较冗长，bind2nd函数用于辅助构造binder2nd，产生它的一个实例。</p>
</li>
<li><p>binder1st和bind1st，将一个具体值绑定到二元函数的第一个参数。</p>
</li>
</ol>
<h3 id="例-10-17：函数适配器实例——找到数组中第一个大于-40-的元素"><a href="#例-10-17：函数适配器实例——找到数组中第一个大于-40-的元素" class="headerlink" title="例 10-17：函数适配器实例——找到数组中第一个大于 40 的元素"></a>例 10-17：函数适配器实例——找到数组中第一个大于 40 的元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//10_17.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> intArr[] = &#123; <span class="number">30</span>, <span class="number">90</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(intArr, intArr + N)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator p = <span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), </span><br><span class="line"><span class="number">40</span>));</span><br><span class="line"><span class="keyword">if</span> (p == a.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;no element greater than 40&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;first element greater than 40 is: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>find_if算法在STL中的原型声明为：</p>
<p>template&lt;class InputIterator, class UnaryPredicate&gt;</p>
<p>InputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate pred);它的功能是查找数组[first, last)区间中第一个pred(x)为真的元素。</p>
<h3 id="组合适配器"><a href="#组合适配器" class="headerlink" title="组合适配器"></a>组合适配器</h3><ol>
<li><p>对于一般的逻辑运算，有时可能还需要对结果求一次逻辑反。</p>
</li>
<li><p>unary_negate和binary_negate实现了这一适配功能。STL还提供了not1和not2辅助生成相应的函数对象实例，分别用于一元谓词和二元谓词的逻辑取反。</p>
</li>
</ol>
<h3 id="例-10-18-ptr-fun、not1-和-not2-产生函数适配器实例"><a href="#例-10-18-ptr-fun、not1-和-not2-产生函数适配器实例" class="headerlink" title="例 10-18 ptr_fun、not1 和 not2 产生函数适配器实例"></a>例 10-18 ptr_fun、not1 和 not2 产生函数适配器实例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10_18.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> intArr[] = &#123; <span class="number">30</span>, <span class="number">90</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">80</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(intArr, intArr + N)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator p;</span><br><span class="line">p = <span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(g), <span class="number">40</span>));</span><br><span class="line"><span class="keyword">if</span> (p == a.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;no element greater than 40&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;first element greater than 40 is: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">p = <span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">15</span>)));</span><br><span class="line"><span class="keyword">if</span> (p == a.<span class="built_in">end</span>())</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;no element is not greater than 15&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;first element that is not greater than 15 is: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">p = <span class="built_in">find_if</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">not2</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()), <span class="number">15</span>));</span><br><span class="line"><span class="keyword">if</span> (p == a.<span class="built_in">end</span>())</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;no element is not greater than 15&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;first element that is not greater than 15 is: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例-10-19-成员函数适配器实例"><a href="#例-10-19-成员函数适配器实例" class="headerlink" title="例 10-19 成员函数适配器实例"></a>例 10-19 成员函数适配器实例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//10_19.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="built_in">Car</span>(<span class="type">int</span> id) &#123; <span class="keyword">this</span>-&gt;id = id; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;car &quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;Car *&gt; pcars;</span><br><span class="line">vector&lt;Car&gt; cars;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">pcars.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Car</span>(i));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">cars.<span class="built_in">push_back</span>(<span class="built_in">Car</span>(i));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;elements in pcars: &quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(pcars.<span class="built_in">begin</span>(), pcars.<span class="built_in">end</span>(), std::<span class="built_in">mem_fun</span>(&amp;Car::display));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;elements in cars: &quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(cars.<span class="built_in">begin</span>(), cars.<span class="built_in">end</span>(), std::<span class="built_in">mem_fun_ref</span>(&amp;Car::display));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; pcars.<span class="built_in">size</span>(); ++i)</span><br><span class="line"><span class="keyword">delete</span> pcars[i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法</p>
<p>STL 算法特点</p>
<ol>
<li><p>STL算法本身是一种函数模版</p>
</li>
<li><p>通过迭代器获得输入数据</p>
</li>
<li><p>通过函数对象对数据进行处理</p>
</li>
<li><p>通过迭代器将结果输出</p>
</li>
<li><p>STL算法是通用的，独立于具体的数据类型、容器类型</p>
</li>
</ol>
<p>STL 算法分类</p>
<ol>
<li><p>不可变序列算法</p>
</li>
<li><p>可变序列算法</p>
</li>
<li><p>排序和搜索算法</p>
</li>
<li><p>数值算法</p>
</li>
</ol>
<p>不可变序列算法</p>
<ol>
<li><p>不直接修改所操作的容器内容的算法</p>
</li>
<li><p>用于查找指定元素、比较两个序列是否相等、对元素进行计数等</p>
</li>
</ol>
<ul>
<li>例：</li>
</ul>
<p>template&lt;class InputIterator, class UnaryPredicate&gt;</p>
<p>InputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate pred);</p>
<p>查找[first, last)区间内pred(x)为真的首个元素</p>
<p>可变序列算法</p>
<ol>
<li><p>可以修改它们所操作的容器对象</p>
</li>
<li><p>包括对序列进行复制、删除、替换、倒序、旋转、交换、分割、去重、填充、洗牌</p>
</li>
</ol>
<p>的算法及生成一个序列的算法</p>
<ul>
<li>例：</li>
</ul>
<p>template&lt;class ForwardIterator, class T&gt;</p>
<p>void fill (ForwardIterator first, ForwardIterator last, const T&amp; x);</p>
<p>将[first, last)区间内的元素全部改写为x。</p>
<p>排序和搜索算法</p>
<ol>
<li><p>对序列进行排序</p>
</li>
<li><p>对两有序序列进行合并</p>
</li>
<li><p>对有序序列进行搜索</p>
</li>
<li><p>有序序列的集合操作</p>
</li>
</ol>
<ul>
<li>堆算法</li>
</ul>
<p> 例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RandomAccessIterator</span> , <span class="keyword">class</span> <span class="title class_">UnaryPredicate</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last, UnaryPredicate comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以函数对象comp为“&lt;”，对 [first, last)区间内的数据进行排序</p>
<h3 id="数值算法"><a href="#数值算法" class="headerlink" title="数值算法"></a>数值算法</h3><ol>
<li><p>求序列中元素的“和”、部分“和”、相邻元素的“差”或两序列的内积</p>
</li>
<li><p>求“和”的“+”、求“差”的“-”以及求内积的“+”和“·”都可由函数对象</p>
</li>
</ol>
<p>指定</p>
<p>例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> InputIterator, <span class="keyword">class</span> OutputIterator, <span class="keyword">class</span> </span></span><br><span class="line"><span class="function">BinaryFunction&gt;</span></span><br><span class="line"><span class="function">OutputIterator <span class="title">partial_sum</span><span class="params">(InputIterator first, InputIterator last, OutputIterator result, BinaryFunction op)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对[first, last)内的元素求部分“和”（所谓部分“和”，是一个长度与输入序</p>
<p>列相同的序列，其第n项为输入序列前n个元素的“和”），以函数对象op为“+”</p>
<p>运算符，结果通过result输出，返回的迭代器指向输出序列最后一个元素的下</p>
<p>一个元素</p>
<h3 id="算法应用举例"><a href="#算法应用举例" class="headerlink" title="算法应用举例"></a>算法应用举例</h3><ol>
<li><p>例10-20——例10-23演示了几类算法的应用。</p>
</li>
<li><p>详见教材第10章</p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>本章主要内容</p>
</li>
<li><p>泛型程序设计的概念</p>
</li>
<li><p>与标准模板库有关的概念和术语</p>
</li>
<li><p>迭代器</p>
</li>
<li><p>容器</p>
</li>
<li><p>函数对象</p>
</li>
<li><p>算法</p>
</li>
<li><p>本章学习目标</p>
</li>
</ul>
<ol>
<li><p>初步了解泛型程序设计的概念</p>
</li>
<li><p>学会C++标准模板库（STL）的使用方法</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOC(11)：流类库与输入输出</title>
    <url>/2024/08/14/SPOC%EF%BC%8811%EF%BC%89%EF%BC%9A%E6%B5%81%E7%B1%BB%E5%BA%93%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>第十一章 流类库与输入&#x2F;输出</p>
<p>主要内容</p>
<p> I&#x2F;O流的概念</p>
<p> 流类库结构</p>
<p> 输出流</p>
<p> 输入流</p>
<p> 输入&#x2F;输出流</p>
<p> 读写文本文件的格式控制</p>
<p>I&#x2F;O 流的概念及流类库结构</p>
<p>程序与外界环境的信息交换</p>
<p> 当程序与外界环境进行信息交换时，存在着两个对象：程序中的对象、文件对象。</p>
<p>流</p>
<p> 一种抽象，负责在数据的生产者和数据的消费者之间建立联系，并管理数据的流动。</p>
<p>流对象与文件操作</p>
<p> 程序建立一个流对象</p>
<p> 指定这个流对象与某个文件对象建立连接</p>
<p> 程序操作流对象</p>
<p> 流对象通过文件系统对所连接的文件对象产生作用。</p>
<p>提取与插入</p>
<p> 读操作在流数据抽象中被称为（从流中）提取</p>
<p> 写操作被称为（向流中）插入。</p>
<p>流类库结构流类列表</p>
<p>输出流概述</p>
<p>最重要的三个输出流</p>
<p> ostream</p>
<p> ofstream</p>
<p> ostringstream</p>
<p>预先定义的输出流对象</p>
<p> cout 标准输出</p>
<p> cerr 标准错误输出，没有缓冲，发送给它的内容立即被输出。 clog 类似于cerr，但是有缓冲，缓冲区满时被输出。</p>
<p>标准输出换向</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;b.out&quot;</span>)</span></span>;</span><br><span class="line">streambuf* pOld =cout.<span class="built_in">rdbuf</span>(fout.<span class="built_in">rdbuf</span>()); </span><br><span class="line"><span class="comment">//…</span></span><br><span class="line">cout.<span class="built_in">rdbuf</span>(pOld); </span><br></pre></td></tr></table></figure>

<p>构造输出流对象</p>
<p> ofstream类支持磁盘文件输出</p>
<p> 如果在构造函数中指定一个文件名，当构造这个对象时该文件是自动打开的</p>
<p>ofstream myFile(“filename”);</p>
<p> 可以在调用默认构造函数之后使用open成员函数打开文件</p>
<p>ofstream myFile; &#x2F;&#x2F;声明一个静态文件输出流对象</p>
<p>myFile.open(“filename”); &#x2F;&#x2F;打开文件，使流对象与文件建立联系</p>
<p> 在构造对象或用open打开文件时可以指定模式</p>
<p>ofstream myFile(“filename”, ios_base::out | ios_base::binary);</p>
<p>文件输出流成员函数的三种类型</p>
<p> 与操纵符等价的成员函数。</p>
<p> 执行非格式化写操作的成员函数。</p>
<p> 其它修改流状态且不同于操纵符或插入运算符的成员函数。</p>
<p>文件输出流成员函数</p>
<p> open函数</p>
<p>把流与一个特定的磁盘文件关联起来。</p>
<p>需要指定打开模式。</p>
<p> put函数</p>
<p>把一个字符写到输出流中。</p>
<p> write函数</p>
<p>把内存中的一块内容写到一个文件输出流中</p>
<p> seekp和tellp函数</p>
<p>操作文件流的内部指针</p>
<p> close函数</p>
<p>关闭与一个文件输出流关联的磁盘文件</p>
<p> 错误处理函数在写到一个流时进行错误处理</p>
<p>向文本文件输出</p>
<p>标准输出设备显示器被系统看作文本文件，所以我们以向标准设备输出为例，介绍文本</p>
<p>文件输出格式控制</p>
<p>插入运算符</p>
<p> 插入(&lt;&lt;)运算符</p>
<p> </p>
<p>为所有标准C++数据类型预先设计的，用于传送字节到一个输出流对象。</p>
<p>操纵符（manipulator）</p>
<p> 插入运算符与操纵符一起工作</p>
<p> </p>
<p>控制输出格式。</p>
<p> 很多操纵符都定义在</p>
<p> </p>
<p>ios_base类中（如hex()）、<iomanip>头文件（如setprecision()）。</iomanip></p>
<p> 控制输出宽度</p>
<p> </p>
<p>在流中放入setw操纵符或调用width成员函数为每个项指定输出宽度。</p>
<p> setw和width仅影响紧随其后的输出项，但其它流格式操纵符保持有效直到发生改</p>
<p>变。</p>
<p> dec、oct和hex操纵符设置输入和输出的默认进制。</p>
<p>例 11-1 使用 width 控制输出宽度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.23</span> <span class="number">35.36</span></span><br><span class="line"><span class="number">653.7</span></span><br><span class="line"><span class="number">4358.24</span></span><br></pre></td></tr></table></figure>

<p>例 11-2 使用 <strong>setw</strong> 操纵符指定宽度</p>
<p>&#x2F;&#x2F;11_2.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i] </span><br><span class="line"> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> Zoot <span class="number">1.23</span></span><br><span class="line">Jimmy <span class="number">35.36</span></span><br><span class="line"> Al <span class="number">653.7</span></span><br><span class="line"> Stan <span class="number">4358.24</span></span><br></pre></td></tr></table></figure>

<p>例 11-3 设置对齐方式</p>
<p>&#x2F;&#x2F;11_3.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)<span class="comment">//左对齐 &lt;&lt; setw(6) &lt;&lt; names[i]</span></span><br><span class="line"> &lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)</span><br><span class="line"> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Zoot <span class="number">1.23</span></span><br><span class="line">Jimmy <span class="number">35.36</span></span><br><span class="line">Al <span class="number">653.7</span></span><br><span class="line">Stan <span class="number">4358.24</span></span><br></pre></td></tr></table></figure>

<p>setiosflags 操纵符</p>
<p> 这个程序中，通过使用带参数的setiosflags操纵符来设置左对齐，setiosflags定</p>
<p>义在头文件iomanip中。</p>
<p> 参数ios_base::left是ios_base的静态常量，因此引用时必须包括ios_base::前缀。</p>
<p> 这里需要用resetiosflags操纵符关闭左对齐标志。setiosflags不同于width和setw，</p>
<p>它的影响是持久的，直到用resetiosflags重新恢复默认值时为止 。</p>
<p> setiosflags的参数是该流的格式标志值，可用按位或（|）运算符进行组合</p>
<p>setiosflags 的参数（流的格式标识）</p>
<p> ios_base::skipws 在输入中跳过空白 。</p>
<p> ios_base::left 左对齐值，用填充字符填充右边。</p>
<p> ios_base::right 右对齐值，用填充字符填充左边（默认对齐方式）。</p>
<p> ios_base::internal 在规定的宽度内，指定前缀符号之后，数值之前，插入指定的</p>
<p>填充字符。</p>
<p> ios_base::dec 以十进制形式格式化数值（默认进制）。</p>
<p> ios_base::oct 以八进制形式格式化数值 。</p>
<p> ios_base::hex 以十六进制形式格式化数值。</p>
<p> ios_base::showbase 插入前缀符号以表明整数的数制。</p>
<p> ios_base::showpoint 对浮点数值显示小数点和尾部的0 。</p>
<p> ios_base::uppercase 对于十六进制数值显示大写字母A到F，对于科学格式显示大</p>
<p>写字母E 。</p>
<p> ios_base::showpos 对于非负数显示正号（“+”）。</p>
<p> ios_base::scientific 以科学格式显示浮点数值。</p>
<p> ios_base::fixed 以定点格式显示浮点数值（没有指数部分） 。</p>
<p> ios_base::unitbuf 在每次插入之后转储并清除缓冲区内容。精度</p>
<p> 浮点数输出精度的默认值是6，例如：3466.98。</p>
<p> 要改变精度：setprecision操纵符（定义在头文件iomanip中）。</p>
<p> 如果不指定fixed或scientific，精度值表示有效数字位数。</p>
<p> 如果设置了ios_base::fixed或ios_base::scientific精度值表示小数点之后的位数。</p>
<p>例 11-4 控制输出精度——未指定 fixed 或 scientific</p>
<p>&#x2F;&#x2F;11_4_1.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Zoot <span class="number">1</span></span><br><span class="line">Jimmy <span class="number">4e+001</span></span><br><span class="line">Al <span class="number">7e+002</span></span><br><span class="line">Stan <span class="number">4e+003</span></span><br></pre></td></tr></table></figure>

<p>例 11-4 控制输出精度——指定 fixed</p>
<p>&#x2F;&#x2F;11_4_2.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::fixed);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Zoot <span class="number">1.2</span></span><br><span class="line">Jimmy <span class="number">35.4</span></span><br><span class="line">Al <span class="number">653.7</span></span><br><span class="line">Stan <span class="number">4358.2</span></span><br></pre></td></tr></table></figure>

<p>例 11-4 控制输出精度——指定 scientific</p>
<p>&#x2F;&#x2F;11_4_3.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::scientific);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Zoot <span class="number">1.2e+000</span>Jimmy <span class="number">3.5e+001</span></span><br><span class="line">Al <span class="number">6.5e+002</span></span><br><span class="line">Stan <span class="number">4.4e+003</span></span><br></pre></td></tr></table></figure>

<p>向二进制文件输出</p>
<p>二进制文件流</p>
<p> 使用ofstream构造函数中的模式参量指定二进制输出模式；</p>
<p> 以通常方式构造一个流，然后使用setmode成员函数，在文件打开后改变模式；</p>
<p> 通过二进制文件输出流对象完成输出。</p>
<p>例 11-5 向二进制文件输出</p>
<p>&#x2F;&#x2F;11_5.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span> &#123; </span><br><span class="line"><span class="type">int</span> mon, day, year; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Date dt = &#123; <span class="number">6</span>, <span class="number">10</span>, <span class="number">92</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;date.dat&quot;</span>, ios_base::binary)</span></span>;</span><br><span class="line">file.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;dt),<span class="built_in">sizeof</span>(dt));</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向字符串输出</p>
<p>将字符串作为输出流的目标，可以实现将其他数据类型转换为字符串的功能</p>
<p>字符串输出流（ ostringstream ）</p>
<p> 用于构造字符串</p>
<p> 功能</p>
<p> </p>
<p>支持ofstream类的除open、close外的所有操作</p>
<p> </p>
<p>str函数可以返回当前已构造的字符串 典型应用</p>
<p> </p>
<p>将数值转换为字符串</p>
<p>例 11-6 用 ostringstream 将数值转换为字符串</p>
<p>&#x2F;&#x2F;11_6.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">toString</span><span class="params">(<span class="type">const</span> T &amp;v)</span> </span>&#123;</span><br><span class="line">ostringstream os; <span class="comment">//创建字符串输出流</span></span><br><span class="line">os &lt;&lt; v; </span><br><span class="line"><span class="comment">//将变量v的值写入字符串流</span></span><br><span class="line"><span class="keyword">return</span> os.<span class="built_in">str</span>(); </span><br><span class="line"><span class="comment">//返回输出流生成的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str1 = <span class="built_in">toString</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2 = <span class="built_in">toString</span>(<span class="number">1.2</span>);</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure>

<p>输入流概述</p>
<p>重要的输入流类</p>
<p> istream类最适合用于顺序文本模式输入。cin是其实例<strong>。</strong></p>
<p> ifstream类支持磁盘文件输入。</p>
<p> istringstream</p>
<p>函数模板 toString 可以将各种支持</p>
<p>“&lt;&lt;“插入符的类型的对象转换为字符串。构造输入流对象</p>
<p> 如果在构造函数中指定一个文件名，在构造该对象时该文件便自动打开。</p>
<p><strong>ifstream myFile(“filename”);</strong></p>
<p> 在调用默认构造函数之后使用open函数来打开文件。</p>
<p>ifstream myFile; &#x2F;&#x2F;建立一个文件流对象</p>
<p><strong>myFile.open(“filename”); &#x2F;&#x2F;<strong><strong>打开文件</strong></strong>“filename****”</strong></p>
<p> 打开文件时可以指定模式</p>
<p><strong>ifstream myFile(“filename”, ios_base::in | ios_base::binary);</strong></p>
<p>使用提取运算符从文本文件输入</p>
<p> 提取运算符(&gt;&gt;)对于所有标准C++数据类型都是预先设计好的。</p>
<p> 是从一个输入流对象获取字节最容易的方法。</p>
<p> ios类中的很多操纵符都可以应用于输入流。但是只有少数几个对输入流对象具有</p>
<p>实际影响，其中最重要的是进制操纵符dec、oct和hex。</p>
<p>输入流相关函数</p>
<p> open 把该流与一个特定磁盘文件相关联。</p>
<p> get 功能与提取运算符（&gt;&gt;）很相像，主要的不同点是get函数在读入数据时包</p>
<p>括空白字符。</p>
<p> getline 功能是从输入流中读取多个字符，并且允许指定输入终止字符，读取完成</p>
<p>后，从读取的内容中删除终止字符。</p>
<p> read 从一个文件读字节到一个指定的内存区域，由长度参数确定要读的字节数。</p>
<p>当遇到文件结束或者在文本模式文件中遇到文件结束标记字符时结束读取。</p>
<p> seekg 用来设置文件输入流中读取数据位置的指针。</p>
<p> tellg 返回当前文件读指针的位置。</p>
<p> close 关闭与一个文件输入流关联的磁盘文件。</p>
<p>输入流应用举例</p>
<p>例 11-7 <strong>get</strong> 函数应用举例</p>
<p>&#x2F;&#x2F;11_7.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> ch;<span class="keyword">while</span> ((ch = cin.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">cout.<span class="built_in">put</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例 11-8 为输入流指定一个终止字符：</p>
<p>&#x2F;&#x2F;11_8.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> string line;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Type a line terminated by &#x27;t&#x27; &quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="built_in">getline</span>(cin, line, <span class="string">&#x27;t&#x27;</span>);</span><br><span class="line"> cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例 11-9 从文件读一个二进制记录到一个结构中</p>
<p>&#x2F;&#x2F;11_9.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SalaryInfo</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> id;</span><br><span class="line"><span class="type">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SalaryInfo employee1 = &#123; <span class="number">600001</span>, <span class="number">8000</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">os</span><span class="params">(<span class="string">&quot;payroll&quot;</span>, ios_base::out | ios_base::binary)</span></span>;</span><br><span class="line">os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;employee1), <span class="built_in">sizeof</span>(employee1));</span><br><span class="line">os.<span class="built_in">close</span>();<span class="function">ifstream <span class="title">is</span><span class="params">(<span class="string">&quot;payroll&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (is) &#123;</span><br><span class="line">SalaryInfo employee2;</span><br><span class="line">is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;employee2), <span class="built_in">sizeof</span>(employee2));</span><br><span class="line">cout &lt;&lt; employee2.id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; employee2.salary &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;payroll&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">is.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例 11-10 用 <strong>seekg</strong> 函数设置位置指针</p>
<p>&#x2F;&#x2F;11_10.cpp, 头部分省略</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> values[] = &#123; <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">os</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::out | ios_base::binary)</span></span>;</span><br><span class="line">os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(values), <span class="built_in">sizeof</span>(values));</span><br><span class="line">os.<span class="built_in">close</span>();</span><br><span class="line"><span class="function">ifstream <span class="title">is</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (is) &#123;</span><br><span class="line">is.<span class="built_in">seekg</span>(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;v), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The 4th integer in the file &#x27;integers&#x27; is &quot;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;integers&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例 11-11 读一个文件并显示出其中 0 元素的位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_11.cpp, 头部分省略int main() &#123;</span></span><br><span class="line"><span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line"><span class="keyword">while</span> (file) &#123;<span class="comment">//读到文件尾file为0</span></span><br><span class="line"> streampos here = file.<span class="built_in">tellg</span>();</span><br><span class="line"> <span class="type">int</span> v;</span><br><span class="line"> file.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;v), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">if</span> (file &amp;&amp; v == <span class="number">0</span>) </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Position &quot;</span> &lt;&lt; here &lt;&lt; <span class="string">&quot; is 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;integers&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从字符串输入</p>
<p>将字符串作为文本输入流的源，可以将字符串转换为其他数据类型</p>
<p>字符串输入流（ istringstream）</p>
<p> 用于从字符串读取数据</p>
<p> 在构造函数中设置要读取的字符串</p>
<p> 功能</p>
<p> </p>
<p>支持ifstream类的除open、close外的所有操作</p>
<p> 典型应用</p>
<p> </p>
<p>将字符串转换为数值</p>
<p>例 11-12 用 istringstream 将字符串转换为数值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_12.cpp, 头部分省略</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">fromString</span><span class="params">(<span class="type">const</span> string &amp;str)</span> </span>&#123;</span><br><span class="line"><span class="function">istringstream <span class="title">is</span><span class="params">(str)</span></span>; <span class="comment">//创建字符串输入流</span></span><br><span class="line">T v;is &gt;&gt; v;<span class="comment">//从字符串输入流中读取变量v</span></span><br><span class="line"><span class="keyword">return</span> v; </span><br><span class="line"><span class="comment">//返回变量v</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> v1 = <span class="built_in">fromString</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">cout &lt;&lt; v1 &lt;&lt; endl;</span><br><span class="line"><span class="type">double</span> v2 = <span class="built_in">fromString</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;1.2&quot;</span>);</span><br><span class="line">cout &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure>

<p>输入&#x2F;输出流</p>
<p>两个重要的输入&#x2F;输出流</p>
<p> 一个iostream对象可以是数据的源或目的。</p>
<p> 两个重要的I&#x2F;O流类都是从iostream派生的，它们是fstream和stringstream。这</p>
<p>些类继承了前面描述的istream和ostream类的功能。</p>
<p>fstream 类</p>
<p> fstream类支持磁盘文件输入和输出。</p>
<p> 如果需要在同一个程序中从一个特定磁盘文件读并写到该磁盘文件，可以构造一个</p>
<p>fstream对象。</p>
<p> 一个fstream对象是有两个逻辑子流的单个流，两个子流一个用于输入，另一个用</p>
<p>于输出。</p>
<p>stringstream 类</p>
<p> stringstream类支持面向字符串的输入和输出</p>
<p> 可以用于对同一个字符串的内容交替读写，同样是由两个逻辑子流构成。</p>
<p>小结 主要内容</p>
<p> </p>
<p>I&#x2F;O流的概念、流类库结构、输出流、输入流、输入&#x2F;输出流、读写文本文件</p>
<p>的格式控制。</p>
<p> 达到的目标</p>
<p>能够将数据持久化。</p>
<p>能够处理文本文件和二进制文件。</p>
<p>能够利用字符串流进行字符串与其他类型之间的转换</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOC（12）:异常处理</title>
    <url>/2024/08/15/SPOC-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="第-12-章-异常处理"><a href="#第-12-章-异常处理" class="headerlink" title="第 12 章 异常处理"></a>第 12 章 异常处理</h2><h3 id="本章主要内容"><a href="#本章主要内容" class="headerlink" title="本章主要内容"></a>本章主要内容</h3><ul>
<li><p>异常处理的基本思想与程序实现 </p>
</li>
<li><p>异常处理中的构造与析构 </p>
</li>
<li><p>标准程序库异常处理 </p>
</li>
<li><p>小结</p>
</li>
</ul>
<h3 id="异常处理的思想与程序实现"><a href="#异常处理的思想与程序实现" class="headerlink" title="异常处理的思想与程序实现"></a>异常处理的思想与程序实现</h3><h4 id="异常处理的基本思想"><a href="#异常处理的基本思想" class="headerlink" title="异常处理的基本思想"></a>异常处理的基本思想</h4><p><img src="https://i.postimg.cc/wvpSVg4J/QQ20240815-092055.png"></p>
<h4 id="异常处理的语法"><a href="#异常处理的语法" class="headerlink" title="异常处理的语法"></a>异常处理的语法</h4><p><img src="https://i.postimg.cc/BbZkrN0n/QQ20240815-092109.png"></p>
<h4 id="例12-1处理除零异常"><a href="#例12-1处理除零异常" class="headerlink" title="例12-1处理除零异常"></a>例12-1处理除零异常</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//12_1.cpp #include &lt;iostream&gt; </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">if</span> (y == <span class="number">0</span>) </span><br><span class="line"> <span class="keyword">throw</span> x; </span><br><span class="line"> <span class="keyword">return</span> x / y; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;5 / 2 = &quot;</span> &lt;&lt; <span class="built_in">divide</span>(<span class="number">5</span>, <span class="number">2</span>) &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;8 / 0 = &quot;</span> &lt;&lt; <span class="built_in">divide</span>(<span class="number">8</span>, <span class="number">0</span>) &lt;&lt; endl; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;7 / 1 = &quot;</span> &lt;&lt; <span class="built_in">divide</span>(<span class="number">7</span>, <span class="number">1</span>) &lt;&lt; endl; </span><br><span class="line"> &#125; <span class="built_in">catch</span> (<span class="type">int</span> e) &#123; </span><br><span class="line"> cout &lt;&lt; e &lt;&lt; <span class="string">&quot; is divided by zero!&quot;</span> &lt;&lt; endl; </span><br><span class="line"> &#125; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;That is ok.&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="异常接口声明"><a href="#异常接口声明" class="headerlink" title="异常接口声明"></a>异常接口声明</h4><ul>
<li><p>一个函数显式声明可能抛出的异常，有利于函数的调用者为异常处理做好准备 </p>
</li>
<li><p>可以在函数的声明中列出这个函数可能抛掷的所有异常类型。</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(A，B，C，D)</span></span>; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>若无异常接口声明，则此函数可以抛掷任何类型的异常。 </p>
</li>
<li><p>不抛掷任何类型异常的函数声明如下：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; </span><br></pre></td></tr></table></figure>

<h4 id="异常处理中的构造与析构"><a href="#异常处理中的构造与析构" class="headerlink" title="异常处理中的构造与析构"></a>异常处理中的构造与析构</h4><p>自动的析构,找到一个匹配的catch异常处理后初始化异常参数。 将从对应的try块开始到异常被抛掷处之间构造（且尚未析构）的所有自动对象进行析构。 从最后一个catch处理之后开始恢复执行。 </p>
<h4 id="例-12-2-带析构语义的类的-C-异常处理"><a href="#例-12-2-带析构语义的类的-C-异常处理" class="headerlink" title="例 12-2 带析构语义的类的 C++异常处理"></a>例 12-2 带析构语义的类的 C++异常处理</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//12_2.cpp </span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">MyException</span>(<span class="type">const</span> string &amp;message) : <span class="built_in">message</span>(message) &#123;&#125; </span><br><span class="line"> ~<span class="built_in">MyException</span>() &#123;&#125; </span><br><span class="line"> <span class="function"><span class="type">const</span> string &amp;<span class="title">getMessage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> message; &#125; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"> string message; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"> <span class="built_in">Demo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Constructor of Demo&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line"> ~<span class="built_in">Demo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Destructor of Demo&quot;</span> &lt;&lt; endl; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span> <span class="params">(MyException)</span> </span>&#123; </span><br><span class="line"> Demo d; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Throw MyException in func()&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;exception thrown by func()&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;In main function&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="built_in">func</span>(); </span><br><span class="line"> &#125; <span class="built_in">catch</span> (MyException&amp; e) &#123; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Caught an exception: &quot;</span> &lt;&lt; e.<span class="built_in">getMessage</span>() &lt;&lt; endl; </span><br><span class="line"> &#125; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Resume the execution of main()&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure>

<h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">In main function </span></span><br><span class="line"><span class="function">Constructor of Demo </span></span><br><span class="line"><span class="function">Throw MyException in <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Destructor of Demo </span></span><br><span class="line"><span class="function">Caught an exception: exception thrown by func() </span></span><br><span class="line"><span class="function">Resume the execution of main() </span></span><br></pre></td></tr></table></figure>

<h3 id="标准程序库异常处理"><a href="#标准程序库异常处理" class="headerlink" title="标准程序库异常处理"></a>标准程序库异常处理</h3><h4 id="标准异常类的继承关系"><a href="#标准异常类的继承关系" class="headerlink" title="标准异常类的继承关系"></a>标准异常类的继承关系</h4><p><img src="https://i.postimg.cc/KzDCpwCW/QQ20240815-092119.png"></p>
<h4 id="C-标准库各种异常类所代表的异常"><a href="#C-标准库各种异常类所代表的异常" class="headerlink" title="C++标准库各种异常类所代表的异常"></a>C++标准库各种异常类所代表的异常</h4><p><img src="https://i.postimg.cc/gjMQmRzq/QQ20240815-092129.png"> </p>
<h4 id="标准异常类的基础"><a href="#标准异常类的基础" class="headerlink" title="标准异常类的基础"></a>标准异常类的基础</h4><ul>
<li><p>exception：标准程序库异常类的公共基类 </p>
</li>
<li><p>logic_error表示可以在程序中被预先检测到的异常 </p>
</li>
<li><p>如果小心地编写程序，这类异常能够避免 </p>
</li>
<li><p>runtime_error表示难以被预先检测的异常</p>
</li>
</ul>
<h3 id="例-12-3-三角形面积计算"><a href="#例-12-3-三角形面积计算" class="headerlink" title="例 12-3 三角形面积计算"></a>例 12-3 三角形面积计算</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//12_3.cpp </span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> </span></span><br><span class="line"></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="comment">//给出三角形三边长，计算三角形面积 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">double</span> c)</span> <span class="title">throw</span> <span class="params">(invalid_argument)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//判断三角形边长是否为正 </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (a &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || c &lt;= <span class="number">0</span>) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;the side length should be positive&quot;</span>); </span><br><span class="line"></span><br><span class="line"> <span class="comment">//判断三边长是否满足三角不等式 </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (a + b &lt;= c || b + c &lt;= a || c + a &lt;= b) </span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;the side length should fit the triangle </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inequation&quot;</span>); </span><br><span class="line"></span><br><span class="line"> <span class="comment">//由Heron公式计算三角形面积 </span></span><br><span class="line"></span><br><span class="line"> <span class="type">double</span> s = (a + b + c) / <span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">sqrt</span>(s * (s - a) * (s - b) * (s - c)); </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"> <span class="type">double</span> a, b, c; <span class="comment">//三角形三边长 </span></span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Please input the side lengths of a triangle: &quot;</span>; </span><br><span class="line"></span><br><span class="line"> cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123; </span><br><span class="line"></span><br><span class="line"> <span class="type">double</span> s = <span class="built_in">area</span>(a, b, c); <span class="comment">//尝试计算三角形面积 </span></span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; s &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"> &#125; <span class="built_in">catch</span> (exception &amp;e) &#123; </span><br><span class="line"></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>• 运行结果1： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Please input the side lengths of a triangle: <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line">Area: <span class="number">6</span> </span><br></pre></td></tr></table></figure>

<p>• 运行结果2： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Please input the side lengths of a triangle: <span class="number">0</span> <span class="number">5</span> <span class="number">5</span> </span><br><span class="line">Error: the side length should be positive </span><br></pre></td></tr></table></figure>

<p>• 运行结果2： </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Please input the side lengths of a triangle: <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> </span><br><span class="line">Error: the side length should fit the triangle inequation 小结 </span><br></pre></td></tr></table></figure>

<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li><p>异常处理的基本思想</p>
</li>
<li><p>C++异常处理的实现</p>
</li>
<li><p>异常处理中的构造与析构</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOC(4):类与对象</title>
    <url>/2022/10/31/SPOC%EF%BC%884%EF%BC%89%EF%BC%9A%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="面向对象程序设计的特点-Features-of-object-oriented-programming"><a href="#面向对象程序设计的特点-Features-of-object-oriented-programming" class="headerlink" title="面向对象程序设计的特点(Features of object-oriented programming)"></a>面向对象程序设计的特点(Features of object-oriented programming)</h2><h3 id="抽象-Abstract-："><a href="#抽象-Abstract-：" class="headerlink" title="抽象(Abstract:)："></a>抽象(Abstract:)：</h3><p>对同一类对象的共同属性和行为进行概括形成类。<br>首先注意问题的本质以及描述，第三次是实现过程和细节。</p>
<blockquote>
<p>Summarize the common properties and behaviors of objects of the same class to form classes.</p>
<p>First, pay attention to the essence of the problem and the description, and the third is the implementation process and details.</p>
</blockquote>
<h4 id="数据抽象-Data-Abstraction-："><a href="#数据抽象-Data-Abstraction-：" class="headerlink" title="数据抽象(Data Abstraction:)："></a>数据抽象(Data Abstraction:)：</h4><p>描述某类对象的属性或状态（对象相互区别的物理量）</p>
<p>Describe the properties or states of a certain class of objects (physical quantities that distinguish objects from each other)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> hour，<span class="type">int</span> minute，<span class="type">int</span> second;</span><br></pre></td></tr></table></figure>



<h4 id="代码抽象-Code-Abstraction-："><a href="#代码抽象-Code-Abstraction-：" class="headerlink" title="代码抽象(Code Abstraction:)："></a>代码抽象(Code Abstraction:)：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">setTime（），showTime（）</span><br></pre></td></tr></table></figure>



<h3 id="抽象的实现；类（abstract-implementation-class-）。"><a href="#抽象的实现；类（abstract-implementation-class-）。" class="headerlink" title="抽象的实现；类（abstract implementation;class.）。"></a>抽象的实现；类（abstract implementation;class.）。</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTime</span><span class="params">(<span class="type">int</span> newH,<span class="type">int</span> newH,<span class="type">int</span> newS)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> hour,minute,second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="边界（border）："><a href="#边界（border）：" class="headerlink" title="边界（border）："></a>边界（border）：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span>｛｝;</span><br></pre></td></tr></table></figure>

<h4 id="外部接口（External-interfaces）"><a href="#外部接口（External-interfaces）" class="headerlink" title="外部接口（External interfaces） :"></a>外部接口（External interfaces） :</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="继承（inherit）："><a href="#继承（inherit）：" class="headerlink" title="继承（inherit）："></a>继承（inherit）：</h2><p>在已有类的基础上，进行扩展形成新的类。</p>
<blockquote>
<p>On the basis of the existing class, it is expanded to form a new class.</p>
</blockquote>
<h4 id="多态-Polymorphism-："><a href="#多态-Polymorphism-：" class="headerlink" title="多态(Polymorphism)："></a>多态(Polymorphism)：</h4><ul>
<li>多态：同一名称，不同的功能实现方式。</li>
<li>目的：达到行为表示统一，减少程序中标识符的个数。</li>
</ul>
<blockquote>
<ul>
<li><p>Polymorphism: Same name, different ways to implement functions.</p>
</li>
<li><p>Purpose: To achieve unity of behavior representation and reduce the number of identifiers in the program.</p>
</li>
</ul>
</blockquote>
<h2 id="类和对象的定义-Definitions-of-classes-and-objects"><a href="#类和对象的定义-Definitions-of-classes-and-objects" class="headerlink" title="类和对象的定义(Definitions of classes and objects)"></a>类和对象的定义(Definitions of classes and objects)</h2><p>类是对同一类对象的抽象和概括，定义类的对象，才可以通过对象使用类中定义的功能。</p>
<blockquote>
<p>A class is an abstraction and generalization of objects of the same class, and the objects that define the class can use the functions defined in the class through the objects</p>
</blockquote>
<h3 id="类和对象的定义事例-Examples-of-definition-of-classes-and-objects"><a href="#类和对象的定义事例-Examples-of-definition-of-classes-and-objects" class="headerlink" title="类和对象的定义事例(Examples of definition of classes and objects)"></a>类和对象的定义事例(Examples of definition of classes and objects)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTime</span><span class="params">(<span class="type">int</span> newH=<span class="number">0</span>,<span class="type">int</span> newH=<span class="number">0</span>,<span class="type">int</span> newM=<span class="number">0</span>,<span class="type">int</span> newS=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> hour,minute,second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="成员函数的实现-Implementation-of-member-functions"><a href="#成员函数的实现-Implementation-of-member-functions" class="headerlink" title="成员函数的实现(Implementation of member functions):"></a>成员函数的实现(Implementation of member functions):</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clock::setTime</span><span class="params">(<span class="type">int</span> newH,<span class="type">int</span> newM,<span class="type">int</span> newS)</span></span>&#123;</span><br><span class="line">hour=newH;</span><br><span class="line">minute=newM;</span><br><span class="line">second=newS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clock::showTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;hour&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;minute&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的使用-Use-of-objects-："><a href="#对象的使用-Use-of-objects-：" class="headerlink" title="对象的使用(Use of objects)："></a>对象的使用(Use of objects)：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> mian（）</span><br><span class="line">｛Clock myClock;</span><br><span class="line">myClock.<span class="built_in">setTime</span>(<span class="number">8</span>,<span class="number">30</span>,<span class="number">30</span>);</span><br><span class="line">myClock.<span class="built_in">showTime</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<h3 id="构造函数-Constructor-："><a href="#构造函数-Constructor-：" class="headerlink" title="构造函数(Constructor)："></a>构造函数(Constructor)：</h3><p>类中的特殊函数，用于描述初始化算法<br>构造函数的作用：在对象被创建时使用特定的值构造对象，讲对象初始化为一个特定的初始状态。<br>例如：希望构造一个Clock类对象时，讲初试时间设置为0：0：0，就可以用过构造函数来设置。<br>构造函数的形式：<br>函数名与类名相同，不能定义返回值类型，也不能有return语句，<br>可以有形式参数，也可以没有形式参数<br>可以是内联函数<br>可以重载<br>可以带默认参数值<br>构造函数什么时候调用，在定义新对象的时候开始定义。</p>
<blockquote>
<p>A special function in a class that describes the initialization algorithm</p>
<p>What the constructor does: When the object is created, it constructs the object with a specific value, and the object is initialized to a specific initial state.</p>
<p>For example, if you want to construct a Clock object, if you want to set the initial test time to 0:0:0, you can use the constructor to set it.</p>
<p>The form of the constructor:</p>
<p>The function name is the same as the class name, and the return value type cannot be defined, nor can there be a return statement.</p>
<p>It can be with or without formal parameters</p>
<p>Can be an inline function</p>
<p>Can be overloaded</p>
<p>It can be with default parameter values</p>
<p>When the constructor is called, it is defined when a new object is defined.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Clock myClock（<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>）；</span><br></pre></td></tr></table></figure>

<p>构造函数的时候，可以有参数表，也可以空着，也可以赋予初值。</p>
<blockquote>
<p>When constructors, there can be a table of arguments, or it can be empty, or it can be given an initial value.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Clock（）;</span><br><span class="line">Clock（<span class="type">int</span> a=<span class="number">0</span>，<span class="type">int</span> b=<span class="number">0</span>，<span class="type">int</span> c=<span class="number">0</span>）；</span><br></pre></td></tr></table></figure>

<p>隐含生成的构造函数<br>如果程序中未定义构造函数，编译器将自动生成一个默认构造函数<br>参数列表为空，部位数据成员设置初始值<br>如果类内定义了成员的初始值，则使用内类定义的初始值，<br>如果没有定义类内的初始值，则以默认方式初始化<br>基本类型的数据默认初始化的值是不确定的。<br>“&#x3D;default”<br>如果程序中已定义构造函数，默认情况下，编译器就不再隐含生成默认构造函数。如果此时依然希望编译器隐含生成默认构造函数，可以使用“&#x3D;default”。</p>
<blockquote>
<p>Implicitly generated constructors</p>
<p>If a constructor is not defined in the program, the compiler will automatically generate a default constructor</p>
<p>The parameter list is empty, and the initial value is set for the part data member</p>
<p>If the initial value of a member is defined within the class, the initial value defined by the inner class is used,</p>
<p>If no initial value within the class is defined, it is initialized in the default way</p>
<p>The default initialization value of the base type of data is non-deterministic.</p>
<p>“&#x3D;default”</p>
<p>If a constructor is defined in the program, the compiler no longer implicitly generates the default constructor by default. If you still want the compiler to implicitly generate the default constructor, you can use “&#x3D;default”.</p>
</blockquote>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Clock</span>()=defalut;<span class="comment">//指示编译器提供默认构造函数</span></span><br><span class="line"><span class="built_in">Clock</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> hour,minute,second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="构造函数例题1-Constructor-Example-1-："><a href="#构造函数例题1-Constructor-Example-1-：" class="headerlink" title="构造函数例题1(Constructor Example 1:)："></a>构造函数例题1(Constructor Example 1:)：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Clock</span>(<span class="type">int</span> newH,<span class="type">int</span> newM,<span class="type">int</span> newS);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTime</span><span class="params">(<span class="type">int</span> newH,<span class="type">int</span> newM,<span class="type">int</span> newS)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> hour,minute,second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="构造函数的实现-Implementation-of-the-constructor"><a href="#构造函数的实现-Implementation-of-the-constructor" class="headerlink" title="构造函数的实现(Implementation of the constructor)"></a>构造函数的实现(Implementation of the constructor)</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Clock::<span class="built_in">Clock</span>(<span class="type">int</span> newH,<span class="type">int</span> newM,<span class="type">int</span> newS):<span class="comment">//初始化列表</span></span><br><span class="line"><span class="built_in">hour</span>(newH),<span class="built_in">minute</span>(newM),<span class="built_in">second</span>(newS)&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Clock <span class="title">c</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">c.<span class="built_in">showTime</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造函数例题2-Constructor-Example-2-："><a href="#构造函数例题2-Constructor-Example-2-：" class="headerlink" title="构造函数例题2(Constructor Example 2)："></a>构造函数例题2(Constructor Example 2)：</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Clock</span>(<span class="type">int</span> newH,<span class="type">int</span> newM,<span class="type">int</span> newS);</span><br><span class="line"><span class="built_in">Clock</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTime</span><span class="params">(<span class="type">int</span> newH,<span class="type">int</span> newM,<span class="type">int</span> newS)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> hour,minute,second;</span><br><span class="line">&#125;;</span><br><span class="line">Clock::<span class="built_in">Clock</span>():<span class="built_in">hour</span>(<span class="number">0</span>),<span class="built_in">minute</span>(<span class="number">0</span>),<span class="built_in">second</span>(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Clock <span class="title">c1</span><span class="params">(<span class="number">8</span>,<span class="number">10</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">Clock c2；</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<h5 id="委托构造函数-Delegate-constructor"><a href="#委托构造函数-Delegate-constructor" class="headerlink" title="委托构造函数(Delegate constructor)"></a>委托构造函数(Delegate constructor)</h5><p>在一个类中重载多个构造函数，只是形参不一样。<br>多个函数重载，显得重复。<br>委托构造函数：一个构造函数可以委托另一个函数帮它完成工作。</p>
<blockquote>
<p>Overload multiple constructors in a class, but with different parameters.</p>
<p>Multiple functions are overloaded and appear repetitive.</p>
<p>Delegate constructors: A constructor can delegate another function to do its job for it.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Clock</span>(<span class="type">int</span> newH,<span class="type">int</span> newM,<span class="type">int</span> newS):<span class="built_in">hour</span>(newH),<span class="built_in">minute</span>(newM),<span class="built_in">second</span>(newS)&#123;<span class="comment">//构造函数&#125;</span></span><br><span class="line">Clock::<span class="built_in">Clock</span>():<span class="built_in">hour</span>(<span class="number">0</span>),<span class="built_in">minute</span>(<span class="number">0</span>),<span class="built_in">second</span>(<span class="number">0</span>)&#123;&#125;<span class="comment">//默认构造函数</span></span><br><span class="line">Clock::<span class="built_in">Clock</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="复制构造函数-Copy-constructor"><a href="#复制构造函数-Copy-constructor" class="headerlink" title="复制构造函数(Copy constructor)"></a>复制构造函数(Copy constructor)</h5><p>定义一个基本变量的时候，用一个已经存在的对象，初始化新对象。<br>实现两个对象的成员对象的一一对应复制<br>复制构造函数是一类特殊的构造函数，其形参为本类的对象引用，作用是用一个已经存在的对象去初始化同类型的新对象，</p>
<blockquote>
<p>When defining a basic variable, initialize the new object with an existing object.</p>
<p>Implement one-to-one correspondence replication of member objects of two objects</p>
<p>The copy constructor is a special class of constructors, whose form parameters are object references of this class, and the function is to initialize a new object of the same type with an existing object.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">类名（形参）;<span class="comment">//构造函数</span></span><br><span class="line">类名(<span class="type">const</span> 类名&amp;对象名);<span class="comment">//复制构造函数的实现</span></span><br><span class="line">&#123;函数体&#125;</span><br><span class="line"><span class="keyword">class</span> 类名 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">类名（形参）;<span class="comment">//构造函数</span></span><br><span class="line">类名(<span class="type">const</span> 类名&amp;对象名);<span class="comment">//复制构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类名::类(<span class="type">const</span> 类名&amp;对象名)</span><br><span class="line">&#123;函数体&#125;;</span><br></pre></td></tr></table></figure>

<p>调用情况：<br>定义一个对象时，以本类另一个对象作为初始值，发生复制构造；<br>如果函数的形参是类的对象，调用函数时，将使用实参对象初始化形参对象，发生复制构造；<br>如果函数的返回值是类的对象，函数执行完成返回主调函数时，将使用return语句中的对象初始化一个临时无名的对象，传递给主调函数，此时发生复制构造。<br>这种情况也可以通过移动构造来避免不必要的构造。<br>隐含的复制构造函数<br>如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个隐含的复制构造函数。<br>这个构造函数执行的功能是：用初始值对象的每一个数据成员，初始化将要建立的对象的对应数据成员。<br>“&#x3D;delete”<br>如果不希望对象被复制构造<br>C++98做法：将复制构造函数声明为private，并且不提供函数的实现<br>c++11的做法：用“&#x3D;delete”指示编译器不生成默认复制构造函数。</p>
<blockquote>
<p>Invocation case:</p>
<p>When an object is defined, another object of the class is used as the initial value, and the replication construction occurs.</p>
<p>If the parameter of the function is an object of the class, when the function is called, the parameter object will be initialized with the parameter object, and the replication construction will occur.</p>
<p>If the return value of the function is an object of the class, when the function is executed and returns the major function, a temporary nameless object will be initialized with the object in the return statement and passed to the major function.</p>
<p>In this case, unnecessary constructs can also be avoided by moving constructs.</p>
<p>Implicit copy constructor</p>
<p>If the programmer does not declare a copy initialization constructor for the class, the compiler generates an implicit copy constructor itself.</p>
<p>This constructor performs the function of initializing the corresponding data member of the object to be created with each data member of the initial value object.</p>
<p>“&#x3D;delete”</p>
<p>If you don’t want the object to be copied to the construct</p>
<p>C++98 method: declare the copy constructor as private and do not provide an implementation of the function</p>
<p>C++11 approach: Use “&#x3D;delete” to indicate that the compiler does not generate the default copy constructor.</p>
</blockquote>
<p>例题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> xx=<span class="number">0</span>,<span class="type">int</span> yy=<span class="number">0</span>)&#123;x=xx.y=yy&#125;</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">const</span> Point&amp;p)=<span class="keyword">delete</span>;<span class="comment">//指示编译器不生成默认复制构造函数</span></span><br><span class="line"><span class="keyword">private</span>：</span><br><span class="line"><span class="type">int</span> x，y;</span><br><span class="line">｝;</span><br></pre></td></tr></table></figure>

<h6 id="复制构造函数的例题-Example-problem-for-copying-a-constructor"><a href="#复制构造函数的例题-Example-problem-for-copying-a-constructor" class="headerlink" title="复制构造函数的例题(Example problem for copying a constructor)"></a>复制构造函数的例题(Example problem for copying a constructor)</h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;p.<span class="built_in">getX</span>()&lt;&lt;endl;</span><br><span class="line"><span class="comment">//p.getX(1);</span></span><br><span class="line"><span class="function">Point <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">Point a;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">｝；</span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> Point&amp;p)&#123;</span><br><span class="line">x=p.x;</span><br><span class="line">y=p.y;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Calling the copy constructor&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Point a;</span><br><span class="line"><span class="function">Point <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">cout&lt;&lt;b.<span class="built_in">getX</span>()&lt;&lt;endl;</span><br><span class="line"><span class="built_in">fun1</span>(b);</span><br><span class="line">b=<span class="built_in">fun2</span>();</span><br><span class="line">cout&lt;&lt;b.<span class="built_in">getX</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="析构函数-Destructor-："><a href="#析构函数-Destructor-：" class="headerlink" title="析构函数(Destructor:)："></a>析构函数(Destructor:)：</h5><p>程序占用内存，消亡的时候需要某种机制来善后。<br>这个机制是析构函数。<br>析构函数完成对象被删除前的一些清理工作。<br>析构函数可以被默认生成。<br>构造函数和析构函数在系统的操作中是必不可缺的函数。<br>～类名();<br>析构函数没有参数，没有返回类型。</p>
<blockquote>
<p>Programs take up memory, and when they die, they need some kind of mechanism to deal with the aftermath.</p>
<p>This mechanism is a destructor.</p>
<p>The destructor does some of the cleanup work before the object is deleted.</p>
<p>Destructors can be generated by default.</p>
<p>Constructors and destructors are indispensable functions in the operation of the system.</p>
<p>~Class Name ();</p>
<p>The destructor has no arguments and no return type.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> xx,<span class="type">int</span> yy);</span><br><span class="line">~<span class="built_in">Point</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">int</span> xx,<span class="type">int</span> yy)&#123;</span><br><span class="line">x=xx;</span><br><span class="line">y=yy;</span><br><span class="line">&#125;</span><br><span class="line">Point::~<span class="built_in">Point</span>()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类的组合-Combination-of-classes-："><a href="#类的组合-Combination-of-classes-：" class="headerlink" title="类的组合(Combination of classes)："></a>类的组合(Combination of classes)：</h3><p>制造业是组装的方式，程序中也可以借用这种部件组装的形式。<br>c++可以实现类的组合。<br>组合类的构造函数怎么声明？<br>类组合的构造函数设计：<br>原则：不仅要负责对本类中的基本类型成员数据初始化，也要对对象初始化。</p>
<blockquote>
<p>Manufacturing is the way of assembly, and the program can also borrow this form of component assembly.</p>
<p>C++ enables a combination of classes.</p>
<p>How do I declare the constructor of a composition class?</p>
<p>Constructor design for class composition:</p>
<p>Principle: Be responsible for initializing not only the primitive type member data in this class, but also the object.</p>
</blockquote>
<h4 id="声明形式-Declaration-form-："><a href="#声明形式-Declaration-form-：" class="headerlink" title="声明形式(Declaration form:)："></a>声明形式(Declaration form:)：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类名：：类名（成员对象所需的形参，本类成员形参）；</span><br><span class="line">｛对象<span class="number">1</span>（参数），对象<span class="number">2</span>（参数）｝</span><br><span class="line">｛</span><br><span class="line"><span class="comment">//函数体其他语句</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>构造组合类对象时的初始化次序<br>首先对构造函数初始化列表中列出的成员（包括基本类型成员和对象成员）进行初始化，初始化次序是成员在类体中定义的次序。<br>成员对象构造函数调用顺序：按对象成员的定义顺序，先声明者先构造。<br>初始化列表中未出现的成员对象，调用默认构造函数（即无形参的）初始化<br>处理完初始化列表之后，再执行构造函数的函数体。</p>
<blockquote>
<p>The initialization order in which combined class objects are constructed</p>
<p>First, the members listed in the constructor initialization list (including primitive type members and object members) are initialized, and the initialization order is the order in which the members are defined in the class body.</p>
<p>Member object constructor call order: The order in which the object members are defined is constructed first.</p>
<p>For member objects that do not appear in the initialization list, call the default constructor (i.e., the intangible parameters) to initialize</p>
<p>After the initialization list is processed, the constructor’s body is executed.</p>
</blockquote>
<h4 id="组合类的例子-Examples-of-combinatorial-classes"><a href="#组合类的例子-Examples-of-combinatorial-classes" class="headerlink" title="组合类的例子(Examples of combinatorial classes)"></a>组合类的例子(Examples of combinatorial classes)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="前向引用声明-Forward-Reference-Statement"><a href="#前向引用声明-Forward-Reference-Statement" class="headerlink" title="前向引用声明(Forward Reference Statement)"></a>前向引用声明(Forward Reference Statement)</h3><p>有的时候希望在一个类中，引用另一个类，出现两个类相互引用的情况。<br>谁在前面谁在后面。<br>类应该先声明，后引用。<br>如果需要在某个类的声明之前，引用该类，则需要进行前向引用声明。<br>前向引用声明只为程序引入一个标识符，但是具体声明在别的地方。</p>
<blockquote>
<p>Sometimes you want to reference another class in one class, and the two classes refer to each other.</p>
<p>Who’s in front and who’s behind.</p>
<p>Classes should be declared first, then referenced.</p>
<p>If you need to reference a class before it is declared, you need to make a forward reference declaration.</p>
<p>Forward reference declarations only introduce an identifier for the program, but the specific declaration is elsewhere.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="comment">//前向引用声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(B,b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(A a)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="前向引用声明的注意事项-Considerations-for-Forward-Referencing-Statements"><a href="#前向引用声明的注意事项-Considerations-for-Forward-Referencing-Statements" class="headerlink" title="前向引用声明的注意事项(Considerations for Forward Referencing Statements)"></a>前向引用声明的注意事项(Considerations for Forward Referencing Statements)</h4><p>在提供一个完整的类声明之前，不能声明该类的对象，也不能在内联成员函数中使用该类对象。<br>当使用前向引用声明时，只能使用被声明的符号，而不能涉及类的任何细节。</p>
<blockquote>
<p>Objects of the class cannot be declared until a complete class declaration has been provided, nor can it be used in an inline member function.</p>
<p>When using forward reference declarations, only the symbol being declared can be used, and no details of the class can be touched.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fred</span>;<span class="comment">//前向引用声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Barney</span></span><br><span class="line">&#123;</span><br><span class="line">Fred x;<span class="comment">//错误：类Fred的声明尚且不完善（不知道占据的字节数目）</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fred</span></span><br><span class="line">&#123;</span><br><span class="line">Barney y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="UML简介-brief-introduction"><a href="#UML简介-brief-introduction" class="headerlink" title="UML简介(brief introduction)"></a>UML简介(brief introduction)</h3><p>可视化的面向对象的建模语言。<br>事物（Things）<br>关系（Relationships）<br>图（）<br>类图<br>Clock类的完整表示<br>类图：</p>
<p>对象图：</p>
<p>依赖关系：</p>
<p>作用关系，关联：</p>
<p>包含关系，聚集：</p>
<blockquote>
<p>Visual object-oriented modeling language.</p>
<p>Things</p>
<p>Relationships</p>
<p>Fig()</p>
<p>Class diagram</p>
<p>A complete representation of the Clock class</p>
<p>Class Diagram:</p>
<p>Object Diagram:</p>
<p>Dependencies:</p>
<p>Role, Relationship:</p>
<p>Containment Relationships, Clusters:</p>
</blockquote>
<h3 id="结构体-Struct’"><a href="#结构体-Struct’" class="headerlink" title="结构体(Struct’)"></a>结构体(Struct’)</h3><p>结构体是一种特殊的类<br>与类唯一的区别：<br>类的缺省访问权限是private<br>结构体的缺省访问权限是public<br>什么时候用结构体而不用类<br>定义主要用来保存数据，而没有什么操作的类型。<br>人们习惯将结构体的数据成员设为共有，因此这时候用结构体更方便。</p>
<blockquote>
<p>A struct is a special class</p>
<p>The only difference with the class:</p>
<p>The default access to a class is private</p>
<p>The default access to structs is public</p>
<p>When to use structs instead of classes</p>
<p>Define types that are primarily used to hold data, but not to do anything.</p>
<p>People are used to making the data members of a struct shared, so it’s more convenient to use a struct at this time.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构体名称&#123;</span><br><span class="line">公有成员</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">保护型成员</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">私有成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体中既可以有数据成员也可以有函数成员。<br>c语言的结构体不能定义函数成员。<br>结构体的初始化<br>如果：<br>一个结构体的全部数据成员都是公共成员；<br>没有用户定义的构造函数；<br>没有基类和虚函数；<br>这个结构体的变量可以用一下语法形式初始化：<br>类型名 变量名 &#x3D;{成员数据1初值，成员数据2初值}；</p>
<blockquote>
<p>A struct can have both data and function members.</p>
<p>C structs cannot define function members.</p>
<p>Initialization of the struct</p>
<p>If:</p>
<p>All data members of a struct are public members;</p>
<p>There are no user-defined constructors;</p>
<p>There are no base classes and virtual functions;</p>
<p>The variables of this struct can be initialized with the following syntax:</p>
<p>Type Name Variable Name &#x3D; {Initial value of member data 1, initial value of member data 2};</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">char</span> sex;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student stu=&#123;<span class="number">97001</span>,<span class="string">&quot;Lin lin&quot;</span>,<span class="string">&#x27;F&#x27;</span>,<span class="number">19</span>&#125;;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Num:&quot;</span>&lt;&lt;stu.num&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Name:&quot;</span>&lt;&lt;syu.name&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Sex&quot;</span>&lt;&lt;stu.sex&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Age&quot;</span>&lt;&lt;stu.age&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="联合体-combo"><a href="#联合体-combo" class="headerlink" title="联合体(combo)"></a>联合体(combo)</h3><p>与类和结构体都很像；特点是存储空间的共用。<br>union 联合体名称{<br>公有成员<br>protected；<br>保护成员<br>private;<br>私有成员<br>};<br>&#x2F;&#x2F;所有的成员共用相同的内存，任何两个对象都不会同时存在。</p>
<blockquote>
<p>It’s very similar to classes and structs; It is characterized by the sharing of storage space.</p>
<p>union consortium name {</p>
<p>Public Member</p>
<p>protected；</p>
<p>Protect members</p>
<p>private;</p>
<p>Private members</p>
<p>};</p>
<p>All members share the same memory, and no two objects exist at the same time.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Mark</span><span class="comment">//表示成绩的联合体</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> grade;<span class="comment">//等级制的成绩</span></span><br><span class="line"><span class="type">bool</span> pass;<span class="comment">//只记得是否通过课程的成绩</span></span><br><span class="line"><span class="type">int</span> precent;<span class="comment">//百分制的成绩</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">无名联合体</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">float</span> f;</span><br><span class="line">&#125;</span><br><span class="line">i=<span class="number">10</span>;</span><br><span class="line">f=<span class="number">2.2</span>;<span class="comment">//冲掉内存</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExamInfo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">enum</span>&#123;GREDE,PASS,PERCENTAGE&#125;mode<span class="comment">//枚举类型</span></span><br><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line"><span class="type">char</span> grade;</span><br><span class="line"><span class="type">bool</span> pass;</span><br><span class="line"><span class="type">int</span> percent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ExamInfo</span>(string name,<span class="type">char</span> grade):<span class="built_in">name</span>(name),<span class="built_in">mode</span>(GRADE),<span class="built_in">grade</span>(grade)&#123;&#125;</span><br><span class="line"><span class="built_in">ExamInfo</span>(string name,<span class="type">bool</span> pass):<span class="built_in">name</span>(name),<span class="built_in">mode</span>(PASS),<span class="built_in">pass</span>(pass)&#123;&#125;</span><br><span class="line"><span class="built_in">ExamInfo</span>(string name,<span class="type">int</span> percent):<span class="built_in">name</span>(name),<span class="built_in">mode</span>(PERCENTAGE),<span class="built_in">percent</span>(percent)&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span>::ExamInfo::<span class="built_in">show</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;name&lt;&lt;<span class="string">&quot;:&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span>(mode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> GRADE:cout&lt;&lt;grade;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PASS:cout&lt;&lt;(pass?)<span class="string">&quot;PASS&quot;</span>:<span class="string">&quot;FAIL&quot;</span>;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PERCENTAGE:cout&lt;&lt;percent;<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl；</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ExamInfo <span class="title">course1</span><span class="params">(<span class="string">&quot;English&quot;</span>,<span class="string">&#x27;B&#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">ExamInfo <span class="title">course2</span><span class="params">(<span class="string">&quot;Calculus&quot;</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function">ExamInfo <span class="title">course3</span><span class="params">(<span class="string">&quot;c++ programing&quot;</span>,<span class="number">85</span>)</span></span>;</span><br><span class="line">course1.<span class="built_in">show</span>();</span><br><span class="line">course2.<span class="built_in">show</span>();</span><br><span class="line">course3.<span class="built_in">show</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举类-Enumeration-Classes-："><a href="#枚举类-Enumeration-Classes-：" class="headerlink" title="枚举类(Enumeration Classes)："></a>枚举类(Enumeration Classes)：</h3><p> 枚举类型可以自动转化成整数类型，称作强类型枚举<br>语法形式：<br>默认的底层类型是int类，</p>
<blockquote>
<p>Enumeration types can be automatically converted into integer types, called strongly typed enums</p>
<p>Grammatical forms:</p>
<p>The default low-level type is the int class,</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">class</span> 枚举类型名：底层类型（枚举值列表）</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Type</span>&#123;General,Light,Medium,Heavy&#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Type</span>:<span class="type">char</span>&#123;General,Light,Medium,Heavy&#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Category</span>&#123;General=<span class="number">1</span>,Pistol,MachineGun,Cannon&#125;;</span><br></pre></td></tr></table></figure>

<p>优点：<br>强作用域，<br>转换限制，<br>可以指定底层类型。<br>1、枚举类型的用途浅例<br>写程序时，我们徐阳为某个对象关联一组可以选择alternative属性，例如学生的成绩分为A、B、C、D等，天气分为sunny、cloudy、rainy等，<br>更常见的是，打开一个文件可以有三种状态，</p>
<blockquote>
<p>Merit:</p>
<p>strong scope,</p>
<p>conversion limit,</p>
<p>You can specify the underlying type.</p>
<ol>
<li>A shallow example of the use of enumeration types</li>
</ol>
<p>When writing a program, we associate a set of optional alternative attributes with an object, such as students’ grades are divided into A, B, C, D, etc., and the weather is divided into sunny, cloudy, rainy, etc.,</p>
<p>More commonly, opening a file can have three states,</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">input;</span><br><span class="line">output;</span><br><span class="line">append;</span><br></pre></td></tr></table></figure>

<p>典型的做法是，定义三个常量(Typically, three constants are defined:)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> input=<span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> output=<span class="number">2</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> append=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h4 id="强作用域，将其作用域限制在枚举类中-strong-scope-which-limits-its-scope-to-an-enumerated-class-，"><a href="#强作用域，将其作用域限制在枚举类中-strong-scope-which-limits-its-scope-to-an-enumerated-class-，" class="headerlink" title="强作用域，将其作用域限制在枚举类中(strong scope, which limits its scope to an enumerated class,)，"></a>强作用域，将其作用域限制在枚举类中(strong scope, which limits its scope to an enumerated class,)，</h4><p>例：使用Type的枚举值General：<br>Type::General<br>转换限制，枚举类对象不可以与整型隐式地相互转换。<br>可以指定底层类型<br>例：</p>
<blockquote>
<p>Example: Use the enumeration value of Type General:</p>
<p>Type::General</p>
<p>Conversion limitations, enumeration objects cannot be implicitly converted to and from integers.</p>
<p>You can specify the underlying type</p>
<p>Example:</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Type</span>：<span class="type">char</span>&#123;General,Light,Medium,Heavy&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Side</span>&#123;Right,Left&#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Thing</span>&#123;Wrong,Right&#125;;<span class="comment">//不冲突</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Side s=Side::Right;</span><br><span class="line">Thing w=Thing::Wrong;</span><br><span class="line">cout&lt;&lt;(s==w)&lt;&lt;endl;<span class="comment">//编译错误，无法直接比较不同枚举类</span></span><br><span class="line"><span class="comment">//底层都是整型</span></span><br><span class="line"><span class="comment">//属于不同的类，不能简单比较</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第四章的总结："><a href="#第四章的总结：" class="headerlink" title="第四章的总结："></a>第四章的总结：</h3><p>面向对象的基本概念<br>类和对象的声明<br>构造函数<br>析构函数<br>内联函数成员<br>复制构造函数<br>类的组合<br>结构体<br>联合体<br>枚举类<br>UML：图像建模语言</p>
<blockquote>
<h3 id="Summary-of-Chapter-4"><a href="#Summary-of-Chapter-4" class="headerlink" title="Summary of Chapter 4:"></a>Summary of Chapter 4:</h3><p>Basic concepts of object-orientation</p>
<p>Declarations of classes and objects</p>
<p>Constructor</p>
<p>Destructors</p>
<p>Inline function members</p>
<p>Copy the constructor</p>
<p>Combination of classes</p>
<p>Structure</p>
<p>Complex</p>
<p>Enumeration classes</p>
<p>UML: Image Modeling Language</p>
</blockquote>
<h3 id="实验四-Experiment-4-："><a href="#实验四-Experiment-4-：" class="headerlink" title="实验四(Experiment 4)："></a>实验四(Experiment 4)：</h3><p>类与对象的声明与使用<br>不同访问属性的成员的访问方式<br>观察构造函数和析构函数的执行过程</p>
<blockquote>
<p>Declarations and use of classes and objects</p>
<p>How members of different access attributes are accessed</p>
<p>Observe the execution of constructors and destructors</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inlcude<span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">CPU_Rank</span>&#123;P1=<span class="number">1</span>,P2,P3,P4,P5,P6,P7&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CPU_Rank rank;</span><br><span class="line"><span class="type">int</span> frequency;</span><br><span class="line"><span class="type">float</span> voltage;<span class="comment">//电压</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CPU（CPU_Rank r,<span class="type">int</span> f,<span class="type">float</span> v）:<span class="built_in">CPU_Rank</span>(r),<span class="built_in">frequency</span>(f),<span class="built_in">voltage</span>(v)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;构造了一个CPU！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">CPU</span>()&#123;cout&lt;&lt;<span class="string">&quot;析构了一个CPU！&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function">CPU_Rank <span class="title">GetRank</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> rank;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetFrequency</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> frequency;&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetVoltage</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="keyword">return</span> voltage;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetRank</span><span class="params">(CPU_Rank r)</span></span>&#123;rank=r;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetFrequency</span><span class="params">(<span class="type">int</span> f)</span></span>&#123;frequency=f;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetVoltage</span><span class="params">(<span class="type">float</span> v)</span></span>&#123;voltage =v;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;CPU开始运行&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;CPU停止运行&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CPU a=&#123;P6,<span class="number">300</span>,<span class="number">2.8</span>&#125;;</span><br><span class="line">a.<span class="built_in">Run</span>();</span><br><span class="line">a.<span class="built_in">Stop</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">MyString</span>(str p):<span class="built_in">p</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> </span><br><span class="line"><span class="type">const</span> </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





















]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOC(5)：数据的共享和保护</title>
    <url>/2022/11/01/SPOC%EF%BC%885%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B1%E4%BA%AB%E5%92%8C%E4%BF%9D%E6%8A%A4/</url>
    <content><![CDATA[<h2 id="标识符的作用域和可见性"><a href="#标识符的作用域和可见性" class="headerlink" title="标识符的作用域和可见性"></a>标识符的作用域和可见性</h2><h3 id="函数原型作用域"><a href="#函数原型作用域" class="headerlink" title="函数原型作用域"></a>函数原型作用域</h3><p>函数原型中的参数</p>
<p>其作用域始于“(”,终于”)”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double area(double radius);</span><br><span class="line">//radius的作用域仅在此处，不能用于程序正文其他地方</span><br></pre></td></tr></table></figure>

<h3 id="局部作用域（块作用域）"><a href="#局部作用域（块作用域）" class="headerlink" title="局部作用域（块作用域）"></a>局部作用域（块作用域）</h3><ul>
<li>函数的形参，在块中声明的标识符</li>
<li>作用域自声明处起，限于块中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void fun(int a)</span><br><span class="line">&#123;int b=a;</span><br><span class="line">cin&gt;&gt;b;</span><br><span class="line">if(b&gt;0)</span><br><span class="line">&#123;</span><br><span class="line">int c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h3><ul>
<li>类的对象具有类作用域</li>
</ul>
<p>其范围包括类体和成员函数体。</p>
<ul>
<li>在类作用域以外访问类的成员：<ol>
<li>静态成员：通过类名，或者该类的对象名，对象引用访问。</li>
<li>非静态成员：通过类名，或者该类的对象名，对象引用，对象指针访问。</li>
</ol>
</li>
</ul>
<h3 id="文件作用域"><a href="#文件作用域" class="headerlink" title="文件作用域"></a>文件作用域</h3><ul>
<li>不在前述各个作用域中出现的声明，就具有文件作用域。</li>
<li>其作用域开始于声明点，结束于文件尾。</li>
</ul>
<blockquote>
<p>可见性：</p>
<ul>
<li>可见性是从对标识符的引用的角度来谈的概念</li>
<li>可见性表示从内层作用域向外层作用域“看”时能看见声明。</li>
<li>如果标识在某处可见，就可以在该处引用此标识符。</li>
<li>如果某个标识符在外层中声明，且在内层中没有同一个标识符的声明，则该标识符在内层可见。</li>
<li>对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层的标识符在内层不可见。</li>
</ul>
</blockquote>
<h3 id="命名空间作用域"><a href="#命名空间作用域" class="headerlink" title="命名空间作用域"></a>命名空间作用域</h3><blockquote>
<p>可见性：</p>
<ul>
<li>可见性是从对标识符的引用的角度来谈的概念</li>
<li>可见性表示从内层作用域向外层作用域“看”时能看见声明。</li>
<li>如果标识在某处可见，就可以在该处引用此标识符。</li>
<li>如果某个标识符在外层中声明，且在内层中没有同一个标识符的声明，则该标识符在内层可见。</li>
<li>对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层的标识符在内层不可见。</li>
</ul>
</blockquote>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int i;//全局变量，文件作用域</span><br><span class="line">int main()</span><br><span class="line">i=5;//为全局变量赋值</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">i=7;</span><br><span class="line">cout&lt;&lt;&quot;i=&quot;&lt;&lt;i&lt;&lt;endl;//输出7，内层会屏蔽外层作用变量</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;i=&quot;&lt;&lt;i&lt;&lt;endl;//输出5</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的生存期"><a href="#对象的生存期" class="headerlink" title="对象的生存期"></a>对象的生存期</h2><h3 id="静态生存区"><a href="#静态生存区" class="headerlink" title="静态生存区"></a>静态生存区</h3><ul>
<li>这种生存期与程序的运行期相同。</li>
<li>在文件作用域中声明的对象具有这种生存期。</li>
<li>在函数内部声明静态生存期对象，要冠以关键字static。</li>
</ul>
<h3 id="非静态生存区"><a href="#非静态生存区" class="headerlink" title="非静态生存区"></a>非静态生存区</h3><ul>
<li>开始于程序执行到声明点时，结束于该标识符的作用域结束处。</li>
<li>块作用域中声明的，没有用static修饰的对象，是动态生存区的对象（习惯称我为局部生存期对象）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std</span><br><span class="line">int i=1;//i为全局变量</span><br><span class="line">void other()</span><br><span class="line">&#123;</span><br><span class="line">static int a=2;</span><br><span class="line">static int b;</span><br><span class="line">//a，b为静态局部变量，具有全局寿命，局部可见。</span><br><span class="line">//只第一次进入函数时被初始化。</span><br><span class="line">int c=10;</span><br><span class="line">//c为局部变量，具有动态生存期</span><br><span class="line">//每次进入函数时都被初始化</span><br><span class="line">a+=2;i+=32;c+=5;</span><br><span class="line">cout&lt;&lt;&quot;--OTHER--\n&quot;;</span><br><span class="line">cout&lt;&lt;&quot;i:&quot;&lt;&lt;i&lt;&lt;&quot;a:&quot;&lt;&lt;a&lt;&lt;&quot;b:&quot;&lt;&lt;b&lt;&lt;&quot;c:&quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">b=a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">static int a;</span><br><span class="line">//a静态局部变量，有全局寿命，局部可见</span><br><span class="line">int b=-10;</span><br><span class="line">int c=0;</span><br><span class="line">//b，c为局部变量，具有动态生存期</span><br><span class="line">cout&lt;&lt;&quot;--MAIN--\n&quot;;</span><br><span class="line">cout&lt;&lt;&quot; i:&quot;&lt;&lt;i&lt;&lt;&quot; a:&quot;&lt;&lt;a&lt;&lt;&quot; b:&quot;&lt;&lt;b&lt;&lt;&quot; c:&quot;&lt;&lt;c;</span><br><span class="line">c+=8;other();</span><br><span class="line">cout&lt;&lt;&quot;--MAIN--\n&quot;;</span><br><span class="line">cout&lt;&lt;&quot; i:&quot;&lt;&lt;i&lt;&lt;&quot; a:&quot;&lt;&lt;a&lt;&lt;&quot; b:&quot;&lt;&lt;b&lt;&lt;&quot; c:&quot;&lt;&lt;c;</span><br><span class="line">i+=10;</span><br><span class="line">other();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">运行结果</span><br><span class="line">--MAIN--</span><br><span class="line">i:1 a:0 b:-10 c:0</span><br><span class="line">--OTHER--</span><br><span class="line">i:33 a:4 b:0 c:15</span><br><span class="line">--MAIN--</span><br><span class="line">i:33 a:0 b:-10 c:8</span><br><span class="line">--OTHER--</span><br><span class="line">i:75 a:6 b:4 c:15</span><br></pre></td></tr></table></figure>

<h2 id="类的静态数据成员"><a href="#类的静态数据成员" class="headerlink" title="类的静态数据成员"></a>类的静态数据成员</h2><ul>
<li>用关键词static声明</li>
<li>为该类所有对象共享，静态数据成员具有静态生存期。</li>
<li>必须在类外定义和初始化，用（::）来指明所属的类。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point//Point类定义</span><br><span class="line">&#123;</span><br><span class="line">private://私有数据成员</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">static int count;//静态数据成员的定义和初始化，使用类名限定</span><br><span class="line">public://外部接口</span><br><span class="line">Point(int x=0,int y=0):x(x),y(y)//构造函数</span><br><span class="line">&#123;</span><br><span class="line">count++;//在构造函数中对count叠加，所有对象共同维护一个count</span><br><span class="line">&#125;</span><br><span class="line">int getX()&#123;return x&#125;;</span><br><span class="line">int getY()&#123;return y&#125;;</span><br><span class="line">Point (Point &amp;p)//拷贝构造函数</span><br><span class="line">&#123;</span><br><span class="line">x=p.x;</span><br><span class="line">y=p.y;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">~Point()&#123;count--;&#125;</span><br><span class="line">void showCount()//输出静态数据成员</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Object count&quot;&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Point::count=0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Point a(4,5);</span><br><span class="line">cout&lt;&lt;&quot;Point A:&quot;&lt;&lt;a.getX()&lt;&lt;&quot;,&quot;&lt;&lt;a.getY();</span><br><span class="line">a.showCount();</span><br><span class="line">Point b(a);</span><br><span class="line">cout&lt;&lt;&quot;Point B:&quot;&lt;&lt;b.getX()&lt;&lt;&quot;,&quot;&lt;&lt;b.getY();</span><br><span class="line">b.showCount();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态函数成员"><a href="#静态函数成员" class="headerlink" title="静态函数成员"></a>静态函数成员</h2><p>静态函数处理静态数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point//Point类定义</span><br><span class="line">&#123;</span><br><span class="line">private://私有数据成员</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">static int count;//静态数据成员的定义和初始化，使用类名限定</span><br><span class="line">public://外部接口</span><br><span class="line">Point(int x=0,int y=0):x(x),y(y)//构造函数</span><br><span class="line">&#123;</span><br><span class="line">count++;//在构造函数中对count叠加，所有对象共同维护一个count</span><br><span class="line">&#125;</span><br><span class="line">int getX()&#123;return x&#125;;</span><br><span class="line">int getY()&#123;return y&#125;;</span><br><span class="line">Point (Point &amp;p)//拷贝构造函数</span><br><span class="line">&#123;</span><br><span class="line">x=p.x;</span><br><span class="line">y=p.y;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">~Point()&#123;count--;&#125;</span><br><span class="line">static void showCount()//输出静态数据成员</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Object count&quot;&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Point::count=0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Point::showCount();//输出对象个数</span><br><span class="line">Point a(4,5);//声明对象a，其构造函数使count+1</span><br><span class="line">cout&lt;&lt;&quot;Point A:&quot;&lt;&lt;a.getX()&lt;&lt;&quot;,&quot;&lt;&lt;a.getY();</span><br><span class="line">Point::showCount();</span><br><span class="line">Point b(a);//声明对象b，其复制函数使count+1</span><br><span class="line">cout&lt;&lt;&quot;Point B:&quot;&lt;&lt;b.getX()&lt;&lt;&quot;,&quot;&lt;&lt;b.getY();</span><br><span class="line">Point::showCount();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的友元"><a href="#类的友元" class="headerlink" title="类的友元"></a>类的友元</h2><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><ul>
<li>友元时c++提供的一种破坏数据封装和数据隐藏的机制。</li>
<li>提供将一个模板声明为另一个模板的友元，一个模板能够引用到另一个模板中本是被隐藏的信息。</li>
<li>可以声明友元函数和友元类</li>
<li>为了确保数据的完整性，及数据封装于隐藏的原则，建议慎重使用友元。</li>
</ul>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><ul>
<li>友元函数是在类声明中由关键字friend修饰的说明的非成员函数，在它的函数体中能够通过对象名访问private和protected成员。</li>
<li>作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择</li>
<li>访问对象中的成员必须通过对象名。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Point(int x,int y):x(x),y(y)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">Point(Point&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">x=p.x;</span><br><span class="line">y=p.y;</span><br><span class="line">&#125;</span><br><span class="line">int getX()&#123;return x;&#125;</span><br><span class="line">int getY()&#123;return y;&#125;</span><br><span class="line">friend float dist(Point &amp;a,Point &amp;b);</span><br><span class="line">static int showCOUNT()&#123;return count;&#125;</span><br><span class="line">private:</span><br><span class="line">int x,y;</span><br><span class="line">static int count;</span><br><span class="line">&#125;;</span><br><span class="line">float dist(Point&amp; a,Point&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">double x=a.x-b.x;</span><br><span class="line">double y=a.y-b.y;</span><br><span class="line">//有修改原本数据的隐患</span><br><span class="line">//避免每次用对象的x，y都要调用一次函数</span><br><span class="line">return </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><ul>
<li><p>若一个类为另一个类的友元，则此类的所有成员，都能访问对方类的私有成员。</p>
</li>
<li><p>声明语法：将友元类名放在另一个类中使用friend修饰说明。</p>
</li>
<li><p>友元关系是单向的，数据成员的开放也就是单向的。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">friend class B;</span><br><span class="line">public:</span><br><span class="line">void display()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int x;</span><br><span class="line">&#125;;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void set(int i);</span><br><span class="line">void display();</span><br><span class="line">private:</span><br><span class="line">A a;</span><br><span class="line">&#125;</span><br><span class="line">void B::set(int i)</span><br><span class="line">&#123;</span><br><span class="line">a.x=i;</span><br><span class="line">&#125;</span><br><span class="line">void B::display()</span><br><span class="line">&#123;</span><br><span class="line">a.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享数据的保护"><a href="#共享数据的保护" class="headerlink" title="共享数据的保护"></a>共享数据的保护</h2><h3 id="常类型"><a href="#常类型" class="headerlink" title="常类型"></a>常类型</h3><h4 id="常对象：必须进行初始化，不能被更新。const-类名-对象名；"><a href="#常对象：必须进行初始化，不能被更新。const-类名-对象名；" class="headerlink" title="常对象：必须进行初始化，不能被更新。const 类名 对象名；"></a>常对象：必须进行初始化，不能被更新。const 类名 对象名；</h4><ul>
<li>用const修饰的对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">A(int i,int j):x(i),y(j)&#123;&#125;</span><br><span class="line">private:</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">A const a(3,4);//a是常对象，不能被更新</span><br></pre></td></tr></table></figure>



<h4 id="常成员：用const进行修饰的类成员：常数据成员和常函数成员。"><a href="#常成员：用const进行修饰的类成员：常数据成员和常函数成员。" class="headerlink" title="常成员：用const进行修饰的类成员：常数据成员和常函数成员。"></a>常成员：用const进行修饰的类成员：常数据成员和常函数成员。</h4><ul>
<li>常成员函数</li>
<li>使用const关键字说明的函数</li>
<li>常成员函数不更新对象的数据成员</li>
<li>常成员函数说明格式：</li>
</ul>
<blockquote>
<p>类型说明符 函数名（参数表) const；这里，const是函数类型的一个组成部分，因此在实现部分也要带const关键字。</p>
</blockquote>
<ul>
<li>const关键字可以被用于参与对重载函数的区分</li>
<li>通过常对象只能调用它的常成员函数</li>
<li>常数据成员：使用const说明的数据成员</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class R</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">R(int r1,int r2):r1(r1),r2(r2)&#123;&#125;</span><br><span class="line">void print();</span><br><span class="line">void print() const;</span><br><span class="line">private:</span><br><span class="line">int r1,r2;</span><br><span class="line">&#125;;</span><br><span class="line">void R::print()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;r1&lt;&lt;&quot;:&quot;&lt;&lt;r2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">void R::print()const</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;r1&lt;&lt;&quot;:&quot;&lt;&lt;r2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">R a(5,4);</span><br><span class="line">a.print();</span><br><span class="line">const R b(20,53);</span><br><span class="line">b.print();//调用void print const()</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">A(int i):</span><br><span class="line">void print();</span><br><span class="line">private:</span><br><span class="line">const int a;</span><br><span class="line">static const int b;//静态常数据对象</span><br><span class="line">&#125;;</span><br><span class="line">const int A::b=10;</span><br><span class="line">A::A(int i):a(i)&#123;&#125;</span><br><span class="line">void A::print()&#123;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;&quot;:&quot;&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A a1(100),a2(0);</span><br><span class="line">a1.print();</span><br><span class="line">a2.print();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="常引用：被引用的对象不能被更新。const-类型说明符号-引用名"><a href="#常引用：被引用的对象不能被更新。const-类型说明符号-引用名" class="headerlink" title="常引用：被引用的对象不能被更新。const 类型说明符号 &amp;引用名"></a>常引用：被引用的对象不能被更新。const 类型说明符号 &amp;引用名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Point(int x=0,int y=0):x(x),y(y)&#123;&#125;</span><br><span class="line">int getX()&#123;return x;&#125;</span><br><span class="line">int getY()&#123;return y;&#125;</span><br><span class="line">friend float dist(const Point &amp;p1,const Point &amp;p2);</span><br><span class="line">private x,y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在友元函数中用常引用做参数，既能获得较高的执行效率，又能保证实参的安全性。</p>
</blockquote>
<h4 id="常数组：数组元素不能被更新。类型说明符-const-数组名-大小"><a href="#常数组：数组元素不能被更新。类型说明符-const-数组名-大小" class="headerlink" title="常数组：数组元素不能被更新。类型说明符 const 数组名[大小]"></a>常数组：数组元素不能被更新。类型说明符 const 数组名[大小]</h4><h4 id="常指针：指向常量的指针。"><a href="#常指针：指向常量的指针。" class="headerlink" title="常指针：指向常量的指针。"></a>常指针：指向常量的指针。</h4><h2 id="多文件结构"><a href="#多文件结构" class="headerlink" title="多文件结构"></a>多文件结构</h2><h3 id="C-的一般组织结构"><a href="#C-的一般组织结构" class="headerlink" title="C++的一般组织结构"></a>C++的一般组织结构</h3><h4 id="一个工程可以分为多个源文件，例如："><a href="#一个工程可以分为多个源文件，例如：" class="headerlink" title="一个工程可以分为多个源文件，例如："></a>一个工程可以分为多个源文件，例如：</h4><ul>
<li>类声明文件（.h文件）</li>
<li>类实现文件（.cpp文件）</li>
<li>类的使用文件（main()所在的.cpp文件)</li>
</ul>
<h4 id="利用多个工程来组合各个文件"><a href="#利用多个工程来组合各个文件" class="headerlink" title="利用多个工程来组合各个文件"></a>利用多个工程来组合各个文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//文件1，类的定义，Point.h</span><br><span class="line">class Point//Point类定义</span><br><span class="line">&#123;</span><br><span class="line">private://私有数据成员</span><br><span class="line">int x;</span><br><span class="line">int y;</span><br><span class="line">static int count;//静态数据成员的定义和初始化，使用类名限定</span><br><span class="line">public://外部接口</span><br><span class="line">Point(int x=0,int y=0):x(x),y(y)//构造函数</span><br><span class="line">&#123;</span><br><span class="line">count++;//在构造函数中对count叠加，所有对象共同维护一个count</span><br><span class="line">&#125;</span><br><span class="line">int getX()&#123;return x&#125;;</span><br><span class="line">int getY()&#123;return y&#125;;</span><br><span class="line">Point (Point &amp;p)//拷贝构造函数</span><br><span class="line">&#123;</span><br><span class="line">x=p.x;</span><br><span class="line">y=p.y;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">~Point()&#123;count--;&#125;</span><br><span class="line">static void showCount()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//文件2，point.h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&quot;Point.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int Point::count=0;</span><br><span class="line">Point::Point(const Point &amp;p):x(p.x),y(p.y)</span><br><span class="line">&#123;count++;&#125;</span><br><span class="line">void Point::showCount()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Object count=&quot;&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">//文件3，主函数 5_10.cpp</span><br><span class="line">#include&quot;Point.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Point(4,5);</span><br><span class="line">cout&lt;&lt;&quot;Point A&quot;&lt;&lt;a.getX()&lt;&lt;&quot;,&quot;&lt;&lt;a.getY();</span><br><span class="line">Point::showCount();</span><br><span class="line">Point b(a);</span><br><span class="line">cout&lt;&lt;&quot;Point B:&quot;&lt;&lt;b.getX()&lt;&lt;&quot;,&quot;&lt;&lt;b.getY();</span><br><span class="line">Point::showCount();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h3><ul>
<li>除了在定义它的源文件中可以使用外，还能被其他文件使用。</li>
<li>文件作用域中定义的变量，默认情况下都是外部变量。</li>
<li>在其他文件中如果需要使用的化，需要用extern关键字声明。</li>
<li>在所有类的之外声明的函数（也就是非成员函数），都具有文件作用域的。</li>
<li>这样的函数都可以在不同的编译单元中被调用</li>
<li>只要在调用之前进行，引用性声明（即声明函数原型）即可。</li>
</ul>
<blockquote>
<p>将变量和函数限制在编译单元内</p>
<ul>
<li>将匿名命名空间中定义的变量和函数，都不会暴露给其他的编译单元</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">namespace</span><br><span class="line">&#123;</span><br><span class="line">//匿名的命名空间</span><br><span class="line">int n;</span><br><span class="line">void f()</span><br><span class="line">&#123;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标准c-库"><a href="#标准c-库" class="headerlink" title="标准c++库"></a>标准c++库</h2><blockquote>
<p>标准c++类库是一个及其灵活且可拓展的可重用软件模块的集合。</p>
</blockquote>
<h3 id="输入-输出类"><a href="#输入-输出类" class="headerlink" title="输入&#x2F;输出类"></a>输入&#x2F;输出类</h3><h3 id="容器类和抽象数据类型"><a href="#容器类和抽象数据类型" class="headerlink" title="容器类和抽象数据类型"></a>容器类和抽象数据类型</h3><h3 id="存储管理类"><a href="#存储管理类" class="headerlink" title="存储管理类"></a>存储管理类</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><h3 id="运行环境支持"><a href="#运行环境支持" class="headerlink" title="运行环境支持"></a>运行环境支持</h3><h2 id="编译预处理"><a href="#编译预处理" class="headerlink" title="编译预处理"></a>编译预处理</h2><h3 id="include包含指令"><a href="#include包含指令" class="headerlink" title="#include包含指令"></a>#include包含指令</h3><ul>
<li>将一个源文件嵌入到当前源文件中该点处。<ol>
<li>#include&lt;文件名&gt;：按标准模式搜索，文件位于c++系统目录的include子目录下</li>
<li>#include“文件名”：首先在当前目录中搜索，若没有，在按标准方式搜索。</li>
</ol>
</li>
</ul>
<h3 id="define-宏定义指令"><a href="#define-宏定义指令" class="headerlink" title="#define 宏定义指令"></a>#define 宏定义指令</h3><ul>
<li>定义符号常量，很多情况已经被const定义语句取代。</li>
<li>定义带参数宏，已经被内联函数取代。</li>
</ul>
<h3 id="undif"><a href="#undif" class="headerlink" title="#undif"></a>#undif</h3><ul>
<li>删除由#define定义的宏，使之不再起作用</li>
</ul>
<h3 id="条件编译指令——-if和-endif"><a href="#条件编译指令——-if和-endif" class="headerlink" title="条件编译指令——#if和#endif"></a>条件编译指令——#if和#endif</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if 常量表达式</span><br><span class="line">//当“常量表达式”非零时编译</span><br><span class="line">程序正文</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="条件编译指令——-else"><a href="#条件编译指令——-else" class="headerlink" title="条件编译指令——#else"></a>条件编译指令——#else</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if 常量表达式</span><br><span class="line">//当“常量表达式”非零时编译</span><br><span class="line">程序正文1</span><br><span class="line">#else</span><br><span class="line">//当“常量表达式”为零时编译</span><br><span class="line">程序正文2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="条件编译指令——-elif"><a href="#条件编译指令——-elif" class="headerlink" title="条件编译指令——#elif"></a>条件编译指令——#elif</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if 常量表达式1</span><br><span class="line">程序正文1//当“常量表达式1”非零时编译</span><br><span class="line">#elif 常量表达式2</span><br><span class="line">程序正文2//当“常量表达式2”非零时编译</span><br><span class="line">#else</span><br><span class="line">程序正文3//其他情况下编译</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h3 id="条件编译指令"><a href="#条件编译指令" class="headerlink" title="条件编译指令"></a>条件编译指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef 标识符</span><br><span class="line">程序段1</span><br><span class="line">#else</span><br><span class="line">程序段2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果“标识符”经#define定义过，且未经undef删除，则编译程序段1；否则编译程序段2.</p>
</blockquote>
<h2 id="第五章小结"><a href="#第五章小结" class="headerlink" title="第五章小结"></a>第五章小结</h2><ul>
<li>对象的生存期，作用域与可见性。</li>
<li>类的静态成员。</li>
<li>数据的共享和保护。</li>
<li>友元</li>
<li>编译预处理指令</li>
<li>多文件结构与工程</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOC(3)：函数(Function)</title>
    <url>/2022/10/17/SPOC%EF%BC%883%EF%BC%89%EF%BC%9A%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数定义-Function-Definition-："><a href="#函数定义-Function-Definition-：" class="headerlink" title="函数定义(Function Definition)："></a>函数定义(Function Definition)：</h2><p>将我们设计好的算法，单独封装出来。<br>函数的参数，计算所需要的参数或者条件。<br>函数的返回值、可有可无。<br>功能性函数和数值形函数。</p>
<blockquote>
<p>The algorithm we designed is encapsulated separately.</p>
<p>The parameters of the function, the parameters or conditions required for the calculation.</p>
<p>The return value of the function is optional.</p>
<p>Functional functions and numerical shape functions.</p>
</blockquote>
<h3 id="定义一个函数-Define-a-function"><a href="#定义一个函数-Define-a-function" class="headerlink" title="定义一个函数(Define a function)"></a>定义一个函数(Define a function)</h3><h4 id="定义函数名-Define-the-function-name"><a href="#定义函数名-Define-the-function-name" class="headerlink" title="定义函数名(Define the function name)"></a>定义函数名(Define the function name)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类型标识符 函数名（形式参数表）</span><br><span class="line">｛语句序列</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>形式参数定义模式(Formal parameters define the schema)：<type1> num1.</type1></p>
<p>形参只在函数中具有效果。</p>
<p>Parameters only have an effect in a function.</p>
<p>返回值就是函数的计算结果。</p>
<p>The return value is the result of the function.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">类型标识符(type identifier)（函数返回值的类型） 函数名（形式参数表）</span><br><span class="line">｛语句序列</span><br><span class="line"><span class="keyword">return</span> xx；</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>无返回值的函数用void作为类型标识符，也不用写return语句。</p>
<p>Functions without a return value use void as the type identifier and do not need to write a return statement.</p>
<h4 id="函数调用-Function-calls-："><a href="#函数调用-Function-calls-：" class="headerlink" title="函数调用(Function calls)："></a>函数调用(Function calls)：</h4><p>对于定义好的函数，以及c++库里面的函数，我们直接调用就可以了。</p>
<p>For the defined functions, as well as the functions in the C++ library, we can call them directly.</p>
<p>调用函数的规则(Rules for calling functions)：</p>
<ul>
<li>调用函数之前需要事前声明<br>函数的定义和调用不在一个程序之中。<br>调用函数之前，我们需要进行一个函数的原型声明。<br>调用形式：<br>函数名（实参列表）</li>
</ul>
<p>A pre-declaration is required before a function can be called</p>
<p>Functions are not defined and invoked in a single program.</p>
<p>Before we can call a function, we need to make a prototype declaration of the function.</p>
<p>Call form:</p>
<p>Function Name (Argument List)</p>
<ul>
<li>嵌套调用：<br>函数之间互相调用。</li>
</ul>
<p>Nested calls:</p>
<p>Functions are called to each other.</p>
<ul>
<li>递归调用：<br>函数自己调用自己。</li>
</ul>
<p>Recursive calls:</p>
<p>Functions call themselves on their own.</p>
<h5 id="例题1：指数函数-Example-1-Exponential-function"><a href="#例题1：指数函数-Example-1-Exponential-function" class="headerlink" title="例题1：指数函数(Example 1: Exponential function)"></a>例题1：指数函数(Example 1: Exponential function)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=b;i++)</span><br><span class="line">a*=a;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="type">int</span> i,j;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Please enter the numbers&quot;</span></span><br><span class="line">cin&gt;&gt;i;</span><br><span class="line">cin&gt;&gt;j;</span><br><span class="line">c=<span class="built_in">pow</span>(i,j);</span><br><span class="line">cout&lt;&lt;c&lt;&lt;end;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例题2：将二进制数转化为十进制数-Example-2-Convert-a-binary-number-to-a-decimal-number"><a href="#例题2：将二进制数转化为十进制数-Example-2-Convert-a-binary-number-to-a-decimal-number" class="headerlink" title="例题2：将二进制数转化为十进制数(Example 2: Convert a binary number to a decimal number)"></a>例题2：将二进制数转化为十进制数(Example 2: Convert a binary number to a decimal number)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=b;i++)</span><br><span class="line">a*=a;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="type">int</span> value=<span class="number">9</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Enter an 8bit binary number&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">&#123;<span class="type">char</span> ch;</span><br><span class="line">cin&gt;&gt;ch;</span><br><span class="line"><span class="keyword">if</span>(ch==‘<span class="number">1</span>’)</span><br><span class="line">&#123;velus+=<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">power</span>(<span class="number">2</span>,i);&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Decimal value is&quot;</span>&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="built_in">power</span> (<span class="type">double</span> x,<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> val=<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">while</span>(n--)</span><br><span class="line">val*=x;</span><br><span class="line"><span class="keyword">return</span> val;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例题三：计算π的值-Example-3-Calculate-the-value-of-the-π"><a href="#例题三：计算π的值-Example-3-Calculate-the-value-of-the-π" class="headerlink" title="例题三：计算π的值(Example 3: Calculate the value of the π)"></a>例题三：计算π的值(Example 3: Calculate the value of the π)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">arctanx</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="type">double</span> sqr=x*x;</span><br><span class="line"><span class="type">double</span> e=x;</span><br><span class="line"><span class="type">double</span> r=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(e/i&gt;<span class="number">1e-15</span>)</span><br><span class="line">&#123;<span class="type">double</span> f=e/i;</span><br><span class="line">r=(i%<span class="number">4</span>==<span class="number">1</span>)?r+f:r-f;</span><br><span class="line">e*=sqr;</span><br><span class="line"><span class="number">1</span>+=<span class="number">2</span>;&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> a=<span class="number">16.0</span>*<span class="built_in">arctan</span>(<span class="number">1</span>/<span class="number">5.0</span>);</span><br><span class="line"><span class="type">double</span> b=<span class="number">4.0</span>*<span class="built_in">arctan</span>(<span class="number">1</span>/<span class="number">239.0</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;PI=&quot;</span>&lt;&lt;a-b&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例题4：寻找回文数字-Example-4-Find-palindromic-numbers"><a href="#例题4：寻找回文数字-Example-4-Find-palindromic-numbers" class="headerlink" title="例题4：寻找回文数字(Example 4: Find palindromic numbers)"></a>例题4：寻找回文数字(Example 4: Find palindromic numbers)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">symm</span><span class="params">(<span class="type">unsigned</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="type">unsigned</span> i=n;</span><br><span class="line"><span class="type">unsigned</span> m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">&#123;m=m*<span class="number">10</span>+i%<span class="number">10</span>;</span><br><span class="line">i/=<span class="number">10</span>;&#125;</span><br><span class="line"><span class="keyword">return</span> m==n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">11</span>;i&lt;=<span class="number">999</span>;i++)</span><br><span class="line">&#123;<span class="keyword">if</span>(<span class="built_in">symm</span>(m)&amp;&amp;<span class="built_in">symm</span>(m*m)&amp;&amp;<span class="built_in">summ</span>(m*m*m))&#125;</span><br><span class="line">cout&lt;&lt;m&lt;&lt;m*m&lt;&lt;m*m*m&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例题5：分段函数-Example-5-Piecewise-functions"><a href="#例题5：分段函数-Example-5-Piecewise-functions" class="headerlink" title="例题5：分段函数(Example 5: Piecewise functions)"></a>例题5：分段函数(Example 5: Piecewise functions)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sin</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> g=<span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> t=x;</span><br><span class="line"><span class="type">int</span> n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">g+=t;</span><br><span class="line">n++;</span><br><span class="line">t=-t*x*x/(<span class="number">2</span>*n<span class="number">-1</span>)/(<span class="number">2</span>*n<span class="number">-2</span>);</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="built_in">fabs</span>(t)&gt;=<span class="number">1e-10</span>);</span><br><span class="line"><span class="keyword">return</span> g;</span><br><span class="line">｝</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="type">double</span> k,r,s;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;r=&quot;</span>;</span><br><span class="line">cin&gt;&gt;r;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;s=&quot;</span>;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="keyword">if</span>(r*r&lt;=s*s)</span><br><span class="line">k=<span class="built_in">sqrt</span>(<span class="built_in">sin</span>(r)*<span class="built_in">sin</span>(r)+<span class="built_in">sin</span>(s)*<span class="built_in">sin</span>(s));</span><br><span class="line"><span class="keyword">else</span> k=<span class="built_in">sin</span>(r*s)/<span class="number">2</span>;</span><br><span class="line">cout&lt;&lt;k&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例题六：投骰子-Example-6-Roll-the-dice"><a href="#例题六：投骰子-Example-6-Roll-the-dice" class="headerlink" title="例题六：投骰子(Example 6: Roll the dice)"></a>例题六：投骰子(Example 6: Roll the dice)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*srand函数</span></span><br><span class="line"><span class="comment">原型：void srand（unsigned int seed）</span></span><br><span class="line"><span class="comment">参数：seed产生随机数的种子</span></span><br><span class="line"><span class="comment">需要头文件：&lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">功能：为使rand（）产生一系列伪随机整数而设置起始点。使用1作为seed参数，可以重新初始化rand（）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">GameStatus</span>&#123;WIN,LOSE,PLAYING&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum,myPoint;</span><br><span class="line">GameStaus staus;</span><br><span class="line"><span class="type">unsigned</span> seed;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rollDice</span><span class="params">()</span></span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Please enter an unsigned integer&quot;</span>;</span><br><span class="line">cin&gt;&gt;seed;</span><br><span class="line"><span class="built_in">srand</span>(seed);</span><br><span class="line">sum=<span class="built_in">rollDice</span>();</span><br><span class="line"><span class="keyword">switch</span>(sun)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">staus=WIN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>;</span><br><span class="line">staus =LOSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>;</span><br><span class="line">staus=PLAYING;</span><br><span class="line">myPoint=sum;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;point is&quot;</span>&lt;&lt;myPoint&lt;&lt;endl;</span><br><span class="line"><span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">while</span>(staus==PLAYING)</span><br><span class="line">&#123;sum=<span class="built_in">doolDice</span>();</span><br><span class="line"><span class="keyword">if</span>(sum==<span class="built_in">myPoint</span>()</span><br><span class="line">staus=WIN;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(sum==)&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">rollDice</span>()</span><br><span class="line">&#123;<span class="type">int</span> die1=<span class="number">1</span>+<span class="built_in">rand</span>()%<span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> die2=<span class="number">1</span>+<span class="built_in">rand</span>()%<span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> sum=die1+die2;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;player rolled&quot;</span>&lt;&lt;die1&lt;&lt;<span class="string">&quot;+&quot;</span>&lt;&lt;</span><br><span class="line">die2&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> sum;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="函数的嵌套调用"><a href="#函数的嵌套调用" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h4><p>主函数调用a函数，a函数调用b函数。<br>就是在一个流程中，不断嵌套新函数。<br>为什么能够精准地返回第一时间的位置呢？<br>因为有栈的存在。<br>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fun2（<span class="type">int</span> m）</span><br><span class="line">｛<span class="keyword">return</span> m*m｝</span><br><span class="line"><span class="type">int</span> fun1（<span class="type">int</span> a，<span class="type">int</span> b）</span><br><span class="line">&#123;<span class="keyword">return</span> <span class="built_in">fun2</span>(a)+<span class="built_in">fun2</span>(b);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数的递归调用-Recursive-calls-to-functions"><a href="#函数的递归调用-Recursive-calls-to-functions" class="headerlink" title="函数的递归调用(Recursive calls to functions)"></a>函数的递归调用(Recursive calls to functions)</h4><p>函数自己调用自己。<br>函数可以直接或者间接地调用自身。</p>
<p>Functions call themselves on their own.</p>
<p>Functions can call themselves directly or indirectly.</p>
<h5 id="例题1：计算n！-Example-1-Calculate-n"><a href="#例题1：计算n！-Example-1-Calculate-n" class="headerlink" title="例题1：计算n！(Example 1: Calculate n!)"></a>例题1：计算n！(Example 1: Calculate n!)</h5><p>公式n！&#x3D;n*（n-1）！&#x2F;&#x2F;递归就是可以转化为数列前后两项的关系。</p>
<p>&#x2F;&#x2F;Recursion is the relationship that can be converted into two terms before and after a sequence.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fun（<span class="type">int</span> a）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a=<span class="number">0</span>) </span><br><span class="line">        <span class="built_in">fun</span>(a)=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">afun</span>(a<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="例题2：从n个人里面选择k个人作为委员会。-Example-2-Select-k-people-from-n-people-to-be-the-committee"><a href="#例题2：从n个人里面选择k个人作为委员会。-Example-2-Select-k-people-from-n-people-to-be-the-committee" class="headerlink" title="例题2：从n个人里面选择k个人作为委员会。(Example 2: Select k people from n people to be the committee.)"></a>例题2：从n个人里面选择k个人作为委员会。(Example 2: Select k people from n people to be the committee.)</h5><p>C（n，k）&#x3D;n！&#x2F;k!*n-k）！<br>C(n,k)&#x3D;C(n-1,k)+C(n-1,k-1)<br>终止条件在递归里面很重要。</p>
<p>Termination conditions are important in recursion.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> comm（<span class="type">int</span> n，<span class="type">int</span> k）</span><br><span class="line">｛</span><br><span class="line">    <span class="keyword">if</span>（k&gt;n）<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(n==k||k==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">comm</span>(n<span class="number">-1</span>,k)+<span class="built_in">comm</span>(n<span class="number">-1</span>,k<span class="number">-1</span>);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p>tip:找出递归边界的方法：<br>数列本身的限制，公式计算的极限。</p>
<p>Tip: Here’s how to find recursive boundaries:</p>
<p>The limits of the sequence itself, the limits of the calculation of the formula.</p>
<h5 id="例题3：汉诺塔问题（Example-3-The-Tower-of-Hanoi-problem）"><a href="#例题3：汉诺塔问题（Example-3-The-Tower-of-Hanoi-problem）" class="headerlink" title="例题3：汉诺塔问题（Example 3: The Tower of Hanoi problem）"></a>例题3：汉诺塔问题（Example 3: The Tower of Hanoi problem）</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> move（<span class="type">char</span> src,<span class="type">char</span> dest）</span><br><span class="line">&#123;cout&lt;&lt;src&lt;&lt;<span class="string">&quot;--&gt;&quot;</span>&lt;&lt;dest&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hanoi</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> scr,<span class="type">char</span> medium,<span class="type">char</span> dest)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>) <span class="built_in">move</span>(src,dest);</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="built_in">hanoi</span>(n<span class="number">-1</span>,src,dest,medium);</span><br><span class="line"><span class="built_in">move</span>(src,dest);</span><br><span class="line"><span class="built_in">hanoi</span>(n<span class="number">-1</span>,medium,scr,dest);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="type">int</span> m;</span><br><span class="line"><span class="built_in">hanoi</span>(m,a,b,c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//追踪递归过程：</span></span><br><span class="line"><span class="comment">//进入，n！=1.调用自身</span></span><br><span class="line"><span class="comment">//每一次数据规模都在缩小</span></span><br><span class="line"><span class="comment">//第一次3 A B C</span></span><br><span class="line"><span class="comment">//第二次（调用自身）2 A C B</span></span><br><span class="line"><span class="comment">//第三次（调用自身）1 A B C</span></span><br><span class="line"><span class="comment">//第四次（调用move（））A-&gt;C</span></span><br><span class="line"><span class="comment">//第五次（退回n=2的状态，调用move（））A-&gt;B</span></span><br><span class="line"><span class="comment">//第六次（调用自身）1 B A C </span></span><br><span class="line"><span class="comment">//第七次（调用move（））B-&gt;C</span></span><br><span class="line"><span class="comment">//第八次（退回n=2的状态）</span></span><br></pre></td></tr></table></figure>

<p>执行完之后，退回入栈的状态，深入递归点进入后，形成流程。</p>
<p>After the execution is completed, the process is formed after returning to the state of the stack and entering the recursion point.</p>
<h4 id="函数的参数传递（Parameter-passing-of-functions）"><a href="#函数的参数传递（Parameter-passing-of-functions）" class="headerlink" title="函数的参数传递（Parameter passing of functions）"></a>函数的参数传递（Parameter passing of functions）</h4><p>形式参数是不占内存的，当调用函数的时候，才会给形参分配内存空间。<br>实参可以是常量，变量和表达式。<br>转化（隐含）：将实参转化为形参。<br>单向传值的作用，被调用函数只会处理形参，形参得到形参的值的时候，就切割了。<br>return语句只能返回一个值。<br>现在需要一个双向传值的事物，方法是传引用&amp;。传引用作参数可以保障实参数据的安全。</p>
<p>Formal arguments do not occupy memory, and when the function is called, memory space is allocated to the form parameters.</p>
<p>Arguments can be constants, variables, and expressions.</p>
<p>Transformation (Implicit): Converts the real parameter into a form parameter.</p>
<p>The function of one-way value transfer is that the called function will only process the form parameters, and when the form parameters get the value of the form parameters, they will be cut.</p>
<p>The return statement can return only one value.</p>
<p>Now you need a thing that passes values in both directions, and the way to do this is by passing a reference &amp;. Passing reference parameters can ensure the security of the parameter data.</p>
<h4 id="引用类型（Reference-type）"><a href="#引用类型（Reference-type）" class="headerlink" title="引用类型（Reference type）"></a>引用类型（Reference type）</h4><p>值传递：单向传递。<br>引用传递：双向传递。<br>引用类型、<br>引用（&amp;）是标识符的别名<br>定义一个引用的时候，必须同时对它进行初始化，使它指向一个已存在的对象。</p>
<p>Value passing: One-way passing.</p>
<p>Reference passing: Two-way delivery.</p>
<p>Reference type,</p>
<p>A reference (&amp;) is an alias for an identifier</p>
<p>When defining a reference, it must also be initialized so that it points to an existing object.</p>
<p>例如（for instance）：<br>int i，j;<br>int &amp;ri&#x3D;i;&#x2F;&#x2F;定义int引用ri，并初始化为变量i的引用。<br>j&#x3D;10;<br>ri&#x3D;j;&#x2F;&#x2F;相当于把j赋值给i（It is equivalent to assigning j to i）<br>一旦一个引用被初始化后，就不能改为指向其他对象<br>引用可以作为形参</p>
<p>Once a reference has been initialized, it cannot be changed to point to another object</p>
<p>References can be used as form parameters</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t=a;a=b;b=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">5</span>,y=<span class="number">10</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;x=&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;y=&quot;</span>&lt;&lt;u&lt;&lt;endl;</span><br><span class="line"><span class="built_in">swap</span>(x,y);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;x=&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;y=&quot;</span>&lt;&lt;u&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不会发生变化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span>&amp; b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t=a;a=b;b=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">5</span>,y=<span class="number">10</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;x=&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;y=&quot;</span>&lt;&lt;u&lt;&lt;endl;</span><br><span class="line"><span class="built_in">swap</span>(x,y);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;x=&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;y=&quot;</span>&lt;&lt;u&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="含有可以变化的参数的函数（A-function-with-parameters-that-can-be-varied）"><a href="#含有可以变化的参数的函数（A-function-with-parameters-that-can-be-varied）" class="headerlink" title="含有可以变化的参数的函数（A function with parameters that can be varied）"></a>含有可以变化的参数的函数（A function with parameters that can be varied）</h4><p>可以变化长度的参数表：<br>如果所有的实参类型相同，可以传递一个initializer_list的标准库类型<br>如果实参的类型不同，我们可以编写可变参数的模板</p>
<p>Table of parameters that can vary in length:</p>
<p>If all arguments are of the same type, you can pass a initializer_list standard library type</p>
<p>If the types of arguments are different, we can write a variadic template initializer_list<br>initializer_list是一种标准库类型，用于表示某种特定类型的值的数组，该类型定义在同名的头文件中。</p>
<p>initializer_list is a standard library type used to represent an array of values of a particular type, defined in a header file with the same name.</p>
<p>具体操作（How to do it:）：<br>initializer_list<T>lst;&#x2F;&#x2F;默认初始化，T类型元素的空列表（Default initialization, an empty list of T-type elements）<br>nitializer_list<T>lst{a,b,c};&#x2F;&#x2F;lst的元素数量和初始值一样多，lst的元素是对应初始值的副本；列表中的元素是const（The number of elements in the LST is as large as the initial value, and the element in the LST is a copy of the corresponding initial value; The element in the list is const）<br>lst2(lst)&#x2F;&#x2F;拷贝或者赋值一个initializer_list对象但不拷贝列表中的元素；拷贝后原始列表和副本共享元素（Copy or assign an initializer_list object without copying the elements in the list; The original list and copy share elements after copying.）。<br>lst2&#x3D;lst<br>lst.size(）&#x2F;&#x2F;列表中的元素数量（The number of elements in the list）<br>lst.begin（）&#x2F;&#x2F;返回指向lst首元素的指针（Returns a pointer to the LST header element）<br>lst.end()&#x2F;&#x2F;返回指向lst尾元素下一位置的指针（Returns a pointer to the next position of the LST tail element）<br>在编写代码输出程序所产生的错误信息时，最好统一用一个函数实现该功能，使得对所有错误的处理都能够整齐划一，<br>然而错误信息的种类不同，<br>调用错误星系时输出函数时传递的参数也会各不相同<br>使用initializer_list编写一个错误信息输出函数，使其可以作用于可变数量的形参。</T></T></p>
<p>When writing the error message generated by the code output program, it is best to implement the function with a unified function, so that all errors can be handled uniformly.</p>
<p>However, the types of misinformation are different,</p>
<p>When calling the error galaxy, the parameters passed in the output function will also vary</p>
<p>Use initializer_list to write an error message output function that can act on a variable number of parameters.</p>
<h4 id="内联函数（Inline-functions）"><a href="#内联函数（Inline-functions）" class="headerlink" title="内联函数（Inline functions）"></a>内联函数（Inline functions）</h4><p>简单地说，就是在调用简单函数提高效率的工具。<br>减少调用函数的麻烦。<br>内联函数声明时的关键字 inline<br>编译时在调用处用函数体进行替换<br>节省了参数传递<br>控制转移等开销</p>
<p>To put it simply, it’s a tool that calls simple functions to improve efficiency.</p>
<p>Reduce the hassle of calling functions.</p>
<p>The keyword inline when the inline function is declared</p>
<p>Replace it with a function body at compile time</p>
<p>Parameter passing is saved</p>
<p>Control overhead such as transfers</p>
<p>注意：<br>内联函数中不能有循环语句和switch语句<br>内联函数的定义必须出现在内联函数在第一次被调用之前</p>
<p>Note:</p>
<p> Inline functions cannot have loop statements and switch statements Inline function definitions must appear before the inline function is called for the first time</p>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namesapce std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">calArea</span><span class="params">(<span class="type">double</span> radius)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> PI*radius*radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> r=<span class="number">3.0</span>;</span><br><span class="line"><span class="type">double</span> area=<span class="built_in">calArea</span>(r);</span><br><span class="line">cout&lt;&lt;area&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Constexpr函数（常量表达式函数-Constant-expression-functions）"><a href="#Constexpr函数（常量表达式函数-Constant-expression-functions）" class="headerlink" title="Constexpr函数（常量表达式函数&#x2F;Constant expression functions）"></a>Constexpr函数（常量表达式函数&#x2F;Constant expression functions）</h4><p>他修饰的函数中，当所有参数都是constexpr时，一定返回constexpr。<br>只要给的是常量，那么返回的也是一个常量。</p>
<p>In the function he modified, when all arguments are constexpr, constexpr must be returned.</p>
<p>As long as a constant is given, then what is returned is also a constant.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> get_size（）｛<span class="keyword">return</span> <span class="number">20</span>；｝</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo=<span class="built_in">get_size</span>();</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;正确：foo是一个常量表达式。</p>
<p>&#x2F;&#x2F;Correct: foo is a constant expression.</p>
<h4 id="带默认参数值的函数-Functions-with-default-parameter-values"><a href="#带默认参数值的函数-Functions-with-default-parameter-values" class="headerlink" title="带默认参数值的函数(Functions with default parameter values)"></a>带默认参数值的函数(Functions with default parameter values)</h4><p>可以在调用的时候，不给予参数也可以有一个默认形参可以使用。</p>
<p>You can use a default parameter without giving a parameter when you call it.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> add（<span class="type">int</span> x=<span class="number">5</span>，<span class="type">int</span> y=<span class="number">6</span>）｛</span><br><span class="line"><span class="keyword">return</span> x+y;｝</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">10</span>,<span class="number">20</span>);<span class="comment">//10+20</span></span><br><span class="line">	<span class="built_in">add</span>(<span class="number">10</span>);<span class="comment">//10+6</span></span><br><span class="line">	<span class="built_in">add</span>();<span class="comment">//5+6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;所有有默认参数的形参都必须列在形参列表的最右，即默认参数值的右边不能有无默认值的参数；<br>调用时，实参和形参的结合次序是从左向右</p>
<p>&#x2F;&#x2F;All parameters with default parameters must be listed on the far right of the parameter list, that is, there can be no parameters with default values to the right of the default parameter values;</p>
<p>When called, the order of combination of the real and form parameters is from left to right</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> add（<span class="type">int</span> x，<span class="type">int</span> y=<span class="number">5</span>，<span class="type">int</span> z=<span class="number">6</span>）;<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> add（<span class="type">int</span> x=<span class="number">1</span>，<span class="type">int</span> y=<span class="number">5</span>，<span class="type">int</span> z）；<span class="comment">//错误</span></span><br><span class="line"><span class="type">int</span> add（<span class="type">int</span> x=<span class="number">1</span>，<span class="type">int</span> y，<span class="type">int</span> z=<span class="number">6</span>）；<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<h5 id="默认参数值与函数的调用位置-The-default-parameter-value-and-the-location-where-the-function-is-called"><a href="#默认参数值与函数的调用位置-The-default-parameter-value-and-the-location-where-the-function-is-called" class="headerlink" title="默认参数值与函数的调用位置(The default parameter value and the location where the function is called)"></a>默认参数值与函数的调用位置(The default parameter value and the location where the function is called)</h5><p>如果一个函数有原型声明，且原型声明在定义之前，则默认参数值应该在函数原型声明中给出；<br>如果只有函数的定义，或函数定义在前，<br>则默认参数值可以在函数定义中给出。</p>
<p>If a function has a prototype declaration, and the prototype declaration is before it is defined, the default parameter values should be given in the function prototype declaration;</p>
<p>If there is only a function definition, or if the function definition comes first,</p>
<p>The default parameter value can be given in the function definition.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x=<span class="number">5</span>，<span class="type">int</span> y=<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x，<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> add（<span class="type">int</span> x=<span class="number">5</span>，<span class="type">int</span> y=<span class="number">6</span>）&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例题1-Example-1-："><a href="#例题1-Example-1-：" class="headerlink" title="例题1(Example 1)："></a>例题1(Example 1)：</h5><p>函数getVolume计算体积<br>有三个形参：length、width、height<br>其中width和height带有默认值2和3<br>主函数中以不同形式调用getVolume</p>
<p>The main function  calls getVolume  in different forms</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getVloume</span><span class="params">(<span class="type">int</span> length，<span class="type">int</span> width，<span class="type">int</span> height=<span class="number">3</span>)</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="type">const</span> <span class="type">int</span> X=<span class="number">10</span>,Y=<span class="number">12</span>,Z=<span class="number">15</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Some box data is&quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">getVolume</span>(X,Y,Z)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Some box data is&quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">getVolume</span>(X,Y)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Some box data is&quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">getVolume</span>(X),&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getVolume</span><span class="params">(<span class="type">int</span> length,<span class="type">int</span> width,<span class="type">int</span> height)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">5</span>)&lt;&lt;length&lt;&lt;<span class="built_in">setw</span>(<span class="number">5</span>)&lt;&lt;width&lt;&lt;<span class="built_in">setw</span>(<span class="number">5</span>)&lt;&lt;height&lt;&lt;<span class="string">&#x27;\t&#x27;</span></span><br><span class="line"><span class="keyword">return</span> length*width*height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数重载-Function-overloading"><a href="#函数重载-Function-overloading" class="headerlink" title="函数重载(Function overloading)"></a>函数重载(Function overloading)</h4><p>函数多态性的体现，C++中允许功能相近的函数在相同的作用域内以相同函数名声明，从而形成重载。方便使用，便于记忆。</p>
<p>The embodiment of function polymorphism, C++ allows functions with similar functions to be declared with the same function name in the same scope, thus forming an overload. Easy to use and easy to remember.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">add</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注意事项，重载函数的形参必须不同：个数不同或者类型不同。<br>编译程序将根据实参和形参的类型及个数的最佳匹配来选择调用哪一个函数。</p>
<p>Note that the parameters of the overloaded function must be different: the number of parameters or the type of the function must be different.</p>
<p>The compiler will choose which function to call based on the best match between the type and number of arguments.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p>编译器不以形参名来区分</p>
<p>Compilers do not distinguish by parameter names</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<p>编译器不以返回值来区分<br>不要将不同功能的函数声明为重载函数，以免出现调用结果的误解，混淆，这样不好。</p>
<p>The compiler does not distinguish by the return value</p>
<p>Don’t declare functions with different functions as overloaded functions, so as to avoid misunderstanding and confusion of the call results, which is not good.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">add</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> x-y;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumOfSquare</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*a+b*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Double <span class="title">sumOfSquare</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*a+b*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="C-系统函数-C-system-functions"><a href="#C-系统函数-C-system-functions" class="headerlink" title="C++系统函数(C++ system functions)"></a>C++系统函数(C++ system functions)</h4><p>C++的系统库提供了几百个函数可以供程序员使用，例如：<br>求平方根函数（sqrt）<br>求绝对值函数（abs）<br>使用系统函数时要包含相应的头文件，例如；<br>cmath<br>例题一：从键盘中输出一个角度值，求出该角度的正弦值，余弦值和正切值。<br>分析：系统函数中提供了求正弦值，余弦值和正切值的函数：sin（），cos（），tan（），函数的声明在头文件cmath中。</p>
<p>The C++ system library provides hundreds of functions for programmers to use, such as:</p>
<p>Finding the Square Root Function (sqrt)</p>
<p>Finding the Absolute Value Function (ABS)</p>
<p>When using system functions, include the appropriate header file, for example;</p>
<p>cmath</p>
<p>Example 1: Output an angle value from the keyboard and find the sine, cosine and tangent value of the angle.</p>
<p>Analysis: Functions for finding sine, cosine, and tangent are provided in System Functions: sin(), cos(), tan(), and the declaration of the functions is in the header file cmath.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br></pre></td></tr></table></figure>

<h3 id="第三章总结-Chapter-3-Summary"><a href="#第三章总结-Chapter-3-Summary" class="headerlink" title="第三章总结(Chapter 3 Summary)"></a>第三章总结(Chapter 3 Summary)</h3><p>函数的定义与调用，参数传递<br>内联函数，带默认值的函数，函数重载<br>C++系统函数</p>
<p>Definition and invocation of functions, and parameter passing</p>
<p>Inline functions, functions with default values, function overloads</p>
<p>C++ system functions</p>
<p>   ▪   实验三（上）<br>本部分的主要实验任务是通过实验练习来进一步理解以下内容：</p>
<p>Experiment 3 (Part I)</p>
<p>The main task of this part of the experiment is to further understand the following through experimental exercises:</p>
<ul>
<li>掌握函数的定义和调用方法。</li>
</ul>
<p>Master the definition of functions and how to call them.</p>
<ul>
<li>学习debug的step into 功能追踪到函数内部。</li>
</ul>
<p>Learn the functionality of debug to trace down to the function.</p>
<ul>
<li>递归算法(Recursive algorithms)</li>
</ul>
<p>例题一、编写函数float Convert(float TempFer)<br>参数和返回值都是float类型<br>实现算法C&#x3D;（F-32）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*<span class="number">5</span>/<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Convert</span><span class="params">(<span class="type">float</span> F)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (F<span class="number">-32</span>)*<span class="number">5</span>/<span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line">例题二、编写斐波那契数列</span><br><span class="line">a（n）=a（n<span class="number">-1</span>）+a（n<span class="number">-2</span>）；</span><br><span class="line"><span class="type">int</span> a（<span class="type">int</span> n）&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">a</span>(n<span class="number">-1</span>)+<span class="built_in">a</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOC(6)：数组,指针与字符串</title>
    <url>/2022/11/03/SPOC%EF%BC%886%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84,%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="数组的定义与使用"><a href="#数组的定义与使用" class="headerlink" title="数组的定义与使用"></a>数组的定义与使用</h2><h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类型说明符 数组名[常量表达式][常量表达式]</span><br></pre></td></tr></table></figure>

<p>数组名的构成方法一般与变量名相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.例如：int a[10];</span><br><span class="line">表示a为整型数组，有10个元素：a[0]……a[9]</span><br><span class="line">2.例如：int a[5][3];</span><br><span class="line">表示a为整型二维数组，其中第一维有5个下标（0~4），第二维有三个下标（0~2），数组的元素个数为15，可以用于存放5行3列的整型数据表格。</span><br></pre></td></tr></table></figure>

<h3 id="数组元素的使用"><a href="#数组元素的使用" class="headerlink" title="数组元素的使用"></a>数组元素的使用</h3><blockquote>
<p>数组必须先定义，后使用</p>
<p>可以逐个引用数组元素</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a[0]=a[5]+a[7]-a[2*3];</span><br><span class="line">b[1][2]=a[2][3]/2;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a[10],b[10];</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=i*2-1;</span><br><span class="line">b[10-i-1]=a[i];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;a[&quot;&lt;&lt;i&lt;&lt;&quot;]=&quot;&lt;&lt;a[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">cout&lt;&lt;&quot;b[&quot;&lt;&lt;i&lt;&lt;&quot;]=&quot;&lt;&lt;b[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组的存储与初始化"><a href="#数组的存储与初始化" class="headerlink" title="数组的存储与初始化"></a>数组的存储与初始化</h2><blockquote>
<p>数组元素在内存中依次存放，它们的地址时连续的，元素见物理地址的相邻，对应着逻辑次序上的相邻。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">int a[10];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组的名字时数组首元素的内存地址</p>
<p>数组名（指针，地址常量）是一个常量，不能被赋值</p>
</blockquote>
<h3 id="一维数组初始化"><a href="#一维数组初始化" class="headerlink" title="一维数组初始化"></a>一维数组初始化</h3><ul>
<li>列出全部元素的初始值</li>
</ul>
<p>例如：static int a[10]&#x3D;{0,1,2,3,4,5,6,7,8,9};</p>
<ul>
<li>可以只给一部分元素指定初值</li>
</ul>
<p>例如;static int a[10]&#x3D;{1,2,4,5,6};</p>
<ul>
<li>列出全部数组元素初值时，可以不指定数组长度</li>
</ul>
<p>例如：static int a[]&#x3D;{0,1,2,3,4,5,6,7,8,9};</p>
<h3 id="二维数组的存储"><a href="#二维数组的存储" class="headerlink" title="二维数组的存储"></a>二维数组的存储</h3><ul>
<li>按行存放</li>
</ul>
<p>例如：float a[3] [4];</p>
<table>
<thead>
<tr>
<th>0</th>
<th>00</th>
<th>01</th>
<th>02</th>
<th>03</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>13</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>21</td>
<td>22</td>
<td>23</td>
</tr>
</tbody></table>
<h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><ul>
<li>将所有初值写在一个{}内，按顺序初始化</li>
</ul>
<p>例如:static int a[3] [4]&#x3D;{1,2,3,4,5,6,7,8,9,10,11,12};</p>
<ul>
<li>分行列出二维数组元素的初值</li>
</ul>
<p>例如：static int a[3] [4]&#x3D;{1,2,3,4},{5,6,7,8,9},{10,11,12};</p>
<ul>
<li>可以只对部分元素初始化</li>
</ul>
<p>例如：static int a[3] [4]&#x3D;{1},{0,6},{0,0,11};</p>
<ul>
<li>列出全部初始值时，第一维下标个数可以省略</li>
</ul>
<p>例如：static int a[] [4]&#x3D;{1,2,3,4,5,6,7,8,9,10,11,12};</p>
<p>或者：static int a[] [4]&#x3D;{1,2,3,4},{5,6,7,8},{9,10,11,12};</p>
<blockquote>
<p>如果不做任何初始化，局部作用域的非静态数组中会存在垃圾数据，static数组中的数据默认初始化为0</p>
<p>如果只对部分元素初始化，剩下的未显示初始化的元素，将被自动化初始化为0</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int f[20]=&#123;1,1&#125;;</span><br><span class="line">for(int i=2;i&lt;20;i++)</span><br><span class="line">&#123;</span><br><span class="line">f[i]=f[i-1]+f[i-2];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;20;i++)//输出，每行5个数</span><br><span class="line">&#123;</span><br><span class="line">if(i%5==0) cout&lt;&lt;endl;</span><br><span class="line">cout.width(12);//设置输出宽度为12</span><br><span class="line">cout&lt;&lt;f[i];</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一维数组的示例"><a href="#一维数组的示例" class="headerlink" title="一维数组的示例"></a>一维数组的示例</h2><ul>
<li>循环从键盘读入若干组选择题答案，计算并输出每组答案的正确率，直到输入ctrl+z为止。</li>
<li>每组连续输入五个答案，每个答案都可以时‘a’，‘d’。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namesoace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const int NUM_QUES=5;</span><br><span class="line">char c;</span><br><span class="line">int ques=0,numCorrect=0;</span><br><span class="line">cout&lt;&lt;&quot;Enter the&quot;&lt;&lt;NUM_QUES&lt;&lt;&quot;question tests&quot;&lt;&lt;endl;</span><br><span class="line">while(cin.get(c))</span><br><span class="line">&#123;</span><br><span class="line">if(c!=&#x27;\n&#x27;)</span><br><span class="line">&#123;</span><br><span class="line">numCorrect++;</span><br><span class="line">cout&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">else cout&lt;&lt;&quot;*&quot;;</span><br><span class="line">ques++;</span><br><span class="line">&#125;else</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Score&quot;&lt;&lt;static_cast&lt;float&gt;(numCorrect)/NUM_QUES*100&lt;&lt;&quot;%&quot;;</span><br><span class="line">ques=0;numCorrect=0;cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组作为函数参数"><a href="#数组作为函数参数" class="headerlink" title="数组作为函数参数"></a>数组作为函数参数</h2><blockquote>
<p>数组元素作实参，与单个变量一样</p>
<p>数组名作参数，形，实参数都应是数组名，类型要一样，传送的是数组首地址，对形参组的改变会直接影响到实参数组。</p>
</blockquote>
<blockquote>
<p>主函数中初始化一个二维数组，表示一个短阵，矩阵，并将每个元素都输出，然后调用子函数，分别计算每一行的元素之和，将和直接存放在每行的第一个元素中，返回主函数之后输出各行元素的和。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void rowSum(int a[][4],int nRow)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;nRow;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=1;j&lt;4;j++)</span><br><span class="line">a[j][0]+=a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int table[3][4]=&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;;</span><br><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;4;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;table[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">rowSum(table,3);</span><br><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;table[i][0]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><h3 id="对象数组的定义与访问"><a href="#对象数组的定义与访问" class="headerlink" title="对象数组的定义与访问"></a>对象数组的定义与访问</h3><ul>
<li><p>定义对象数组 类名 数组名[元素个数]</p>
</li>
<li><p>访问对象数组元素 数组名[下标].成员名</p>
</li>
</ul>
<h3 id="对象数组的初始化"><a href="#对象数组的初始化" class="headerlink" title="对象数组的初始化"></a>对象数组的初始化</h3><ul>
<li>数组中每一个元素对象被创建时，系统都会调用类构造函数初始化该对象。</li>
<li>通过初始化列表赋值。</li>
</ul>
<p>Point a[2]&#x3D;{Point(1,2),Point(3,4)};</p>
<ul>
<li>如果没有为数组元素指定显式初始值，数组元素便使用默认值初始化（调用默认构造函数）。</li>
</ul>
<h3 id="数组元素的构造与析构"><a href="#数组元素的构造与析构" class="headerlink" title="数组元素的构造与析构"></a>数组元素的构造与析构</h3><ul>
<li>构造数组时，元素所属的类未声明构造函数，则采用默认构造函数，</li>
<li>各元素对象的初值要求为相同的值时，可以声明具有默认形参值的构造函数</li>
<li>各元素对象的初值要求为不同的值时，需要声明带形参的构造函数。</li>
<li>当数组中每一个对象被删除时，系统都要调用一次析构函数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Point.h</span><br><span class="line">#ifddef_POINT_H</span><br><span class="line">#define_POINT_H</span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">Point();</span><br><span class="line">Point(int x,int y);</span><br><span class="line">~Point();</span><br><span class="line">void move(int newX,int newY);</span><br><span class="line">int getX()const&#123;return x;&#125;</span><br><span class="line">int getY()const&#123;return y;&#125;</span><br><span class="line">static void showCount();//静态函数成员</span><br><span class="line">private://私有数据成员</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">#endif//_POINT_H</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//Point.cpp</span><br><span class="line">#include&quot;Point.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">Point::Point():x(0),y(0)&#123;&#125;</span><br><span class="line">Point::Point(int x,int y):x(x),y(y)&#123;&#125;</span><br><span class="line">void Point::move(int newX,int newY)</span><br><span class="line">&#123;</span><br><span class="line">x=newX;</span><br><span class="line">y=newY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&quot;Point.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Point a[2];</span><br><span class="line">for(int i=0;i&lt;2;i++)</span><br><span class="line">a[i].move(i+10,i+20);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int array[3]=&#123;1,2,3&#125;;</span><br><span class="line">int* p;</span><br><span class="line">for(p=array;p&lt;array+sizeof(array)/sizeof(int);++p)</span><br><span class="line">&#123;</span><br><span class="line">*p+=2;</span><br><span class="line">std::cout&lt;&lt;*p&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int array[3]=&#123;1,2,3&#125;;</span><br><span class="line">for(int&amp;e:array)</span><br><span class="line">&#123;</span><br><span class="line">e+=2;</span><br><span class="line">std::cout&lt;&lt;e&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针的概念，定义和运算方式"><a href="#指针的概念，定义和运算方式" class="headerlink" title="指针的概念，定义和运算方式"></a>指针的概念，定义和运算方式</h2><h3 id="内存空间的访问方式："><a href="#内存空间的访问方式：" class="headerlink" title="内存空间的访问方式："></a>内存空间的访问方式：</h3><ul>
<li><p>通过变量名访问</p>
</li>
<li><p>通过地址访问</p>
</li>
</ul>
<h3 id="指针变量的定义："><a href="#指针变量的定义：" class="headerlink" title="指针变量的定义："></a>指针变量的定义：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int i;</span><br><span class="line">static int* ptr=&amp;i;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>指向int变量的指针</p>
</blockquote>
<p>例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*ptr=3;</span><br></pre></td></tr></table></figure>

<h3 id="与地址相关的运算——“-”和“-”"><a href="#与地址相关的运算——“-”和“-”" class="headerlink" title="与地址相关的运算——“*”和“&amp;”"></a>与地址相关的运算——“*”和“&amp;”</h3><ul>
<li>指针运算符：*</li>
<li>地址运算符：&amp;</li>
</ul>
<h2 id="指针的初始化和赋值"><a href="#指针的初始化和赋值" class="headerlink" title="指针的初始化和赋值"></a>指针的初始化和赋值</h2><h3 id="指针变量的初始化"><a href="#指针变量的初始化" class="headerlink" title="指针变量的初始化"></a>指针变量的初始化</h3><ul>
<li>语法形式 存储类型 数据类型 *指针名&#x3D;初始地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int* pa=&amp;a;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意事项<ol>
<li>用变量地址作为初值时，该变量必须在初始化之前已声明过，且变量类型应与指针类型一致。</li>
<li>可以用一个已有合法值的指针去初始化另一个指针变量</li>
<li>不要用一个内部非静态变量去初始化static指针</li>
</ol>
</li>
</ul>
<h3 id="指针变量的赋值运算"><a href="#指针变量的赋值运算" class="headerlink" title="指针变量的赋值运算"></a>指针变量的赋值运算</h3><ul>
<li><p>语法形式 指针名&#x3D;地址</p>
</li>
<li><p>注意：地址中存放的数据类型与指针类型必须相符，向指针变量赋的值必须时地址常量或变量，不能是普通整数。</p>
</li>
<li><p>例如：通过地址运算“&amp;”求得已定义的变量和对象的起始地址，动态内存分配成功时返回的地址。</p>
</li>
<li><p>例外：整数0可以赋给指针，表示空指针。</p>
</li>
<li><p>允许定义或声明指向void类型的指针。该指针可以被赋予任何类型对象的地址。void* general；</p>
</li>
</ul>
<h3 id="指针空值nullptr"><a href="#指针空值nullptr" class="headerlink" title="指针空值nullptr"></a>指针空值nullptr</h3><p>c++11使用nullptr关键字，是表达更准确，类型更安全的空指针。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int* ptr=&amp;i;</span><br><span class="line">i=10;</span><br><span class="line">cout&lt;&lt;&quot;i=&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;*ptr=&quot;&lt;&lt;*ptr&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//!void voidObject//不能声明void类型的变量</span><br><span class="line">void* pv;//对，可以声明void类型的指针</span><br><span class="line">int i=5;</span><br><span class="line">pv=&amp;i;</span><br><span class="line">int* pint=static_cast&lt;int*&gt;(pv);//void类型指针指向整型变量</span><br><span class="line">cout&lt;&lt;&quot;*pint=&quot;&lt;&lt;*pint&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h3><ul>
<li><p>const指针</p>
</li>
<li><p>不能通过指向常量的指针改变所指对象的值，但指针本身可以改变，可以指向另外的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a;</span><br><span class="line">const int* p1=&amp;a;\\p1是指向常量的指针</span><br><span class="line">int b;</span><br><span class="line">p1=&amp;b;//正确，p1本身的值可以改变</span><br><span class="line">*p1=1;//编译出错，不能通过p1改变所指的对象的值</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="指针类型的常量"><a href="#指针类型的常量" class="headerlink" title="指针类型的常量"></a>指针类型的常量</h3><ul>
<li>若声明指针常量，则指针本身的值不能改变。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a;</span><br><span class="line">int* const p2=&amp;a;</span><br><span class="line">p2=&amp;b;//错误，指针常量锁定，不能换对象</span><br></pre></td></tr></table></figure>

<h2 id="指针算数运算和关系运算"><a href="#指针算数运算和关系运算" class="headerlink" title="指针算数运算和关系运算"></a>指针算数运算和关系运算</h2><h3 id="指针类型的算术运算"><a href="#指针类型的算术运算" class="headerlink" title="指针类型的算术运算"></a>指针类型的算术运算</h3><ul>
<li>指针p加上或减去n：其意义是指针当前指向位置的前方或后方有n个数据的起始位置。</li>
<li>指针的++，–运算：意义是指向下一个或前一个完整数据的起始。</li>
<li>运算的结果值取决于指针指向的数据类型，总是指向一个完整数据的起始位置。</li>
<li>当指针指向连续存储的同类型数据时，指针与整数的加减运算和自增自减才算有意义。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">short a[4];</span><br><span class="line">short* pa=a;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>*pa</td>
<td>a[0]</td>
</tr>
<tr>
<td>*(pa+1)</td>
<td>a[1]</td>
</tr>
<tr>
<td>*(pa+2)</td>
<td>a[2]</td>
</tr>
<tr>
<td>*(pa+3)</td>
<td>a[3]</td>
</tr>
</tbody></table>
<h3 id="指针类型的关系运算"><a href="#指针类型的关系运算" class="headerlink" title="指针类型的关系运算"></a>指针类型的关系运算</h3><ul>
<li>指向相同类型的数据的指针之间，可以进行各种关系运算。</li>
<li>指向不同数据类型的指针，以及指针与一般整数变量之间的关系运算是无意义的。</li>
<li>指针可以和零之间进行等于或不等于的关系运算</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p==0||p！=0</span><br></pre></td></tr></table></figure>

<h2 id="综合实例环节"><a href="#综合实例环节" class="headerlink" title="综合实例环节"></a>综合实例环节</h2><blockquote>
<p>一个活期储蓄账户包括：</p>
<ul>
<li>信息：账号（id），余额（balance），年利率（rate）等</li>
<li>操作：显示账户信息（show），存款（deposit），取款（withdraw），结算利息（settle）</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class SaingAccount</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">int id;</span><br><span class="line">double:balance;</span><br><span class="line">double rate;</span><br><span class="line">int lastDate;</span><br><span class="line">double accumulation;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">floor函数：</span><br><span class="line">-向下取整函数（在数学上成为高斯函数）</span><br><span class="line">-用来得到一个不大于一个数的最大整数。</span><br><span class="line">—声明在头文件cmath中</span><br><span class="line">对一个数x做四舍五入取整：floor(x+0.5)</span><br><span class="line">floor(amount*100+0.5)/100;保留两位小数</span><br><span class="line">ceil是向上取整函数</span><br></pre></td></tr></table></figure>

<h2 id="指针处理数组"><a href="#指针处理数组" class="headerlink" title="指针处理数组"></a>指针处理数组</h2><h3 id="定义指向数组元素的指针"><a href="#定义指向数组元素的指针" class="headerlink" title="定义指向数组元素的指针"></a>定义指向数组元素的指针</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义与赋值</span><br><span class="line">int a[10],*pa;</span><br><span class="line">pa=&amp;a[0];//pa=a;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">等效的形式</span><br><span class="line">*pa就是a[0],*(pa+1)就是a[1],*(pa+i)就是a[i] </span><br><span class="line">a[i],*(pa+1),*(a+i),pa[i]都是等效的</span><br></pre></td></tr></table></figure>

<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Point* pa[2];</span><br><span class="line">//由pa[0]、pa[1]两个指针构成</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int line1[]=&#123;1,0,0&#125;;//矩阵第一行</span><br><span class="line">int line2[]=&#123;0,1,0&#125;;</span><br><span class="line">int line3[]=&#123;0,0,1&#125;;</span><br><span class="line">//定义整型指针并初始化</span><br><span class="line">int* pline[3]=&#123;line1,line2,line3&#125;;</span><br><span class="line">cout&lt;&lt;&quot;Matrix test&quot;&lt;&lt;endl;</span><br><span class="line">//输出矩阵</span><br><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=0;j&lt;3;j++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;pline[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="以指针作为函数参数"><a href="#以指针作为函数参数" class="headerlink" title="以指针作为函数参数"></a>以指针作为函数参数</h2><h3 id="为什么需要用指针作为参数？"><a href="#为什么需要用指针作为参数？" class="headerlink" title="为什么需要用指针作为参数？"></a>为什么需要用指针作为参数？</h3><ul>
<li><p>需要数据双向传递时（引用也可以达到这个效果）</p>
</li>
<li><p>需要传递一组数据，只传首地址运行效率比较高</p>
</li>
</ul>
<blockquote>
<p>读入三个浮点数，按整数和小数部分分别输出。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">void splitFloat(float s,int* intPart,float* fracPart)</span><br><span class="line">&#123;</span><br><span class="line">*intPart=static_cast&lt;int&gt;(x);</span><br><span class="line">*fracPart=x-*intPart;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;3;i++)</span><br><span class="line">&#123;</span><br><span class="line">float x,f;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">splitFloat(x,&amp;n.&amp;f);//变量地址作为实参</span><br><span class="line">cout&lt;&lt;n&lt;&lt;f;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="指向常量的指针作为形参"><a href="#指向常量的指针作为形参" class="headerlink" title="指向常量的指针作为形参"></a>指向常量的指针作为形参</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=6;</span><br><span class="line">void print(const int* p,int n)</span><br><span class="line">&#123;</span><br><span class="line">//指针指向的对象不会变</span><br><span class="line">cout&lt;&lt;&quot;&#123;&quot;&lt;&lt;*p;</span><br><span class="line">for(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;,&quot;&lt;&lt;*(p+i);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;&quot;&#125;&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int array[N];</span><br><span class="line">for(int i=0;i&lt;N;i++)</span><br><span class="line">&#123;cin&gt;&gt;array[i];</span><br><span class="line">&#125;</span><br><span class="line">print(array,N);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h2><h3 id="函数指针的定义"><a href="#函数指针的定义" class="headerlink" title="函数指针的定义"></a>函数指针的定义</h3><ul>
<li>定义形式：存储类型 数据类型 (*函数指针名)();</li>
<li>含义 函数指针指向的时程序代码存储区。</li>
</ul>
<h3 id="函数指针的典型用途-实现函数回调"><a href="#函数指针的典型用途-实现函数回调" class="headerlink" title="函数指针的典型用途-实现函数回调"></a>函数指针的典型用途-实现函数回调</h3><ul>
<li>通过函数指针调用的函数</li>
</ul>
<p>例如将函数的指针作为参数传递给一个函数，使得在处理相似问题时，可以灵活的使用不同的方法</p>
<ul>
<li>调用者不关心谁是调用者</li>
</ul>
<p>需要知道存在一个具有特定原型和限制条件的被调用函数</p>
<blockquote>
<p>函数指针举例<br>编写一个计算函数compute，对两个整数进行各种计算有一个形参为指向具体算法函数的指针，根据不同的实参函数，用不同的算法进行计算。编写三个函数:求两个整数的最大值、最小值、和。分别用这三个函数作为实参，测试compute函数。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int compute(int a,int b,int(*func)(int,int))</span><br><span class="line">&#123;return func(a,b)&#125;;</span><br><span class="line">int max(int a,int b)</span><br><span class="line">&#123;return ((a&gt;b)?a:b;)&#125;</span><br><span class="line">int min(int a,int b)</span><br><span class="line">&#123;return ((a&lt;b)?a:b;)&#125;</span><br><span class="line">int sum(int a,int b)</span><br><span class="line">&#123;return a+b;&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a,b,res;</span><br><span class="line">res=compute(a,b,&amp;max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h2><h3 id="对象指针定义形式"><a href="#对象指针定义形式" class="headerlink" title="对象指针定义形式"></a>对象指针定义形式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Point a(5,10);</span><br><span class="line">Point* ptr;</span><br><span class="line">ptr=&amp;a;</span><br></pre></td></tr></table></figure>

<h3 id="通过指针访问对象成员"><a href="#通过指针访问对象成员" class="headerlink" title="通过指针访问对象成员"></a>通过指针访问对象成员</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对象-&gt;成员名</span><br><span class="line">ptr-&gt;getx();</span><br><span class="line">//(*ptr).getx();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Point&#123;int x=0;int y=0&#125;:x(x),y(y)&#123;&#125;</span><br><span class="line">int getX()const&#123;return x;&#125;</span><br><span class="line">int getY()const&#123;return y;&#125;</span><br><span class="line">private:</span><br><span class="line">int x,y;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;0</span><br><span class="line">Point a(4,5);</span><br><span class="line">Point* p1=&amp;a;</span><br><span class="line">cout&lt;&lt;p1-&gt;getX()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;a.getX()&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><ul>
<li><p>隐含与类的每一个非静态成员函数中。</p>
</li>
<li><p>指出成员函数所操作的对象。</p>
<p>当通过一个对象调用成员函数时，系统先将该对象的地址赋给this指针，任何调用成员函数，成员函数对对象的数据成员进行操作时，就隐含了this指针。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Point类中的getX函数中的语句</span><br><span class="line">return x;</span><br><span class="line">相当于：</span><br><span class="line">return this-&gt;x;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Fred;</span><br><span class="line">class Barney</span><br><span class="line">&#123;</span><br><span class="line">Fred x;//类Barnety的声明不够明确</span><br><span class="line">&#125;;</span><br><span class="line">class Fred</span><br><span class="line">&#123;</span><br><span class="line">Barney;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Fred;</span><br><span class="line">class Barney</span><br><span class="line">&#123;</span><br><span class="line">Fred* x;</span><br><span class="line">&#125;;</span><br><span class="line">class Fred</span><br><span class="line">&#123;</span><br><span class="line">Barney y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><h3 id="动态申请内存的操作符-new"><a href="#动态申请内存的操作符-new" class="headerlink" title="动态申请内存的操作符 new"></a>动态申请内存的操作符 new</h3><p>new 类型名T(初始化参数列表)</p>
<ul>
<li>功能：在程序执行期间，申请用于存放T类型对象的内存空间，并依初值列表赋以初值。</li>
<li>结果值：成功：T类型的指针，指向新分配的内存；失败：抛出异常。</li>
</ul>
<h3 id="释放内存操作符delete"><a href="#释放内存操作符delete" class="headerlink" title="释放内存操作符delete"></a>释放内存操作符delete</h3><p>delete指针p</p>
<ul>
<li>功能：释放指针p所指向的内存，p必须时new操作符的返回值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std:</span><br><span class="line">class Point &#123;</span><br><span class="line">public:</span><br><span class="line">Point():x(0),y(0)&#123;</span><br><span class="line">cout&lt;&lt;&quot;Default Constructor called.&quot;&lt;&lt;endl;</span><br><span class="line">Point(int x, int y) : x(x),y(y)&#123;</span><br><span class="line">cout&lt;&lt;&quot;Constructor called.&quot;&lt;&lt;endl;</span><br><span class="line">~Point()&#123; cout&lt;&lt;&quot;Destructor called.&quot;&lt;&lt;endl; &#125;</span><br><span class="line">int getX() const &#123; return x;&#125;</span><br><span class="line">int getY() const &#123; return y; &#125;</span><br><span class="line">void move(int newX, int newY)&#123;</span><br><span class="line">x = newX;</span><br><span class="line">y = newY:</span><br><span class="line">private:</span><br><span class="line">int x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">cout &lt;&lt;&quot;Step one:&quot;&lt;&lt; endl:</span><br><span class="line">Point*ptr1 = new Point; //调用默认构造函数</span><br><span class="line">delete ptr1;//删除对象，自动调用析构函数</span><br><span class="line">cout&lt;&lt;&quot;Step two:&quot;&lt;&lt; endl:</span><br><span class="line">ptr1=new Point(1,2);</span><br><span class="line">delete ptr1;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="申请和释放动态数组"><a href="#申请和释放动态数组" class="headerlink" title="申请和释放动态数组"></a>申请和释放动态数组</h2><h3 id="分配和释放动态数组"><a href="#分配和释放动态数组" class="headerlink" title="分配和释放动态数组"></a>分配和释放动态数组</h3><ul>
<li>分配：new 类型名T[数组长度]：数组长度可以时任何整数型的表达式，在进行时运算。</li>
<li>释放：delete[] 数组名p：释放指针p所指向的数组，p必须时用new分配得到的数组首地址。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point&#123; //类的声明同例6-16,略&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">Point*ptr=new Point[2]: //创建对象数组</span><br><span class="line">ptr[0].move(5,10);//通过指针访问数组元素的成员</span><br><span class="line">ptr[1].move(15,20); //通过指针访问数组元素的成员</span><br><span class="line">cout &lt;&lt;&quot;Deleting...&quot; &lt;&lt; endl;</span><br><span class="line">//删除整个对象数组</span><br><span class="line">delete[] ptr;</span><br><span class="line">return O;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态创建多维数组"><a href="#动态创建多维数组" class="headerlink" title="动态创建多维数组"></a>动态创建多维数组</h3><p>new 类型名[第一维长度] [第二维长度]……;</p>
<ul>
<li>如果内存申请成功，new运算返回一个指向新分配内存首地址的指针。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char(*fp)[3];</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>fp</th>
<th>fp+1</th>
</tr>
</thead>
<tbody><tr>
<td>fp[0] [0]</td>
<td>fp[1] [0]</td>
</tr>
<tr>
<td>fp[0] [1]</td>
<td>fp[1] [1]</td>
</tr>
<tr>
<td>fp[0] [2]</td>
<td>fp[1] [2]</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int (*cp)[9][8] = new int[7][9][8];</span><br><span class="line">for (int i= 0; i&lt; 7; i++)</span><br><span class="line">for (intj = 0; j&lt; 9; j+ +)</span><br><span class="line">for (int k = 0; k &lt; 8; k++)</span><br><span class="line">*(*(*(cp +i) +j)+k)=(i*100 +j*10 + k); </span><br><span class="line">for (inti = 0; i &lt; 7; i++)&#123;</span><br><span class="line">for (intj = 0;j&lt; 9; j+ +)&#123;</span><br><span class="line">for (int k = 0; k &lt; 8; k++)</span><br><span class="line">cout &lt;&lt; cp[i][j][k]&lt;&lt;&quot; &quot;;</span><br><span class="line">cout &lt;&lt; endl;&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">delete[lcp;它返回首地址的这个变量</span><br><span class="line">retiirn 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="申请和释放动态"><a href="#申请和释放动态" class="headerlink" title="申请和释放动态"></a>申请和释放动态</h2><h3 id="将动态内组封装为类"><a href="#将动态内组封装为类" class="headerlink" title="将动态内组封装为类"></a>将动态内组封装为类</h3><ul>
<li>更加简介，便于管理</li>
<li>可以在访问数组元素前检查下标是否越界。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point&#123; //类的声明同例6-16.. &#125;;</span><br><span class="line">class ArrayOfPoints &#123;</span><br><span class="line">//动志数组类</span><br><span class="line">public:</span><br><span class="line">ArrayOfPoints(int size) :size(size) &#123;</span><br><span class="line">points = new Point[size];</span><br><span class="line">~ArrayOfPoints() &#123;</span><br><span class="line">cout &lt;&lt; &quot;Deleting..&quot; &lt;&lt; endl;</span><br><span class="line">delete[] points;</span><br><span class="line">Point&amp; element(int index) &#123;</span><br><span class="line">assert(index &gt;= 0 &amp;&amp; index &lt; size);</span><br><span class="line">return points[index];</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">Point*points; //指向动态数组首地址</span><br><span class="line">int size;</span><br><span class="line">//数组大小</span><br><span class="line">&#125;;</span><br><span class="line">这个点类 cass point</span><br><span class="line">int main()&#123;</span><br><span class="line">int count;</span><br><span class="line">cout &lt;&lt; &quot;Please enter the count of points: &quot;</span><br><span class="line">cin &gt;&gt;count;</span><br><span class="line">ArrayOfPoints points(count);//创建数组对象</span><br><span class="line">points.element(0).move(5,0);//访问数组元素的成员</span><br><span class="line">points.element(1).move(15,20);//访问数组元素的成员</span><br><span class="line">return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="c-11的智能指针"><a href="#c-11的智能指针" class="headerlink" title="c++11的智能指针"></a>c++11的智能指针</h3><ul>
<li>unique_ptr:不允许多个指针共享资源，可以用标准库中的move函数转移指针。</li>
<li>shared_ptr：多个指针共享资源。</li>
<li>weak_ptr：可以赋值shared_ptr，但其构造或者释放对资源不产生影响。</li>
</ul>
<h2 id="vector对象"><a href="#vector对象" class="headerlink" title="vector对象"></a>vector对象</h2><h3 id="为什么需要vector？"><a href="#为什么需要vector？" class="headerlink" title="为什么需要vector？"></a>为什么需要vector？</h3><ul>
<li>封装任何类型的动态数组，自动创建和删除</li>
<li>数组下标越界检查</li>
</ul>
<h3 id="vector对象的定义"><a href="#vector对象的定义" class="headerlink" title="vector对象的定义"></a>vector对象的定义</h3><p>vector&lt;元素类型&gt; 数组对象名(数组长度)；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; arr(5);</span><br></pre></td></tr></table></figure>

<h3 id="vector对象的使用"><a href="#vector对象的使用" class="headerlink" title="vector对象的使用"></a>vector对象的使用</h3><ul>
<li>对数组元素的引用</li>
</ul>
<p>与普通数组具有相同形式：</p>
<p>vector对象名[下标表达式]</p>
<p>vector数组对象名不表示数组首地址</p>
<ul>
<li>获得数组长度</li>
</ul>
<p>使用size函数</p>
<p>vector对象名.size()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">unsigned n;</span><br><span class="line">cout &lt;&lt; &quot;n =&quot;;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">vector&lt;double&gt; arr(n)</span><br><span class="line">//创建数组对象</span><br><span class="line">cout &lt;&lt; &quot;Please input &quot; &lt;&lt; n &lt;&lt;&quot; real numbers:&quot; &lt;&lt; endl;</span><br><span class="line">for (unsigned i= 0; i&lt;n; i+ +)</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">cout &lt;&lt;&quot;Average = &quot;&lt;&lt; average(arr)&lt;&lt; endl;</span><br><span class="line">return O;</span><br><span class="line">&#125;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//计算数组arr中元素的平均值</span><br><span class="line">double average(const vector&lt;double&gt; &amp;arr)</span><br><span class="line">double sum = 0:</span><br><span class="line">for (unsignedi= 0; i&lt;arr.size(); i+ +)</span><br><span class="line">sum += arri],</span><br><span class="line">return sum / arr.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">int main()</span><br><span class="line">std::vector&lt;int&gt;v=&#123;1,2,3&#125;;</span><br><span class="line">for(autoi=v.begin();i!= vend(); ++i)</span><br><span class="line">std:.cout &lt;&lt;*i&lt;&lt; std::endl;</span><br><span class="line">for(auto e:v)</span><br><span class="line">std::cout&lt;&lt;e&lt;&lt;std:.endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深层复制和浅层复制"><a href="#深层复制和浅层复制" class="headerlink" title="深层复制和浅层复制"></a>深层复制和浅层复制</h2><h3 id="浅层复制"><a href="#浅层复制" class="headerlink" title="浅层复制"></a>浅层复制</h3><ul>
<li>实现对象间数据元素的一一对应复制</li>
</ul>
<h3 id="深层复制"><a href="#深层复制" class="headerlink" title="深层复制"></a>深层复制</h3><ul>
<li>当被复制的对象数据成员时指针类型时，不是复制该指针成员本身，而是将指针所指对象进行复制。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">using namespace std,</span><br><span class="line">class Point &#123;</span><br><span class="line">//类的声明同例6-16</span><br><span class="line">//</span><br><span class="line">class ArrayOfPoints &#123;</span><br><span class="line">//类的声明同例6-18</span><br><span class="line">//.</span><br><span class="line">int main(&#123;</span><br><span class="line">int count;</span><br><span class="line">cout &lt;&lt; &quot;Please enter the count of points: &quot;,</span><br><span class="line">Cin &gt;&gt;count;</span><br><span class="line">ArrayOfPoints pointsArrayl(count); //创建对象数组</span><br><span class="line">pointsArrayl.element(0).move(5,10);</span><br><span class="line">pointsArray1.element(1).move(15,20);</span><br><span class="line">ArrayOfPoints pointsArray2(pointsArray1); //创建副本</span><br><span class="line">cout &lt;&lt; &quot;Copy of pointsArrayl:&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;Point_0 of array2: &quot;&lt;&lt; pointsArray2.element(0).getX( &lt;&lt;&quot;,&quot;</span><br><span class="line">&lt;&lt; pointsArray2.element(0).getY() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;Point_l of array2: &quot; &lt;&lt; pointsArray2.element(l).getX()&lt;&lt;&quot;,&quot;</span><br><span class="line">&lt;&lt; pointsArray2.element(1).getY() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cassert&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Point&#123;//类的声明同例6-16</span><br><span class="line">class ArrayOfPoints &#123;</span><br><span class="line">public:</span><br><span class="line">ArrayOfPoints(const ArrayOfPoints&amp; pointsArray);</span><br><span class="line">//其他成员同例6-18</span><br><span class="line">&#125;;</span><br><span class="line">ArrayOfPoints::ArrayOfPoints(const ArrayOfPoints&amp; v) &#123;</span><br><span class="line">size = v.size;</span><br><span class="line">points = new Point[size];</span><br><span class="line">for (int i= 0;i&lt; size; i++)</span><br><span class="line">points[i] = v.points[i];</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">//同例6-20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h2><h3 id="移动构造-1"><a href="#移动构造-1" class="headerlink" title="移动构造"></a>移动构造</h3><ul>
<li>c++11标准中提供了一种新的构造方式——移动构造</li>
<li>c++11之前，如果要将源对象的状态转移到目标对象只能通过复制，在某些情况下，我们没有必要复制对象，只需要移动它们。</li>
</ul>
<h3 id="移动构造函数："><a href="#移动构造函数：" class="headerlink" title="移动构造函数："></a>移动构造函数：</h3><p>class_name(class_name&amp;&amp;);</p>
<ul>
<li>版本1：使用深层复制构造函数</li>
</ul>
<p>返回时构造临时对象，动态分配将临时对象返回到主调函数，然后删除临时对象。</p>
<ul>
<li>版本2：使用移动构造函数</li>
</ul>
<p>将要返回的局部对象转移到主调函数中去，省去了构造和删除临时对象的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class IntNum &#123;</span><br><span class="line">public:</span><br><span class="line">IntNum(int x=0):xptr(new int(x))&#123;//构造函数</span><br><span class="line">cout&lt;&lt;&quot;Calling constructor...&quot;&lt;&lt; endl;</span><br><span class="line">IntNum(const IntNum &amp; n):xptr(new int(*n.xptr))&#123;//复制构造函数</span><br><span class="line">cout &lt;&lt; “Calling copy constructor...“</span><br><span class="line">&lt;&lt; endl.</span><br><span class="line">~IntNum()&#123;//析构函数</span><br><span class="line">delete xptr;</span><br><span class="line">cout &lt;&lt; &quot;Destructing...&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int getInt()&#123; return *xptr;&#125;</span><br><span class="line">private:</span><br><span class="line">int *xptr;</span><br><span class="line">&#125;;</span><br><span class="line">//获取一个对象</span><br><span class="line">IntNum::getNum()</span><br><span class="line">&#123;</span><br><span class="line">IntNum a;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;getNum().getInt()&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">运行结果</span><br><span class="line">Callint constructor……</span><br><span class="line">//进入getNum函数，启动构造函数，创建对象a</span><br><span class="line">Calling copy constructor...</span><br><span class="line">//对象a离开函数getNum，启动复制构造函数，创建一个a的副本</span><br><span class="line">Destructing...</span><br><span class="line">//对象a离开函数，本身被析构，清除内存</span><br><span class="line">0</span><br><span class="line">//调出a的副本对应的getInt()函数，输出0</span><br><span class="line">Destructing...</span><br><span class="line">//程序结束，析构副本指针</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>复制构造</th>
<th>移动构造</th>
</tr>
</thead>
<tbody><tr>
<td>堆内存a&lt;-临时对象-复制构造-&gt;a-&gt;堆内存b</td>
<td>堆内存a&lt;-临时对象-复制构造-&gt;a-&gt;堆内存a</td>
</tr>
</tbody></table>
<blockquote>
<p>当临时对象在被复制之后，就不再被利用了，我们完全可以把临时对象的资源直接移动，这样就避免了多余的复制操作。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class IntNum &#123;</span><br><span class="line">public:</span><br><span class="line">IntNum(int x=0):xptr(new int(x))&#123;//构造函数</span><br><span class="line">cout&lt;&lt;&quot;Calling constructor...&quot;&lt;&lt; endl;</span><br><span class="line">IntNum(const IntNum &amp; n):xptr(new int(*n.xptr))&#123;//复制构造函数</span><br><span class="line">cout &lt;&lt; “Calling copy constructor...“</span><br><span class="line">&lt;&lt; endl.</span><br><span class="line">InNum(IntNum &amp;&amp; n):xptr(n.xptr)</span><br><span class="line">&#123;n.xptr=nullptr;</span><br><span class="line">//及时将对象的指针置为0指针，防止发生多次析构</span><br><span class="line">cout&lt;&lt;&quot;Caling move constructor……&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">//&amp;&amp;是右值引用，即将消亡的值就是右值</span><br><span class="line">//函数返回的临时变量是右值</span><br><span class="line">~IntNum()&#123;//析构函数</span><br><span class="line">delete xptr;</span><br><span class="line">cout &lt;&lt; &quot;Destructing...&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int getInt()&#123; return *xptr;&#125;</span><br><span class="line">private:</span><br><span class="line">int *xptr;</span><br><span class="line">&#125;;</span><br><span class="line">//获取一个对象</span><br><span class="line">IntNum::getNum()</span><br><span class="line">&#123;</span><br><span class="line">IntNum a;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;getNum().getInt()&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">运行结果</span><br><span class="line">Callint constructor……</span><br><span class="line">//进入getNum函数，启动构造函数，创建对象a</span><br><span class="line">Calling move constructor...</span><br><span class="line">//对象a离开函数getNum，启动移动构造函数，将目标a的指针直接转移</span><br><span class="line">Destructing...</span><br><span class="line">//对象a离开函数，本身被析构，清除内存</span><br><span class="line">0</span><br><span class="line">//调出a的副本对应的getInt()函数，输出0</span><br><span class="line">Destructing...</span><br><span class="line">//程序结束，析构副本指针</span><br></pre></td></tr></table></figure>

<h2 id="c风格字符串"><a href="#c风格字符串" class="headerlink" title="c风格字符串"></a>c风格字符串</h2><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><ul>
<li>例：”program”</li>
<li>各字符连续，顺序存放，每一个字符占一个字节，以’\0’结尾，相当于一个隐含创建的字符常量数组。</li>
<li>“progarm”出现在表达式中，表示这一char数组的首地址</li>
<li>首地址可以赋给char常量指针</li>
<li>const char* STRING1&#x3D;”program”;</li>
</ul>
<h3 id="用字符数组表示字符串的缺点"><a href="#用字符数组表示字符串的缺点" class="headerlink" title="用字符数组表示字符串的缺点"></a>用字符数组表示字符串的缺点</h3><ul>
<li>执行链接、拷贝、比较等操作，都需要显式调用库函数，很麻烦</li>
<li>当字符串长度很不确定时，需要用new动态创建字符数组，最后要用delete释放，很繁琐</li>
<li>字符串实际长度大于为它分配的空间时，会产生数组下标越界的错误。</li>
</ul>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="string类常用的构造函数"><a href="#string类常用的构造函数" class="headerlink" title="string类常用的构造函数"></a>string类常用的构造函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string(); //默认构造函数，建立一个长度为0的串</span><br><span class="line">例:</span><br><span class="line">string sl;</span><br><span class="line">string(const char *s); //用指针s指向的的字符串常量初始化string对象</span><br><span class="line">例:</span><br><span class="line">string s2 = &quot;abc&quot;;</span><br><span class="line">string(const string&amp; rhs); //复制构造函数</span><br><span class="line">例:</span><br><span class="line">string s3 = s2;</span><br></pre></td></tr></table></figure>

<h3 id="string类常用操作"><a href="#string类常用操作" class="headerlink" title="string类常用操作"></a>string类常用操作</h3><p>将串s和t连接成一个新串 s+t<br>用t更新s s&#x3D;t</p>
<p>判断s与t是否相等s&#x3D;&#x3D;t<br>判断s与t是否不等s!&#x3D;t<br>判断s是否小于t(按字典顺序比较)<br>S &lt;t<br>判断s是否小于或等于t<br>按字典顺序比较 )<br>S &lt;&#x3D;t七较)<br>趄顺序比较 )<br>判断s是否大于 s&gt;t<br>判断s是否大于或等s&gt;&#x3D;t<br>访问串中下标为i的字s[i]<br>例:<br>string sl &#x3D; “abc”,s2 &#x3D; “def”.<br>string s3&#x3D;s1+s2; &#x2F;&#x2F;结果是”abcdef”<br>bools4&#x3D;(s1&lt;s2); &#x2F;&#x2F;结果是true<br>char s5 &#x3D; s2[1];&#x2F;&#x2F;结果实际上这个加法操作呢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//根据value的值输出true或false</span><br><span class="line">//title为提示文字</span><br><span class="line">inline void test(const char *title. bool</span><br><span class="line">value)</span><br><span class="line">cout &lt;&lt; title &lt;&lt;&quot;returns &quot;</span><br><span class="line">&lt;&lt;(value? &quot;true&quot; : false&quot;)&lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">string s1 = &quot;DEF&quot;:</span><br><span class="line">cout &lt;&lt; “sl is &quot; &lt;&lt; sl &lt;&lt; endl;</span><br><span class="line">string s2:</span><br><span class="line">cout &lt;&lt;&quot;Please enter s2: &quot;;</span><br><span class="line">cin &gt;&gt;s2:</span><br><span class="line">cout &lt;&lt;&quot;length of s2:&quot;&lt;&lt;s2.length() &lt;&lt; endl;</span><br><span class="line">//比较运算符的测试</span><br><span class="line">test(&#x27;s1 &lt;= \&#x27;ABC\&quot;&quot;, s1 &lt;= &quot;ABC&quot;);</span><br><span class="line">test(“\&quot;DEF\&#x27;&lt;= s1°,&quot;DEF&quot; &lt;= s1);</span><br><span class="line">//连接运算符的测试</span><br><span class="line">S2 += s1:</span><br><span class="line">cout &lt;&lt;“s2 = s2 + s1: &quot;&lt;&lt; s2 &lt;&lt; endl:</span><br><span class="line">cout &lt;&lt; &quot;length of s2: &quot;&lt;&lt; s2.length() &lt;&lt; endl;</span><br><span class="line">return 0:</span><br></pre></td></tr></table></figure>

<h3 id="输入整行字符串"><a href="#输入整行字符串" class="headerlink" title="输入整行字符串"></a>输入整行字符串</h3><ul>
<li>getline可以输入整行字符串（要包string头文件）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getline(cin,s2);</span><br></pre></td></tr></table></figure>

<ul>
<li>输入字符串时，可以使用其他分隔符作为字符串结束的标志将分隔符作为getline的第三个参数即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getline(cin,s2,&#x27;,&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">for (int i = 0; i&lt; 2; i++)&#123;</span><br><span class="line">string city, state;</span><br><span class="line">getline(cin, city, &#x27;,&#x27;);</span><br><span class="line">getline(cin, state);</span><br><span class="line">cout &lt;&lt; &quot;City:&quot; &lt;&lt; city &lt;&lt; &quot;</span><br><span class="line">State:&quot;&lt;&lt; state &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第六章小结"><a href="#第六章小结" class="headerlink" title="第六章小结"></a>第六章小结</h2><ul>
<li>数组</li>
<li>指针</li>
<li>动态存储分配</li>
<li>指针与数组</li>
<li>指针与函数</li>
<li>对象的复制与移动</li>
<li>字符串</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>SOPC(7):继承和派生</title>
    <url>/2022/11/04/SPOC%EF%BC%887%EF%BC%89%EF%BC%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/</url>
    <content><![CDATA[<h2 id="导学"><a href="#导学" class="headerlink" title="导学"></a>导学</h2><h2 id="继承的基本概念和语法"><a href="#继承的基本概念和语法" class="headerlink" title="继承的基本概念和语法"></a>继承的基本概念和语法</h2><ul>
<li><p>继承与派生是同一过程从不同的角度看</p>
<ol>
<li>保持已有类的特性而构造新类的过程称为继承。</li>
<li>在已有类的基础上新增自己的特性而产生新类的过程称为派生，</li>
</ol>
</li>
<li><p>被继承的已有类称为基类(或父类)</p>
</li>
<li><p>派生出的新类称为派生类(或子类)。</p>
</li>
<li><p>直接参与派生出某类的基类称为直接基类</p>
</li>
<li><p>基类的基类甚至更高层的基类称为间接基类。</p>
</li>
</ul>
<h3 id="派生的目的"><a href="#派生的目的" class="headerlink" title="派生的目的"></a>派生的目的</h3><ul>
<li>当新的问题出现，原有程序无法解决时，需要对原有程序进行改造。</li>
</ul>
<h3 id="单继承时派生类的定义"><a href="#单继承时派生类的定义" class="headerlink" title="单继承时派生类的定义"></a>单继承时派生类的定义</h3><ul>
<li><p>语法<br>class 派生类名:继承方式 基类名<br>{成员声明;}；</p>
</li>
<li><p>例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* class Derived: public Base</span><br><span class="line">  public:</span><br><span class="line">  Derived ();</span><br><span class="line">  ~Derived ();</span><br><span class="line">  &#125;；</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多继承时派生类的定义"><a href="#多继承时派生类的定义" class="headerlink" title="多继承时派生类的定义"></a>多继承时派生类的定义</h3><ul>
<li><p>语法<br>class 派生类名:继承方式1 基类名1,继承方式2 基类名2<br>{成员声明;}；<br>注意:每一个“继承方式”，只用于限制对紧随其后之基类的继承。</p>
</li>
<li><p>例</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Derived: public Basel, private Base2</span><br><span class="line">public:</span><br><span class="line">Derived ();</span><br><span class="line">~Derived ();</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>

<h3 id="派生类的构成"><a href="#派生类的构成" class="headerlink" title="派生类的构成"></a>派生类的构成</h3><ul>
<li><p>吸收基类成员</p>
</li>
<li><p>改造基类成员</p>
</li>
<li><p>添加新的成员</p>
</li>
</ul>
<h3 id="吸收基类成员"><a href="#吸收基类成员" class="headerlink" title="吸收基类成员"></a>吸收基类成员</h3><ul>
<li><p>默认情况下派生类包含了全部基类中除构造和析构函数之外的所有成员。</p>
</li>
<li><p>C++11规定可以用using语句继承基类构造函数。</p>
</li>
</ul>
<h2 id="基类与派生类类型转换"><a href="#基类与派生类类型转换" class="headerlink" title="基类与派生类类型转换"></a>基类与派生类类型转换</h2><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li><p>共有派生类对象可以被当作基类的对象使用，反之则不可。</p>
<ol>
<li>派生类的对象可以隐含转换为基类对象</li>
<li>派生类的对象可以初始化基类的引用</li>
<li>派生类的指针可以隐含转换基类的指针</li>
</ol>
</li>
<li><p>通过基类对象名，指针只能使用从基类继承的成员。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Base1&#123;//基类1定义</span><br><span class="line">public:</span><br><span class="line">	void display()const</span><br><span class="line">	&#123;</span><br><span class="line">	cout&lt;&lt;&quot;Base1::display()&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base2:public Base1&#123;//派生类Base2定义</span><br><span class="line">public:</span><br><span class="line">	void display() const &#123;cout&lt;&lt;&quot;Base2::display()&quot;&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived:public Base2&#123;//公有派生类Derived定义</span><br><span class="line">public：</span><br><span class="line">void display()const</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;Derived.play()&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void fun(Base1 *ptr)</span><br><span class="line">&#123;</span><br><span class="line">ptr-&gt;display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Base1 base1;//声明Base1类对象</span><br><span class="line">Base2 base2;//声明Base2类对象</span><br><span class="line">Derived derived;//声明Derived类对象</span><br><span class="line"></span><br><span class="line">fun(&amp;base1);//三个对象调用fun函数</span><br><span class="line">fun(&amp;base2);</span><br><span class="line">fun(&amp;derived);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//这样调用的都是Base1的display函数</span><br><span class="line">//需要用虚函数才能解决这个问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="私有继承和保护继承"><a href="#私有继承和保护继承" class="headerlink" title="私有继承和保护继承"></a>私有继承和保护继承</h2><h3 id="私有继承（private）"><a href="#私有继承（private）" class="headerlink" title="私有继承（private）"></a>私有继承（private）</h3><h4 id="继承的访问控制"><a href="#继承的访问控制" class="headerlink" title="继承的访问控制"></a>继承的访问控制</h4><ul>
<li>基类的public和protected成员：都以private身份出现在派生类中；</li>
<li>基类的private成员：不可直接访问</li>
</ul>
<h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><ul>
<li>派生类中的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员；</li>
<li>通过派生类的对象：不能直接访问从基类继承的任何成员。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef _RECTANGLE_H</span><br><span class="line">#define _RECTANGLE_H</span><br><span class="line">#include&quot;Point.h&quot;</span><br><span class="line">class Rectangle:private Point&#123;//派生类定义部分</span><br><span class="line">public://新增共有函数成员</span><br><span class="line">	void initRectangle(float x,float y.float w.float h)</span><br><span class="line">	&#123;</span><br><span class="line">	initPoint(x,y);//调用基类共有成员函数</span><br><span class="line">	this-&gt;w=w;</span><br><span class="line">	this-&gt;h=h;</span><br><span class="line">	&#125;</span><br><span class="line">	void move(float offX,float offY)&#123;Point::move(offX,offY);&#125;</span><br><span class="line">	float getX()const &#123;return Point::getX();&#125;</span><br><span class="line">	float getY()const &#123;return Point::getY();&#125;</span><br><span class="line">	float getH()const &#123;return h;&#125;</span><br><span class="line">	float getW()const &#123;return w;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include Rectangle.h</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">Rectangle rect; //定义Rectangle类的对象</span><br><span class="line">rect.initRectangle(2,3,20,10);//设置矩形的数据</span><br><span class="line">rect.move(3,2); //移动矩形位置</span><br><span class="line">cout &lt;&lt; &quot;The data of rect(x,y,w,h): &quot;&lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; rect.getX() &lt;&lt;&quot;,&quot;</span><br><span class="line">//输出矩形的特征参数</span><br><span class="line">&lt;&lt; rect.getY() &lt;&lt; &quot;,</span><br><span class="line">&lt;&lt; rect.getW() &lt;&lt; &quot;,</span><br><span class="line">&lt;&lt; rect.getH( &lt;&lt; end;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保护继承-protected"><a href="#保护继承-protected" class="headerlink" title="保护继承(protected)"></a>保护继承(protected)</h3><h4 id="继承的访问控制-1"><a href="#继承的访问控制-1" class="headerlink" title="继承的访问控制"></a>继承的访问控制</h4><ul>
<li><p>基类的public和protected成员:都以protected身份出现在派生类中</p>
</li>
<li><p>基类的private成员:不可直接访问</p>
</li>
</ul>
<h4 id="访问权限-1"><a href="#访问权限-1" class="headerlink" title="访问权限"></a>访问权限</h4><ul>
<li><p>派生类中的成员函数:可以直接访问关中的public和protected成员，但不能直接访问基类的private成员:</p>
</li>
<li><p>通过派生类的对象:不能直接访问从基类继承的任何成员</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected 成员的特点与作用</span><br><span class="line">。对建立其所在类对象的模块来说，它与 private 成员的性质相同</span><br><span class="line">对于其派生类来说，它与 public 成员的性质相同,</span><br><span class="line">既实现了数据隐藏，又方便继承，实现代码重用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">protected:</span><br><span class="line">int x;</span><br><span class="line">&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">A a;</span><br><span class="line">a.x=5;//错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">protected;</span><br><span class="line">int x;</span><br><span class="line">&#125;;</span><br><span class="line">class B:public A&#123;</span><br><span class="line">public:</span><br><span class="line">	void function();</span><br><span class="line">&#125;;</span><br><span class="line">void B::function()</span><br><span class="line">&#123;</span><br><span class="line">x=5;//正确</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">void setA(int);</span><br><span class="line">void showA() const;</span><br><span class="line">private:</span><br><span class="line">int a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">void setB(int);</span><br><span class="line">void showB() const;</span><br><span class="line">private:</span><br><span class="line">int b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C : public A, private B &#123;</span><br><span class="line">public:</span><br><span class="line">void setC(int, int, int);</span><br><span class="line">void showC() const;</span><br><span class="line">private const:</span><br><span class="line">int c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void A::setA(int x)&#123;</span><br><span class="line">a=X;</span><br><span class="line">&#125;</span><br><span class="line">void B:setB(int x)&#123;</span><br><span class="line">b=X;</span><br><span class="line">&#125;</span><br><span class="line">void C::setC(int x, int y, int z) &#123;</span><br><span class="line">//派生类成员直接访问基类的</span><br><span class="line">//公有成员</span><br><span class="line">setA(x);</span><br><span class="line">setB(y);</span><br><span class="line">C=Z;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">C obj;</span><br><span class="line">obj.setA(5);</span><br><span class="line">obj.showA();</span><br><span class="line">obj.setC(6,7,9);</span><br><span class="line">obj.showC0;</span><br><span class="line">obj.setB(6);错误</span><br><span class="line">obj.showB(); 错误</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承方式简介及共有继承"><a href="#继承方式简介及共有继承" class="headerlink" title="继承方式简介及共有继承"></a>继承方式简介及共有继承</h2><h2 id="不同继承方式的影响主要体现在"><a href="#不同继承方式的影响主要体现在" class="headerlink" title="不同继承方式的影响主要体现在:"></a>不同继承方式的影响主要体现在:</h2><ul>
<li><p>派生类成员对基类成员的访问权限;</p>
</li>
<li><p>通过派生类对象对基类成员的访问权限。</p>
</li>
</ul>
<h2 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h2><p>公有继承<br>私有继承<br>保护继承</p>
<h2 id="公有继承-public"><a href="#公有继承-public" class="headerlink" title="公有继承(public)"></a>公有继承(public)</h2><h3 id="继承的访问控制-2"><a href="#继承的访问控制-2" class="headerlink" title="继承的访问控制"></a>继承的访问控制</h3><p><strong>基类的public和protected成员</strong>:访问属性在派生类中保持不变<br><strong>基类的private成员</strong>:不可直接访问。</p>
<h3 id="访问权限-2"><a href="#访问权限-2" class="headerlink" title="访问权限"></a>访问权限</h3><p>派生类中的成员函数:可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员<br>通过派生类的对象:只能访问public成员。</p>
<p><img src="https://p.sda1.dev/18/72f2d3f970d68d69376784de327ea7f8/50446767001f7e1e8497e9ede157d0eb.png"></p>
<p><img src="https://p.sda1.dev/18/bb2282a9b163a5286ce979532f3ea08b/2868f075356ccddd175e6611e3897f1a.png"></p>
<h2 id="派生类的构造函数"><a href="#派生类的构造函数" class="headerlink" title="派生类的构造函数"></a>派生类的构造函数</h2><h3 id="默认情况下"><a href="#默认情况下" class="headerlink" title="默认情况下"></a>默认情况下</h3><ul>
<li><p>基类的构造函数不被继承;</p>
</li>
<li><p>派生类需要定义自己的构造函数。</p>
</li>
</ul>
<h3 id="C-11规定"><a href="#C-11规定" class="headerlink" title="C++11规定"></a>C++11规定</h3><ul>
<li><p>可用using语句继承基类构造函数;</p>
</li>
<li><p>但是只能初始化从基类继承的成员。</p>
</li>
<li><p>语法形式:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> B::B;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果想要定制自己的成员，那么最好自己去书写构造函数。</p>
<h3 id="若不继承基类的构造函数"><a href="#若不继承基类的构造函数" class="headerlink" title="若不继承基类的构造函数"></a>若不继承基类的构造函数</h3><ul>
<li>派生类新增成员：派生类定义构造函数进行初始化</li>
<li>继承来的成员：自动调用基类的构造函数进行初始化</li>
<li>派生类的构造函数需要给基类的构造函数传递参数</li>
</ul>
<p>单继承时构造函数的定义语法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">派生类名::派生类名(基类所需要的形参，本类成员所需的形参)</span><br><span class="line">	基类名(参数表)，本类成员初始化列表</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//其他初始化;</span></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>();</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i);</span><br><span class="line">    ~<span class="built_in">B</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">B:<span class="built_in">B</span>()</span><br><span class="line">&#123;</span><br><span class="line">    b=<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;B&#x27;s default constructor called&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">B::~<span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B&#x27;s destructor called&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B::print</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:publicB</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>();</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> i,<span class="type">int</span> j);</span><br><span class="line">    ~<span class="built_in">C</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line">C:<span class="built_in">C</span>()</span><br><span class="line">&#123;</span><br><span class="line">    c=<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;C&#x27;s default constructor called&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">C::~<span class="built_in">C</span>()&#123;cout&lt;&lt;<span class="string">&quot;C&#x27;s destructor called&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">obj</span><span class="params">(<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多继承情况下派生类的构造函数"><a href="#多继承情况下派生类的构造函数" class="headerlink" title="多继承情况下派生类的构造函数"></a>多继承情况下派生类的构造函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">派生类名::派生类名(参数表):</span><br><span class="line">基类名<span class="number">1</span>(基类<span class="number">1</span>初始化参数表),</span><br><span class="line">基类名<span class="number">2</span>(基类<span class="number">2</span>初始化参数表),</span><br><span class="line">基类名<span class="built_in">n</span>(基类n初始化参数表),</span><br><span class="line">本类成员初始化列表</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//其他初始化；</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="派生类与基类的构造函数"><a href="#派生类与基类的构造函数" class="headerlink" title="派生类与基类的构造函数"></a>派生类与基类的构造函数</h3><ul>
<li><h4 id="当基类有默认构造函数是"><a href="#当基类有默认构造函数是" class="headerlink" title="当基类有默认构造函数是"></a>当基类有默认构造函数是</h4></li>
<li><p>派生类构造函数可以不向基类构造函数传递参数</p>
</li>
<li><p>构造派生类的对象时，基类的默认构造函数将被调用</p>
</li>
<li><h4 id="如需执行基类中带参数的构造函数"><a href="#如需执行基类中带参数的构造函数" class="headerlink" title="如需执行基类中带参数的构造函数"></a>如需执行基类中带参数的构造函数</h4></li>
<li><p>派生类构造函数应为基类构造函数提供参数</p>
</li>
</ul>
<h3 id="构造函数的执行顺序"><a href="#构造函数的执行顺序" class="headerlink" title="构造函数的执行顺序"></a>构造函数的执行顺序</h3><h4 id="调用基类构造函数"><a href="#调用基类构造函数" class="headerlink" title="调用基类构造函数"></a>调用基类构造函数</h4><ul>
<li>顺序按照它们被继承时声明的顺序（从左往右）</li>
</ul>
<h4 id="对初始化列表中的成员进行初始化"><a href="#对初始化列表中的成员进行初始化" class="headerlink" title="对初始化列表中的成员进行初始化"></a>对初始化列表中的成员进行初始化</h4><ul>
<li>按照它们在类中的成员进行初始化</li>
<li>对象成员初始化时自动调用其所属类的构造函数（由初始化列表提供参数）</li>
</ul>
<h4 id="执行派生类的构造函数体中的内容"><a href="#执行派生类的构造函数体中的内容" class="headerlink" title="执行派生类的构造函数体中的内容"></a>执行派生类的构造函数体中的内容</h4><h3 id="派生类构造函数的举例"><a href="#派生类构造函数的举例" class="headerlink" title="派生类构造函数的举例"></a>派生类构造函数的举例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Base1</span><span class="params">()</span></span>&#123;<span class="built_in">Base1</span>(<span class="type">int</span> i);&#125;;</span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Base2</span><span class="params">()</span></span>&#123;<span class="built_in">Base2</span>(<span class="type">int</span> j);&#125;;</span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Base3</span><span class="params">()</span></span>&#123;<span class="built_in">Base3</span>();&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base2,<span class="keyword">public</span> Base1,<span class="keyword">public</span> Base <span class="number">3</span></span><br><span class="line">&#123;<span class="comment">//派生新类Derived，注意类名的顺序</span></span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//派生类的共有成员</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c):<span class="built_in">Base1</span>(a),<span class="built_in">member2</span>(d),<span class="built_in">menber1</span>(c),<span class="built_in">Base2</span>(b)&#123;&#125;</span><br><span class="line">    <span class="comment">//注意基类名的个数和顺序，注意成员对象名的个数与顺序</span></span><br><span class="line">    <span class="keyword">private</span>:<span class="comment">//派生类的私有成员对象</span></span><br><span class="line">    Base1 merber1;</span><br><span class="line">    Base2 merber2;</span><br><span class="line">    Base3 merber3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">obj</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="派生类的复制构造函数"><a href="#派生类的复制构造函数" class="headerlink" title="派生类的复制构造函数"></a>派生类的复制构造函数</h3><p>若派生类没有声明复制构造函数</p>
<ul>
<li>编译器会在需要的时候生成一个隐含的复制构造函数</li>
<li>先调用基类的复制构造函数</li>
<li>再为派生类新增的成员执行复制</li>
</ul>
<p>若派生类定义了复制构造函数</p>
<ul>
<li>一般都要为基类的复制构造函数传递参数</li>
<li>复制构造函数都只能接受一个参数，既用来初始化派生类定义的成员，也将被传递给基类的复制构造函数</li>
<li>基类的复制构造函数形参类型时基类对象的引用，实参可以是派生类对象的引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C::C(const C&amp;c1):B(c1)&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们从前面学习的知识可以知道，我们对象的引用最后都可以指向基类的对象</p>
</blockquote>
<h3 id="派生类的析构函数"><a href="#派生类的析构函数" class="headerlink" title="派生类的析构函数"></a>派生类的析构函数</h3><ul>
<li>析构函数无法被继承，必要的时候需要自己去书写</li>
<li>声明方式与无继承关系的函数一样</li>
<li>不需要主动去调用基类的析构函数（系统会代劳）</li>
<li>先执行派生类析构函数的函数体，再调用基类的析构函数</li>
</ul>
<h3 id="派生类对象析构举例"><a href="#派生类对象析构举例" class="headerlink" title="派生类对象析构举例"></a>派生类对象析构举例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Base1</span>(<span class="type">int</span> i)&#123;cout&lt;&lt;<span class="string">&quot;1g\n&quot;</span>;&#125;</span><br><span class="line"><span class="comment">//基础构造函数</span></span><br><span class="line">	~<span class="built_in">Base1</span>()&#123;cout&lt;&lt;<span class="string">&quot;1x\n&quot;</span>;&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>(<span class="type">int</span> j)&#123;cout&lt;&lt;<span class="string">&quot;2g\n&quot;</span>;&#125;</span><br><span class="line">    ~<span class="built_in">Base2</span>()&#123;cout&lt;&lt;<span class="string">&quot;2x\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base3</span>()&#123;cout&lt;&lt;<span class="string">&quot;3g\n&quot;</span>;&#125;</span><br><span class="line">    ~<span class="built_in">Base3</span>()&#123;cout&lt;&lt;<span class="string">&quot;3x\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base2,<span class="keyword">public</span> Base1,<span class="keyword">public</span> Base3 &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d):<span class="built_in">Base1</span>(a),<span class="built_in">member2</span>(d),<span class="built_in">member1</span>(c),<span class="built_in">Base2</span>(b)&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Base1 member1;</span><br><span class="line">    Base2 member2;</span><br><span class="line">    Base3 member3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">obj</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问从基类继承的成员"><a href="#访问从基类继承的成员" class="headerlink" title="访问从基类继承的成员"></a>访问从基类继承的成员</h3><h4 id="作用域限定"><a href="#作用域限定" class="headerlink" title="作用域限定"></a>作用域限定</h4><p>当派生类与基类有相同成员时：</p>
<ul>
<li>若未特别限定，则通过派生类对象使用的时派生类中的同名成员</li>
<li>如要通过派生类对象访问基类中被隐藏的同名对象，应使用基类名和作用域操作符(::)来限定</li>
</ul>
<h3 id="多继承同名隐藏举例"><a href="#多继承同名隐藏举例" class="headerlink" title="多继承同名隐藏举例"></a>多继承同名隐藏举例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;m1\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;m2\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;md\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    Derived *p=&amp;d;</span><br><span class="line">    <span class="comment">//访问Derived类中的成员变量</span></span><br><span class="line">    d.var=<span class="number">1</span>;</span><br><span class="line">    d.<span class="built_in">fun</span>();</span><br><span class="line">    <span class="comment">//访问Base1类中的成员变量</span></span><br><span class="line">    d.Base1::var=<span class="number">2</span>;</span><br><span class="line">    d.Base1::<span class="built_in">fun</span>();</span><br><span class="line">    <span class="comment">//访问Base2类中的成员变量</span></span><br><span class="line">    d.Base2::var=<span class="number">3</span>;</span><br><span class="line">    d.Base2::<span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二义性问题"><a href="#二义性问题" class="headerlink" title="二义性问题"></a>二义性问题</h3><ul>
<li><p>如果从不同的基类继承了同名成员，但是再派生类中没有定义同名成员，“派生类对象名或引用名，成员名”、“派生类指针-&gt;成员名”访问成员存在二义性问题。</p>
</li>
<li><p>解决方式：用类名限定</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;<span class="keyword">public</span>:<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;<span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;&#125;;</span><br><span class="line"><span class="comment">//如果定义C c1,那么c1.f()具有二义性</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base0</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: <span class="type">int</span> var0;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun0</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>: <span class="keyword">public</span> Base0&#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//外部接口</span></span><br><span class="line">    <span class="type">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>: <span class="keyword">public</span> Base0&#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//外部接口</span></span><br><span class="line">    <span class="type">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Member of Derived&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.Base1::var0=<span class="number">2</span>;</span><br><span class="line">    d.Base1::<span class="built_in">fun0</span>();</span><br><span class="line">    d.Base2::var0=<span class="number">3</span>;</span><br><span class="line">    d.Base2::<span class="built_in">fun0</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Derived类对象d的存储结构示意图</p>
<p><img src="https://p.sda1.dev/18/cf7c5e1488272f0990eb30c2f8d96221/8f90affba196eb508fec6d073e25e63b.png" alt="https://p.sda1.dev/18/cf7c5e1488272f0990eb30c2f8d96221/8f90affba196eb508fec6d073e25e63b.png"></p>
<h3 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h3><h4 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h4><ul>
<li><p>当派生类从多个基类派生，而这些基类又共同基类，则在访问此共同基类中的成员时，将产生冗余，并可能因为冗余而带来不一致性。</p>
</li>
<li><p>以virtual来说明基类的类继承方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> B;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主要用来解决多继承问题时可能发生的对同一基类继承多次而产生的二义性问题</p>
</li>
<li><p>为最远的派生类提供唯一的基类对象，而不产生多次复制</p>
</li>
<li><p>在第一级继承的时候就要将共同基类设计为虚基类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var0;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Base0 fun()\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Base0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Base0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Derived fun()\n&quot;</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.var0=<span class="number">2</span>;</span><br><span class="line">    d.<span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚基类继承就不用再调基类的函数</p>
<h3 id="虚基类及其派生类构造函数"><a href="#虚基类及其派生类构造函数" class="headerlink" title="虚基类及其派生类构造函数"></a>虚基类及其派生类构造函数</h3></li>
</ul>
<p>​	建立对象时所指定的类指称为最远派生类</p>
<p>虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。</p>
<p>​	在整个继承机构中，直接或间接继承虚基类所有的派生类，都必须在构造函数的成员初始化列表中为虚基类的构造函数列出来参数，如果未列出，则表示调用的是该虚基类的默认构造函数。</p>
<p>​	在建立对象时，只有最远派生类的调用虚基类的构造函数，其他类对虚基类构造函数的调用被忽略。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base0</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base0</span>(<span class="type">int</span> var):<span class="built_in">var0</span>(var)&#123;&#125;</span><br><span class="line">    <span class="type">int</span> var0;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun0</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Base0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>(<span class="type">int</span> var):<span class="built_in">Base0</span>(var)&#123;cout&lt;&lt;<span class="string">&quot;Base1 constructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">    <span class="type">int</span> var1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Base0</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>(<span class="type">int</span> var):<span class="built_in">Base0</span>(var)&#123;&#125;</span><br><span class="line">    <span class="type">int</span> var2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> var):<span class="built_in">Base0</span>(var),<span class="built_in">Base1</span>(var),<span class="built_in">Base2</span>(var)&#123;&#125;</span><br><span class="line">    <span class="type">int</span> var;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    d.var0=<span class="number">2</span>;</span><br><span class="line">    d.<span class="built_in">fun0</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>继承和派生的基本概念</p>
<p>单继承和多继承</p>
<p>类成员的访问控制</p>
<p>派生类对象的构造和析构</p>
<p>派生类与基类对象的类型转换</p>
<p>类对象的标识与访问</p>
<p>虚继承</p>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOC(9)：模板和群体数据（Templates and population data）</title>
    <url>/2022/11/09/SPOC%EF%BC%889%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%BE%A4%E4%BD%93%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="本章主要内容（The-main-content-of-this-chapter-）"><a href="#本章主要内容（The-main-content-of-this-chapter-）" class="headerlink" title="本章主要内容（The main content of this chapter:）"></a>本章主要内容（The main content of this chapter:）</h2><ul>
<li>函数模板与类模板（Function templates and class templates）</li>
<li>线性群体（Linear populations）</li>
<li>群体数据的组织（Organization of population data）</li>
</ul>
<h2 id="函数模板（Function-templates）"><a href="#函数模板（Function-templates）" class="headerlink" title="函数模板（Function templates）"></a>函数模板（Function templates）</h2><ul>
<li>如果重载的函数，其解决问题的逻辑是一致的，函数体语句相同，只是处理的数据类型不同，那么写多个相同的函数体，是重复劳动，而且还可能因为代码的冗余造成不一致性。</li>
</ul>
<p>If the logic of solving the problem of the overloaded function is the same, the function body statement is the same, but the data type is different, then writing multiple identical function bodies is repetitive work, and it may also cause inconsistency due to the redundancy of the code.</p>
<ul>
<li>解决：使用模板</li>
</ul>
<p>Solve: Use a template</p>
<h3 id="求绝对值函数的模板（A-template-for-finding-an-absolute-value-function）"><a href="#求绝对值函数的模板（A-template-for-finding-an-absolute-value-function）" class="headerlink" title="求绝对值函数的模板（A template for finding an absolute value function）"></a>求绝对值函数的模板（A template for finding an absolute value function）</h3><ul>
<li>整数类型和浮点数类型求绝对值的算法，需要写两种重载函数吗？</li>
</ul>
<p>Do I need to write two overloaded functions for the algorithm of finding absolute values of integer type and floating-point number?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;<span class="number">0</span>?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">abs</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;<span class="number">0</span>?-x:x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决：函数模板</li>
</ul>
<p>Solve: Use a template</p>
<blockquote>
<p>创建一个通用功能的函数；</p>
<p>支持多种不同形参</p>
<p>简化重载函数的函数体设计</p>
<p>create a function with a generic function;</p>
<p>A variety of different parameters are supported</p>
<p>Simplify the design of the function body of overloaded functions</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">abs</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;<span class="number">0</span>?-x:x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">abs</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&lt;<span class="number">0</span>?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> d=<span class="number">5.5</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">abs</span>(n)&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">abs</span>(d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出（output）：</p>
<h3 id="函数模板定义语法（Function-template-definition-syntax）"><a href="#函数模板定义语法（Function-template-definition-syntax）" class="headerlink" title="函数模板定义语法（Function template definition syntax）"></a>函数模板定义语法（Function template definition syntax）</h3><ul>
<li>语法形式</li>
</ul>
<p>Grammatical forms</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;模板参数表（Template parameter table）&gt;</span><br><span class="line">函数定义（Function definition）</span><br></pre></td></tr></table></figure>

<ul>
<li>+模板参数表的内容（The contents of the template parameter table）</li>
</ul>
<blockquote>
<p>类型参数：class(或typename)标识符</p>
<p>常量参数：类型说明符 标识符</p>
<p>模板参数：template&lt;参数表&gt;class 标识符</p>
<p>Type parameter：class (or typename) identifieri</p>
<p>Constant parameter: Type Specifier Identifier</p>
<p>Template parameter：template<Parameter table>class identifier</Parameter></p>
</blockquote>
<p>输出：</p>
<p><img src="https://p.sda1.dev/18/abc308c1784bcd1987d39fd3af2cce49/006cb046ab052d647eee387c91e99d71.png"></p>
<h3 id="函数模板的示例（An-example-of-a-function-template）"><a href="#函数模板的示例（An-example-of-a-function-template）" class="headerlink" title="函数模板的示例（An example of a function template）"></a>函数模板的示例（An example of a function template）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//定义函数模板 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outputArray</span><span class="params">(<span class="type">const</span> T *array, <span class="type">int</span> count)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line"> cout &lt;&lt; array[i] &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line"> <span class="comment">//如果数组元素是类的对象，需要该对象所属类重载了流插入运算符“&lt;&lt;”</span></span><br><span class="line"> <span class="comment">//If the array element is an object of a class, the stream insertion operator needs to be overloaded with the class to which the object belongs“&lt;&lt;”</span></span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> A_COUNT = <span class="number">8</span>, B_COUNT = <span class="number">8</span>, C_COUNT = <span class="number">20</span>; </span><br><span class="line"><span class="type">int</span> a [A_COUNT] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;; </span><br><span class="line"><span class="type">double</span> b[B_COUNT] = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span>, <span class="number">7.7</span>, <span class="number">8.8</span> &#125;; </span><br><span class="line"><span class="type">char</span> c[C_COUNT] = <span class="string">&quot;Welcome!&quot;</span>; </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot; a array contains:&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="built_in">outputArray</span>(a, A_COUNT); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot; b array contains:&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="built_in">outputArray</span>(b, B_COUNT); </span><br><span class="line"> cout &lt;&lt; <span class="string">&quot; c array contains:&quot;</span> &lt;&lt; endl; </span><br><span class="line"> <span class="built_in">outputArray</span>(c, C_COUNT); </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="https://p.sda1.dev/18/462884f4a8760f7007c8e2b2aeff1a2d/5a1589463899fadad249d0379fc29a77.png"></p>
<p>注意(Notice)：</p>
<ul>
<li><p>一个函数模板并非自动可以处理所有类型的数据</p>
</li>
<li><p>只有能够进行函数模板中运算的类型，可以作为类型实参</p>
</li>
<li><p>自定义的类，需要重载模板中的运算符，才能作为类型实参</p>
</li>
<li><p>A function template may not automatically handle all types of data</p>
</li>
<li><p>Only types that can be used for operations in the function template can be used as type arguments</p>
</li>
<li><p>Custom classes need to be overloaded with operators from the template to be used as type arguments</p>
</li>
</ul>
<h2 id="类模板-Class-templates"><a href="#类模板-Class-templates" class="headerlink" title="类模板(Class templates)"></a>类模板(Class templates)</h2><h3 id="类模板的作用-The-role-of-class-templates"><a href="#类模板的作用-The-role-of-class-templates" class="headerlink" title="类模板的作用(The role of class templates)"></a>类模板的作用(The role of class templates)</h3><ul>
<li>使用类模板使用户可以为类声明一种模式，使得类中的某些数据成员、某些成员函数的参数、某些成员函数的返回值、能取任意类型（包括基本类型的和用户自定义类型）</li>
<li>Using a class template allows the user to declare a schema for the class so that some of the data members in the class, the parameters of some member functions, the return values of some member functions, and the ability to take any type (including basic types and user-defined types).</li>
</ul>
<h3 id="类模板的声明-A-declaration-of-a-class-template"><a href="#类模板的声明-A-declaration-of-a-class-template" class="headerlink" title="类模板的声明(A declaration of a class template)"></a>类模板的声明(A declaration of a class template)</h3><ul>
<li>类模板(Class template)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tamplate &lt;模板参数表（Template parameter table）&gt;</span><br><span class="line"><span class="keyword">class</span> 类名（Class name）</span><br><span class="line">&#123;类成员声明（Class member declaration）&#125;；</span><br></pre></td></tr></table></figure>

<ul>
<li>如果需要在类模板以外定义其成员函数，则要采用以下的形式：</li>
</ul>
<p>If you need to define its member functions outside of the class template, you need to do so in the following form:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;模板参数表（tamplate parameter table）&gt;</span><br><span class="line">类型名（<span class="keyword">typename</span>） </span><br><span class="line">类名（<span class="keyword">class</span> <span class="title class_">name</span>）&lt;模板参数标识符列表（A list of <span class="keyword">template</span> parameter identifiers）&gt;:</span><br><span class="line">函数名（function name）(参数表（parameter table）)</span><br></pre></td></tr></table></figure>

<h4 id="类模板示例（An-example-of-a-class-template）"><a href="#类模板示例（An-example-of-a-class-template）" class="headerlink" title="类模板示例（An example of a class template）"></a>类模板示例（An example of a class template）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">float</span> gpa;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    T item;</span><br><span class="line">    <span class="type">bool</span> haveValue;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Store</span>();</span><br><span class="line">    <span class="function">T &amp;<span class="title">getElem</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">putElem</span><span class="params">(<span class="type">const</span> T &amp;x)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T &amp;Store&lt;T&gt;::<span class="built_in">getElem</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(!haveValue)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No item present!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Store&lt;T&gt;::<span class="built_in">putElem</span>(<span class="type">const</span> T &amp;x)&#123;</span><br><span class="line">    item=x;</span><br><span class="line">    haveValue=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Store&lt;<span class="type">int</span>&gt; s1,s2;</span><br><span class="line">    s1.<span class="built_in">putElem</span>(<span class="number">10</span>);</span><br><span class="line">    s2.<span class="built_in">putElem</span>(<span class="number">20</span>);</span><br><span class="line">    cout&lt;&lt;s1.<span class="built_in">getElem</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;s2.<span class="built_in">getElem</span>()&lt;&lt;endl;</span><br><span class="line">    Student g=&#123;<span class="number">1000</span>,<span class="number">23</span>&#125;;</span><br><span class="line">    Store&lt;Student&gt; s3;</span><br><span class="line">    s3.<span class="built_in">putElem</span>(g);</span><br><span class="line">    cout&lt;&lt;s3.<span class="built_in">getElem</span>().id&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;s3.<span class="built_in">getElem</span>().gpa&lt;&lt;endl;</span><br><span class="line">    Store&lt;<span class="type">double</span>&gt; d;</span><br><span class="line">    cout&lt;&lt;d.<span class="built_in">getElem</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个代码没有出现问题但是在编译的过程中却出错了</p>
</blockquote>
<h2 id="线性群体的概念（The-concept-of-a-linear-group）"><a href="#线性群体的概念（The-concept-of-a-linear-group）" class="headerlink" title="线性群体的概念（The concept of a linear group）"></a>线性群体的概念（The concept of a linear group）</h2><ul>
<li>群体是指由多个数据元素组成的集合体。群体可以分为两个大类：<strong>线性群体</strong>和<strong>非线性群体</strong></li>
</ul>
<p>A population is a collection of multiple data elements. Populations can be divided into two broad categories: linear groups and nonlinear groups</p>
<ul>
<li>线性群体中的元素按位置排列有序，可以区分按顺序。</li>
</ul>
<p>The elements in a linear group are arranged in an orderly manner by position and can be distinguished by order.</p>
<ul>
<li>非线性群体不用位置顺序来标识元素。</li>
</ul>
<p>Nonlinear groups do not identify elements in a positional order.</p>
<ul>
<li>线性群体中的元素次序与其逻辑位置关系是对应的。在线性群体中，可以按照访问的不同方法分为<strong>直接访问</strong>、<strong>顺序访问</strong>和<strong>索引访问</strong></li>
</ul>
<p>The order of elements in a linear group corresponds to their logical positional relationships. In a linear population, it can be divided into direct access, sequential access, and index access according to different methods of access</p>
<h2 id="数组类模板（Array-class-templates）"><a href="#数组类模板（Array-class-templates）" class="headerlink" title="数组类模板（Array class templates）"></a>数组类模板（Array class templates）</h2><ul>
<li>静态数组具有固定元素个数的群体，其中的元素可以通过下标直接访问。（大小在编译的时候就确定了，在运行时无法修改）</li>
</ul>
<p>Static arrays have groups with a fixed number of elements, the elements of which can be accessed directly via subscripts. (The size is determined at compile time and cannot be modified at runtime)</p>
<ul>
<li>动态数组由一系列位置连续的，任意数量相同类型的元素组成（其元素个数可以在程序运行时改变）</li>
</ul>
<p>A dynamic array consists of a series of consecutive, any number of elements of the same type (the number of which can be changed while the program is running)</p>
<ul>
<li>vector就是用类模板实现的动态数组</li>
</ul>
<p>vector is a dynamic array implemented with a class template</p>
<h3 id="动态数组类模板程序（Dynamic-array-class-templater）"><a href="#动态数组类模板程序（Dynamic-array-class-templater）" class="headerlink" title="动态数组类模板程序（Dynamic array class templater）"></a>动态数组类模板程序（Dynamic array class templater）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ARRSY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARRSY_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T* list;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Array</span>(<span class="type">int</span> sz=<span class="number">50</span>);<span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">Array</span>(<span class="type">const</span> Array&lt;T&gt;&amp;a);<span class="comment">//拷贝构造函数</span></span><br><span class="line">        ~<span class="built_in">Array</span>();<span class="comment">//析构函数</span></span><br><span class="line">        Array&lt;T&gt;&amp;<span class="keyword">operator</span>=(<span class="type">const</span> Array&lt;T&gt;&amp;rhs);</span><br><span class="line">        T&amp;<span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line">        <span class="type">const</span> T &amp;<span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span>;</span><br><span class="line">        <span class="keyword">operator</span> T*();</span><br><span class="line">        <span class="keyword">operator</span> <span class="type">const</span> T*() <span class="type">const</span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> sz)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//数组类模板定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; Array&lt;T&gt;::<span class="built_in">Array</span>(<span class="type">int</span> sz)&#123;</span><br><span class="line">    <span class="built_in">assert</span>(sz&gt;=<span class="number">0</span>);</span><br><span class="line">    size=sz;</span><br><span class="line">    list =<span class="keyword">new</span> T[size];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态分配size个T类型的元素空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;Array&lt;T&gt;::~<span class="built_in">Array</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Array&lt;T&gt;::<span class="built_in">Array</span>(<span class="type">const</span> Array&lt;T&gt; &amp;a)&#123;</span><br><span class="line">    size=a.<span class="built_in">size</span>();</span><br><span class="line">    list=<span class="keyword">new</span> T[size];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list[i]=a.list[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复制构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Array&lt;T&gt;&amp;Array&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> Array&lt;T&gt;&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;rhs!=<span class="keyword">this</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(size!=rhs.size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] list;</span><br><span class="line">            size=rhs.size;</span><br><span class="line">            list=<span class="keyword">new</span> T[size];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            list[i]=rhs.list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载“=”运算符，将对象rhs复制给本对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T &amp;Array&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">assert</span>(n&gt;=<span class="number">0</span> &amp;&amp;n&lt;size);</span><br><span class="line">    <span class="keyword">return</span> list[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载下标运算符，实现与普通数组一样通过下标访问元素，具有越界检查功能</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">const</span> T </span><br><span class="line">&amp;Array&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> n)<span class="type">const</span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(n&gt;=<span class="number">0</span>&amp;&amp;n&lt;size);</span><br><span class="line"><span class="keyword">return</span> list[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; Array&lt;T&gt;::<span class="keyword">operator</span> T*() &#123;<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载“*”运算符，实现将Array&lt;T&gt;对象转换为T*类型指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> Array&lt;T&gt;::<span class="built_in">getSize</span>()<span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取当前数组的大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="type">void</span> Array&lt;T&gt;::<span class="built_in">resize</span>(<span class="type">int</span> sz)&#123;</span><br><span class="line">    <span class="built_in">assert</span>(sz&gt;=<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sz==size) <span class="keyword">return</span>;</span><br><span class="line">    T*newlist=<span class="keyword">new</span> T[sz];</span><br><span class="line">    <span class="type">int</span> n=(sz&lt;size)?sz:size;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    newlist[i]=list[i];</span><br><span class="line">    <span class="keyword">delete</span>[]list;</span><br><span class="line">    list=newlist;</span><br><span class="line">    size=sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将数组大小修改为sz</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Array.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Array&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> n,count=<span class="number">0</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter the elements of the array: &quot;</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> isPrism=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;count;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%a[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                isPrism=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isPrism)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count==a.<span class="built_in">getSize</span>())a.<span class="built_in">resize</span>(count*<span class="number">2</span>);</span><br><span class="line">                a[count++]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">setw</span>(<span class="number">8</span>)&lt;&lt;a[i];</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表的概念与结点类模板（The-concept-of-linked-lists-and-node-class-templates）"><a href="#链表的概念与结点类模板（The-concept-of-linked-lists-and-node-class-templates）" class="headerlink" title="链表的概念与结点类模板（The concept of linked lists and node class templates）"></a>链表的概念与结点类模板（The concept of linked lists and node class templates）</h2><h3 id="顺序访问的线性群体-链表类（Sequentially-accessed-linear-population-linked-list-classes）"><a href="#顺序访问的线性群体-链表类（Sequentially-accessed-linear-population-linked-list-classes）" class="headerlink" title="顺序访问的线性群体-链表类（Sequentially accessed linear population-linked list classes）"></a>顺序访问的线性群体-链表类（Sequentially accessed linear population-linked list classes）</h3><ul>
<li>链表是一种动态数据结构，可以用来表示顺序访问的线性群体</li>
</ul>
<p>A linked list is a dynamic data structure that can be used to represent linear groups of sequential accesses</p>
<ul>
<li>链表是由系列结点组成的，结点可以在运行时动态生成</li>
</ul>
<p>A linked list is made up of a series of nodes, which can be dynamically generated at runtime</p>
<ul>
<li>每个结点包括数据域和指向链表下一个结点的指针（即下一个结点的地址）</li>
</ul>
<p>Each node includes a data field and a pointer to the next node in the linked list (i.e., the address of the next node)</p>
<p>如果链表每个结点中只有一个指向后继结点的指针，则该链表称为单链表</p>
<p>If a linked list has only one pointer to a successor node in each node, the linked list is called a singly linked list。</p>
<p><img src="https://p.sda1.dev/18/98b46e9ca7dc7aa284f89d90672ee996/e0619a759e0c50f9f1c5d7b8e0d2d76a.png"></p>
<h3 id="单链表的结点类模板（Node-class-template-for-a-singly-linked-list）"><a href="#单链表的结点类模板（Node-class-template-for-a-singly-linked-list）" class="headerlink" title="单链表的结点类模板（Node class template for a singly linked list）"></a>单链表的结点类模板（Node class template for a singly linked list）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">  Node&lt;T&gt; *next; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  T data;  </span><br><span class="line">  <span class="built_in">Node</span>(<span class="type">const</span> T&amp; item,Node&lt;T&gt;* next = <span class="number">0</span>); </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">insertAfter</span><span class="params">(Node&lt;T&gt; *p)</span></span>; </span><br><span class="line">  <span class="function">Node&lt;T&gt; *<span class="title">deleteAfter</span><span class="params">()</span></span>; </span><br><span class="line">  <span class="function">Node&lt;T&gt; *<span class="title">nextNode</span><span class="params">()</span> <span class="type">const</span></span>; </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h3 id="在结点后插入一个结点（Inserts-a-node-after-the-node）"><a href="#在结点后插入一个结点（Inserts-a-node-after-the-node）" class="headerlink" title="在结点后插入一个结点（Inserts a node after the node）"></a>在结点后插入一个结点（Inserts a node after the node）</h3><p><img src="https://p.sda1.dev/18/c053c2c0c4ecdf98b7d075d1f5af29e9/7eee1610bad70108233e04fb04c36658.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Node&lt;T&gt;::<span class="built_in">insertAfter</span>(Node&lt;T&gt;*p)&#123;</span><br><span class="line">    p-&gt;next=next;</span><br><span class="line">    next=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除结点之后的结点（Delete-the-node-after-the-node-）"><a href="#删除结点之后的结点（Delete-the-node-after-the-node-）" class="headerlink" title="删除结点之后的结点（Delete the node after the node ）"></a>删除结点之后的结点（Delete the node after the node ）</h3><p><img src="https://p.sda1.dev/18/ecc7c7711b8c7aa3f754b779f7486e1a/1a617c0aba9c24af76b1dff86491daa2.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Node&lt;T&gt;*Node&lt;T&gt;::<span class="built_in">deleteAfter</span>(<span class="type">void</span>)&#123;</span><br><span class="line">    Node&lt;T&gt;*temPtr=next;</span><br><span class="line">    <span class="keyword">if</span>(next==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    next=temptr-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> temPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NODE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_H</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Node&lt;T&gt;*next;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    T data;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> T &amp;data,Node&lt;T&gt;*next=<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertAfter</span><span class="params">(Node&lt;T&gt;*p)</span></span>;</span><br><span class="line">    <span class="function">Node&lt;T&gt;*<span class="title">deleteAfter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Node&lt;T&gt;*<span class="title">nextNode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> Node&lt;T&gt;*<span class="title">nextNode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类模板的实现部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Node&lt;T&gt;*Node&lt;T&gt;::<span class="built_in">nextNode</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回后继结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">const</span> Node&lt;T&gt;*Node&lt;T&gt;::<span class="built_in">nextNode</span>() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回后继结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Node&lt;T&gt;::<span class="built_in">insertAfter</span>(Node&lt;T&gt;*p)&#123;</span><br><span class="line">    p-&gt;next=next;</span><br><span class="line">    next=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在当前结点之后插入一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;Node&lt;T&gt;*Node&lt;T&gt;::<span class="built_in">deleteAfter</span>()&#123;</span><br><span class="line">    Node&lt;T&gt;*temPtr=next;</span><br><span class="line">    <span class="keyword">if</span>(next==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    next=temPtr-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> temPtr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除q指向的结点，并返回其后继结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意不要重复定义构造函数</p>
<p>Be careful not to define the constructor repeatedly</p>
</blockquote>
<ul>
<li>Node.h</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NODE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_H</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Node&lt;T&gt;*next;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    T data;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> T &amp;data,Node&lt;T&gt;*next=<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertAfter</span><span class="params">(Node&lt;T&gt;*p)</span></span>;</span><br><span class="line">    <span class="function">Node&lt;T&gt;*<span class="title">deleteAfter</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Node&lt;T&gt;*<span class="title">nextNode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> Node&lt;T&gt;*<span class="title">nextNode</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类模板的实现部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Node&lt;T&gt;*Node&lt;T&gt;::<span class="built_in">nextNode</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回后继结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">const</span> Node&lt;T&gt;*Node&lt;T&gt;::<span class="built_in">nextNode</span>() <span class="type">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回后继结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Node&lt;T&gt;::<span class="built_in">insertAfter</span>(Node&lt;T&gt;*p)&#123;</span><br><span class="line">    p-&gt;next=next;</span><br><span class="line">    next=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在当前结点之后插入一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;Node&lt;T&gt;*Node&lt;T&gt;::<span class="built_in">deleteAfter</span>()&#123;</span><br><span class="line">    Node&lt;T&gt;*temPtr=next;</span><br><span class="line">    <span class="keyword">if</span>(next==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    next=temPtr-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> temPtr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除next指向的结点，并返回其后继结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Node&lt;T&gt;::<span class="built_in">deleteNode</span>()&#123;</span><br><span class="line">    <span class="built_in">delete</span>(<span class="keyword">this</span>-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<ul>
<li>LinkedList.h</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LINKEDLIST_H </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LINKEDLIST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Node.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123; </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt;*front,*rear;</span><br><span class="line">    Node&lt;T&gt;*prevPtr,*currPtr;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> position;</span><br><span class="line">    <span class="function">Node&lt;T&gt; *<span class="title">newNode</span><span class="params">(<span class="type">const</span> T &amp;item,Node&lt;T&gt;*ptrNext=<span class="literal">NULL</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">freeNode</span><span class="params">(Node&lt;T&gt; *p)</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(<span class="type">const</span> LinkedList&lt;T&gt;&amp; L)</span></span>; </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedList</span>();</span><br><span class="line">    <span class="built_in">LinkedList</span>(<span class="type">const</span> LinkedList&lt;T&gt;&amp; L);</span><br><span class="line">    ~<span class="built_in">LinkedList</span>();</span><br><span class="line">    LinkedList&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> LinkedList&lt;T&gt;&amp; L);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> pos=<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">endOfList</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">currentPosition</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertFront</span><span class="params">(<span class="type">const</span> T&amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertRear</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertAt</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertAfter</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>; </span><br><span class="line">    <span class="function">T <span class="title">deleteFront</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteCurrent</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function">T&amp; <span class="title">data</span><span class="params">()</span></span>;    </span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">data</span><span class="params">()</span> <span class="type">const</span></span>;   <span class="comment">//返回对当前结点成员数据的常引用</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Node&lt;T&gt; *LinkedList&lt;T&gt;::<span class="built_in">newNode</span>(<span class="type">const</span> T&amp; item, Node&lt;T&gt;* ptrNext) </span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;*p;</span><br><span class="line">    p=<span class="keyword">new</span> <span class="built_in">Node</span>&lt;T&gt;(item,ptrNext);</span><br><span class="line">    <span class="comment">//给p开了新的内存空间</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Memory allocation failed in newNode()!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkedList&lt;T&gt;::<span class="built_in">freeNode</span>(Node&lt;T&gt;*p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放p结点的内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkedList&lt;T&gt;::<span class="built_in">insertFront</span>(<span class="type">const</span> T&amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(front!=<span class="literal">NULL</span>) <span class="built_in">reset</span>();</span><br><span class="line">    <span class="built_in">insert</span>(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在头部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkedList&lt;T&gt;::<span class="built_in">insertAt</span>(<span class="type">const</span> T&amp;item)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;*nNode;</span><br><span class="line">prevPtr=rear;</span><br><span class="line"><span class="keyword">if</span>(prevPtr==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    nNode=<span class="built_in">newNode</span>(item,front);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    nNode=<span class="built_in">newNode</span>(item);</span><br><span class="line">    prevPtr-&gt;<span class="built_in">insertAfter</span>(nNode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(prev==rear)</span><br><span class="line">&#123;</span><br><span class="line">    rear=nNode;</span><br><span class="line">    position=size;</span><br><span class="line">&#125;</span><br><span class="line">currPtr=nNode;</span><br><span class="line">size++;</span><br><span class="line"><span class="comment">//在指定位置前插入元素，如果位置为0则插入到头部，否则插入到指定位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入链表当前位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkedList&lt;T&gt;::<span class="built_in">insertAfter</span>(<span class="type">const</span> T&amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;* nNode;</span><br><span class="line">    nNode=<span class="built_in">newNode</span>(item);</span><br><span class="line">    <span class="keyword">if</span>(prevPtr==<span class="literal">NULL</span>&amp;&amp;front==<span class="literal">NULL</span>&amp;&amp;rear==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nNode=front;</span><br><span class="line">    <span class="comment">//表为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        currPtr-&gt;<span class="built_in">insertAfter</span>(nNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表中</span></span><br><span class="line">    <span class="keyword">if</span>(currPtr==rear)</span><br><span class="line">    &#123;</span><br><span class="line">        rear-&gt;<span class="built_in">insertAfter</span>(nNode);</span><br><span class="line">        rear=nNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表尾</span></span><br><span class="line">    currPtr=nNode;</span><br><span class="line">    position++;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkedList&lt;T&gt;::<span class="built_in">insertRear</span>(<span class="type">const</span> T&amp;item)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;*nNode;</span><br><span class="line">prevPtr=rear;</span><br><span class="line">nNode=<span class="built_in">newNode</span>(item);</span><br><span class="line"><span class="keyword">if</span>(rear==<span class="literal">NULL</span>)front=rear=nNode;</span><br><span class="line"><span class="keyword">else</span> &#123;rear-&gt;<span class="built_in">insertAfter</span>(nNode);</span><br><span class="line">rear=nNode;</span><br><span class="line">&#125;</span><br><span class="line">currPtr=rear;</span><br><span class="line">position=size;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在尾部插入元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T LinkedList&lt;T&gt;::<span class="built_in">deleteFront</span>()</span><br><span class="line">&#123;</span><br><span class="line">    T item;</span><br><span class="line">    <span class="keyword">if</span>(front==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;Error: List is empty in deleteFront()!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    prevPtr=front;</span><br><span class="line">    item=front-&gt;data;</span><br><span class="line">    front=front-&gt;<span class="built_in">nextNode</span>();</span><br><span class="line">    prevPtr-&gt;<span class="built_in">deleteNode</span>();</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除头部元素并返回其值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkedList&lt;T&gt;::<span class="built_in">deleteCurrent</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;*nNode;</span><br><span class="line">    <span class="keyword">if</span>(currPtr==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;Error: List is empty in deleteCurrent()!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(currPtr==front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">deleteFront</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    currPtr=front;</span><br><span class="line">    nNode=prevPtr-&gt;<span class="built_in">deleteAfter</span>();</span><br><span class="line">    nNode-&gt;<span class="built_in">deleteNode</span>();</span><br><span class="line">    prevPtr=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> pos=<span class="number">0</span>;pos!=position<span class="number">-1</span>;pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        prevPtr=currPtr;</span><br><span class="line">        currPtr=currPtr-&gt;<span class="built_in">nextNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    position--;</span><br><span class="line">    size--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除当前位置元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; LinkedList&lt;T&gt;::<span class="built_in">data</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(currPtr==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;Error: List is empty in data()!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currPtr-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回对当前结点成员数据的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">const</span> T&amp; LinkedList&lt;T&gt;::<span class="built_in">data</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(currPtr==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;Error: List is empty in data()!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currPtr-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回对当前结点成员数据的常引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkedList&lt;T&gt;::<span class="built_in">copy</span>(<span class="type">const</span> LinkedList&lt;T&gt;&amp;L)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt;*p=L.front;</span><br><span class="line"><span class="type">int</span> pos;</span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">insertRear</span>(p-&gt;data);</span><br><span class="line">    p=p-&gt;<span class="built_in">nextNode</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(position==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">prevPtr=<span class="literal">NULL</span>;</span><br><span class="line">currPtr=front;</span><br><span class="line"><span class="keyword">for</span>(pos=<span class="number">0</span>;pos!=position;pos++)</span><br><span class="line">&#123;</span><br><span class="line">    prevPtr=currPtr;</span><br><span class="line">    currPtr=currPtr-&gt;<span class="built_in">nextNode</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//copy函数实现链表的深拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LinkedList&lt;T&gt;::~<span class="built_in">LinkedList</span>()&#123;<span class="built_in">clear</span>();&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> LinkedList&lt;T&gt;::<span class="built_in">getSize</span>()<span class="type">const</span>&#123;<span class="keyword">return</span> size;&#125;</span><br><span class="line"><span class="comment">//返回链表的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> LinkedList&lt;T&gt;::<span class="built_in">isEmpty</span>()<span class="type">const</span>&#123;<span class="keyword">return</span> size==<span class="number">0</span>;&#125;</span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkedList&lt;T&gt;:: <span class="built_in">next</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(currPtr!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        prevPtr=currPtr;</span><br><span class="line">        currPtr=currPtr-&gt;<span class="built_in">nextNode</span>();</span><br><span class="line">        position++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动到下一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">bool</span> LinkedList&lt;T&gt;::<span class="built_in">endOfList</span>()<span class="type">const</span>&#123;<span class="keyword">return</span> currPtr==<span class="literal">NULL</span>;&#125;</span><br><span class="line"><span class="comment">//判断是否到达链表尾部</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> LinkedList&lt;T&gt;::<span class="built_in">currentPosition</span>()<span class="type">const</span>&#123;<span class="keyword">return</span> position;&#125;</span><br><span class="line"><span class="comment">//返回当前位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LinkedList&lt;T&gt;::<span class="built_in">LinkedList</span>(<span class="type">const</span> LinkedList&lt;T&gt;&amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    front=real=<span class="literal">NULL</span>;</span><br><span class="line">    prevPtr=currPtr=<span class="literal">NULL</span>;</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">    position=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">copy</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LinkedList&lt;T&gt;&amp; LinkedList&lt;T&gt;::<span class="keyword">operator</span> =(<span class="type">const</span> LinkedList&lt;T&gt;&amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>==&amp;L) <span class="keyword">return</span>*<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">copy</span>(L);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值运算符重载</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkedList&lt;T&gt;::<span class="built_in">reset</span>(<span class="type">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> startPos;</span><br><span class="line">    <span class="keyword">if</span>(front==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">0</span>||pos&gt;size<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;Invalid position in reset()!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        prevPtr=<span class="literal">NULL</span>;</span><br><span class="line">        currPtr=front;</span><br><span class="line">        position=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        currPtr=front-&gt;<span class="built_in">nextNode</span>();</span><br><span class="line">        prevPtr=front;</span><br><span class="line">        startPos=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(position=startPos;position!=pos;position++)</span><br><span class="line">        &#123;</span><br><span class="line">            prevPtr=currPtr;</span><br><span class="line">            currPtr=currPtr-&gt;<span class="built_in">nextNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//重置当前位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkedList&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt;*currPosition,*nextPosition;</span><br><span class="line">    currPosition=front;</span><br><span class="line">    <span class="keyword">while</span>(currPosition!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nextPosition=currPosition-&gt;<span class="built_in">nextNode</span>();</span><br><span class="line">        <span class="built_in">freeNode</span>(currPosition);</span><br><span class="line">        currPosition=nextPosition-&gt;<span class="built_in">nextNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    front=rear=<span class="literal">NULL</span>;</span><br><span class="line">    prevPtr=currPtr=<span class="literal">NULL</span>;</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">    position=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>9-7.cpp</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;LinkedList.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkedList&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> item;</span><br><span class="line">        cin&gt;&gt;item;</span><br><span class="line">        list.<span class="built_in">insertFront</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;List:&quot;</span>;</span><br><span class="line">    list.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">while</span>(!list.<span class="built_in">endOfList</span>())&#123;</span><br><span class="line">        cout&lt;&lt;list.<span class="built_in">data</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        list.<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Please enter some interger needed to be deleted&quot;</span>;</span><br><span class="line">    cin&gt;&gt;key;</span><br><span class="line">    list.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">while</span>(!list.<span class="built_in">endOfList</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.<span class="built_in">data</span>()==key)&#123;</span><br><span class="line">            list.<span class="built_in">deleteCurrent</span>();</span><br><span class="line">            list.<span class="built_in">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;List:&quot;</span>;</span><br><span class="line">    list.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">while</span>(!list.<span class="built_in">endOfList</span>())&#123;</span><br><span class="line">        cout&lt;&lt;list.<span class="built_in">data</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        list.<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈类"><a href="#栈类" class="headerlink" title="栈类"></a>栈类</h2><p>栈是只能从一端访问的线性群体，可以访问的这一段称栈顶，另一端称栈底，栈是一种后进先出的数据结构。</p>
<h3 id="栈示意图"><a href="#栈示意图" class="headerlink" title="栈示意图"></a>栈示意图</h3><p><img src="https://p.sda1.dev/18/ec71067fe45ffeae0d56c0468c324e09/3b85e7559923827ad9d58f8a153e1acd.png"></p>
<h3 id="栈的应用举例——表达式处理"><a href="#栈的应用举例——表达式处理" class="headerlink" title="栈的应用举例——表达式处理"></a>栈的应用举例——表达式处理</h3><p><img src="https://p.sda1.dev/18/352f3a5d97bef6a225965b99191c0696/67032199e0d66195c2234e0367ad9f17.png"></p>
<h3 id="栈的基本状态"><a href="#栈的基本状态" class="headerlink" title="栈的基本状态"></a>栈的基本状态</h3><h4 id="栈空"><a href="#栈空" class="headerlink" title="栈空"></a>栈空</h4><p>栈中没有元素（以数组容纳的栈为例） </p>
<p><img src="https://p.sda1.dev/18/98146bb399fe58cf836f389a0e628e6c/cb97e8868ac0d01dc30adbebc1bbb4d5.png"></p>
<h4 id="栈满"><a href="#栈满" class="headerlink" title="栈满"></a>栈满</h4><p>栈中元素个数达到上限（以数组容纳的栈为例） </p>
<p><img src="https://p.sda1.dev/18/2487afe1fbb150988fc0160459456e31/86661e6ec00def0820b2d387ab489e40.png"></p>
<h4 id="一般状态"><a href="#一般状态" class="headerlink" title="一般状态"></a>一般状态</h4><p>栈中有元素，但未达到栈满状态（以数组容纳的栈为例） </p>
<p><img src="https://p.sda1.dev/18/ec71067fe45ffeae0d56c0468c324e09/3b85e7559923827ad9d58f8a153e1acd.png"></p>
<h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><ul>
<li>初始化</li>
<li>入栈</li>
<li>出栈</li>
<li>清空栈</li>
<li>访问栈顶元素</li>
<li>检测栈的状态</li>
</ul>
<h4 id="栈类模板"><a href="#栈类模板" class="headerlink" title="栈类模板"></a>栈类模板</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STACK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> SIZE=<span class="number">50</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Stack&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T list[SIZE];</span><br><span class="line">        <span class="type">int</span> top;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Stack</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T&amp;item)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">const</span> T&amp; <span class="title">peek</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> SIZE&gt;</span><br><span class="line">Stack&lt;T,SIZE&gt;::<span class="built_in">Stack</span>()</span><br><span class="line">&#123;</span><br><span class="line">    top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> SIZE&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T,SIZE&gt;::<span class="built_in">push</span>(<span class="type">const</span> T&amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isEmpty</span>());</span><br><span class="line">    list[++top]=item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> SIZE&gt;</span><br><span class="line">T Stack&lt;T,SIZE&gt;::<span class="built_in">pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isEmpty</span>());</span><br><span class="line">    <span class="keyword">return</span> list[top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> SIZE&gt;</span><br><span class="line">T Stack&lt;T,SIZE&gt;::<span class="built_in">pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isEmpty</span>());</span><br><span class="line">    <span class="keyword">return</span> list[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> SIZE&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;T,SIZE&gt;::<span class="built_in">isFull</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top==SIZE<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> SIZE&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;T,SIZE&gt;::<span class="built_in">isEmpty</span>() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> top==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> SIZE&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T,SIZE&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="一个简单的整数计算器"><a href="#一个简单的整数计算器" class="headerlink" title="一个简单的整数计算器"></a>一个简单的整数计算器</h4><p>实现一个简单的整数计算器，能够进行加、减、乘、除和乘方运算。使用时算式采用后缀输入法，每个操作数、操作符之间都以空白符分隔。例如，若要计算”3+5”则输入”3 5 +”。乘方运算符用”^”表示。每次运算在前次结果基础上进行，若要将前次运算结果清除，可键入”c”。当键入”q”时程序结束。 </p>
<h5 id="Calculator-cpp"><a href="#Calculator-cpp" class="headerlink" title="Calculator.cpp"></a>Calculator.cpp</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Calculator.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">stringToDouble</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">istringstream <span class="title">stream</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="type">double</span> result;</span><br><span class="line">    stream&gt;&gt;result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Calculator::enter</span><span class="params">(<span class="type">double</span> num)</span></span>&#123;s.<span class="built_in">push</span>(num);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Calculator::getTwoOperands</span><span class="params">(<span class="type">double</span> &amp;num1, <span class="type">double</span> &amp;num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    num1=s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">isEmpty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    num2=s.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Calculator::compute</span><span class="params">(<span class="type">char</span> op)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> num1,num2;</span><br><span class="line">    <span class="type">bool</span> result=<span class="built_in">getTwoOperands</span>(num1,num2);</span><br><span class="line">    <span class="keyword">if</span>(result)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: s.<span class="built_in">push</span>(num2+num1); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: s.<span class="built_in">push</span>(num2-num1); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: s.<span class="built_in">push</span>(num2*num1); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">if</span>(num1==<span class="number">0</span>)&#123;cout&lt;&lt;<span class="string">&quot;Error: Division by zero&quot;</span>&lt;&lt;endl; s.<span class="built_in">clear</span>();&#125;</span><br><span class="line">            <span class="keyword">else</span> s.<span class="built_in">push</span>(num2/num1); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;^&#x27;</span>: s.<span class="built_in">push</span>(<span class="built_in">pow</span>(num2,num1)); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: cout&lt;&lt;<span class="string">&quot;Invalid operator&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;s.<span class="built_in">peek</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">else</span> s.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Calculator::run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">while</span>(cin&gt;&gt;str,str!=<span class="string">&quot;q&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(str[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>c<span class="number">&#x27;</span>:s.<span class="built_in">clear</span>();<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="number">&#x27;</span>-<span class="string">&#x27;:if(str.size()&gt;1)</span></span><br><span class="line"><span class="string">                enter(stringToDouble(str));</span></span><br><span class="line"><span class="string">                else compute(str[0]);</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">                case&#x27;</span>+<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">                case&#x27;</span>*<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">                case&#x27;</span>/<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">                case&#x27;</span>^<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">                compute(str[0]);break;</span></span><br><span class="line"><span class="string">                default:enter(stringToDouble(str));</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    void Calculator::clear()&#123;</span></span><br><span class="line"><span class="string">        s.clear();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;Calculator.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calculator c;</span><br><span class="line">    c.<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列类模板"><a href="#队列类模板" class="headerlink" title="队列类模板"></a>队列类模板</h2><p>队列是只能向一端添加元素，从另一端删除元素的线性群体 </p>
<p><img src="https://p.sda1.dev/18/2708dae00ae662a19e5ddfbf78876da9/16069c1ef745b44e7269b5727e60bea9.png"></p>
<h4 id="队列的基本状态"><a href="#队列的基本状态" class="headerlink" title="队列的基本状态"></a>队列的基本状态</h4><h5 id="队空"><a href="#队空" class="headerlink" title="队空"></a>队空</h5><p>队列中没有元素（以数组容纳的队列为例） </p>
<p><img src="https://p.sda1.dev/18/46d2917246cb33788209e927810ea360/4902e4a84c2432cf417e542efb823bca.png" alt="队空"></p>
<h5 id="队满"><a href="#队满" class="headerlink" title="队满"></a>队满</h5><p>队列中元素个数达到上限（以数组容纳的队列为例） </p>
<p><img src="https://p.sda1.dev/18/c6cd6a2e8dc850b0afc04a8957986da1/bd4f36ed24ee1d73e5166304aafafa3c.png" alt="队满"></p>
<h5 id="一般状态-1"><a href="#一般状态-1" class="headerlink" title="一般状态"></a>一般状态</h5><p>队列中有元素，但未达到队满状态（以数组容纳的队列为例） </p>
<p><img src="https://p.sda1.dev/18/3b0e4eaa847c11fd85c5f23d20fb5938/a08bff26e1c143198a59e26331431a7c.png" alt="一般状态"></p>
<h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>在想象中将数组弯曲成环形，元素出队时，后继元素不移动，每当队尾达到数组最</p>
<p>后一个元素时，便再回到数组开头。 </p>
<p><img src="https://p.sda1.dev/18/bdae161bb1351c1c524e9ab0991d6081/d89afbf32a0f4607b749ee964ed0cdab.png" alt="循环队列"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> front,rear,count;</span><br><span class="line">        T list[SIZE];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Queue</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">const</span> T &amp;<span class="title">getFront</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">isFull</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> SIZE&gt; </span><br><span class="line">Queue&lt;T, SIZE&gt;::<span class="built_in">Queue</span>() : <span class="built_in">front</span>(<span class="number">0</span>), <span class="built_in">rear</span>(<span class="number">0</span>), <span class="built_in">count</span>(<span class="number">0</span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> SIZE&gt;</span><br><span class="line"><span class="type">void</span> Queue&lt;T,SIZE&gt;::<span class="built_in">insert</span>(<span class="type">const</span> T&amp;item)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(count!=SIZE);</span><br><span class="line">list[rear]=item;</span><br><span class="line">rear=(rear+<span class="number">1</span>)%SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> SIZE&gt; T Queue&lt;T, SIZE&gt;::<span class="built_in">remove</span>() &#123; </span><br><span class="line"> <span class="built_in">assert</span>(count != <span class="number">0</span>); </span><br><span class="line"> <span class="type">int</span> temp = front; <span class="comment">//记录下原先的队首指针 </span></span><br><span class="line"> count--; <span class="comment">//元素个数自减 </span></span><br><span class="line"> front = (front + <span class="number">1</span>) % SIZE;<span class="comment">//队首指针增1。取余以实现循环队列 </span></span><br><span class="line"> <span class="keyword">return</span> list[temp]; <span class="comment">//返回首元素值 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> SIZE&gt; </span><br><span class="line"><span class="type">const</span> T &amp;Queue&lt;T, SIZE&gt;::<span class="built_in">getFront</span>() <span class="type">const</span> &#123; </span><br><span class="line"> <span class="keyword">return</span> list[front]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> SIZE&gt; </span><br><span class="line"><span class="type">int</span> Queue&lt;T, SIZE&gt;::<span class="built_in">getLength</span>() <span class="type">const</span> &#123; <span class="comment">//返回队列元素个数 </span></span><br><span class="line"> <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> SIZE&gt; </span><br><span class="line"><span class="type">bool</span> Queue&lt;T, SIZE&gt;::<span class="built_in">isEmpty</span>() <span class="type">const</span> &#123; <span class="comment">//测试队空否 </span></span><br><span class="line"> <span class="keyword">return</span> count == <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> SIZE&gt; </span><br><span class="line"><span class="type">bool</span> Queue&lt;T, SIZE&gt;::<span class="built_in">isFull</span>() <span class="type">const</span> &#123; <span class="comment">//测试队满否 </span></span><br><span class="line"> <span class="keyword">return</span> count == SIZE; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> SIZE&gt; </span><br><span class="line"><span class="type">void</span> Queue&lt;T, SIZE&gt;::<span class="built_in">clear</span>() &#123; <span class="comment">//清空队列 </span></span><br><span class="line"> count = <span class="number">0</span>; </span><br><span class="line"> front = <span class="number">0</span>; </span><br><span class="line"> rear = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="排序概述"><a href="#排序概述" class="headerlink" title="排序概述"></a>排序概述</h2><p>排序是将一个数据元素的任意序列，重新排列成一个按关键字有序的序列。 </p>
<ul>
<li>数据元素：数据的基本单位。在计算机中通常作为一个整体进行考虑。一个数据元</li>
</ul>
<p>素可由若干数据项组成。 </p>
<ul>
<li><p>关键字：数据元素中某个数据项的值，用它可以标识（识别）一个数据元素。 </p>
</li>
<li><p>在排序过程中需要完成两种基本操作：</p>
</li>
</ul>
<blockquote>
<p>比较两个数的大小 </p>
</blockquote>
<blockquote>
<p>调整元素在序列中的位置 </p>
</blockquote>
<h3 id="内部排序和外部排序"><a href="#内部排序和外部排序" class="headerlink" title="内部排序和外部排序"></a>内部排序和外部排序</h3><h4 id="内部排序："><a href="#内部排序：" class="headerlink" title="内部排序："></a>内部排序：</h4><p>待排序的数据元素存放在计算机内存中进行的排序过程。 </p>
<h4 id="外部排序："><a href="#外部排序：" class="headerlink" title="外部排序："></a>外部排序：</h4><p>待排序的数据元素数量很大，以致内存存中一次不能容纳全部数据，在排序过程中尚需对外存进行访问的排序过程。</p>
<h3 id="几种简单的内部排序方法"><a href="#几种简单的内部排序方法" class="headerlink" title="几种简单的内部排序方法"></a>几种简单的内部排序方法</h3><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>每一步将一个待排序元素按其关键字值的大小插入到已排序序列的适当位置上，直到待排序元素插入完为止。 </p>
<p><img src="https://p.sda1.dev/18/ececd1f3eba3158b8bbb9c6c9d167fd4/0e454abb2a75c88edb829a7b57ad0631.png" alt="插入排序"></p>
<h5 id="直接插入排序类模板"><a href="#直接插入排序类模板" class="headerlink" title="直接插入排序类模板"></a>直接插入排序类模板</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(T a[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="comment">//设置更新变量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=i;</span><br><span class="line">        <span class="comment">//将i的值赋给j</span></span><br><span class="line">        T temp=a[i];</span><br><span class="line">        <span class="comment">//暂存a[i]的值</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;temp&lt;a[j<span class="number">-1</span>])</span><br><span class="line">        <span class="comment">//这里都是升序排列</span></span><br><span class="line">  		<span class="comment">//一直循环到比temp大的位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[j]=a[j<span class="number">-1</span>];</span><br><span class="line">            j--;</span><br><span class="line">            <span class="comment">//将比temp大的元素全部后移一格</span></span><br><span class="line">        &#125;</span><br><span class="line">        a[j]=temp;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>每次从待排序序列中选择一个关键字最小的元素，（当需要按关键字升序排列时），顺序排在已排序序列的最后，直至全部排完。</p>
<h5 id="选择排序类模板"><a href="#选择排序类模板" class="headerlink" title="选择排序类模板"></a>选择排序类模板</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;x, T &amp;y)</span> </span>&#123; </span><br><span class="line"> T temp = x; </span><br><span class="line"> x = y; </span><br><span class="line"> y = temp; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//交换两个对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(T a[], <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) </span><br><span class="line"> &#123; </span><br><span class="line"> <span class="type">int</span> leastIndex = i; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) </span><br><span class="line"> <span class="keyword">if</span> (a[j] &lt; a[leastIndex]) leastIndex = j; </span><br><span class="line"> <span class="built_in">mySwap</span>(a[i], a[leastIndex]); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p.sda1.dev/18/dd87d5b62a8c6aa41e475be43ee87eb9/4831d0605cbdc27232dce00b3ac899cb.png" alt="选择排序"></p>
<h4 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h4><p>两两比较待排序序列中的元素，并交换不满足顺序要求的各对元素，直到全部满足顺序要求为止。</p>
<p><img src="https://p.sda1.dev/18/c0ae93053675e0db4d492c93d177fcbb/f5edae720f4ec03d409885c50ac55717.png" alt="交换排序"></p>
<h5 id="交换排序类模板"><a href="#交换排序类模板" class="headerlink" title="交换排序类模板"></a>交换排序类模板</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;x, T &amp;y)</span> </span>&#123; </span><br><span class="line"> T temp = x; </span><br><span class="line"> x = y; </span><br><span class="line"> y = temp; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(T a[], <span class="type">int</span> n)</span> </span>&#123; </span><br><span class="line"> <span class="type">int</span> i = n – <span class="number">1</span>; </span><br><span class="line"> <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123; </span><br><span class="line"> <span class="type">int</span> lastExchangeIndex = <span class="number">0</span>; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) </span><br><span class="line"> <span class="keyword">if</span> (a[j + <span class="number">1</span>] &lt; a[j]) &#123; </span><br><span class="line"> <span class="built_in">mySwap</span>(a[j], a[j + <span class="number">1</span>]); </span><br><span class="line"> lastExchangeIndex = j; </span><br><span class="line"> &#125; </span><br><span class="line"> i = lastExchangeIndex; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOC(11)：流类库与输入输出</title>
    <url>/2024/08/14/SPOC%EF%BC%9A%E6%B5%81%E7%B1%BB%E5%BA%93%E4%B8%8E%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h2 id="第十一章-流类库与输入-输出"><a href="#第十一章-流类库与输入-输出" class="headerlink" title="第十一章 流类库与输入&#x2F;输出"></a>第十一章 流类库与输入&#x2F;输出</h2><h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ul>
<li><p>I&#x2F;O流的概念</p>
</li>
<li><p>流类库结构</p>
</li>
<li><p>输出流</p>
</li>
<li><p>输入流</p>
</li>
<li><p>输入&#x2F;输出流</p>
</li>
<li><p>读写文本文件的格式控制</p>
</li>
</ul>
<h3 id="I-O-流的概念及流类库结构"><a href="#I-O-流的概念及流类库结构" class="headerlink" title="I&#x2F;O 流的概念及流类库结构"></a>I&#x2F;O 流的概念及流类库结构</h3><h4 id="程序与外界环境的信息交换"><a href="#程序与外界环境的信息交换" class="headerlink" title="程序与外界环境的信息交换"></a>程序与外界环境的信息交换</h4><p>当程序与外界环境进行信息交换时，存在着两个对象：程序中的对象、文件对象。</p>
<h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>一种抽象，负责在数据的生产者和数据的消费者之间建立联系，并管理数据的流动。流对象与文件操作</p>
<ul>
<li><p>程序建立一个流对象</p>
</li>
<li><p>指定这个流对象与某个文件对象建立连接</p>
</li>
<li><p>程序操作流对象</p>
</li>
<li><p>流对象通过文件系统对所连接的文件对象产生作用。</p>
</li>
</ul>
<h4 id="提取与插入"><a href="#提取与插入" class="headerlink" title="提取与插入"></a>提取与插入</h4><ul>
<li><p>读操作在流数据抽象中被称为（从流中）提取</p>
</li>
<li><p>写操作被称为（向流中）插入。</p>
</li>
</ul>
<p>流类库结构流类列表</p>
<p>输出流概述</p>
<h4 id="最重要的三个输出流"><a href="#最重要的三个输出流" class="headerlink" title="最重要的三个输出流"></a>最重要的三个输出流</h4><ul>
<li><p>ostream</p>
</li>
<li><p>ofstream</p>
</li>
<li><p>ostringstream</p>
</li>
</ul>
<h4 id="预先定义的输出流对象"><a href="#预先定义的输出流对象" class="headerlink" title="预先定义的输出流对象"></a>预先定义的输出流对象</h4><ul>
<li><p>cout 标准输出</p>
</li>
<li><p>cerr 标准错误输出，没有缓冲，发送给它的内容立即被输出。 clog 类似于cerr，但是有缓冲，缓冲区满时被输出。</p>
</li>
</ul>
<h4 id="标准输出换向"><a href="#标准输出换向" class="headerlink" title="标准输出换向"></a>标准输出换向</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">&quot;b.out&quot;</span>)</span></span>;</span><br><span class="line">streambuf* pOld =cout.<span class="built_in">rdbuf</span>(fout.<span class="built_in">rdbuf</span>()); </span><br><span class="line"><span class="comment">//…</span></span><br><span class="line">cout.<span class="built_in">rdbuf</span>(pOld); </span><br></pre></td></tr></table></figure>

<h4 id="构造输出流对象"><a href="#构造输出流对象" class="headerlink" title="构造输出流对象"></a>构造输出流对象</h4><ul>
<li><p>ofstream类支持磁盘文件输出</p>
</li>
<li><p>如果在构造函数中指定一个文件名，当构造这个对象时该文件是自动打开的ofstream myFile(“filename”);</p>
</li>
<li><p>可以在调用默认构造函数之后使用open成员函数打开文件ofstream myFile; &#x2F;&#x2F;声明一个静态文件输出流对象myFile.open(“filename”); &#x2F;&#x2F;打开文件，使流对象与文件建立联系</p>
</li>
<li><p>在构造对象或用open打开文件时可以指定模式ofstream myFile(“filename”, ios_base::out | ios_base::binary);</p>
</li>
</ul>
<h4 id="文件输出流成员函数的三种类型"><a href="#文件输出流成员函数的三种类型" class="headerlink" title="文件输出流成员函数的三种类型"></a>文件输出流成员函数的三种类型</h4><ul>
<li><p>与操纵符等价的成员函数。</p>
</li>
<li><p>执行非格式化写操作的成员函数。</p>
</li>
<li><p>其它修改流状态且不同于操纵符或插入运算符的成员函数。</p>
</li>
</ul>
<h4 id="文件输出流成员函数"><a href="#文件输出流成员函数" class="headerlink" title="文件输出流成员函数"></a>文件输出流成员函数</h4><ul>
<li>open函数</li>
</ul>
<p>把流与一个特定的磁盘文件关联起来。</p>
<p>需要指定打开模式。</p>
<ul>
<li>put函数</li>
</ul>
<p>把一个字符写到输出流中。</p>
<ul>
<li>write函数</li>
</ul>
<p>把内存中的一块内容写到一个文件输出流中</p>
<ul>
<li>seekp和tellp函数</li>
</ul>
<p>操作文件流的内部指针</p>
<ul>
<li>close函数</li>
</ul>
<p>关闭与一个文件输出流关联的磁盘文件</p>
<ul>
<li>错误处理函数在写到一个流时进行错误处理</li>
</ul>
<h4 id="向文本文件输出"><a href="#向文本文件输出" class="headerlink" title="向文本文件输出"></a>向文本文件输出</h4><p>标准输出设备显示器被系统看作文本文件，所以我们以向标准设备输出为例，介绍文本</p>
<p>文件输出格式控制</p>
<h4 id="插入运算符"><a href="#插入运算符" class="headerlink" title="插入运算符"></a>插入运算符</h4><ul>
<li><p>插入(&lt;&lt;)运算符</p>
</li>
<li><p>为所有标准C++数据类型预先设计的，用于传送字节到一个输出流对象。</p>
</li>
</ul>
<h4 id="操纵符（manipulator）"><a href="#操纵符（manipulator）" class="headerlink" title="操纵符（manipulator）"></a>操纵符（manipulator）</h4><ul>
<li><p>插入运算符与操纵符一起工作</p>
</li>
<li><p>控制输出格式。</p>
</li>
<li><p>很多操纵符都定义在ios_base类中（如hex()）、<iomanip>头文件（如setprecision()）。</iomanip></p>
</li>
<li><p>控制输出宽度</p>
<ol>
<li><p>在流中放入setw操纵符或调用width成员函数为每个项指定输出宽度。</p>
</li>
<li><p>setw和width仅影响紧随其后的输出项，但其它流格式操纵符保持有效直到发生改</p>
</li>
</ol>
</li>
</ul>
<p>变。</p>
<ul>
<li>dec、oct和hex操纵符设置输入和输出的默认进制。</li>
</ul>
<h4 id="例-11-1-使用-width-控制输出宽度"><a href="#例-11-1-使用-width-控制输出宽度" class="headerlink" title="例 11-1 使用 width 控制输出宽度"></a>例 11-1 使用 width 控制输出宽度</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果:"></a>输出结果:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.23</span> <span class="number">35.36</span></span><br><span class="line"><span class="number">653.7</span></span><br><span class="line"><span class="number">4358.24</span></span><br></pre></td></tr></table></figure>

<h4 id="例-11-2-使用-setw-操纵符指定宽度"><a href="#例-11-2-使用-setw-操纵符指定宽度" class="headerlink" title="例 11-2 使用 setw 操纵符指定宽度"></a>例 11-2 使用 <strong>setw</strong> 操纵符指定宽度</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i] </span><br><span class="line"> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果:"></a>输出结果:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> Zoot <span class="number">1.23</span></span><br><span class="line">Jimmy <span class="number">35.36</span></span><br><span class="line"> Al <span class="number">653.7</span></span><br><span class="line"> Stan <span class="number">4358.24</span></span><br></pre></td></tr></table></figure>

<h4 id="例-11-3-设置对齐方式"><a href="#例-11-3-设置对齐方式" class="headerlink" title="例 11-3 设置对齐方式"></a>例 11-3 设置对齐方式</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_3.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)<span class="comment">//左对齐 &lt;&lt; setw(6) &lt;&lt; names[i]</span></span><br><span class="line"> &lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)</span><br><span class="line"> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果-2"><a href="#输出结果-2" class="headerlink" title="输出结果:"></a>输出结果:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Zoot <span class="number">1.23</span></span><br><span class="line">Jimmy <span class="number">35.36</span></span><br><span class="line">Al <span class="number">653.7</span></span><br><span class="line">Stan <span class="number">4358.24</span></span><br></pre></td></tr></table></figure>

<h4 id="setiosflags-操纵符"><a href="#setiosflags-操纵符" class="headerlink" title="setiosflags 操纵符"></a>setiosflags 操纵符</h4><ul>
<li><p>这个程序中，通过使用带参数的setiosflags操纵符来设置左对齐，setiosflags定义在头文件iomanip中。</p>
</li>
<li><p>参数ios_base::left是ios_base的静态常量，因此引用时必须包括ios_base::前缀。</p>
</li>
<li><p>这里需要用resetiosflags操纵符关闭左对齐标志。setiosflags不同于width和setw，它的影响是持久的，直到用resetiosflags重新恢复默认值时为止 。</p>
</li>
<li><p>setiosflags的参数是该流的格式标志值，可用按位或（|）运算符进行组合setiosflags 的参数（流的格式标识）</p>
</li>
<li><p>ios_base::skipws 在输入中跳过空白 。</p>
</li>
<li><p>ios_base::left 左对齐值，用填充字符填充右边。</p>
</li>
<li><p>ios_base::right 右对齐值，用填充字符填充左边（默认对齐方式）。</p>
</li>
<li><p>ios_base::internal 在规定的宽度内，指定前缀符号之后，数值之前，插入指定的填充字符。</p>
</li>
<li><p>ios_base::dec 以十进制形式格式化数值（默认进制）。</p>
</li>
<li><p>ios_base::oct 以八进制形式格式化数值 。</p>
</li>
<li><p>ios_base::hex 以十六进制形式格式化数值。</p>
</li>
<li><p>ios_base::showbase 插入前缀符号以表明整数的数制。</p>
</li>
<li><p>ios_base::showpoint 对浮点数值显示小数点和尾部的0 。</p>
</li>
<li><p>ios_base::uppercase 对于十六进制数值显示大写字母A到F，对于科学格式显示大写字母E 。</p>
</li>
<li><p>ios_base::showpos 对于非负数显示正号（“+”）。</p>
</li>
<li><p>ios_base::scientific 以科学格式显示浮点数值。</p>
</li>
<li><p>ios_base::fixed 以定点格式显示浮点数值（没有指数部分） 。</p>
</li>
<li><p>ios_base::unitbuf 在每次插入之后转储并清除缓冲区内容。精度</p>
</li>
<li><p>浮点数输出精度的默认值是6，例如：3466.98。</p>
</li>
<li><p>要改变精度：setprecision操纵符（定义在头文件iomanip中）。</p>
</li>
<li><p>如果不指定fixed或scientific，精度值表示有效数字位数。</p>
</li>
<li><p>如果设置了ios_base::fixed或ios_base::scientific精度值表示小数点之后的位数。</p>
</li>
</ul>
<h4 id="例-11-4-控制输出精度——未指定-fixed-或-scientific"><a href="#例-11-4-控制输出精度——未指定-fixed-或-scientific" class="headerlink" title="例 11-4 控制输出精度——未指定 fixed 或 scientific"></a>例 11-4 控制输出精度——未指定 fixed 或 scientific</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_4_1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Zoot <span class="number">1</span></span><br><span class="line">Jimmy <span class="number">4e+001</span></span><br><span class="line">Al <span class="number">7e+002</span></span><br><span class="line">Stan <span class="number">4e+003</span></span><br></pre></td></tr></table></figure>

<h4 id="例-11-4-控制输出精度——指定-fixed"><a href="#例-11-4-控制输出精度——指定-fixed" class="headerlink" title="例 11-4 控制输出精度——指定 fixed"></a>例 11-4 控制输出精度——指定 fixed</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_4_2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::fixed);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果：-1"><a href="#输出结果：-1" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Zoot <span class="number">1.2</span></span><br><span class="line">Jimmy <span class="number">35.4</span></span><br><span class="line">Al <span class="number">653.7</span></span><br><span class="line">Stan <span class="number">4358.2</span></span><br></pre></td></tr></table></figure>

<h4 id="例-11-4-控制输出精度——指定-scientific"><a href="#例-11-4-控制输出精度——指定-scientific" class="headerlink" title="例 11-4 控制输出精度——指定 scientific"></a>例 11-4 控制输出精度——指定 scientific</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_4_3.cpp</span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> values[] = &#123; <span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span> &#125;;</span><br><span class="line">string names[] = &#123; <span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span> &#125;;</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::scientific);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line"> cout &lt;&lt; <span class="built_in">setiosflags</span>(ios_base::left)</span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">&lt;&lt; <span class="built_in">resetiosflags</span>(ios_base::left)<span class="comment">//清除左对齐设置</span></span><br><span class="line">&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; values[i] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果：-2"><a href="#输出结果：-2" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Zoot <span class="number">1.2e+000</span>Jimmy <span class="number">3.5e+001</span></span><br><span class="line">Al <span class="number">6.5e+002</span></span><br><span class="line">Stan <span class="number">4.4e+003</span></span><br></pre></td></tr></table></figure>

<h3 id="向二进制文件输出"><a href="#向二进制文件输出" class="headerlink" title="向二进制文件输出"></a>向二进制文件输出</h3><h4 id="二进制文件流"><a href="#二进制文件流" class="headerlink" title="二进制文件流"></a>二进制文件流</h4><ul>
<li><p>使用ofstream构造函数中的模式参量指定二进制输出模式；</p>
</li>
<li><p>以通常方式构造一个流，然后使用setmode成员函数，在文件打开后改变模式；</p>
</li>
<li><p>通过二进制文件输出流对象完成输出。</p>
</li>
</ul>
<h4 id="例-11-5-向二进制文件输出"><a href="#例-11-5-向二进制文件输出" class="headerlink" title="例 11-5 向二进制文件输出"></a>例 11-5 向二进制文件输出</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_5.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span> &#123; </span><br><span class="line"><span class="type">int</span> mon, day, year; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Date dt = &#123; <span class="number">6</span>, <span class="number">10</span>, <span class="number">92</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;date.dat&quot;</span>, ios_base::binary)</span></span>;</span><br><span class="line">file.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;dt),<span class="built_in">sizeof</span>(dt));</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="向字符串输出"><a href="#向字符串输出" class="headerlink" title="向字符串输出"></a>向字符串输出</h4><p>将字符串作为输出流的目标，可以实现将其他数据类型转换为字符串的功能</p>
<h4 id="字符串输出流（-ostringstream-）"><a href="#字符串输出流（-ostringstream-）" class="headerlink" title="字符串输出流（ ostringstream ）"></a>字符串输出流（ ostringstream ）</h4><ul>
<li><p>用于构造字符串</p>
</li>
<li><p>功能</p>
<ol>
<li>支持ofstream类的除open、close外的所有操作</li>
<li>str函数可以返回当前已构造的字符串 典型应用</li>
<li>将数值转换为字符串</li>
</ol>
</li>
</ul>
<h4 id="例-11-6-用-ostringstream-将数值转换为字符串"><a href="#例-11-6-用-ostringstream-将数值转换为字符串" class="headerlink" title="例 11-6 用 ostringstream 将数值转换为字符串"></a>例 11-6 用 ostringstream 将数值转换为字符串</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_6.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">toString</span><span class="params">(<span class="type">const</span> T &amp;v)</span> </span>&#123;</span><br><span class="line">ostringstream os; <span class="comment">//创建字符串输出流</span></span><br><span class="line">os &lt;&lt; v; </span><br><span class="line"><span class="comment">//将变量v的值写入字符串流</span></span><br><span class="line"><span class="keyword">return</span> os.<span class="built_in">str</span>(); </span><br><span class="line"><span class="comment">//返回输出流生成的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str1 = <span class="built_in">toString</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">string str2 = <span class="built_in">toString</span>(<span class="number">1.2</span>);</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果：-3"><a href="#输出结果：-3" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure>

<h3 id="输入流概述"><a href="#输入流概述" class="headerlink" title="输入流概述"></a>输入流概述</h3><h4 id="重要的输入流类"><a href="#重要的输入流类" class="headerlink" title="重要的输入流类"></a>重要的输入流类</h4><ul>
<li><p>istream类最适合用于顺序文本模式输入。cin是其实例<strong>。</strong></p>
</li>
<li><p>ifstream类支持磁盘文件输入。</p>
</li>
<li><p>istringstream</p>
</li>
</ul>
<p>函数模板 toString 可以将各种支持“&lt;&lt;“插入符的类型的对象转换为字符串。构造输入流对象</p>
<ul>
<li>如果在构造函数中指定一个文件名，在构造该对象时该文件便自动打开。</li>
</ul>
<h4 id="ifstream-myFile-“filename”"><a href="#ifstream-myFile-“filename”" class="headerlink" title="ifstream myFile(“filename”);"></a><strong>ifstream myFile(“filename”);</strong></h4><ul>
<li>在调用默认构造函数之后使用open函数来打开文件。</li>
</ul>
<p>ifstream myFile; &#x2F;&#x2F;建立一个文件流对象</p>
<h4 id="myFile-open-“filename”-打开文件“filename-”"><a href="#myFile-open-“filename”-打开文件“filename-”" class="headerlink" title="myFile.open(“filename”); &#x2F;&#x2F;打开文件“filename****”"></a><strong>myFile.open(“filename”); &#x2F;&#x2F;<strong><strong>打开文件</strong></strong>“filename****”</strong></h4><p> 打开文件时可以指定模式</p>
<h4 id="ifstream-myFile-“filename”-ios-base-in-ios-base-binary"><a href="#ifstream-myFile-“filename”-ios-base-in-ios-base-binary" class="headerlink" title="ifstream myFile(“filename”, ios_base::in | ios_base::binary);"></a><strong>ifstream myFile(“filename”, ios_base::in | ios_base::binary);</strong></h4><p>使用提取运算符从文本文件输入</p>
<ul>
<li><p>提取运算符(&gt;&gt;)对于所有标准C++数据类型都是预先设计好的。</p>
</li>
<li><p>是从一个输入流对象获取字节最容易的方法。</p>
</li>
<li><p>ios类中的很多操纵符都可以应用于输入流。但是只有少数几个对输入流对象具有</p>
</li>
</ul>
<p>实际影响，其中最重要的是进制操纵符dec、oct和hex。</p>
<h4 id="输入流相关函数"><a href="#输入流相关函数" class="headerlink" title="输入流相关函数"></a>输入流相关函数</h4><ul>
<li><p>open 把该流与一个特定磁盘文件相关联。</p>
</li>
<li><p>get 功能与提取运算符（&gt;&gt;）很相像，主要的不同点是get函数在读入数据时包括空白字符。</p>
</li>
<li><p>getline 功能是从输入流中读取多个字符，并且允许指定输入终止字符，读取完成后，从读取的内容中删除终止字符。</p>
</li>
<li><p>read 从一个文件读字节到一个指定的内存区域，由长度参数确定要读的字节数。当遇到文件结束或者在文本模式文件中遇到文件结束标记字符时结束读取。</p>
</li>
<li><p>seekg 用来设置文件输入流中读取数据位置的指针。</p>
</li>
<li><p>tellg 返回当前文件读指针的位置。</p>
</li>
<li><p>close 关闭与一个文件输入流关联的磁盘文件。</p>
</li>
</ul>
<h4 id="输入流应用举例"><a href="#输入流应用举例" class="headerlink" title="输入流应用举例"></a>输入流应用举例</h4><h4 id="例-11-7-get-函数应用举例"><a href="#例-11-7-get-函数应用举例" class="headerlink" title="例 11-7 get 函数应用举例"></a>例 11-7 <strong>get</strong> 函数应用举例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_7.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">char</span> ch;<span class="keyword">while</span> ((ch = cin.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">cout.<span class="built_in">put</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例-11-8-为输入流指定一个终止字符："><a href="#例-11-8-为输入流指定一个终止字符：" class="headerlink" title="例 11-8 为输入流指定一个终止字符："></a>例 11-8 为输入流指定一个终止字符：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_8.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> string line;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;Type a line terminated by &#x27;t&#x27; &quot;</span> &lt;&lt; endl; </span><br><span class="line"><span class="built_in">getline</span>(cin, line, <span class="string">&#x27;t&#x27;</span>);</span><br><span class="line"> cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例-11-9-从文件读一个二进制记录到一个结构中"><a href="#例-11-9-从文件读一个二进制记录到一个结构中" class="headerlink" title="例 11-9 从文件读一个二进制记录到一个结构中"></a>例 11-9 从文件读一个二进制记录到一个结构中</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_9.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SalaryInfo</span> &#123;</span><br><span class="line"><span class="type">unsigned</span> id;</span><br><span class="line"><span class="type">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SalaryInfo employee1 = &#123; <span class="number">600001</span>, <span class="number">8000</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">os</span><span class="params">(<span class="string">&quot;payroll&quot;</span>, ios_base::out | ios_base::binary)</span></span>;</span><br><span class="line">os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;employee1), <span class="built_in">sizeof</span>(employee1));</span><br><span class="line">os.<span class="built_in">close</span>();<span class="function">ifstream <span class="title">is</span><span class="params">(<span class="string">&quot;payroll&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (is) &#123;</span><br><span class="line">SalaryInfo employee2;</span><br><span class="line">is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;employee2), <span class="built_in">sizeof</span>(employee2));</span><br><span class="line">cout &lt;&lt; employee2.id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; employee2.salary &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;payroll&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">is.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例-11-10-用-seekg-函数设置位置指针"><a href="#例-11-10-用-seekg-函数设置位置指针" class="headerlink" title="例 11-10 用 seekg 函数设置位置指针"></a>例 11-10 用 <strong>seekg</strong> 函数设置位置指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_10.cpp, 头部分省略</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> values[] = &#123; <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="function">ofstream <span class="title">os</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::out | ios_base::binary)</span></span>;</span><br><span class="line">os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(values), <span class="built_in">sizeof</span>(values));</span><br><span class="line">os.<span class="built_in">close</span>();</span><br><span class="line"><span class="function">ifstream <span class="title">is</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (is) &#123;</span><br><span class="line">is.<span class="built_in">seekg</span>(<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;v), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The 4th integer in the file &#x27;integers&#x27; is &quot;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;integers&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例-11-11-读一个文件并显示出其中-0-元素的位置"><a href="#例-11-11-读一个文件并显示出其中-0-元素的位置" class="headerlink" title="例 11-11 读一个文件并显示出其中 0 元素的位置"></a>例 11-11 读一个文件并显示出其中 0 元素的位置</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_11.cpp, 头部分省略int main() &#123;</span></span><br><span class="line"><span class="function">ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;integers&quot;</span>, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (file) &#123;</span><br><span class="line"><span class="keyword">while</span> (file) &#123;<span class="comment">//读到文件尾file为0</span></span><br><span class="line"> streampos here = file.<span class="built_in">tellg</span>();</span><br><span class="line"> <span class="type">int</span> v;</span><br><span class="line"> file.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(&amp;v), <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> <span class="keyword">if</span> (file &amp;&amp; v == <span class="number">0</span>) </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Position &quot;</span> &lt;&lt; here &lt;&lt; <span class="string">&quot; is 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ERROR: Cannot open file &#x27;integers&#x27;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从字符串输入"><a href="#从字符串输入" class="headerlink" title="从字符串输入"></a>从字符串输入</h3><p>将字符串作为文本输入流的源，可以将字符串转换为其他数据类型</p>
<h4 id="字符串输入流（-istringstream）"><a href="#字符串输入流（-istringstream）" class="headerlink" title="字符串输入流（ istringstream）"></a>字符串输入流（ istringstream）</h4><ul>
<li><p>用于从字符串读取数据</p>
</li>
<li><p>在构造函数中设置要读取的字符串</p>
</li>
<li><p>功能</p>
<ol>
<li>支持ifstream类的除open、close外的所有操作</li>
</ol>
</li>
<li><p>典型应用</p>
<ol>
<li>将字符串转换为数值</li>
</ol>
</li>
</ul>
<h4 id="例-11-12-用-istringstream-将字符串转换为数值"><a href="#例-11-12-用-istringstream-将字符串转换为数值" class="headerlink" title="例 11-12 用 istringstream 将字符串转换为数值"></a>例 11-12 用 istringstream 将字符串转换为数值</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//11_12.cpp, 头部分省略</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">fromString</span><span class="params">(<span class="type">const</span> string &amp;str)</span> </span>&#123;</span><br><span class="line"><span class="function">istringstream <span class="title">is</span><span class="params">(str)</span></span>; <span class="comment">//创建字符串输入流</span></span><br><span class="line">T v;is &gt;&gt; v;<span class="comment">//从字符串输入流中读取变量v</span></span><br><span class="line"><span class="keyword">return</span> v; </span><br><span class="line"><span class="comment">//返回变量v</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> v1 = <span class="built_in">fromString</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">cout &lt;&lt; v1 &lt;&lt; endl;</span><br><span class="line"><span class="type">double</span> v2 = <span class="built_in">fromString</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;1.2&quot;</span>);</span><br><span class="line">cout &lt;&lt; v2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出结果：-4"><a href="#输出结果：-4" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1.2</span></span><br></pre></td></tr></table></figure>

<h3 id="输入-输出流"><a href="#输入-输出流" class="headerlink" title="输入&#x2F;输出流"></a>输入&#x2F;输出流</h3><h4 id="两个重要的输入-输出流"><a href="#两个重要的输入-输出流" class="headerlink" title="两个重要的输入&#x2F;输出流"></a>两个重要的输入&#x2F;输出流</h4><ul>
<li><p>一个iostream对象可以是数据的源或目的。</p>
</li>
<li><p>两个重要的I&#x2F;O流类都是从iostream派生的，它们是fstream和stringstream。这些类继承了前面描述的istream和ostream类的功能。</p>
</li>
</ul>
<h4 id="fstream-类"><a href="#fstream-类" class="headerlink" title="fstream 类"></a>fstream 类</h4><ul>
<li><p>fstream类支持磁盘文件输入和输出。</p>
</li>
<li><p>如果需要在同一个程序中从一个特定磁盘文件读并写到该磁盘文件，可以构造一个</p>
</li>
</ul>
<h4 id="fstream对象。"><a href="#fstream对象。" class="headerlink" title="fstream对象。"></a>fstream对象。</h4><ul>
<li>一个fstream对象是有两个逻辑子流的单个流，两个子流一个用于输入，另一个用于输出。</li>
</ul>
<p>stringstream 类</p>
<ul>
<li><p>stringstream类支持面向字符串的输入和输出</p>
</li>
<li><p>可以用于对同一个字符串的内容交替读写，同样是由两个逻辑子流构成。</p>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="主要内容-1"><a href="#主要内容-1" class="headerlink" title="主要内容"></a>主要内容</h4><ul>
<li><p>I&#x2F;O流的概念</p>
</li>
<li><p>流类库结构</p>
</li>
<li><p>输出流</p>
</li>
<li><p>输入流</p>
</li>
<li><p>输入&#x2F;输出流</p>
</li>
<li><p>读写文本文件的格式控制</p>
</li>
</ul>
<h4 id="达到的目标"><a href="#达到的目标" class="headerlink" title="达到的目标"></a>达到的目标</h4><ol>
<li><p>能够将数据持久化。</p>
</li>
<li><p>能够处理文本文件和二进制文件。</p>
</li>
<li><p>能够利用字符串流进行字符串与其他类型之间的转换</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOC(8):多态性</title>
    <url>/2022/11/06/SPOC%EF%BC%888%EF%BC%89%EF%BC%9A%E5%A4%9A%E6%80%81%E6%80%A7/</url>
    <content><![CDATA[<h2 id="运算符重载的规则"><a href="#运算符重载的规则" class="headerlink" title="运算符重载的规则"></a>运算符重载的规则</h2><p>思考：用“+”、“-”能够实现复数的加减运算吗？</p>
<p>重载未类的非静态成员函数</p>
<p>重载未非成员函数</p>
<h2 id="双目运算符重载为成员函数"><a href="#双目运算符重载为成员函数" class="headerlink" title="双目运算符重载为成员函数"></a>双目运算符重载为成员函数</h2><h3 id="运算符重载为成员函数"><a href="#运算符重载为成员函数" class="headerlink" title="运算符重载为成员函数"></a>运算符重载为成员函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span> 运算符（形参）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">参数个数=原操作个数<span class="number">-1</span>（后置++，--除外）</span><br></pre></td></tr></table></figure>

<h3 id="双目运算符重载规则"><a href="#双目运算符重载规则" class="headerlink" title="双目运算符重载规则"></a>双目运算符重载规则</h3><p>​	如果要重载B为类成员函数，使之能够实现表达式oprd1 B oprd2，其中oprd1为A类对象，则B应重载为A类的成员函数，形参类型应该是oprd2所属的类型。</p>
<p>​	经重载后，表达式oprd1 B oprd2相当于oprd1.operator B(oprd2)</p>
<h4 id="复数类加减法重载为成员函数"><a href="#复数类加减法重载为成员函数" class="headerlink" title="复数类加减法重载为成员函数"></a>复数类加减法重载为成员函数</h4><ul>
<li>将+、-运算重载为复数类的成员函数</li>
<li>实部和虚部分别相加减</li>
<li>两个操作数都是复数类的对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r=<span class="number">0.0</span>,<span class="type">double</span> i=<span class="number">0.0</span>):<span class="built_in">real</span>(r),<span class="built_in">imag</span>(i)&#123;&#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c2)<span class="type">const</span>;</span><br><span class="line">    Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex&amp; c2)<span class="type">const</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real,imag;</span><br><span class="line">&#125;;</span><br><span class="line">Complex Complex::<span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c2)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">Complex</span>(real+c2.real,imag+c2.imag);&#125;</span><br><span class="line">Complex Complex::<span class="keyword">operator</span>-(<span class="type">const</span> Complex&amp; c2)<span class="type">const</span>&#123;<span class="keyword">return</span> <span class="built_in">Complex</span>(real-c2.real,imag-c2.imag);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Complex::display</span><span class="params">()</span><span class="type">const</span></span>&#123;cout&lt;&lt;real&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;imag&lt;&lt;endl;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">2.5</span>,<span class="number">3.5</span>)</span>,<span class="title">c2</span><span class="params">(<span class="number">1.1</span>,<span class="number">5.7</span>)</span></span>;</span><br><span class="line">    Complex c3=c1+c2;</span><br><span class="line">    c3.<span class="built_in">display</span>();</span><br><span class="line">    Complex c4=c1-c2;</span><br><span class="line">    c4.<span class="built_in">display</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p.sda1.dev/18/b59c5135b2a20caa291e51c6ea607b5d/04498db706ecd2c26342540b19dfb455.png"></p>
<h2 id="单目运算符重载为成员函数"><a href="#单目运算符重载为成员函数" class="headerlink" title="单目运算符重载为成员函数"></a>单目运算符重载为成员函数</h2><h3 id="前置单目运算符重载规则"><a href="#前置单目运算符重载规则" class="headerlink" title="前置单目运算符重载规则"></a>前置单目运算符重载规则</h3><p>如果要重载U为类成员函数，使之能够实现表达式U oprd，其中oprd为A类对象，则U应该被重载为A类的成员函数，无形参。</p>
<p>经过重载之后，表达式U oprd相当于oprd.operator U()</p>
<h3 id="后置单目运算符-和–重载规则"><a href="#后置单目运算符-和–重载规则" class="headerlink" title="后置单目运算符++和–重载规则"></a>后置单目运算符++和–重载规则</h3><p>如果要重载++或–为类成员函数，使之能够实现表达式oprd+或oprd-，其中oprd为A类对象，则++或–应被重载为A类的成员函数，且具有一个int类型的形参。</p>
<p>经重载后，表达式oprd++相当于oprd.operator ++(0)</p>
<h4 id="重载前置-和后置-为时钟类成员函数"><a href="#重载前置-和后置-为时钟类成员函数" class="headerlink" title="重载前置++和后置++为时钟类成员函数"></a>重载前置++和后置++为时钟类成员函数</h4><ul>
<li>前置单目运算符，重载函数没有形参</li>
<li>后置++运算符，重载函数需要有一个int形参</li>
<li>操作数是时钟类的对象</li>
<li>实现时间增加一秒钟</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Clock</span>(<span class="type">int</span> hour=<span class="number">0</span>,<span class="type">int</span> minute=<span class="number">0</span>,<span class="type">int</span> second=<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showTime</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    Clock&amp; <span class="keyword">operator</span>++();</span><br><span class="line">    Clock <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hour,minute,second;</span><br><span class="line">&#125;;</span><br><span class="line">Clock::<span class="built_in">Clock</span>(<span class="type">int</span> hour,<span class="type">int</span> minute,<span class="type">int</span> second)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>&lt;=hour&amp;&amp;hour&lt;<span class="number">24</span>%%<span class="number">0</span>&lt;=minute&amp;&amp;minute&lt;<span class="number">60</span>&amp;&amp;<span class="number">0</span>&lt;=second&amp;&amp;second&lt;<span class="number">60</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hour=hour;</span><br><span class="line">        <span class="keyword">this</span>-&gt;minute=minute;</span><br><span class="line">        <span class="keyword">this</span>-&gt;second=second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;cout&lt;&lt;<span class="string">&quot;Time Error!\n&quot;</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clock::showTime</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;hour&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;minute&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;second&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运算符重载为非成员函数"><a href="#运算符重载为非成员函数" class="headerlink" title="运算符重载为非成员函数"></a>运算符重载为非成员函数</h2><h3 id="运算符重载为非成员函数-1"><a href="#运算符重载为非成员函数-1" class="headerlink" title="运算符重载为非成员函数"></a>运算符重载为非成员函数</h3><p>有些运算符不能重载为成员函数，例如二元运算符的左操作数不是对象，或者是不能由我们重载运算符的对象。</p>
<h3 id="运算符重载为非成员函数的规则"><a href="#运算符重载为非成员函数的规则" class="headerlink" title="运算符重载为非成员函数的规则"></a>运算符重载为非成员函数的规则</h3><p>函数的形参代表依从左到右的次序排列的各操作数。</p>
<p>重载为非成员函数时。</p>
<p>参数个数&#x3D;原操作数个数（后置++，–除外）</p>
<p>至少应该有一个自定义类型的参数</p>
<p>后置单目运算符++和–的重载函数，形参列表中要增加一个int，但不必写形参名。</p>
<p>如果在运算符的重载函数中需要操作某类对象的私有成员，可以将此函数声明为该类的友元。</p>
<h3 id="运算符重载1为非成员函数的规则"><a href="#运算符重载1为非成员函数的规则" class="headerlink" title="运算符重载1为非成员函数的规则"></a>运算符重载1为非成员函数的规则</h3><p>双目运算符B重载后，表达式oprd1 B oprd2等同于operator B(oprd)后置单目运算符++和–重载后，表达式oprd B等同于operator B(oprd.0)</p>
<h4 id="重载Complex的加减法和“"><a href="#重载Complex的加减法和“" class="headerlink" title="重载Complex的加减法和“&lt;&lt;”运算符为非成员函数"></a>重载Complex的加减法和“&lt;&lt;”运算符为非成员函数</h4><ul>
<li><p>将+、-（双目）重载为非成员函数，并将其声明为复数类的友元，两个操作数都是复数类的常引用。</p>
</li>
<li><p>将&lt;&lt;(双目)重载为非成员函数，并将其声明为复数类的友元，它的左操作数是std::ostream引用，右操作数为复数类的常引用，返回std::ostream引用，用以支持一下形式的输出：</p>
</li>
<li><pre><code class="cpp">cout&lt;&lt;a&lt;&lt;b;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">该输出调用的是</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">operator&lt;&lt;(operator&lt;&lt;(cout,a),b);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r=<span class="number">0.0</span>,<span class="type">double</span> i=<span class="number">0.0</span>):<span class="built_in">real</span>(r),<span class="built_in">imag</span>(i)&#123;&#125;;</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c1,<span class="type">const</span> Complex&amp; c2);</span><br><span class="line">    <span class="keyword">friend</span> Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex&amp; c1,<span class="type">const</span> Complex&amp; c2);</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os,<span class="type">const</span> Complex&amp; c);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real,imag;</span><br><span class="line">&#125;;</span><br><span class="line">Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex&amp; c1,<span class="type">const</span> Complex&amp; c2)&#123;<span class="keyword">return</span> <span class="built_in">Complex</span>(c1.real+c2.real,c1.imag+c2.imag);&#125;</span><br><span class="line">Complex <span class="keyword">operator</span>-(<span class="type">const</span> Complex&amp; c1,<span class="type">const</span> Complex&amp; c2)&#123;<span class="keyword">return</span> <span class="built_in">Complex</span>(c1.real-c2.real,c1.imag-c2.imag);&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,<span class="type">const</span> Complex&amp; c)&#123;cout&lt;&lt;c.real&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;c.imag;<span class="keyword">return</span> out;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">5</span>,<span class="number">4</span>)</span>,<span class="title">c2</span><span class="params">(<span class="number">2</span>,<span class="number">10</span>)</span>,c3</span>;</span><br><span class="line">    c3=c1-c2;</span><br><span class="line">    cout&lt;&lt;c1&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;c2&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;c3&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;c1+c2&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

![](https://p.sda1.dev/18/8755d261619d890c0e9353a8aed87a38/faf30fd4233c46ac29b3e3808e3f7d11.png)
</code></pre>
</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="类型转换规则"><a href="#类型转换规则" class="headerlink" title="类型转换规则"></a>类型转换规则</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base1::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>:<span class="keyword">public</span> Base1&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Base2::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Derived::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Base1 *ptr)</span></span>&#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base1 base1;</span><br><span class="line">    Base2 base2;</span><br><span class="line">    Derived derived;</span><br><span class="line">    <span class="built_in">fun</span>(&amp;base1);</span><br><span class="line">    <span class="built_in">fun</span>(&amp;base2);</span><br><span class="line">    <span class="built_in">fun</span>(&amp;derived);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p.sda1.dev/18/65caa7288507772341086ac552035df9/32842b637a6e08017db6dd6ecc28102e.png"></p>
<h3 id="通过虚函数实现运行时多态"><a href="#通过虚函数实现运行时多态" class="headerlink" title="通过虚函数实现运行时多态"></a>通过虚函数实现运行时多态</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Base1::display</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Base1::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>:<span class="keyword">public</span> Base1&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Base2::display</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Base2::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::display</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Derived::display()&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Base1 *ptr)</span></span>&#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base1 base1;</span><br><span class="line">    Base2 base2;</span><br><span class="line">    Derived derived;</span><br><span class="line">    <span class="built_in">fun</span>(&amp;base1);</span><br><span class="line">    <span class="built_in">fun</span>(&amp;base2);</span><br><span class="line">    <span class="built_in">fun</span>(&amp;derived);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p.sda1.dev/18/ec68de0765b14cbb9f17ee3e894e4656/0d8ec154d2604ce54b232dd670aa8727.png"></p>
<h3 id="初识虚函数"><a href="#初识虚函数" class="headerlink" title="初识虚函数"></a>初识虚函数</h3><ul>
<li><p>用virtual关键字说明的函数</p>
</li>
<li><p>虚函数是实现运行时多态性基础</p>
</li>
<li><p>C++的虚函数时动态绑定的函数</p>
</li>
<li><p>虚函数必须是非静态的成员函数，虚函数经过派生之后，就可以实现运行过程中的多态。</p>
</li>
<li><p>一般成员函数可以是虚函数</p>
</li>
<li><p>构造函数不能是虚函数</p>
</li>
<li><p>析构函数可以是虚函数</p>
</li>
</ul>
<h3 id="一般虚函数成员"><a href="#一般虚函数成员" class="headerlink" title="一般虚函数成员"></a>一般虚函数成员</h3><h4 id="虚函数的声明"><a href="#虚函数的声明" class="headerlink" title="虚函数的声明"></a>虚函数的声明</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 函数类型 函数名 (形参表)；</span><br></pre></td></tr></table></figure>

<p>虚函数声明只能出现在类定义的函数原型声明中，而不能在成员函数实现的时候。</p>
<p>在派生类中可以对基类中的成员函数进行覆盖。</p>
<p>虚函数一般不声明为内联函数，因为对虚函数的调用需要动态绑定，而对内联函数的处理时静态的。</p>
<h3 id="virtual关键字"><a href="#virtual关键字" class="headerlink" title="virtual关键字"></a>virtual关键字</h3><p>派生类可以不显式的用virtual声明虚函数，这时系统就会用以下规则来判断派生类的一个成员函数是不是虚函数。</p>
<ul>
<li>该函数是否与基类的虚函数有相同名称、参数个数及对应参数类型</li>
<li>该函数是否与基类的虚函数有相同的返回值或者满足类型兼容规则的指针、引用型的返回值</li>
<li>如果从名称、参数及返回值三个方面检查之后，派生类的函数满足上述条件，就会自动确定为虚函数。这时，派生类的虚函数便覆盖率基类的虚函数。</li>
<li>派生类中的虚函数还会隐藏基类中同名函数的所有其他重载形式</li>
<li>一般习惯于在派生类的函数中也使用virtual关键字，以增加程序的可读性。</li>
</ul>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>为什么需要虚析构函数？可能通过基类指针删除派生类对象，如果你打算允许其他人通过基类指针调用对象的析构函数（通过delete这样做时正常的），就需要让基类的析构函数成为虚函数，否则执行delete的结果时不确定的。</p>
<h3 id="一个不使用虚析构函数的例子"><a href="#一个不使用虚析构函数的例子" class="headerlink" title="一个不使用虚析构函数的例子"></a>一个不使用虚析构函数的例子</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inlcude<span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>();</span><br><span class="line">&#125;;</span><br><span class="line">Base::~<span class="built_in">Base</span>()&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Base destructor&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>();</span><br><span class="line">    ~<span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inlcude<span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span>~<span class="built_in">Base</span>();</span><br><span class="line">&#125;;</span><br><span class="line">Base::~<span class="built_in">Base</span>()&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Base destructor&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="虚表与动态绑定"><a href="#虚表与动态绑定" class="headerlink" title="虚表与动态绑定"></a>虚表与动态绑定</h2><h3 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h3><ul>
<li>每个多态类有一个虚表(virtual table)</li>
<li>虚表中有当前类的各个虚函数的入口地址</li>
<li>每个对象有一个指向当前类的虚表的指针(虚指针vptr)</li>
</ul>
<h3 id="动态绑定的实现"><a href="#动态绑定的实现" class="headerlink" title="动态绑定的实现"></a>动态绑定的实现</h3><ul>
<li>构造函数中为对象的虚指针赋值</li>
<li>通过多态类型的指针或引用调用成员函数时，通过虚指针找到虚表，进而找到所调用的虚函数的入口地址</li>
<li>通过该入口地址调用虚函数</li>
</ul>
<p>虚表示意图</p>
<p><img src="https://p.sda1.dev/18/0738771e7ab995b92f3f0a5bb8a7c9a7/6eeb75ff7399cc94e2d4999d5a508e0f.png"></p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数时一个在基类中声明的虚函数，它在该基类中没有定义具体的操作内容，要求各派生类根据实际需要定义自己的版本，纯虚函数的声明格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 函数类型 函数名(函数表)=<span class="number">0</span>；</span><br></pre></td></tr></table></figure>

<p>带有纯虚函数的类称为抽象类</p>
<h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><p>带有纯虚函数的类叫做抽象类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名&#123;<span class="keyword">virtual</span> 类型 函数名(参数表)=<span class="number">0</span>；&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象类作用"><a href="#抽象类作用" class="headerlink" title="抽象类作用"></a>抽象类作用</h3><ul>
<li>抽象类为抽象和设计的目的而声明</li>
<li>将有关数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。</li>
<li>对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现</li>
</ul>
<blockquote>
<p>抽象类只能作为基类去使用</p>
<p>不能定义抽象类的对象</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span><span class="type">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span>:<span class="keyword">public</span> Base1&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Base2::display</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Base2 display() const&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>:<span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Derived::display</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Derived display() const&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Base1*ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base2 base2;</span><br><span class="line">    Derived derived;</span><br><span class="line">    <span class="built_in">fun</span>(&amp;base2);</span><br><span class="line">    <span class="built_in">fun</span>(&amp;derived);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p.sda1.dev/18/c7a3e07e30ca22ad5bd12a4b7f5262c3/917c23a6e50b415690ea9214116cab51.png"></p>
<h2 id="C-11：override和final"><a href="#C-11：override和final" class="headerlink" title="C++11：override和final"></a>C++11：override和final</h2><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>多态行为的基础：基类声明虚函数，继承类声明一个函数覆盖该虚函数</p>
<p>覆盖要求：函数签名（signature）完全一只</p>
<p>函数签名包括 函数名 参数列表 const</p>
<h3 id="显式函数覆盖"><a href="#显式函数覆盖" class="headerlink" title="显式函数覆盖"></a>显式函数覆盖</h3><p>c++11引入显式函数覆盖，在编译期而非运行期捕获此类错误，在虚函数显式重载中运用，编译器会检查基类是否存在一虚拟函数，在派生类中带有声明override的虚拟函数，有相同的函数前面（signature）；若不存在，则会回报错误。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>C++11提供的final，用来避免类被继承，或是基类的函数被改写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span> <span class="keyword">final</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span> &#123;<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">final</span></span>;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived2</span> :Base2&#123;<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;<span class="keyword">final</span>&#125;<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure>

<h2 id="第八章小结"><a href="#第八章小结" class="headerlink" title="第八章小结"></a>第八章小结</h2><ul>
<li>多态性的概念，运算符重载，虚函数，纯虚函数，抽象类，override和final</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章：人事管理项目</title>
    <url>/2025/05/12/%E4%BA%BA%E4%BA%8B%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>结合AI以及一些基本的GUI内容进行人事管理项目的开发。</p>
<ul>
<li>第一步：创建一个模块来做这个项目</li>
<li>第二步：分析项目的业务需求</li>
</ul>
<ol>
<li>提供一个登录和注册用户的界面</li>
<li>提供一个人事信息管理的界面：展示全部员工信息，提供一个根据名称查询某个员工信息的展示，添加员工信息，删除员工信息，修改员工信息</li>
<li>分析项目的角色<ul>
<li>登录用户：登录名称，密码</li>
<li>员工信息：ID、性别、年龄、电话、职位、入职时间、薪水、部门信息</li>
</ul>
</li>
<li>分析系统的界面：<ul>
<li>登录界面类：创建登录界面</li>
<li>信息管理界面类：创建信息管理界面</li>
</ul>
</li>
</ol>
<ul>
<li>第三步：结合AI开始开发：Gemini<ul>
<li>Ai帮我们生成一个登录界面</li>
<li>AI帮我们生成一个信息管理界面</li>
</ul>
</li>
</ul>
<h2 id="人事系统-界面获取"><a href="#人事系统-界面获取" class="headerlink" title="人事系统 界面获取"></a>人事系统 界面获取</h2><h2 id="人事系统-界面分析-角色定义"><a href="#人事系统-界面分析-角色定义" class="headerlink" title="人事系统 界面分析 角色定义"></a>人事系统 界面分析 角色定义</h2><h2 id="人事系统-登录功能-AI"><a href="#人事系统-登录功能-AI" class="headerlink" title="人事系统 登录功能 AI"></a>人事系统 登录功能 AI</h2><h3 id="LoginFrame类的源码"><a href="#LoginFrame类的源码" class="headerlink" title="LoginFrame类的源码"></a>LoginFrame类的源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.border.EmptyBorder;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> JTextField usernameField;</span><br><span class="line">    <span class="keyword">private</span> JPasswordField passwordField;</span><br><span class="line">    <span class="keyword">private</span> JButton loginButton;</span><br><span class="line">    <span class="keyword">private</span> JButton registerButton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;登录界面&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">400</span>, <span class="number">300</span>); <span class="comment">// 稍微增大窗口</span></span><br><span class="line">        <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="built_in">this</span>.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">        createAndShowGUI(); <span class="comment">// 调用 createAndShowGUI 方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createAndShowGUI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建主面板</span></span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">mainPanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">BorderLayout</span>()); <span class="comment">// 使用 BorderLayout</span></span><br><span class="line">        mainPanel.setBackground(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">240</span>, <span class="number">240</span>, <span class="number">240</span>)); <span class="comment">// 浅灰色背景</span></span><br><span class="line">        mainPanel.setBorder(<span class="keyword">new</span> <span class="title class_">EmptyBorder</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>)); <span class="comment">// 设置边距</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置字体</span></span><br><span class="line">        <span class="type">Font</span> <span class="variable">chineseFont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;宋体&quot;</span>, Font.PLAIN, <span class="number">18</span>); <span class="comment">// 使用宋体，增大字号</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建顶部面板，包含标题</span></span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">titlePanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">        titlePanel.setBackground(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">240</span>, <span class="number">240</span>, <span class="number">240</span>)); <span class="comment">// 浅灰色背景</span></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">titleLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;用户登录&quot;</span>); <span class="comment">// 更友好的标题</span></span><br><span class="line">        titleLabel.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;微软雅黑&quot;</span>, Font.BOLD, <span class="number">24</span>)); <span class="comment">// 更现代的字体</span></span><br><span class="line">        titlePanel.add(titleLabel);</span><br><span class="line">        mainPanel.add(titlePanel, BorderLayout.NORTH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建中心面板，包含用户名和密码输入框</span></span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">centerPanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 使用 GridLayout，增加间距</span></span><br><span class="line">        centerPanel.setBackground(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">240</span>, <span class="number">240</span>, <span class="number">240</span>)); <span class="comment">// 浅灰色背景</span></span><br><span class="line">        centerPanel.setBorder(<span class="keyword">new</span> <span class="title class_">EmptyBorder</span>(<span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>)); <span class="comment">// 设置内部边距</span></span><br><span class="line"></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">usernameLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;用户名:&quot;</span>);</span><br><span class="line">        usernameLabel.setFont(chineseFont);</span><br><span class="line">        centerPanel.add(usernameLabel);</span><br><span class="line"></span><br><span class="line">        usernameField = <span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line">        usernameField.setFont(chineseFont);</span><br><span class="line">        centerPanel.add(usernameField);</span><br><span class="line"></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">passwordLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;密码:&quot;</span>);</span><br><span class="line">        passwordLabel.setFont(chineseFont);</span><br><span class="line">        centerPanel.add(passwordLabel);</span><br><span class="line"></span><br><span class="line">        passwordField = <span class="keyword">new</span> <span class="title class_">JPasswordField</span>();</span><br><span class="line">        passwordField.setFont(chineseFont);</span><br><span class="line">        centerPanel.add(passwordField);</span><br><span class="line">        mainPanel.add(centerPanel, BorderLayout.CENTER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建底部面板，包含登录和注册按钮</span></span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">buttonPanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>(FlowLayout.CENTER, <span class="number">20</span>, <span class="number">0</span>)); <span class="comment">// 使用 FlowLayout, 增加按钮间距</span></span><br><span class="line">        buttonPanel.setBackground(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">240</span>, <span class="number">240</span>, <span class="number">240</span>)); <span class="comment">// 浅灰色背景</span></span><br><span class="line"></span><br><span class="line">        loginButton = <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;登录&quot;</span>);</span><br><span class="line">        loginButton.setFont(chineseFont);</span><br><span class="line">        loginButton.setBackground(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">59</span>, <span class="number">89</span>, <span class="number">182</span>)); <span class="comment">// 更醒目的颜色</span></span><br><span class="line">        loginButton.setForeground(Color.WHITE);</span><br><span class="line">        loginButton.setFocusPainted(<span class="literal">false</span>); <span class="comment">// 移除焦点边框</span></span><br><span class="line">        buttonPanel.add(loginButton);</span><br><span class="line"></span><br><span class="line">        registerButton = <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;注册&quot;</span>);</span><br><span class="line">        registerButton.setFont(chineseFont);</span><br><span class="line">        registerButton.setBackground(<span class="keyword">new</span> <span class="title class_">Color</span>(<span class="number">59</span>, <span class="number">89</span>, <span class="number">182</span>)); <span class="comment">// 更醒目的颜色</span></span><br><span class="line">        registerButton.setForeground(Color.WHITE);</span><br><span class="line">        registerButton.setFocusPainted(<span class="literal">false</span>); <span class="comment">// 移除焦点边框</span></span><br><span class="line">        buttonPanel.add(registerButton);</span><br><span class="line">        mainPanel.add(buttonPanel, BorderLayout.SOUTH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加事件监听器</span></span><br><span class="line">        loginButton.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">                <span class="comment">// 在这里添加登录逻辑</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> usernameField.getText();</span><br><span class="line">                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(passwordField.getPassword()); <span class="comment">// 获取密码</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span>  验证用户名和密码</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(username) &amp;&amp; <span class="string">&quot;password&quot;</span>.equals(password)) &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(LoginFrame.<span class="built_in">this</span>, <span class="string">&quot;登录成功!&quot;</span>);</span><br><span class="line">                    <span class="comment">// 登录成功后，创建并显示员工信息管理界面</span></span><br><span class="line">                    SwingUtilities.invokeLater(() -&gt; &#123;</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">EmployeeManagementFrame</span>().setVisible(<span class="literal">true</span>);</span><br><span class="line">                    &#125;);</span><br><span class="line">                    LoginFrame.<span class="built_in">this</span>.dispose(); <span class="comment">// 关闭登录界面</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    JOptionPane.showMessageDialog(LoginFrame.<span class="built_in">this</span>, <span class="string">&quot;用户名或密码错误!&quot;</span>, <span class="string">&quot;错误&quot;</span>, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        registerButton.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">                <span class="comment">// 在这里添加注册逻辑</span></span><br><span class="line">                JOptionPane.showMessageDialog(LoginFrame.<span class="built_in">this</span>, <span class="string">&quot;注册功能尚未实现!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加面板到窗体</span></span><br><span class="line">        <span class="built_in">this</span>.add(mainPanel);</span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SwingUtilities.invokeLater(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LoginFrame</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="独立的继承内容"><a href="#独立的继承内容" class="headerlink" title="独立的继承内容"></a>独立的继承内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">LoginFrame</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;登录界面&quot;</span>);  </span><br><span class="line">    <span class="built_in">this</span>.setSize(<span class="number">400</span>, <span class="number">300</span>); <span class="comment">// 稍微增大窗口  </span></span><br><span class="line">    <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  </span><br><span class="line">    <span class="built_in">this</span>.setLocationRelativeTo(<span class="literal">null</span>);  </span><br><span class="line">    createAndShowGUI(); <span class="comment">// 调用 createAndShowGUI 方法  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="人事系统-弹出添加员工信息的界面-AI"><a href="#人事系统-弹出添加员工信息的界面-AI" class="headerlink" title="人事系统 弹出添加员工信息的界面 AI"></a>人事系统 弹出添加员工信息的界面 AI</h2><h3 id="员工信息类EmployeeManagementFrame源码"><a href="#员工信息类EmployeeManagementFrame源码" class="headerlink" title="员工信息类EmployeeManagementFrame源码"></a>员工信息类EmployeeManagementFrame源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> javax.swing.border.EmptyBorder;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeManagementFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JTextField idField, genderField, ageField, phoneField, positionField, hireDateField, salaryField, departmentField;</span><br><span class="line">    <span class="keyword">private</span> JButton addButton, deleteButton, updateButton;</span><br><span class="line">    <span class="keyword">private</span> JTextArea displayArea;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Employee&gt; employeeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存储员工信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EmployeeManagementFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;员工信息管理&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">        <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); <span class="comment">// 关闭窗口时只关闭当前窗口</span></span><br><span class="line">        <span class="built_in">this</span>.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">        createAndShowGUI();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createAndShowGUI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 主面板</span></span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">mainPanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">BorderLayout</span>());</span><br><span class="line">        mainPanel.setBorder(<span class="keyword">new</span> <span class="title class_">EmptyBorder</span>(<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顶部面板，用于输入员工信息</span></span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">inputPanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">8</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">        inputPanel.setBorder(BorderFactory.createTitledBorder(<span class="string">&quot;员工信息&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Font</span> <span class="variable">labelFont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;宋体&quot;</span>, Font.PLAIN, <span class="number">16</span>);</span><br><span class="line">        <span class="type">Font</span> <span class="variable">fieldFont</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;宋体&quot;</span>, Font.PLAIN, <span class="number">14</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">idLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;ID:&quot;</span>);</span><br><span class="line">        idLabel.setFont(labelFont);</span><br><span class="line">        idField = <span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line">        idField.setFont(fieldFont);</span><br><span class="line">        inputPanel.add(idLabel);</span><br><span class="line">        inputPanel.add(idField);</span><br><span class="line"></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">genderLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;性别:&quot;</span>);</span><br><span class="line">        genderLabel.setFont(labelFont);</span><br><span class="line">        genderField = <span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line">        genderField.setFont(fieldFont);</span><br><span class="line">        inputPanel.add(genderLabel);</span><br><span class="line">        inputPanel.add(genderField);</span><br><span class="line"></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">ageLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;年龄:&quot;</span>);</span><br><span class="line">        ageLabel.setFont(labelFont);</span><br><span class="line">        ageField = <span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line">        ageField.setFont(fieldFont);</span><br><span class="line">        inputPanel.add(ageLabel);</span><br><span class="line">        inputPanel.add(ageField);</span><br><span class="line"></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">phoneLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;电话:&quot;</span>);</span><br><span class="line">        phoneLabel.setFont(labelFont);</span><br><span class="line">        phoneField = <span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line">        phoneField.setFont(fieldFont);</span><br><span class="line">        inputPanel.add(phoneLabel);</span><br><span class="line">        inputPanel.add(phoneField);</span><br><span class="line"></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">positionLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;职位:&quot;</span>);</span><br><span class="line">        positionLabel.setFont(labelFont);</span><br><span class="line">        positionField = <span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line">        positionField.setFont(fieldFont);</span><br><span class="line">        inputPanel.add(positionLabel);</span><br><span class="line">        inputPanel.add(positionField);</span><br><span class="line"></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">hireDateLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;入职时间:&quot;</span>);</span><br><span class="line">        hireDateLabel.setFont(labelFont);</span><br><span class="line">        hireDateField = <span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line">        hireDateField.setFont(fieldFont);</span><br><span class="line">        inputPanel.add(hireDateLabel);</span><br><span class="line">        inputPanel.add(hireDateField);</span><br><span class="line"></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">salaryLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;薪水:&quot;</span>);</span><br><span class="line">        salaryLabel.setFont(labelFont);</span><br><span class="line">        salaryField = <span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line">        salaryField.setFont(fieldFont);</span><br><span class="line">        inputPanel.add(salaryLabel);</span><br><span class="line">        inputPanel.add(salaryField);</span><br><span class="line"></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">departmentLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;部门信息:&quot;</span>);</span><br><span class="line">        departmentLabel.setFont(labelFont);</span><br><span class="line">        departmentField = <span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line">        departmentField.setFont(fieldFont);</span><br><span class="line">        inputPanel.add(departmentLabel);</span><br><span class="line">        inputPanel.add(departmentField);</span><br><span class="line"></span><br><span class="line">        mainPanel.add(inputPanel, BorderLayout.NORTH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中心面板，用于显示员工信息</span></span><br><span class="line">        displayArea = <span class="keyword">new</span> <span class="title class_">JTextArea</span>();</span><br><span class="line">        displayArea.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;Monospaced&quot;</span>, Font.PLAIN, <span class="number">14</span>));</span><br><span class="line">        <span class="type">JScrollPane</span> <span class="variable">scrollPane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JScrollPane</span>(displayArea);</span><br><span class="line">        mainPanel.add(scrollPane, BorderLayout.CENTER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 底部面板，包含添加、删除和修改按钮</span></span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">buttonPanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>(FlowLayout.CENTER, <span class="number">20</span>, <span class="number">0</span>));</span><br><span class="line">        addButton = <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;添加&quot;</span>);</span><br><span class="line">        deleteButton = <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;删除&quot;</span>);</span><br><span class="line">        updateButton = <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;修改&quot;</span>);</span><br><span class="line"></span><br><span class="line">        buttonPanel.add(addButton);</span><br><span class="line">        buttonPanel.add(deleteButton);</span><br><span class="line">        buttonPanel.add(updateButton);</span><br><span class="line"></span><br><span class="line">        mainPanel.add(buttonPanel, BorderLayout.SOUTH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加事件监听器</span></span><br><span class="line">        addButton.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">                <span class="comment">// 添加员工信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> idField.getText();</span><br><span class="line">                <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> genderField.getText();</span><br><span class="line">                <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> ageField.getText();</span><br><span class="line">                <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> phoneField.getText();</span><br><span class="line">                <span class="type">String</span> <span class="variable">position</span> <span class="operator">=</span> positionField.getText();</span><br><span class="line">                <span class="type">String</span> <span class="variable">hireDate</span> <span class="operator">=</span> hireDateField.getText();</span><br><span class="line">                <span class="type">String</span> <span class="variable">salary</span> <span class="operator">=</span> salaryField.getText();</span><br><span class="line">                <span class="type">String</span> <span class="variable">department</span> <span class="operator">=</span> departmentField.getText();</span><br><span class="line"></span><br><span class="line">                <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(id, gender, age, phone, position, hireDate, salary, department);</span><br><span class="line">                employeeList.add(employee);</span><br><span class="line"></span><br><span class="line">                updateDisplayArea(); <span class="comment">// 更新显示区域</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 清空输入框</span></span><br><span class="line">                idField.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                genderField.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                ageField.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                phoneField.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                positionField.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                hireDateField.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                salaryField.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                departmentField.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        deleteButton.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">                <span class="comment">// 删除员工信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">idToDelete</span> <span class="operator">=</span> JOptionPane.showInputDialog(EmployeeManagementFrame.<span class="built_in">this</span>, <span class="string">&quot;请输入要删除的员工ID:&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (idToDelete != <span class="literal">null</span> &amp;&amp; !idToDelete.isEmpty()) &#123;</span><br><span class="line">                    Iterator&lt;Employee&gt; iterator = employeeList.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                        <span class="keyword">if</span> (employee.getId().equals(idToDelete)) &#123;</span><br><span class="line">                            iterator.remove(); <span class="comment">// 使用迭代器删除元素</span></span><br><span class="line">                            updateDisplayArea(); <span class="comment">// 更新显示区域</span></span><br><span class="line">                            JOptionPane.showMessageDialog(EmployeeManagementFrame.<span class="built_in">this</span>, <span class="string">&quot;员工信息删除成功!&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    JOptionPane.showMessageDialog(EmployeeManagementFrame.<span class="built_in">this</span>, <span class="string">&quot;未找到该ID的员工!&quot;</span>, <span class="string">&quot;错误&quot;</span>, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        updateButton.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">                <span class="comment">// 修改员工信息</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">idToUpdate</span> <span class="operator">=</span> JOptionPane.showInputDialog(EmployeeManagementFrame.<span class="built_in">this</span>, <span class="string">&quot;请输入要修改的员工ID:&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (idToUpdate != <span class="literal">null</span> &amp;&amp; !idToUpdate.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Employee employee : employeeList) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (employee.getId().equals(idToUpdate)) &#123;</span><br><span class="line">                            <span class="comment">// 弹出修改信息的对话框</span></span><br><span class="line">                            <span class="type">JPanel</span> <span class="variable">updatePanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">8</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line">                            <span class="type">JTextField</span> <span class="variable">genderFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getGender());</span><br><span class="line">                            <span class="type">JTextField</span> <span class="variable">ageFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getAge());</span><br><span class="line">                            <span class="type">JTextField</span> <span class="variable">phoneFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getPhone());</span><br><span class="line">                            <span class="type">JTextField</span> <span class="variable">positionFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getPosition());</span><br><span class="line">                            <span class="type">JTextField</span> <span class="variable">hireDateFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getHireDate());</span><br><span class="line">                            <span class="type">JTextField</span> <span class="variable">salaryFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getSalary());</span><br><span class="line">                            <span class="type">JTextField</span> <span class="variable">departmentFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getDepartment());</span><br><span class="line"></span><br><span class="line">                            updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;性别:&quot;</span>));</span><br><span class="line">                            updatePanel.add(genderFieldUpdate);</span><br><span class="line">                            updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;年龄:&quot;</span>));</span><br><span class="line">                            updatePanel.add(ageFieldUpdate);</span><br><span class="line">                            updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;电话:&quot;</span>));</span><br><span class="line">                            updatePanel.add(phoneFieldUpdate);</span><br><span class="line">                            updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;职位:&quot;</span>));</span><br><span class="line">                            updatePanel.add(positionFieldUpdate);</span><br><span class="line">                            updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;入职时间:&quot;</span>));</span><br><span class="line">                            updatePanel.add(hireDateFieldUpdate);</span><br><span class="line">                            updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;薪水:&quot;</span>));</span><br><span class="line">                            updatePanel.add(salaryFieldUpdate);</span><br><span class="line">                            updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;部门:&quot;</span>));</span><br><span class="line">                            updatePanel.add(departmentFieldUpdate);</span><br><span class="line"></span><br><span class="line">                            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> JOptionPane.showConfirmDialog(EmployeeManagementFrame.<span class="built_in">this</span>, updatePanel, <span class="string">&quot;修改员工信息&quot;</span>, JOptionPane.OK_CANCEL_OPTION);</span><br><span class="line">                            <span class="keyword">if</span> (result == JOptionPane.OK_OPTION) &#123;</span><br><span class="line">                                <span class="comment">// 更新员工信息</span></span><br><span class="line">                                employee.setGender(genderFieldUpdate.getText());</span><br><span class="line">                                employee.setAge(ageFieldUpdate.getText());</span><br><span class="line">                                employee.setPhone(phoneFieldUpdate.getText());</span><br><span class="line">                                employee.setPosition(positionFieldUpdate.getText());</span><br><span class="line">                                employee.setHireDate(hireDateFieldUpdate.getText());</span><br><span class="line">                                employee.setSalary(salaryFieldUpdate.getText());</span><br><span class="line">                                employee.setDepartment(departmentFieldUpdate.getText());</span><br><span class="line"></span><br><span class="line">                                updateDisplayArea(); <span class="comment">// 更新显示区域</span></span><br><span class="line">                                JOptionPane.showMessageDialog(EmployeeManagementFrame.<span class="built_in">this</span>, <span class="string">&quot;员工信息修改成功!&quot;</span>);</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    JOptionPane.showMessageDialog(EmployeeManagementFrame.<span class="built_in">this</span>, <span class="string">&quot;未找到该ID的员工!&quot;</span>, <span class="string">&quot;错误&quot;</span>, JOptionPane.ERROR_MESSAGE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.add(mainPanel);</span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新显示区域</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateDisplayArea</span><span class="params">()</span> &#123;</span><br><span class="line">        displayArea.setText(<span class="string">&quot;&quot;</span>); <span class="comment">// 清空显示区域</span></span><br><span class="line">        <span class="keyword">for</span> (Employee employee : employeeList) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">employeeInfo</span> <span class="operator">=</span> String.format(<span class="string">&quot;ID: %s, 性别: %s, 年龄: %s, 电话: %s, 职位: %s, 入职时间: %s, 薪水: %s, 部门: %s\n&quot;</span>,</span><br><span class="line">                    employee.getId(), employee.getGender(), employee.getAge(), employee.getPhone(), employee.getPosition(), employee.getHireDate(), employee.getSalary(), employee.getDepartment());</span><br><span class="line">            displayArea.append(employeeInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SwingUtilities.invokeLater(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EmployeeManagementFrame</span>().setVisible(<span class="literal">true</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;```</span><br><span class="line">### Employee类</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String age;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> String position;</span><br><span class="line">    <span class="keyword">private</span> String hireDate;</span><br><span class="line">    <span class="keyword">private</span> String salary;</span><br><span class="line">    <span class="keyword">private</span> String department;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String id, String gender, String age, String phone, String position, String hireDate, String salary, String department)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">        <span class="built_in">this</span>.position = position;</span><br><span class="line">        <span class="built_in">this</span>.hireDate = hireDate;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">        <span class="built_in">this</span>.department = department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and setters</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String gender)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(String age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPosition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPosition</span><span class="params">(String position)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.position = position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHireDate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hireDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHireDate</span><span class="params">(String hireDate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hireDate = hireDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(String salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDepartment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> department;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDepartment</span><span class="params">(String department)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.department = department;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义管理窗口"><a href="#自定义管理窗口" class="headerlink" title="自定义管理窗口"></a>自定义管理窗口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">EmployeeManagementFrame</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;员工信息管理&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.setSize(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">    <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); <span class="comment">// 关闭窗口时只关闭当前窗口</span></span><br><span class="line">    <span class="built_in">this</span>.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">    createAndShowGUI();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将相关的数据全部放到类的前面，作为全局变量</span></span><br></pre></td></tr></table></figure>

<h2 id="人事系统-登录功能-人工"><a href="#人事系统-登录功能-人工" class="headerlink" title="人事系统 登录功能 人工"></a>人事系统 登录功能 人工</h2><p>系统中需要存储用户信息，我们可以先开发注册功能，注册一些用户信息，为了简化操作，我们可以直接在系统当中存放一些用户信息。<br>准备一个集合容器，存储系统中全部的用户信息</p>
<h3 id="用户信息集合容器"><a href="#用户信息集合容器" class="headerlink" title="用户信息集合容器"></a>用户信息集合容器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();  </span><br><span class="line"><span class="comment">//初始化几个测试用户对象信息，作为登录用  </span></span><br><span class="line"><span class="keyword">static</span> &#123;  </span><br><span class="line">    users.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Shiokou&quot;</span>, <span class="string">&quot;Shiokou&quot;</span>));  </span><br><span class="line">    users.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Shiokou1&quot;</span>, <span class="string">&quot;Shiokou1&quot;</span>));  </span><br><span class="line">    users.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Shiokou2&quot;</span>, <span class="string">&quot;Shiokou2&quot;</span>));  </span><br><span class="line">    users.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Shiokou3&quot;</span>, <span class="string">&quot;Shiokou3&quot;</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h4><ul>
<li>给登录按钮绑定一个点击事件监听器</li>
<li>一旦点击登录按钮，就拿到输入框输入用户名和密码</li>
<li>去集合当中查看是否存在这个用户对象，如果通过认证，则跳转到信息管理界面，登录失败就弹出提示<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">loginButton.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;  </span><br><span class="line">        <span class="comment">// 在这里添加登录逻辑  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> usernameField.getText();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(passwordField.getPassword()); <span class="comment">// 获取密码  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 验证用户名和密码  </span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">authenticated</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (user.getUsername().equals(username) &amp;&amp; user.getPassword().equals(password)) &#123;  </span><br><span class="line">                authenticated = <span class="literal">true</span>;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (authenticated) &#123;  </span><br><span class="line">            JOptionPane.showMessageDialog(LoginFrame.<span class="built_in">this</span>, <span class="string">&quot;登录成功!&quot;</span>);  </span><br><span class="line">            <span class="comment">// 登录成功后，创建并显示员工信息管理界面  </span></span><br><span class="line">            SwingUtilities.invokeLater(() -&gt; &#123;  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">EmployeeManagementFrame</span>().setVisible(<span class="literal">true</span>);  </span><br><span class="line">            &#125;);  </span><br><span class="line">            LoginFrame.<span class="built_in">this</span>.dispose(); <span class="comment">// 关闭登录界面  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            JOptionPane.showMessageDialog(LoginFrame.<span class="built_in">this</span>, <span class="string">&quot;用户名或密码错误!&quot;</span>, <span class="string">&quot;错误&quot;</span>, JOptionPane.ERROR_MESSAGE);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="注册功能追加"><a href="#注册功能追加" class="headerlink" title="注册功能追加"></a>注册功能追加</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registerButton.addActionListener(e -&gt; &#123;  </span><br><span class="line">    <span class="comment">// 创建注册界面  </span></span><br><span class="line">    <span class="type">JPanel</span> <span class="variable">registerPanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>));  </span><br><span class="line">    <span class="type">JTextField</span> <span class="variable">registerUsernameField</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>();  </span><br><span class="line">    <span class="type">JPasswordField</span> <span class="variable">registerPasswordField</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPasswordField</span>();  </span><br><span class="line">    <span class="type">JPasswordField</span> <span class="variable">confirmPasswordField</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPasswordField</span>();  </span><br><span class="line">  </span><br><span class="line">    registerPanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;用户名:&quot;</span>));  </span><br><span class="line">    registerPanel.add(registerUsernameField);  </span><br><span class="line">    registerPanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;密码:&quot;</span>));  </span><br><span class="line">    registerPanel.add(registerPasswordField);  </span><br><span class="line">    registerPanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;确认密码:&quot;</span>));  </span><br><span class="line">    registerPanel.add(confirmPasswordField);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> JOptionPane.showConfirmDialog(LoginFrame.<span class="built_in">this</span>, registerPanel, <span class="string">&quot;注册&quot;</span>, JOptionPane.OK_CANCEL_OPTION);  </span><br><span class="line">    <span class="keyword">if</span> (result == JOptionPane.OK_OPTION) &#123;  </span><br><span class="line">        <span class="comment">// 获取注册信息  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> registerUsernameField.getText();  </span><br><span class="line">        <span class="type">char</span>[] password = registerPasswordField.getPassword();  </span><br><span class="line">        <span class="type">char</span>[] confirmPassword = confirmPasswordField.getPassword();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 验证用户名是否已存在  </span></span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (user.getUsername().equals(username)) &#123;  </span><br><span class="line">                JOptionPane.showMessageDialog(LoginFrame.<span class="built_in">this</span>, <span class="string">&quot;用户名已存在!&quot;</span>, <span class="string">&quot;错误&quot;</span>, JOptionPane.ERROR_MESSAGE);  </span><br><span class="line">                <span class="keyword">return</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 验证密码和确认密码是否一致  </span></span><br><span class="line">        <span class="keyword">if</span> (!Arrays.equals(password, confirmPassword)) &#123;  </span><br><span class="line">            JOptionPane.showMessageDialog(LoginFrame.<span class="built_in">this</span>, <span class="string">&quot;密码和确认密码不一致!&quot;</span>, <span class="string">&quot;错误&quot;</span>, JOptionPane.ERROR_MESSAGE);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 创建新用户  </span></span><br><span class="line">        <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(username, <span class="keyword">new</span> <span class="title class_">String</span>(password));  </span><br><span class="line">        users.add(newUser);  </span><br><span class="line">  </span><br><span class="line">        JOptionPane.showMessageDialog(LoginFrame.<span class="built_in">this</span>, <span class="string">&quot;注册成功!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="完成信息管理界面的核心开发"><a href="#完成信息管理界面的核心开发" class="headerlink" title="完成信息管理界面的核心开发"></a>完成信息管理界面的核心开发</h2><h3 id="界面的用户信息"><a href="#界面的用户信息" class="headerlink" title="界面的用户信息"></a>界面的用户信息</h3><h4 id="有参构造器"><a href="#有参构造器" class="headerlink" title="有参构造器"></a>有参构造器</h4><ul>
<li>登录成功后将登录信息传给信息管理界面</li>
<li>通过有参构造器的使用，调用的时候传入用户的姓名信息。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">EmployeeManagementFrame</span><span class="params">(String username)</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;欢迎，&quot;</span>+username+<span class="string">&quot;进入人事信息管理界面&quot;</span>);  </span><br><span class="line">    <span class="built_in">this</span>.username = username;  </span><br><span class="line">    frame =<span class="built_in">this</span>;  </span><br><span class="line">    createAndShowGUI();  </span><br><span class="line">    <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>添加员工信息的功能<ul>
<li>准备一个静态的集合，存储系统中的所有员工信息</li>
<li>给添加事件绑定事件</li>
<li>点击添加按钮后，弹出一个添加员工信息的输入框</li>
<li>把员工信息封装成一个员工对象，存到系统当中去，然后刷新表格，展示最新添加的数据</li>
</ul>
</li>
</ul>
<h4 id="信息表现形式"><a href="#信息表现形式" class="headerlink" title="信息表现形式"></a>信息表现形式</h4><ul>
<li>用表格来表示用户的各种信息</li>
<li>修改的事件监听器</li>
<li>删除的事件监听器</li>
<li>添加的事件监听器</li>
</ul>
<h5 id="表格的表现形式"><a href="#表格的表现形式" class="headerlink" title="表格的表现形式"></a>表格的表现形式</h5><h5 id="添加的事件监听器"><a href="#添加的事件监听器" class="headerlink" title="添加的事件监听器"></a>添加的事件监听器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addButton.addActionListener(e -&gt; &#123;  </span><br><span class="line">    <span class="comment">// 添加员工信息  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> idField.getText();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> genderField.getText();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> ageField.getText();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> phoneField.getText();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">position</span> <span class="operator">=</span> positionField.getText();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">hireDate</span> <span class="operator">=</span> hireDateField.getText();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">salary</span> <span class="operator">=</span> salaryField.getText();  </span><br><span class="line">    <span class="type">String</span> <span class="variable">department</span> <span class="operator">=</span> departmentField.getText();  </span><br><span class="line">  </span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(id, gender, age, phone, position, hireDate, salary, department);  </span><br><span class="line">    employeeList.add(employee);  </span><br><span class="line">    employees.add(employee); <span class="comment">// 添加到静态集合  </span></span><br><span class="line">  </span><br><span class="line">    updateDisplayArea(); <span class="comment">// 更新显示区域  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 清空输入框  </span></span><br><span class="line">    idField.setText(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">    genderField.setText(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">    ageField.setText(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">    phoneField.setText(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">    positionField.setText(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">    hireDateField.setText(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">    salaryField.setText(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">    departmentField.setText(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="删除的事件监听器"><a href="#删除的事件监听器" class="headerlink" title="删除的事件监听器"></a>删除的事件监听器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eleteMenuItem.addActionListener(e -&gt; &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">selectedRow</span> <span class="operator">=</span> employeeTable.getSelectedRow();  </span><br><span class="line">    <span class="keyword">if</span> (selectedRow != -<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employeeToDelete</span> <span class="operator">=</span> employees.get(selectedRow);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> JOptionPane.showConfirmDialog(EmployeeManagementFrame.<span class="built_in">this</span>, <span class="string">&quot;确定要删除员工 &quot;</span> + employeeToDelete.getId() + <span class="string">&quot; 吗?&quot;</span>, <span class="string">&quot;删除确认&quot;</span>, JOptionPane.YES_NO_OPTION);  </span><br><span class="line">        <span class="keyword">if</span> (result == JOptionPane.YES_OPTION) &#123;  </span><br><span class="line">            employees.remove(selectedRow);  </span><br><span class="line">            updateDisplayArea(); <span class="comment">// 更新显示区域  </span></span><br><span class="line">            JOptionPane.showMessageDialog(EmployeeManagementFrame.<span class="built_in">this</span>, <span class="string">&quot;员工信息删除成功!&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        JOptionPane.showMessageDialog(EmployeeManagementFrame.<span class="built_in">this</span>, <span class="string">&quot;请选择要删除的员工!&quot;</span>, <span class="string">&quot;错误&quot;</span>, JOptionPane.ERROR_MESSAGE);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="修改的事件监听器"><a href="#修改的事件监听器" class="headerlink" title="修改的事件监听器"></a>修改的事件监听器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">updateMenuItem.addActionListener(e -&gt; &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">selectedRow</span> <span class="operator">=</span> employeeTable.getSelectedRow();  </span><br><span class="line">    <span class="keyword">if</span> (selectedRow != -<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employees.get(selectedRow);  </span><br><span class="line">        <span class="comment">// 弹出修改信息的对话框  </span></span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">updatePanel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">8</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>));  </span><br><span class="line">        <span class="type">JTextField</span> <span class="variable">genderFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getGender());  </span><br><span class="line">        <span class="type">JTextField</span> <span class="variable">ageFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getAge());  </span><br><span class="line">        <span class="type">JTextField</span> <span class="variable">phoneFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getPhone());  </span><br><span class="line">        <span class="type">JTextField</span> <span class="variable">positionFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getPosition());  </span><br><span class="line">        <span class="type">JTextField</span> <span class="variable">hireDateFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getHireDate());  </span><br><span class="line">        <span class="type">JTextField</span> <span class="variable">salaryFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getSalary());  </span><br><span class="line">        <span class="type">JTextField</span> <span class="variable">departmentFieldUpdate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(employee.getDepartment());  </span><br><span class="line">  </span><br><span class="line">        updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;性别:&quot;</span>));  </span><br><span class="line">        updatePanel.add(genderFieldUpdate);  </span><br><span class="line">        updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;年龄:&quot;</span>));  </span><br><span class="line">        updatePanel.add(ageFieldUpdate);  </span><br><span class="line">        updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;电话:&quot;</span>));  </span><br><span class="line">        updatePanel.add(phoneFieldUpdate);  </span><br><span class="line">        updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;职位:&quot;</span>));  </span><br><span class="line">        updatePanel.add(positionFieldUpdate);  </span><br><span class="line">        updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;入职时间:&quot;</span>));  </span><br><span class="line">        updatePanel.add(hireDateFieldUpdate);  </span><br><span class="line">        updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;薪水:&quot;</span>));  </span><br><span class="line">        updatePanel.add(salaryFieldUpdate);  </span><br><span class="line">        updatePanel.add(<span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;部门:&quot;</span>));  </span><br><span class="line">        updatePanel.add(departmentFieldUpdate);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> JOptionPane.showConfirmDialog(EmployeeManagementFrame.<span class="built_in">this</span>, updatePanel, <span class="string">&quot;修改员工信息&quot;</span>, JOptionPane.OK_CANCEL_OPTION);  </span><br><span class="line">        <span class="keyword">if</span> (result == JOptionPane.OK_OPTION) &#123;  </span><br><span class="line">            <span class="comment">// 更新员工信息  </span></span><br><span class="line">            employee.setGender(genderFieldUpdate.getText());  </span><br><span class="line">            employee.setAge(ageFieldUpdate.getText());  </span><br><span class="line">            employee.setPhone(phoneFieldUpdate.getText());  </span><br><span class="line">            employee.setPosition(positionFieldUpdate.getText());  </span><br><span class="line">            employee.setHireDate(hireDateFieldUpdate.getText());  </span><br><span class="line">            employee.setSalary(salaryFieldUpdate.getText());  </span><br><span class="line">            employee.setDepartment(departmentFieldUpdate.getText());  </span><br><span class="line">  </span><br><span class="line">            updateDisplayArea(); <span class="comment">// 更新显示区域  </span></span><br><span class="line">            JOptionPane.showMessageDialog(EmployeeManagementFrame.<span class="built_in">this</span>, <span class="string">&quot;员工信息修改成功!&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        JOptionPane.showMessageDialog(EmployeeManagementFrame.<span class="built_in">this</span>, <span class="string">&quot;请选择要修改的员工!&quot;</span>, <span class="string">&quot;错误&quot;</span>, JOptionPane.ERROR_MESSAGE);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="鼠标行动监听器"><a href="#鼠标行动监听器" class="headerlink" title="鼠标行动监听器"></a>鼠标行动监听器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">employeeTable.addMouseListener(<span class="keyword">new</span> <span class="title class_">MouseAdapter</span>() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mouseReleased</span><span class="params">(MouseEvent e)</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (e.isPopupTrigger()) &#123;  </span><br><span class="line">                <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> employeeTable.rowAtPoint(e.getPoint());  </span><br><span class="line">                <span class="keyword">if</span> (row &gt;= <span class="number">0</span> &amp;&amp; row &lt; employeeTable.getRowCount()) &#123;  </span><br><span class="line">                    employeeTable.setRowSelectionInterval(row, row);  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    employeeTable.clearSelection();  </span><br><span class="line">                &#125;  </span><br><span class="line">                popupMenu.show(e.getComponent(), e.getX(), e.getY());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">this</span>.add(mainPanel);  </span><br><span class="line">    <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化表格数据  </span></span><br><span class="line">    updateDisplayArea();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="美化GUI界面"><a href="#美化GUI界面" class="headerlink" title="美化GUI界面"></a>美化GUI界面</h3><h4 id="ImagePanel类"><a href="#ImagePanel类" class="headerlink" title="ImagePanel类"></a>ImagePanel类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shiokou.HM.ui;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;  </span><br><span class="line"><span class="keyword">import</span> javax.swing.*;  </span><br><span class="line"><span class="keyword">import</span> java.awt.*;  </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ImagePanel</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Image image;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImagePanel</span><span class="params">(String imagePath)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> getClass().getResourceAsStream(imagePath);  </span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;  </span><br><span class="line">                image = ImageIO.read(inputStream);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                System.err.println(<span class="string">&quot;找不到图片: &quot;</span> + imagePath);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;  </span><br><span class="line">            ex.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">paintComponent</span><span class="params">(Graphics g)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>.paintComponent(g);  </span><br><span class="line">        <span class="keyword">if</span> (image != <span class="literal">null</span>) &#123;  </span><br><span class="line">            g.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">this</span>.getWidth(), <span class="built_in">this</span>.getHeight(), <span class="built_in">this</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣3250单调数组对的数目1</title>
    <url>/2024/11/28/%E5%8A%9B%E6%89%A33250%E5%8D%95%E8%B0%83%E6%95%B0%E7%BB%84%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE1/</url>
    <content><![CDATA[<h2 id="3250-单调数组对的数目-I"><a href="#3250-单调数组对的数目-I" class="headerlink" title="3250. 单调数组对的数目 I"></a><a href="https://leetcode.cn/problems/find-the-count-of-monotonic-pairs-i/">3250. 单调数组对的数目 I</a></h2><p>给你一个长度为 <code>n</code> 的 <strong>正</strong> 整数数组 <code>nums</code> 。</p>
<p>如果两个 <strong>非负</strong> 整数数组 <code>(arr1, arr2)</code> 满足以下条件，我们称它们是 <strong>单调</strong> 数组对：</p>
<ul>
<li>两个数组的长度都是 <code>n</code> 。</li>
<li><code>arr1</code> 是单调 <strong>非递减</strong> 的，换句话说 <code>arr1[0] &lt;= arr1[1] &lt;= ... &lt;= arr1[n - 1]</code> 。</li>
<li><code>arr2</code> 是单调 <strong>非递增</strong> 的，换句话说 <code>arr2[0] &gt;= arr2[1] &gt;= ... &gt;= arr2[n - 1]</code> 。</li>
<li>对于所有的 <code>0 &lt;= i &lt;= n - 1</code> 都有 <code>arr1[i] + arr2[i] ==· nums[i]</code> 。</li>
</ul>
<p>请你返回所有 <strong>单调</strong> 数组对的数目。</p>
<p>由于答案可能很大，请你将它对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<p><strong>示例 1：</strong></p>
<p><strong>输入：</strong>nums &#x3D; [2,3,2]</p>
<p><strong>输出：</strong>4</p>
<p><strong>解释：</strong></p>
<p>单调数组对包括：</p>
<ol>
<li><code>([0, 1, 1], [2, 2, 1])</code></li>
<li><code>([0, 1, 2], [2, 2, 0])</code></li>
<li><code>([0, 2, 2], [2, 1, 0])</code></li>
<li><code>([1, 2, 2], [1, 1, 0])</code></li>
</ol>
<p><strong>示例 2：</strong></p>
<p><strong>输入：</strong>nums &#x3D; [5,5,5,5]</p>
<p><strong>输出：</strong>126</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n == nums.length &lt;= 2000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 50</code></li>
</ul>
<p>解决这道题，我面临的第一个问题就是，我读不懂题目，一般来说理解</p>
]]></content>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能：深度学习</title>
    <url>/2023/06/09/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="学习深度学习关键是动手"><a href="#学习深度学习关键是动手" class="headerlink" title="学习深度学习关键是动手"></a>学习深度学习关键是动手</h1><ul>
<li><p>深度学习是人工智能最热的领域<br>核心是神经网络</p>
</li>
<li><p>神经网络是一门语言</p>
</li>
<li><p>应该像学习Python&#x2F;C++一样学习<br>深度学习</p>
</li>
<li><p>是一本深度学习教科书<br>覆盖90年代至今的重要模型<br>每一章是一个Jupyter记事本<br>提供所有模型的完整实现<br>在真实数据上运行</p>
</li>
<li><p>内容免费<br><a href="https://zh.d2l.ai/">https://zh.d2l.ai/</a></p>
</li>
</ul>
<h1 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h1><p><img src="https://p.sda1.dev/18/e1d8281a361048724981392b20f0a9d2/658e7da32893c9cb72be2a26c253b731.png"></p>
<h1 id="深度学习介绍"><a href="#深度学习介绍" class="headerlink" title="深度学习介绍"></a>深度学习介绍</h1><p><img src="https://p.sda1.dev/18/8c98b3a6f279b67f8f31326577d581b4/d7694b35c1af508b16dcbebc2576b8aa.png"></p>
<h3 id="深度学习在图片分类上做了一个比较大的突破"><a href="#深度学习在图片分类上做了一个比较大的突破" class="headerlink" title="深度学习在图片分类上做了一个比较大的突破"></a>深度学习在图片分类上做了一个比较大的突破</h3><p><img src="https://p.sda1.dev/18/8cbd5c4df6060e94046a03d5c25f8265/30c75ee8ea820476cc2bb547b47868c9.png"></p>
<h3 id="样式迁移"><a href="#样式迁移" class="headerlink" title="样式迁移"></a>样式迁移</h3><p><img src="https://p.sda1.dev/18/e340d0b1567d8f1a9bcf3ac3c1f1b70e/dc9dd8d06dce943a0f909686dc613ec3.png"></p>
<p><img src="https://p.sda1.dev/18/c2e4d086d2dec274f72276fb3ab4e4cc/d33a8b86464b087a47ed8d5d3e3f0915.png"></p>
<h3 id="物体分割与检测"><a href="#物体分割与检测" class="headerlink" title="物体分割与检测"></a>物体分割与检测</h3><p><img src="/2023/06/09/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240902223753885.png" alt="image-20240902223753885"></p>
<h3 id="人脸合成"><a href="#人脸合成" class="headerlink" title="人脸合成"></a>人脸合成</h3><p><img src="/2023/06/09/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240902223902817.png" alt="image-20240902223902817"></p>
<h3 id="文字生成图片"><a href="#文字生成图片" class="headerlink" title="文字生成图片"></a>文字生成图片</h3><p><img src="https://p.sda1.dev/18/56d3b65e6b09caf3a6c87ef7fe3e31e3/bd845fa882b0a5d56e90fa3533cacde2.png"></p>
<h3 id="文字生成模型"><a href="#文字生成模型" class="headerlink" title="文字生成模型"></a>文字生成模型</h3><p><img src="https://p.sda1.dev/18/a9bd75ed63ba6ad9cfc1133c01c54557/d2feabeaf3a3fec1ed774d7be84fa2b9.png"></p>
<p><img src="https://p.sda1.dev/18/9e7881a5b8cc2161e8a3b40a4fb5fbb6/c7aeff9e81f25910a85b0a581338edef.png"></p>
<h3 id="无人驾驶"><a href="#无人驾驶" class="headerlink" title="无人驾驶"></a>无人驾驶</h3><p><img src="/2023/06/09/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%EF%BC%9A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240902224048852.png" alt="image-20240902224048852"></p>
<h3 id="案例研究-广告点击"><a href="#案例研究-广告点击" class="headerlink" title="案例研究-广告点击"></a>案例研究-广告点击</h3><p><img src="https://p.sda1.dev/18/13766acd778617da84ab3b415a968453/ccd275803bc40ce1a265f998590d37e1.png"></p>
<h4 id="预测与训练"><a href="#预测与训练" class="headerlink" title="预测与训练"></a>预测与训练</h4><p>看到一个广告的时候，首先要继续做特征提取，将这些特征放入模型，进行点击率预测。</p>
<p><img src="https://p.sda1.dev/18/947da527c1d602863e2d808d25fe8958/a78a1eb32f31ca0af263540cd86e7faf.png"></p>
<h4 id="完整的故事"><a href="#完整的故事" class="headerlink" title="完整的故事"></a>完整的故事</h4><p><img src="https://p.sda1.dev/18/bdc7f6e374c9b4c666e56d98f8144527/5f9208ed4f6086665f83f243f7f5b1ed.png"></p>
<h2 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="模型的可解释性"><a href="#模型的可解释性" class="headerlink" title="模型的可解释性"></a>模型的可解释性</h3><p>在图片分割领域为什么有效？</p>
<p>图片的有效性和模型的可解释性是两回事，可解释性与人类理解有关，有效性是客观存在的。</p>
<blockquote>
<p>模型的可解释性是关注的一个焦点。</p>
</blockquote>
<h3 id="符号学能和机器学习融合起来吗"><a href="#符号学能和机器学习融合起来吗" class="headerlink" title="符号学能和机器学习融合起来吗"></a>符号学能和机器学习融合起来吗</h3><p>符号学在深度学习上具有一定的进展。</p>
<h3 id="数据科学家和专家的区别"><a href="#数据科学家和专家的区别" class="headerlink" title="数据科学家和专家的区别"></a>数据科学家和专家的区别</h3><p>领域专家：比如做农业方面的专家，给出需求。</p>
<p>数据科学家：把专家的问题变成一个任务，训练出还行的模型。</p>
<p>AI专家：训练出精度非常高的模型。</p>
<h3 id="mac是否支持Pytorch"><a href="#mac是否支持Pytorch" class="headerlink" title="mac是否支持Pytorch"></a>mac是否支持Pytorch</h3><h3 id="自然语言处理进度"><a href="#自然语言处理进度" class="headerlink" title="自然语言处理进度"></a>自然语言处理进度</h3><h3 id="无人驾驶的误判"><a href="#无人驾驶的误判" class="headerlink" title="无人驾驶的误判"></a>无人驾驶的误判</h3><h2 id="动手安装"><a href="#动手安装" class="headerlink" title="动手安装"></a>动手安装</h2><ul>
<li><p>[可选]使用 conda&#x2F;miniconda环境<br>conda env remove d2l-zh<br>conda create -n -y d2l-zh python&#x3D;3.8 pip<br>conda activate d2l-zh</p>
</li>
<li><p>安装需要的包<br>pip install -y jupyter d2l torch torchvision</p>
</li>
<li><p>下载代码并执行<br>wget <a href="https://zh-v2.d2l.ai/d2l-zh.zip">https://zh-v2.d2l.ai/d2l-zh.zip</a><br>unzip d2l-zh.zip<br>jupyter notebook</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库：第一章 数据库相关概念</title>
    <url>/2025/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93.%E7%AC%AC%E4%B8%80%E7%AB%A0.MySql/</url>
    <content><![CDATA[<h1 id="1-MySQL概述"><a href="#1-MySQL概述" class="headerlink" title="1. MySQL概述"></a>1. MySQL概述</h1><h2 id="1-1-数据库相关概念"><a href="#1-1-数据库相关概念" class="headerlink" title="1.1 数据库相关概念"></a>1.1 数据库相关概念</h2><p><strong>什么是数据库？</strong>  #flashcard<br>数据库（Database）是一个有组织的数据集合，用于存储和管理信息。 它可以让你以结构化的方式存储、检索、更新和删除数据。 想象一下，它就像一个电子化的文件柜，可以高效地存储和查找各种信息。</p>
<!--ID: 1744130598815-->

<p><strong>核心概念：</strong> #flashcard </p>
<ul>
<li><strong>数据 (Data):</strong>  数据库中存储的基本元素，可以是任何类型的信息，例如文本、数字、日期、图像等。</li>
<li><strong>数据库管理系统 (DBMS):</strong>  用于创建、管理和访问数据库的软件。 MySQL 就是一种 DBMS。 其他常见的 DBMS 包括 PostgreSQL、Oracle、SQL Server 等。</li>
<li><strong>SQL (Structured Query Language):</strong>  用于与数据库进行交互的标准化语言。 可以使用 SQL 来查询、插入、更新和删除数据。</li>
<li><strong>表 (Table):</strong>  数据库中存储数据的基本单元。 表格由行和列组成，类似于电子表格。</li>
<li><strong>行 (Row) &#x2F; 记录 (Record):</strong>  表中的一行数据，代表一个实体或对象的信息。</li>
<li><strong>列 (Column) &#x2F; 字段 (Field):</strong>  表中的一列数据，代表实体或对象的某个属性。</li>
<li><strong>主键 (Primary Key):</strong>  用于唯一标识表中每一行的列。 主键的值不能重复，也不能为空。</li>
<li><strong>外键 (Foreign Key):</strong>  用于建立表与表之间关系的列。 外键指向另一个表的主键。</li>
<li><strong>索引 (Index):</strong>  一种数据结构，用于加速数据库的查询速度。 类似于书籍的目录，可以快速定位到需要的数据。</li>
<li><strong>事务 (Transaction):</strong>  一系列数据库操作的集合，要么全部成功执行，要么全部失败回滚。 事务保证了数据的完整性和一致性。</li>
<li><strong>模式 (Schema):</strong>  数据库的结构定义，包括表、列、数据类型、关系等。<br><img src="https://i.imgur.com/24p8DZW.png"><!--ID: 1744130598825--></li>
</ul>
<h2 id="1-2-MySQL"><a href="#1-2-MySQL" class="headerlink" title="1.2 MySQL"></a>1.2 MySQL</h2><h3 id="1-2-1-MySQL的下载"><a href="#1-2-1-MySQL的下载" class="headerlink" title="1.2.1 MySQL的下载"></a>1.2.1 MySQL的下载</h3><p><img src="https://i.imgur.com/J5BtKvY.png"></p>
<p>下载社区版本<br><img src="https://i.imgur.com/SBDMeCM.png"><br><img src="https://i.imgur.com/Z1ZCD3w.png"><br><img src="https://i.imgur.com/7YBKjYs.png"></p>
<ol>
<li><img src="https://i.imgur.com/PE6ZnrH.png"></li>
<li><img src="https://i.imgur.com/50TKXiy.png"></li>
<li>安装选中的这些包<img src="https://i.imgur.com/5oY92R6.png"><img src="https://i.imgur.com/uSfnajk.png"></li>
<li><img src="https://i.imgur.com/xS55uwm.png"></li>
<li><img src="https://i.imgur.com/ZaSMdVr.png" alt="shiokou0408"></li>
<li><img src="https://i.imgur.com/uJRLAAm.png"></li>
<li>以录到底，直接运行<img src="https://i.imgur.com/tr7kdlb.png"></li>
</ol>
<p>安装完成</p>
<h3 id="1-2-2-MySQL的启动与停止-flashcard"><a href="#1-2-2-MySQL的启动与停止-flashcard" class="headerlink" title="1.2.2 MySQL的启动与停止 #flashcard"></a>1.2.2 MySQL的启动与停止 #flashcard</h3><p><img src="https://i.imgur.com/244bfRx.png"></p>
<!--ID: 1744130598833-->


<p><img src="https://i.imgur.com/LneMvbr.png"></p>
<p>直接右键操作可查看 MySQL 数据库运行相关情况。也可通过命令行操作：</p>
<ul>
<li>启动：<code>net start mysql80</code></li>
<li>停止：<code>net stop mysql80</code><br>mysql80是在注册为windows系统时的名称。<br><img src="https://i.imgur.com/fY1HYMq.png"></li>
</ul>
<h3 id="1-2-3-客户端连接-flashcard"><a href="#1-2-3-客户端连接-flashcard" class="headerlink" title="1.2.3 客户端连接 #flashcard"></a>1.2.3 客户端连接 #flashcard</h3><p>方法一：使用MySQL提供的客户端命令行工具。</p>
<!--ID: 1744130598841-->

<!--⚠️Imgur upload failed, check dev console-->
<p>![[Pasted image 20250408163939.png]]<img src="https://i.imgur.com/j5ek70w.png"><br><img src="https://i.imgur.com/IEH5HCl.png"></p>
<p><strong>方式二：windows系统自带命令行工具连接</strong><br>指令：<code>mysql [-h 127.0.0.1] [-P 3306] -u root -p</code></p>
<ul>
<li><code>mysql</code>：启动 MySQL 客户端命令。</li>
<li><code>-h 127.0.0.1</code>：<code>-h</code> 用于指定连接主机地址，<code>127.0.0.1</code> 代表本地主机。</li>
<li><code>-P 3306</code>：<code>-P</code>（大写）指定连接端口，MySQL 默认端口为 3306 。</li>
<li><code>-u root</code>：<code>-u</code> 用于指定用户名，<code>root</code> 为 MySQL 超级用户账号。</li>
<li><code>-p</code>：表示后续需输入密码。<br>使用这种方法，得配置MySQL的环境变量。<br>[[MySQl的环境变量]]</li>
</ul>
<h3 id="1-2-3-数据模型-flashcard"><a href="#1-2-3-数据模型-flashcard" class="headerlink" title="1.2.3 数据模型 #flashcard"></a>1.2.3 数据模型 #flashcard</h3><p><strong>客户端与 DBMS 关系</strong></p>
<ul>
<li>客户端通过 DBMS（数据库管理系统）与数据库交互，如左侧图示，客户端设备（两台电脑）借助 DBMS（齿轮图标代表其管理运作功能 ）来操作数据库。<!--ID: 1744130598849--></li>
</ul>
<p><strong>数据库示例</strong> #flashcard </p>
<ul>
<li>数据库可存储不同类型数据记录，如图右侧表格：<ul>
<li>上方表格存储数据库相关信息，含 <code>id</code>、<code>name</code>（数据库名称，如 MySQL ）、<code>price</code>（价格 ）、<code>type</code>（类型 ）字段，示例记录有 MySQL 价格 100 等。</li>
<li>下方表格存储人员信息，有 <code>id</code>、<code>name</code>（人名 ）、<code>age</code>（年龄 ）、<code>gender</code>（性别 ）字段 ，如令狐冲 28 岁男性等记录。<br>  <img src="https://i.imgur.com/3KmrfBn.png"><br>  关系型数据库  <!--ID: 1744130598858--></li>
</ul>
</li>
</ul>
<p><strong>什么是关系型数据库？</strong> #flashcard<br>关系型数据库 (Relational Database) 是一种基于关系模型的数据库。 关系模型使用表格（也称为关系）来表示数据和数据之间的关系。 它是目前最常用的一种数据库类型。<br><img src="https://i.imgur.com/kJIqQcC.png"><br>二维表就是像电子表格一样，用行和列来组织数据的表格。 每行代表一个东西，每列代表这个东西的一个属性。 简单、直观、好用！<br><strong>特点：</strong></p>
<ul>
<li><strong>数据结构化：</strong> 数据以表格的形式存储，结构清晰，易于理解和管理。</li>
<li><strong>数据完整性：</strong> 通过主键、外键、约束等机制保证数据的完整性和一致性。</li>
<li><strong>ACID 特性：</strong> 关系型数据库支持 ACID 事务，保证数据的可靠性。<ul>
<li><strong>原子性 (Atomicity):</strong>  事务中的所有操作要么全部成功，要么全部失败。</li>
<li><strong>一致性 (Consistency):</strong>  事务执行前后，数据库的状态必须保持一致。</li>
<li><strong>隔离性 (Isolation):</strong>  多个事务并发执行时，每个事务都应该感觉不到其他事务的存在。</li>
<li><strong>持久性 (Durability):</strong>  事务一旦提交，其结果就应该永久保存，即使系统发生故障也不会丢失。</li>
</ul>
</li>
<li><strong>SQL 支持：</strong> 使用 SQL 作为标准查询语言，易于学习和使用。<!--ID: 1744130598866--></li>
</ul>
<p><strong>核心概念：</strong> #flashcard </p>
<ul>
<li><strong>关系模型 (Relational Model):</strong>  关系型数据库的基础理论。 它将数据组织成表格，表格由行和列组成。</li>
<li><strong>表 (Table):</strong>  数据库中存储数据的基本单元。 每个表代表一个实体或对象，例如客户、订单、产品等。</li>
<li><strong>行 (Row) &#x2F; 记录 (Record):</strong>  表中的一行数据，代表一个实体或对象的具体信息。</li>
<li><strong>列 (Column) &#x2F; 字段 (Field):</strong>  表中的一列数据，代表实体或对象的某个属性。</li>
<li><strong>主键 (Primary Key):</strong>  用于唯一标识表中每一行的列。 主键的值不能重复，也不能为空。</li>
<li><strong>外键 (Foreign Key):</strong>  用于建立表与表之间关系的列。 外键指向另一个表的主键。</li>
<li><strong>关系 (Relationship):</strong>  表与表之间的联系。 关系可以是：<ul>
<li><strong>一对一 (One-to-One):</strong>  一个表中的一条记录对应另一个表中的一条记录。</li>
<li><strong>一对多 (One-to-Many):</strong>  一个表中的一条记录对应另一个表中的多条记录。</li>
<li><strong>多对多 (Many-to-Many):</strong>  一个表中的多条记录对应另一个表中的多条记录。 通常需要一个中间表来建立多对多关系。</li>
</ul>
</li>
<li><strong>SQL (Structured Query Language):</strong>  用于与关系型数据库进行交互的标准化语言。 可以使用 SQL 来查询、插入、更新和删除数据。</li>
</ul>
<p> 数据模型 #flashcard<br><img src="https://i.imgur.com/PhpEO1q.png"></p>
<ol>
<li><strong>客户端 - DBMS - 数据库关系</strong><ul>
<li>客户端（如电脑设备）通过数据库管理系统（DBMS）与数据库进行交互。DBMS 如同中间桥梁，管理和控制客户端对数据库的访问与操作。</li>
</ul>
</li>
<li><strong>数据库内容示例</strong><ul>
<li><strong>数据库相关信息表</strong>：<ul>
<li>字段包括 <code>id</code>、<code>name</code>、<code>price</code>、<code>type</code> 。</li>
<li>示例数据：<code>id</code> 为 1 时，<code>name</code> 是 MySQL，<code>price</code> 为 100，<code>type</code> 是数据库 ；还有 Oracle 等相关记录。</li>
</ul>
</li>
<li><strong>人员信息表</strong>：<ul>
<li>字段包括 <code>id</code>、<code>name</code>、<code>age</code>、<code>gender</code> 。</li>
<li>示例数据：记录了令狐冲（28 岁，男）、风清扬（68 岁，男）、东方不败（32 岁，男）等信息。  <!--ID: 1744130598878--></li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库：第六章 事务</title>
    <url>/2025/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93.%E7%AC%AC%E5%85%AD%E7%AB%A0.%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h2><h3 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h3><ul>
<li><strong>定义</strong>：事务是一组操作的集合，是不可分割的工作单位。这些操作会作为一个整体向系统提交或撤销，即要么全部成功，要么全部失败 。</li>
</ul>
<h3 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h3><ul>
<li><strong>场景</strong>：以转账为例，假设存在账户信息表（有 <code>id</code>、<code>name</code>、<code>money</code> 字段 ） ，其中张三 <code>id</code> 为1，余额 <code>money</code> 为2000；李四 <code>id</code> 为2，余额 <code>money</code> 为2000 。当进行张三给李四转账1000操作时，涉及张三账户余额减少、李四账户余额增加等操作，这些操作需纳入一个事务。若其中某一步出错，比如张三余额减少后系统故障，事务会回滚，保证数据一致性，避免张三钱少了而李四钱没增加的情况。 可通过“查询张三账户余额”等操作来验证事务执行结果。<br>这个错误叫做抛错误<br><img src="https://i.imgur.com/MJntGAJ.png"><br><img src="https://i.imgur.com/LZ6rVGR.png"></li>
</ul>
<h2 id="事务的基本操作"><a href="#事务的基本操作" class="headerlink" title="事务的基本操作"></a>事务的基本操作</h2><p><img src="https://i.imgur.com/z78c1Ug.png"><br><img src="https://i.imgur.com/nIr97MW.png"><br><img src="https://i.imgur.com/A3Jv4ox.png"><br>手动提交<br><img src="https://i.imgur.com/fpk2t0r.png"><br>事务操作<br><img src="https://i.imgur.com/V9gBroh.png"><br>回滚事务<br><img src="https://i.imgur.com/KUny1v3.png"><br><img src="https://i.imgur.com/R88cb3V.png"></p>
<h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><h3 id="事务的四大特性（ACID）"><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）"></a>事务的四大特性（ACID）</h3><ol>
<li><strong>原子性（Atomicity）</strong><ul>
<li><strong>定义</strong>：事务是不可分割的最小操作单元，事务中的操作要么全部成功执行，要么全部失败回滚 。比如银行转账，从一个账户扣款和向另一个账户存款必须同时成功或同时失败，不能只执行其中一个操作。</li>
</ul>
</li>
<li><strong>一致性（Consistency）</strong><ul>
<li><strong>定义</strong>：事务执行完成后，数据库中所有数据都要保持一致状态。例如转账前后，参与转账的两个账户总金额应保持不变 。</li>
</ul>
</li>
<li><strong>隔离性（Isolation）</strong><ul>
<li><strong>定义</strong>：数据库通过隔离机制，确保事务在不受外部并发操作干扰的独立环境下运行。避免多个事务并发执行时，一个事务的执行结果被其他事务干扰 。</li>
</ul>
</li>
<li><strong>持久性（Durability）</strong><ul>
<li><strong>定义</strong>：事务一旦提交或回滚，对数据库中数据所做的更改将永久保存。提交后，数据变更会持久化存储；回滚后，数据恢复到事务开始前的状态 。<br> <img src="https://i.imgur.com/MSmXPlB.png"><br> <img src="https://i.imgur.com/9DTSJeW.png"></li>
</ul>
</li>
</ol>
<h2 id="并发事务引发的问题"><a href="#并发事务引发的问题" class="headerlink" title="并发事务引发的问题"></a>并发事务引发的问题</h2><table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>脏读</td>
<td>一个事务读到另外一个事务还没有提交的数据。</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务按照条件查询数据时，没有对应的 数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”。</td>
</tr>
<tr>
<td><img src="https://i.imgur.com/ExeMqtH.png"></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/f4GFojI.png"></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/Fr8GEF9.png"></td>
<td></td>
</tr>
<tr>
<td>主键冲突</td>
<td></td>
</tr>
</tbody></table>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable Read (默认)</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<ol>
<li><strong>查看事务隔离级别</strong><br>使用SQL语句 <code>SELECT @@TRANSACTION_ISOLATION;</code> ，执行该语句可查询当前数据库的事务隔离级别设置。</li>
<li><strong>设置事务隔离级别</strong><br>语法为 <code>SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125;</code><br><img src="https://i.imgur.com/lo3vktm.png"><br><img src="https://i.imgur.com/XCB7xvr.png"><br><img src="https://i.imgur.com/XCJEBbd.png"></li>
</ol>
<p>脏读<br><img src="https://i.imgur.com/71hYMqr.png"><br>解决脏读<br><img src="https://i.imgur.com/2cH0qko.png"><br>解决不可重复读，但是会出现幻读问题<br><img src="https://i.imgur.com/sdC6EJq.png"><br>幻读<br><img src="https://i.imgur.com/YOnXpWk.png"><br>解决<br><img src="https://i.imgur.com/l0rWtJ9.png"><br><img src="https://i.imgur.com/7S2Lp0B.png"><br><img src="https://i.imgur.com/4aBXUEa.png"></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库：第五章 多表查询</title>
    <url>/2025/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93.%E7%AC%AC%E4%BA%94%E7%AB%A0.%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="5-1-数据库表结构关系-概述"><a href="#5-1-数据库表结构关系-概述" class="headerlink" title="5.1 数据库表结构关系 - 概述"></a>5.1 数据库表结构关系 - 概述</h2><p>在项目开发进行数据库表结构设计时，需依据业务需求及业务模块关系来分析设计。因业务相互关联，表结构间存在多种联系，主要有：</p>
<ul>
<li><strong>一对多（多对一）</strong>：一个表中的一条记录对应另一个表中的多条记录，反之，一个表中的多条记录对应另一个表中的一条记录 。</li>
<li><strong>多对多</strong>：两个表中的记录相互间存在多条对应关系。</li>
<li><strong>一对一</strong>：两个表中的记录一一对应 。</li>
</ul>
<h3 id="数据库表关系-：一对多（多对一）"><a href="#数据库表关系-：一对多（多对一）" class="headerlink" title="数据库表关系 ：一对多（多对一）"></a>数据库表关系 ：一对多（多对一）</h3><p><strong>案例</strong>：以部门与员工关系为例，一个部门存在多个员工，而一个员工只隶属于一个部门 。<br><strong>关系特点</strong>：一方（部门）可对应多方（员工），多方中的每一方（员工）仅对应一方（部门） 。<br><strong>实现方式</strong>：在 “多” 的一方（员工表）建立外键，该外键指向 “一” 的一方（部门表）的主键。这样就能通过外键关联，体现部门与员工间一对多（多对一）的关系 。<br><img src="https://i.imgur.com/S1OgrLI.png"></p>
<h3 id="数据库表关系-：多对多（多对多）"><a href="#数据库表关系-：多对多（多对多）" class="headerlink" title="数据库表关系 ：多对多（多对多）"></a>数据库表关系 ：多对多（多对多）</h3><p><strong>案例</strong>：学生与课程的关系，一个学生可选择多门课程，一门课程也能被多个学生选择。<br><strong>关系特点</strong>：双方中任意一方的一条记录，都能与另一方的多条记录关联。<br><strong>实现方式</strong>：创建第三张中间表，中间表至少设置两个外键，分别与学生表主键、课程表主键关联，以此体现多对多关系。</p>
<p><img src="https://i.imgur.com/YdCAfXZ.png"></p>
<p><img src="https://i.imgur.com/kgMhOAO.png"><br>中间表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建student_course表，用于体现学生与课程的多对多关系</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_course(</span><br><span class="line">    <span class="comment">-- 定义id字段，类型为int，自动递增，设为主键，并添加注释“主键”</span></span><br><span class="line">    id <span class="type">int</span> auto_increment comment <span class="string">&#x27;主键&#x27;</span> <span class="keyword">primary</span> key, </span><br><span class="line">    <span class="comment">-- 定义studentid字段，类型为int，不允许为null，添加注释“学生ID”</span></span><br><span class="line">    studentid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;学生ID&#x27;</span>, </span><br><span class="line">    <span class="comment">-- 定义courseid字段，类型为int，不允许为null，添加注释“课程ID”</span></span><br><span class="line">    courseid <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;课程ID&#x27;</span>, </span><br><span class="line">    <span class="comment">-- 定义外键fk_courseid，关联course表的id字段</span></span><br><span class="line">    <span class="keyword">constraint</span> fk_courseid <span class="keyword">foreign</span> key (courseid) <span class="keyword">references</span> course (id), </span><br><span class="line">    <span class="comment">-- 定义外键fk_studentid，关联student表的id字段</span></span><br><span class="line">    <span class="keyword">constraint</span> fk_studentid <span class="keyword">foreign</span> key (studentid) <span class="keyword">references</span> student (id) </span><br><span class="line">)comment <span class="string">&#x27;学生课程中间表&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 向student_course表插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student_course <span class="keyword">values</span> </span><br><span class="line">(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="keyword">null</span>,<span class="number">1</span>,<span class="number">3</span>),</span><br><span class="line">(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">2</span>),</span><br><span class="line">(<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">3</span>),</span><br><span class="line">(<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">4</span>); </span><br></pre></td></tr></table></figure>

<h3 id="数据库表关系-：一对一（一对一）"><a href="#数据库表关系-：一对一（一对一）" class="headerlink" title="数据库表关系 ：一对一（一对一）"></a>数据库表关系 ：一对一（一对一）</h3><p><strong>案例</strong>：以用户与用户详情关系为例。<br><strong>关系特点</strong>：表与表之间记录一一对应。常用于单表拆分场景，把一张表的基础字段置于一张表，其他详情字段放在另一张表，借此提升操作效率。<br><img src="https://i.imgur.com/fq3KwA5.png"><br><img src="https://i.imgur.com/7gI6fUD.png"></p>
<h2 id="5-2-数据库表结构关系-多表查询"><a href="#5-2-数据库表结构关系-多表查询" class="headerlink" title="5.2 数据库表结构关系 - 多表查询"></a>5.2 数据库表结构关系 - 多表查询</h2><p><img src="https://i.imgur.com/W7o5hNT.png"></p>
<h3 id="笛卡尔积："><a href="#笛卡尔积：" class="headerlink" title="笛卡尔积："></a>笛卡尔积：</h3><p><strong>定义</strong>：在数学里，笛卡尔积是两个集合（如 A 集合和 B 集合 ）所有元素的组合情况。<br><strong>在数据库中的应用</strong>：多表查询时会出现笛卡尔积现象，需消除无效的笛卡尔积，以获取正确、有效的查询结果。<br><img src="https://i.imgur.com/IrGrpKu.png"><br><img src="https://i.imgur.com/S3Ezk7S.png"></p>
<h3 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h3><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p><strong>定义</strong>：查询两张表交集部分。</p>
<p><strong>语法</strong></p>
<ul>
<li><p><strong>隐式内连接</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span>,表<span class="number">2</span> <span class="keyword">WHERE</span> 条件...;</span><br></pre></td></tr></table></figure>
<p>通过在 <code>FROM</code> 子句中列出多个表，并用 <code>WHERE</code> 子句指定连接条件。</p>
</li>
<li><p><strong>显式内连接</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表<span class="number">1</span> [<span class="keyword">INNER</span>] <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 连接条件...;</span><br></pre></td></tr></table></figure>
<p>使用 <code>JOIN</code> 关键字明确表示连接操作，<code>ON</code> 关键字后指定连接条件，<code>INNER</code> 可省略 。<br><img src="https://i.imgur.com/6ClLq7q.png"><br>没公共部分，故少一个数据<img src="https://i.imgur.com/mVshc8J.png"></p>
</li>
</ul>
<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>左外连接</p>
<ul>
<li><strong>语法</strong>：<code>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件...;</code></li>
<li><strong>说明</strong>：相当于查询表 1（左表）的所有数据，包含表 1 和表 2 交集部分的数据 。即左表的记录全部展示，右表满足连接条件的记录展示，不满足的用 <code>NULL</code> 填充对应字段。<br><img src="https://i.imgur.com/cm41Q8p.png"><br>查全了<br>右外连接</li>
<li><strong>语法</strong>：<code>SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件...;</code></li>
<li><strong>说明</strong>：查询表 2（右表）的所有数据，包含表 1 和表 2 交集部分的数据 。右表记录全部展示，左表满足连接条件的记录展示，不满足的用 <code>NULL</code> 填充对应字段。<br><img src="https://i.imgur.com/i2wb9sc.png"><br>修改的时候记得commit<br><img src="https://i.imgur.com/QBvUY8e.png"></li>
</ul>
<h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h5><p>自连接查询语法</p>
<ul>
<li><strong>语法</strong>：<code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件...;</code></li>
<li><strong>说明</strong>：自连接查询是指在同一个表上进行连接操作。该表通过不同别名（如别名A和别名B ）被视为不同的逻辑表来建立连接关系。自连接查询既可以是内连接查询（仅返回满足连接条件的行），也可以是外连接查询（如左外连接、右外连接，会根据连接类型返回包含不满足条件行，以 <code>NULL</code> 填充相关字段的数据 ）。 </li>
<li><img src="https://i.imgur.com/Ld04WIA.png"><br><img src="https://i.imgur.com/b03AKWt.png"><br><img src="https://i.imgur.com/Uqpa5Fu.png"><br><img src="https://i.imgur.com/XKHD5lZ.png"></li>
</ul>
<h3 id="UNION-查询"><a href="#UNION-查询" class="headerlink" title="UNION 查询"></a>UNION 查询</h3><ul>
<li><strong>定义</strong>：将多次查询的结果合并起来，形成一个新的查询结果集。</li>
<li><strong>语法</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A...</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B...;</span><br></pre></td></tr></table></figure>
<img src="https://i.imgur.com/8RDw5Pw.png"></li>
</ul>
<p><img src="https://i.imgur.com/5LVCIWU.png"><br><img src="https://i.imgur.com/7BRpZEz.png"><br><img src="https://i.imgur.com/rw36JOe.png"></p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul>
<li><strong>概念</strong>：在 SQL 语句中嵌套 <code>SELECT</code> 语句，也叫嵌套查询。子查询外部语句可以是 <code>INSERT</code> &#x2F; <code>UPDATE</code> &#x2F; <code>DELETE</code> &#x2F; <code>SELECT</code> 中的任意一个。</li>
<li>例如：<code>SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);</code></li>
<li><strong>分类</strong>：<ul>
<li><strong>标量子查询</strong>：子查询结果为单个值。</li>
<li><strong>列子查询</strong>：子查询结果为一列。</li>
<li><strong>行子查询</strong>：子查询结果为一行。</li>
<li><strong>表子查询</strong>：子查询结果为多行多列。<br>  <img src="https://i.imgur.com/VpEdVbq.png"><br>  <img src="https://i.imgur.com/z919F8I.png"></li>
</ul>
</li>
</ul>
<h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a><strong>标量子查询</strong></h4><p>子查询结果为单个值。</p>
<ul>
<li><strong>定义</strong>：子查询返回的结果是单个值（如数字、字符串、日期等 ），这是子查询中最简单的形式。</li>
<li><strong>常用操作符</strong>：<code>=</code>、<code>&lt;&gt;</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code> 。 可用于 <code>WHERE</code> 子句等位置，进行条件判断等操作 。<br><img src="https://i.imgur.com/qkxspyJ.png"><br>子查询<br><img src="https://i.imgur.com/pTrJAcv.png"></li>
</ul>
<h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a><strong>列子查询</strong></h4><p>子查询结果为一列。</p>
<p><strong>列子查询</strong>是指子查询返回的结果是一列数据（可以有多行）。</p>
<p>在列子查询中，常用的操作符包括：</p>
<ul>
<li><strong>IN</strong>: 用于判断某个值是否在子查询返回的结果集合中。如果存在，则条件为真。</li>
<li><strong>NOT IN</strong>: 用于判断某个值是否不在子查询返回的结果集合中。如果不存在，则条件为真。</li>
<li><strong>ANY (或 SOME)</strong>:  只要子查询返回的结果集合中，有任意一个值满足条件，则条件为真。 <code>ANY</code> 和 <code>SOME</code> 的作用是相同的。</li>
<li><strong>ALL</strong>: 子查询返回的结果集合中，所有值都必须满足条件，条件才为真。<!--⚠️Imgur upload failed, check dev console-->
![[Pasted image 20250417150657.png]]<br><img src="https://i.imgur.com/mbNrngn.png"><br><img src="https://i.imgur.com/ckkxIjT.png"><br><img src="https://i.imgur.com/ojWHuYl.png"></li>
</ul>
<h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a><strong>行子查询</strong></h4><ul>
<li><strong>定义</strong>：子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。</li>
<li><strong>常用操作符</strong>：&#x3D;、&lt;&gt;、IN、NOT IN<br><img src="https://i.imgur.com/OwnuaVE.png"></li>
</ul>
<h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><ul>
<li><strong>定义</strong>：子查询返回的结果是多行多列，这种子查询称为表子查询。</li>
<li><strong>常用操作符</strong>：IN<br><img src="https://i.imgur.com/v1GjaMm.png"><br><img src="https://i.imgur.com/DyeDBLT.png"></li>
</ul>
<h3 id="多表查询案例"><a href="#多表查询案例" class="headerlink" title="多表查询案例"></a>多表查询案例</h3><p>根据需求，完成 SQL 语句的编写</p>
<ol>
<li><p><strong>查询员工基本信息</strong>：查询员工的姓名、年龄、职位、部门信息。<img src="https://i.imgur.com/ntVL2Lx.png"></p>
</li>
<li><p><strong>查询特定年龄员工信息</strong>：查询年龄小于 30 岁的员工姓名、年龄、职位、部门信息。<img src="https://i.imgur.com/PnN7Gnx.png"></p>
</li>
<li><p><strong>查询部门信息</strong>：查询拥有员工的部门 ID、部门名称。<img src="https://i.imgur.com/RSqSJaJ.png"></p>
</li>
<li><p><strong>查询大龄员工及部门</strong>：查询所有年龄大于 40 岁的员工，及其归属的部门名称；若员工无部门分配，也需展示。<img src="https://i.imgur.com/FVXICPo.png"></p>
</li>
<li><p><strong>查询工资等级</strong>：查询所有员工的工资等级。<img src="https://i.imgur.com/r5YAhw1.png"></p>
</li>
<li><p><strong>查询特定部门员工信息及工资等级</strong>：查询 “研发部” 所有员工的信息及工资等级。<img src="https://i.imgur.com/DnPhbCs.png"></p>
</li>
<li><p><strong>查询特定部门平均工资</strong>：查询 “研发部” 员工的平均工资。<img src="https://i.imgur.com/xUp0OPi.png"></p>
</li>
<li><p><strong>查询高工资员工信息</strong>：查询工资比 “灭绝” 高的员工信息。<img src="https://i.imgur.com/ANPatuy.png"></p>
</li>
<li><p><strong>查询高于平均薪资员工信息</strong>：查询比平均薪资高的员工信息。<img src="https://i.imgur.com/gcKH3S0.png"></p>
</li>
<li><p><strong>查询低于部门平均工资员工信息</strong>：查询低于本部门平均工资的员工信息。<img src="https://i.imgur.com/CSjl53m.png"></p>
</li>
<li><p><strong>统计部门员工人数</strong>：查询所有的部门信息，并统计部门的员工人数。<img src="https://i.imgur.com/sWC2cR2.png"></p>
</li>
<li><p><strong>查询学生选课情况</strong>：查询所有学生的选课情况，展示出学生名称，学号，课程名称<img src="https://i.imgur.com/Zqb2xv0.png"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库：第三章 函数</title>
    <url>/2025/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93.%E7%AC%AC%E4%B8%89%E7%AB%A0.%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>函数：数据库函数是预定义的、可重用的代码块，用于执行特定的数据操作或计算，并返回一个结果。</p>
<h2 id="3-1-字符串函数"><a href="#3-1-字符串函数" class="headerlink" title="3.1 字符串函数"></a>3.1 字符串函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT(S1,S2,…Sn)</td>
<td>字符串拼接，把 S1, S2, … Sn 合并成一个字符串</td>
</tr>
<tr>
<td>LOWER(str)</td>
<td>将字符串 str 全部转换为小写</td>
</tr>
<tr>
<td>UPPER(str)</td>
<td>将字符串 str 全部转换为大写</td>
</tr>
<tr>
<td>LPAD(str,n,pad)</td>
<td>左填充，用字符串 pad 对 str 左边填充，使总长度达 n</td>
</tr>
<tr>
<td>RPAD(str,n,pad)</td>
<td>右填充，用字符串 pad 对 str 右边填充，使总长度达 n</td>
</tr>
<tr>
<td>TRIM(str)</td>
<td>去除字符串头部和尾部的空格</td>
</tr>
<tr>
<td>SUBSTRING(str,start,len)</td>
<td>返回字符串 str 从 start 位置起长度为 len 的子字符串</td>
</tr>
<tr>
<td>concat</td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/rvDLCuJ.png"></td>
<td></td>
</tr>
<tr>
<td>upper</td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/0LQQ1BV.png"></td>
<td></td>
</tr>
<tr>
<td>lower</td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/feCNcw6.png"></td>
<td></td>
</tr>
<tr>
<td>lpad</td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/kfnAFWm.png"></td>
<td></td>
</tr>
<tr>
<td>rpad</td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/3sGCKki.png"></td>
<td></td>
</tr>
<tr>
<td>trim</td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/dWQZ23S.png"></td>
<td></td>
</tr>
<tr>
<td>substring</td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/cSWbuCR.png"></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/30QCp7M.png"></td>
<td></td>
</tr>
</tbody></table>
<h2 id="3-2-数值函数"><a href="#3-2-数值函数" class="headerlink" title="3.2 数值函数"></a>3.2 数值函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CEIL(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>MOD(x,y)</td>
<td>返回 x&#x2F;y 的模</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回 0 - 1 内的随机数</td>
</tr>
<tr>
<td>ROUND(x,y)</td>
<td>求参数 x 的四舍五入值，保留 y 位小数</td>
</tr>
<tr>
<td>ceil</td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/1tTB3u8.png"></td>
<td></td>
</tr>
</tbody></table>
<p>floor<br><img src="https://i.imgur.com/bbmOt0u.png"></p>
<p>mod<br><img src="https://i.imgur.com/yPpZTQA.png"></p>
<p>rand<br><img src="https://i.imgur.com/MHuiXQF.png"></p>
<p>round<br><img src="https://i.imgur.com/geaW3qO.png"></p>
<p>验证码<br><img src="https://i.imgur.com/SLXoU5l.png"><br>有bug<br><img src="https://i.imgur.com/YQjNNxf.png"><br>最终方案<br><img src="https://i.imgur.com/saStmBt.png"></p>
<h2 id="3-3-日期函数"><a href="#3-3-日期函数" class="headerlink" title="3.3 日期函数"></a>3.3 日期函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>NOW()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>YEAR(date)</td>
<td>获取指定 date 的年份</td>
</tr>
<tr>
<td>MONTH(date)</td>
<td>获取指定 date 的月份</td>
</tr>
<tr>
<td>DAY(date)</td>
<td>获取指定 date 的日期</td>
</tr>
<tr>
<td>DATE_ADD(date, INTERVAL expr type)</td>
<td>返回日期 &#x2F; 时间值加上时间间隔 expr 后的时间值</td>
</tr>
<tr>
<td>DATEDIFF(date1, date2)</td>
<td>返回起始时间 date1 和结束时间 date2 之间的天数</td>
</tr>
<tr>
<td>curdate</td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/vbXQ08V.png"></td>
<td></td>
</tr>
</tbody></table>
<p>curtime<br><img src="https://i.imgur.com/Yw1Pe1M.png"></p>
<p>now<br><img src="https://i.imgur.com/zqUFpdc.png"><br>year<br><img src="https://i.imgur.com/g9VPbaI.png"><br>month<br><img src="https://i.imgur.com/P8QpVE0.png"><br>day<br><img src="https://i.imgur.com/7Yhia96.png"><br>date add<br><img src="https://i.imgur.com/3YqEtLf.png"><br>差异天数<br><img src="https://i.imgur.com/I0BhlvC.png"><br>需求<br><img src="https://i.imgur.com/wYNLMvV.png"><br><img src="https://i.imgur.com/CeUd0Ac.png"></p>
<h2 id="3-4-流程控制函数"><a href="#3-4-流程控制函数" class="headerlink" title="3.4 流程控制函数"></a>3.4 流程控制函数</h2><p>流程函数可在 SQL 语句中实现条件筛选，提升语句效率。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>IF(value, t, f)</td>
<td>若 value 为 true，返回 t；否则返回 f</td>
</tr>
<tr>
<td>IFNULL(value1, value2)</td>
<td>若 value1 不为空，返回 value1；否则返回 value2</td>
</tr>
<tr>
<td>CASE WHEN [val1] THEN [res1] … ELSE [default] END</td>
<td>若 val1 为 true，返回 res1；否则返回 default 默认值</td>
</tr>
<tr>
<td>CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td>
<td>若 expr 的值等于 val1，返回 res1；否则返回 default 默认值</td>
</tr>
<tr>
<td>ifnull</td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/UIw08Jl.png"></td>
<td></td>
</tr>
</tbody></table>
<p>if<br><img src="https://i.imgur.com/SiB89au.png"></p>
<p>case<br><img src="https://i.imgur.com/HZr0MXC.png"></p>
<p><img src="https://i.imgur.com/AmB9oQ6.png"></p>
<p><img src="https://i.imgur.com/vdLYWPq.png"></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库：第二章 SQL</title>
    <url>/2025/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93.%E7%AC%AC%E4%BA%8C%E7%AB%A0.SQL/</url>
    <content><![CDATA[<h2 id="2-1-SQL通用语句-flashcard"><a href="#2-1-SQL通用语句-flashcard" class="headerlink" title="2.1 SQL通用语句 #flashcard"></a>2.1 SQL通用语句 #flashcard</h2><ol>
<li><strong>书写格式</strong>：SQL 语句可单行或多行书写，均以分号 <code>;</code> 结尾。</li>
<li><strong>可读性增强</strong>：可利用空格或缩进使 SQL 语句更具可读性。</li>
<li><strong>大小写规则</strong>：在 MySQL 数据库中，SQL 语句不区分大小写，但建议将关键字大写。</li>
<li><strong>注释方式</strong><ul>
<li><strong>单行注释</strong>：<code>-- 注释内容</code> ；MySQL 还特有 <code># 注释内容</code> 。</li>
<li><strong>多行注释</strong>：<code>/* 注释内容 */</code> 。</li>
</ul>
</li>
</ol>
<!--ID: 1744130440676-->

<table>
<thead>
<tr>
<th>分类</th>
<th>全称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DDL</td>
<td>Data Definition Language</td>
<td>数据定义语言，用于定义数据库对象（数据库、表、字段等）</td>
</tr>
<tr>
<td>DML</td>
<td>Data Manipulation Language</td>
<td>数据操作语言，用于对数据库表中的数据进行增删改</td>
</tr>
<tr>
<td>DQL</td>
<td>Data Query Language</td>
<td>数据查询语言，用于查询数据库表中的记录</td>
</tr>
<tr>
<td>DCL</td>
<td>Data Control Language</td>
<td>数据控制语言，用于创建数据库用户、控制数据库的访问权限</td>
</tr>
</tbody></table>
<h3 id="2-1-1-DDL-flashcard"><a href="#2-1-1-DDL-flashcard" class="headerlink" title="2.1.1 DDL #flashcard"></a>2.1.1 DDL #flashcard</h3><p> SQL - DDL 数据库操作</p>
<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><ul>
<li><strong>查询所有数据库</strong>：<br><code>SHOW DATABASES;</code><br><img src="https://i.imgur.com/wUEx8la.png"><br>[[Probelm1]]<br><img src="https://i.imgur.com/clGnFuj.png">]]</li>
<li><strong>查询当前数据库</strong>：<br><code>SELECT DATABASE();</code><br><img src="https://i.imgur.com/d5r7FkC.png"></li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><code>CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];</code><br><img src="https://i.imgur.com/vNfSzR1.png"><br><img src="https://i.imgur.com/WZULzsB.png"><br><img src="https://i.imgur.com/6ZoSXXL.png"></p>
<ul>
<li><strong>尝试一</strong>：使用 <code>create database itheima default charset utf8;</code> 语句创建 <code>itheima</code> 数据库，提到存在字符存储长度相关问题（有的字符存储占三个字符，有的占四个字符 ）。</li>
<li><strong>尝试二</strong>：改用 <code>create database itheima default charset utf8mb4;</code> 语句创建 <code>itheima</code> 数据库，执行成功，提示 <code>Query OK, 1 row affected (0.01 sec)</code> ，推荐使用 <code>utf8mb4</code> 字符集处理字符存储问题。</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><code>DROP DATABASE [IF EXISTS] 数据库名;</code><br><img src="https://i.imgur.com/jIzgpql.png"></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>USE 数据库名;</code><br><img src="https://i.imgur.com/OaavpIY.png"></p>
<!--ID: 1744130440721-->

<ul>
<li>DDL-表操作-查询</li>
</ul>
<ol>
<li><p><strong>查询当前数据库所有表</strong></p>
<ul>
<li>语句：<code>SHOW TABLES;</code><img src="https://i.imgur.com/hKNlcB1.png"><img src="https://i.imgur.com/QTGW5om.png"></li>
</ul>
</li>
<li><p><strong>查询表结构</strong></p>
<ul>
<li>语句：<code>DESC 表名;</code><img src="https://i.imgur.com/54t1f5f.png"></li>
</ul>
</li>
<li><p><strong>查询指定表的建表语句</strong></p>
<ul>
<li>语句：&#96;SHOW CREATE TABLE 表名;<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    字段<span class="number">1</span> 字段<span class="number">1</span>类型 [COMMENT 字段<span class="number">1</span>注释],</span><br><span class="line">    字段<span class="number">2</span> 字段<span class="number">2</span>类型 [COMMENT 字段<span class="number">2</span>注释],</span><br><span class="line">    字段<span class="number">3</span> 字段<span class="number">3</span>类型 [COMMENT 字段<span class="number">3</span>注释],</span><br><span class="line">   ...</span><br><span class="line">    字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">) [COMMENT 表注释];</span><br></pre></td></tr></table></figure>
<strong>说明</strong>：</li>
</ul>
</li>
</ol>
<ul>
<li><code>CREATE TABLE</code> 是创建表的关键字。</li>
<li><code>表名</code> 是要创建的表的名称，需符合命名规范 。</li>
<li>每个 <code>字段</code> 后跟其对应的 <code>字段类型</code>，如常见的 <code>INT</code>（整数型）、<code>VARCHAR</code>（可变长度字符串型）等。</li>
<li><code>COMMENT</code> 关键字用于添加注释，对字段或表进行说明解释，增强代码可读性，注释内容可选。<img src="https://i.imgur.com/Yz7oHaQ.png"><br><img src="https://i.imgur.com/CweM7GA.png"></li>
</ul>
<ul>
<li>DDL-表操作-数据类型</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>类型</th>
<th>大小</th>
<th>有符号 (SIGNED) 范围</th>
<th>无符号 (UNSIGNED) 范围</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值类型</td>
<td>TINYINT</td>
<td>1 byte</td>
<td>(-128, 127)</td>
<td>(0, 255)</td>
<td>小整数值</td>
</tr>
<tr>
<td>数值类型</td>
<td>SMALLINT</td>
<td>2 bytes</td>
<td>(-32768, 32767)</td>
<td>(0, 65535)</td>
<td>大整数值</td>
</tr>
<tr>
<td>数值类型</td>
<td>MEDIUMINT</td>
<td>3 bytes</td>
<td>(-8388608, 8388607)</td>
<td>(0, 16777215)</td>
<td>大整数值</td>
</tr>
<tr>
<td>数值类型</td>
<td>INT或INTEGER</td>
<td>4 bytes</td>
<td>(-2147483648, 2147483647)</td>
<td>(0, 4294967295)</td>
<td>大整数值</td>
</tr>
<tr>
<td>数值类型</td>
<td>BIGINT</td>
<td>8 bytes</td>
<td>(-2^63, 2^63 - 1)</td>
<td>(0, 2^64 - 1)</td>
<td>极大整数值</td>
</tr>
<tr>
<td>数值类型</td>
<td>FLOAT</td>
<td>4 bytes</td>
<td>(-3.402823466 E+38, 3.402823466351 E+38)</td>
<td>0 和 (1.175494351 E-38, 3.402823466 E+38)</td>
<td>单精度浮点数值</td>
</tr>
<tr>
<td>数值类型</td>
<td>DOUBLE</td>
<td>8 bytes</td>
<td>(-1.7976931348623157 E+308, 1.7976931348623157 E+308)</td>
<td>0 和 (2.2250738585072014 E-308, 1.7976931348623157 E+308)</td>
<td>双精度浮点数值</td>
</tr>
<tr>
<td>数值类型</td>
<td>DECIMAL</td>
<td>依赖于 M 和 D 的值</td>
<td>依赖于 M 和 D 的值</td>
<td>依赖于 M 和 D 的值</td>
<td>小数值 (精确定点数)</td>
</tr>
<tr>
<td>精度（Precision，通常用 M 表示）和标度（Scale，通常用 D 表示）是用于 <code>DECIMAL</code> 数据类型的概念，它们定义了数值的精确度和范围。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>**精度 (M)**：<ul>
<li>精度是指数值中可以存储的总位数。这包括整数部分的位数和小数部分的位数。</li>
<li>例如，如果一个 <code>DECIMAL</code> 类型的精度是 10，那么这个数值总共可以存储 10 位数字。</li>
</ul>
</li>
<li>**标度 (D)**：<ul>
<li>标度是指数值中小数部分的位数。</li>
<li>例如，如果一个 <code>DECIMAL</code> 类型的标度是 2，那么这个数值将保留两位小数。</li>
</ul>
</li>
</ul>
<p><strong>举例说明：</strong><br>假设你定义一个 <code>DECIMAL(5, 2)</code> 类型的字段：</p>
<ul>
<li>精度 (M) &#x3D; 5，表示总共可以存储 5 位数字。</li>
<li>标度 (D) &#x3D; 2，表示其中 2 位是小数。<br>这意味着你可以存储的最大值是 999.99，最小值是 -999.99。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>精度决定了数值的总位数，包括整数和小数部分。</li>
<li>标度决定了数值中小数的位数。<br>在 <code>DECIMAL(M, D)</code> 中，<code>M</code> 必须大于或等于 <code>D</code>。 如果 <code>D</code> 是 0，则数值没有小数部分。</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串类型</td>
<td>CHAR</td>
<td>0 - 255 bytes</td>
<td>定长字符串</td>
</tr>
<tr>
<td>字符串类型</td>
<td>VARCHAR</td>
<td>0 - 65535 bytes</td>
<td>变长字符串</td>
</tr>
<tr>
<td>字符串类型</td>
<td>TINYBLOB</td>
<td>0 - 255 bytes</td>
<td>不超过 255 个字符的二进制数据</td>
</tr>
<tr>
<td>字符串类型</td>
<td>TINYTEXT</td>
<td>0 - 255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>字符串类型</td>
<td>BLOB</td>
<td>0 - 65535 bytes</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>字符串类型</td>
<td>TEXT</td>
<td>0 - 65535 bytes</td>
<td>长文本数据</td>
</tr>
<tr>
<td>字符串类型</td>
<td>MEDIUMBLOB</td>
<td>0 - 16777215 bytes</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td>字符串类型</td>
<td>MEDIUMTEXT</td>
<td>0 - 16777215 bytes</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td>字符串类型</td>
<td>LONGBLOB</td>
<td>0 - 4294967295 bytes</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>字符串类型</td>
<td>LONGTEXT</td>
<td>0 - 4294967295 bytes</td>
<td>极大文本数据</td>
</tr>
</tbody></table>
<h3 id="2-1-2-基础-SQL-图形化界面工具DataGrip"><a href="#2-1-2-基础-SQL-图形化界面工具DataGrip" class="headerlink" title="2.1.2 基础-SQL-图形化界面工具DataGrip"></a>2.1.2 基础-SQL-图形化界面工具DataGrip</h3><p>下载地址：<a href="https://pan.baidu.com/s/1oYmpTCD8Uh_tMUJ2onj1Ww?pwd=4x7z&pwd=4x7z">https://pan.baidu.com/s/1oYmpTCD8Uh_tMUJ2onj1Ww?pwd&#x3D;4x7z&amp;pwd&#x3D;4x7z</a><br>破解方法：<a href="https://www.bilibili.com/video/BV1yhdSYcEC2/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=9216022843178d0a5e4b781fe29849b5">https://www.bilibili.com/video/BV1yhdSYcEC2/?spm_id_from&#x3D;333.1007.top_right_bar_window_history.content.click&amp;vd_source&#x3D;9216022843178d0a5e4b781fe29849b5</a><br><img src="https://i.imgur.com/NGZpcBn.png"><br>建立新项目<br><img src="https://i.imgur.com/g4mkI3j.png"><br><img src="https://i.imgur.com/IjOdpr0.png"><br>自动下载驱动<br><img src="https://i.imgur.com/7lpgMOS.png"></p>
<p><img src="https://i.imgur.com/yQPuP8b.png"></p>
<p><img src="https://i.imgur.com/O23or3S.png"><br><img src="https://i.imgur.com/9Pn8IFa.png"><br>连接建立好了<br><img src="https://i.imgur.com/h5hEKal.png"><br>展示所有的数据库<br><img src="https://i.imgur.com/wAf0f5f.png"><br><img src="https://i.imgur.com/BRG1dlE.png"><br>创建新数据库<br><img src="https://i.imgur.com/inqFbhz.png"><br><img src="https://i.imgur.com/oJkRB3e.png"><br>添加新的表<br><img src="https://i.imgur.com/IyRhQQa.png"><br>添加新的字段<br><img src="https://i.imgur.com/xTDw7Qq.png"><br>添加两个字段，注意看脚本<br><img src="https://i.imgur.com/DWEIStv.png"><br>允许存储null值<br><img src="https://i.imgur.com/vEmJHCC.png"><br>成功创建<br><img src="https://i.imgur.com/ZrHaAaj.png"><br>修改表<br><img src="https://i.imgur.com/jls1civ.png"><br>修改表的指令<br><img src="https://i.imgur.com/7mIXXRq.png"><br>编写SQL语句，操作这个数据库<br><img src="https://i.imgur.com/WC5a1tm.png"><br>编写完成直接执行<br><img src="https://i.imgur.com/SSVE6nI.png"><br>再执行一条<br><img src="https://i.imgur.com/7llxxRb.png"><br>再执行一条</p>
<h3 id="2-1-3-DML"><a href="#2-1-3-DML" class="headerlink" title="2.1.3 DML"></a>2.1.3 DML</h3><p>DML (数据操纵语言) 用于<strong>修改数据库中的数据</strong>。</p>
<p>主要操作：</p>
<ul>
<li><strong>增 (INSERT):</strong> 添加新数据</li>
<li><strong>删 (DELETE):</strong> 删除数据</li>
<li><strong>改 (UPDATE):</strong> 修改数据</li>
</ul>
<p>DML 负责<strong>数据内容</strong>，而不是数据库结构。<br><img src="https://i.imgur.com/8cKs0v1.png"></p>
<h4 id="SQL-DML添加数据笔记"><a href="#SQL-DML添加数据笔记" class="headerlink" title="SQL - DML添加数据笔记"></a>SQL - DML添加数据笔记</h4><h5 id="一、给指定字段添加数据"><a href="#一、给指定字段添加数据" class="headerlink" title="一、给指定字段添加数据"></a>一、给指定字段添加数据</h5><p>语法：<code>INSERT INTO 表名 (字段名1,字段名2, ...) VALUES (值1,值2, ...);</code><br>应用场景：当只想为表中的部分字段插入数据时使用，需明确指定字段名，值的顺序与字段名顺序对应。</p>
<h5 id="二、给全部字段添加数据"><a href="#二、给全部字段添加数据" class="headerlink" title="二、给全部字段添加数据"></a>二、给全部字段添加数据</h5><p>语法：<code>INSERT INTO 表名 VALUES (值1,值2, ...);</code><br>应用场景：当要为表的所有字段插入数据，且清楚表结构中字段顺序时使用，按表字段顺序提供对应值。 </p>
<h5 id="三、批量添加数据"><a href="#三、批量添加数据" class="headerlink" title="三、批量添加数据"></a>三、批量添加数据</h5><ol>
<li><strong>指定字段批量添加</strong><ul>
<li><strong>语法</strong>：<code>INSERT INTO 表名 (字段名1,字段名2, ...) VALUES (值1,值2, ...),(值1,值2, ...),(值1,值2, ...);</code></li>
<li><strong>说明</strong>：可一次性向指定字段插入多组数据，每个 <code>(值1,值2, ...)</code> 为一组，组内值顺序与前面指定字段顺序对应。</li>
</ul>
</li>
<li><strong>全部字段批量添加</strong><ul>
<li><strong>语法</strong>：<code>INSERT INTO 表名 VALUES (值1,值2, ...),(值1,值2, ...),(值1,值2, ...);</code></li>
<li><strong>说明</strong>：无需指定字段名，按表字段顺序，一次插入多组数据，每组数据个数与表字段数一致。<br> <img src="https://i.imgur.com/OMoc828.png"></li>
</ul>
</li>
</ol>
<p><img src="https://i.imgur.com/paSb7fI.png"><br>建表成功</p>
<p><img src="https://i.imgur.com/5a1t6Yp.png"><br>查看创建结果</p>
<p><img src="https://i.imgur.com/6DSGX95.png"><br>将年龄设置为无符号</p>
<p><img src="https://i.imgur.com/jBVXtx0.png"><br>超范围</p>
<p><img src="https://i.imgur.com/kikhcIG.png"><br>不指定插入</p>
<p><img src="https://i.imgur.com/yZlNCh0.png"><br>批量插入</p>
<h4 id="DML-修改数据"><a href="#DML-修改数据" class="headerlink" title="DML-修改数据"></a>DML-修改数据</h4><h5 id="SQL-UPDATE-语句（数据更新）"><a href="#SQL-UPDATE-语句（数据更新）" class="headerlink" title="SQL - UPDATE 语句（数据更新）"></a>SQL - UPDATE 语句（数据更新）</h5><p><strong>语法</strong>：<code>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [WHERE 条件];</code><br><strong>说明</strong>：</p>
<ul>
<li><code>UPDATE</code> ：关键字，用于标识要对表进行更新操作。</li>
<li><code>表名</code> ：指定要更新数据的目标表。</li>
<li><code>SET</code> ：关键字，其后跟着要更新的字段及对应新值，可同时更新多个字段，用逗号分隔。</li>
<li><code>WHERE</code> （可选）：条件子句，用于筛选出满足特定条件的记录进行更新。若省略 <code>WHERE</code> ，会更新表中的所有记录。</li>
</ul>
<p><img src="https://i.imgur.com/YuaY1kc.png"><br><img src="https://i.imgur.com/xBCKOx3.png"><br><img src="https://i.imgur.com/pvfoeia.png"><br><img src="https://i.imgur.com/yzfFD8h.png"></p>
<p><img src="https://i.imgur.com/YNVBMYm.png"><br>不安全<br><img src="https://i.imgur.com/icff6KE.png"><br>修改结果</p>
<h5 id="DML-删除数据"><a href="#DML-删除数据" class="headerlink" title="DML-删除数据"></a>DML-删除数据</h5><p>SQL - DELETE 语句（数据删除）</p>
<p><strong>语法</strong>：<code>DELETE FROM 表名 [WHERE 条件]</code><br><strong>说明</strong>：</p>
<ul>
<li><code>DELETE FROM</code> ：关键字组合，表明要执行删除操作，指定从哪个表删除数据 。</li>
<li><code>表名</code> ：要删除数据所在的目标表。</li>
<li><code>WHERE</code> （可选）：条件子句，用于筛选出满足特定条件的记录进行删除。若省略 <code>WHERE</code> ，会删除表中的所有记录。<br><img src="https://i.imgur.com/EfHVsTV.png"></li>
</ul>
<p><img src="https://i.imgur.com/dT1AvqU.png"></p>
<p><img src="https://i.imgur.com/HnUrUiT.png"></p>
<p><img src="https://i.imgur.com/9jakMje.png"></p>
<p><img src="https://i.imgur.com/bV4EOzD.png"></p>
<h2 id="2-1-4-DQL"><a href="#2-1-4-DQL" class="headerlink" title="2.1.4 DQL"></a>2.1.4 DQL</h2><h3 id="SQL-DQL-基本查询"><a href="#SQL-DQL-基本查询" class="headerlink" title="SQL - DQL 基本查询"></a>SQL - DQL 基本查询</h3><h4 id="一、查询多个字段"><a href="#一、查询多个字段" class="headerlink" title="一、查询多个字段"></a>一、查询多个字段</h4><ol>
<li><strong>指定字段查询</strong><ul>
<li><strong>语法</strong>：<code>SELECT 字段1,字段2,字段3... FROM 表名;</code></li>
<li><strong>说明</strong>：从指定 <code>表名</code> 中选取 <code>字段1,字段2,字段3...</code> 这些特定字段的数据进行查询。</li>
</ul>
</li>
<li><strong>全字段查询</strong><ul>
<li><strong>语法</strong>：<code>SELECT * FROM 表名;</code></li>
<li><strong>说明</strong>：<code>*</code> 为通配符，代表从 <code>表名</code> 中选取所有字段的数据进行查询。<br> <img src="https://i.imgur.com/0zBXGuz.png"><br> <img src="https://i.imgur.com/GbaphtI.png"><br> 查询部分数据<br> <img src="https://i.imgur.com/thRnu16.png"><br> 查询所有地址<br> <img src="https://i.imgur.com/u2agadM.png"><br> 快捷查询<br> <img src="https://i.imgur.com/nxANpE0.png"><br> 起别名<br> <img src="https://i.imgur.com/wXUIb3d.png"><br> 去重查询</li>
</ul>
</li>
</ol>
<h4 id="二、设置别名"><a href="#二、设置别名" class="headerlink" title="二、设置别名"></a>二、设置别名</h4><ul>
<li><strong>语法</strong>：<code>SELECT 字段1 [AS 别名1],字段2 [AS 别名2]... FROM 表名;</code></li>
<li><strong>说明</strong>：<code>AS</code> 关键字用于给字段设置别名，方便在查询结果展示或后续操作中使用更易懂的名称，<code>AS</code> 可省略 。</li>
</ul>
<h4 id="三、去除重复记录"><a href="#三、去除重复记录" class="headerlink" title="三、去除重复记录"></a>三、去除重复记录</h4><ul>
<li><strong>语法</strong>：<code>SELECT DISTINCT 字段列表 FROM 表名;</code></li>
<li><strong>说明</strong>：<code>DISTINCT</code> 关键字用于去除 <code>字段列表</code> 中重复的记录，只保留不同值的记录。</li>
</ul>
<h3 id="SQL-DQL条件查询"><a href="#SQL-DQL条件查询" class="headerlink" title="SQL -DQL条件查询"></a>SQL -DQL条件查询</h3><h4 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a>一、语法</h4><p><code>SELECT 字段列表 FROM 表名 WHERE 条件列表;</code>  </p>
<p>说明：</p>
<ul>
<li><code>SELECT</code>：用于指定要查询的字段。可指定一个或多个字段，多个字段间用逗号分隔；若要查询所有字段，可用 <code>*</code> 代替字段列表。</li>
<li><code>FROM</code>：指定从哪个表中获取数据 。</li>
<li><code>WHERE</code>：筛选条件，用于限定从表中选取符合特定条件的记录，只有满足条件的记录才会出现在查询结果中。</li>
</ul>
<h4 id="二、条件"><a href="#二、条件" class="headerlink" title="二、条件"></a>二、条件</h4><p> （一）比较运算符</p>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
<tr>
<td><code>=</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>&lt;&gt;</code> 或 <code>!=</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>BETWEEN... AND...</code></td>
<td>在某个范围之内 (含最小值、最大值)</td>
</tr>
<tr>
<td><code>IN(...)</code></td>
<td>在 <code>in</code> 之后的列表中的值，多选一</td>
</tr>
<tr>
<td><code>LIKE</code> 占位符</td>
<td>模糊匹配 (_匹配单个字符，% 匹配任意个字符)</td>
</tr>
<tr>
<td><code>IS NULL</code></td>
<td>是否为空</td>
</tr>
</tbody></table>
<p>（二）逻辑运算符</p>
<table>
<thead>
<tr>
<th align="left">逻辑运算符</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>AND</code> 或 <code>&amp;&amp;</code></td>
<td align="left">并且 (多个条件同时成立)</td>
</tr>
<tr>
<td align="left"><code>OR</code> 或 ‘||’</td>
<td align="left">或者 (多个条件任意一个成立)</td>
</tr>
<tr>
<td align="left"><code>NOT</code> 或 <code>!</code></td>
<td align="left">非，不是</td>
</tr>
<tr>
<td align="left"><img src="https://i.imgur.com/tUv5mBj.png"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">查询年龄</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="https://i.imgur.com/Jx8p3Wo.png"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">查询不等号</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="https://i.imgur.com/MkqB3wM.png"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">查询为null的</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="https://i.imgur.com/2i6z8AS.png"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">查询非null的</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="https://i.imgur.com/1JdJAek.png"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">不等于的两种语法</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="https://i.imgur.com/myKtFIy.png"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">查询范围的两种语法</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="https://i.imgur.com/R2lz3Qp.png"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">或的语法</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="https://i.imgur.com/j3mTvnD.png"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">in语法</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="https://i.imgur.com/jdLEZEE.png"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">查指定字符数</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="https://i.imgur.com/ga3AETX.png"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">查指定字符</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><img src="https://i.imgur.com/2SG6Iyp.png"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="SQL-DQL聚合函数"><a href="#SQL-DQL聚合函数" class="headerlink" title="SQL -DQL聚合函数"></a>SQL -DQL聚合函数</h3><h4 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h4><p>聚合函数是将表中的一列数据视为一个整体，进行纵向计算的函数。它能对列中的多个数据值进行处理，输出一个统计结果，用于快速获取数据集合的总体特征。</p>
<h4 id="二、常见聚合函数"><a href="#二、常见聚合函数" class="headerlink" title="二、常见聚合函数"></a>二、常见聚合函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>count</code></td>
<td>统计数量，可计算列的行数或满足特定条件的行数</td>
<td>统计员工表总人数：<code>SELECT COUNT(*) FROM employees;</code><br>统计工资大于5000的员工数：<code>SELECT COUNT(*) FROM employees WHERE salary &gt; 5000;</code></td>
</tr>
<tr>
<td><code>max</code></td>
<td>找出列中的最大值</td>
<td>找出员工表中最高工资：<code>SELECT MAX(salary) FROM employees;</code></td>
</tr>
<tr>
<td><code>min</code></td>
<td>找出列中的最小值</td>
<td>找出员工表中最低工资：<code>SELECT MIN(salary) FROM employees;</code></td>
</tr>
<tr>
<td><code>avg</code></td>
<td>计算列中数值的平均值</td>
<td>计算员工表平均工资：<code>SELECT AVG(salary) FROM employees;</code></td>
</tr>
<tr>
<td><code>sum</code></td>
<td>对列中的数值进行求和</td>
<td>计算员工表工资总和：<code>SELECT SUM(salary) FROM employees;</code></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/PtOS9LB.png"></td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/7QnLf1r.png"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>求总量</td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/o4h0oMO.png"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>条件总量</td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/JVHl0K1.png"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>求均值</td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/5mRmmL0.png"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>求最大值</td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/0CHLI9u.png"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>求最小值</td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/gc67qch.png"></td>
<td></td>
<td></td>
</tr>
<tr>
<td>条件总和</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="SQL-DQL分组查询"><a href="#SQL-DQL分组查询" class="headerlink" title="SQL -DQL分组查询"></a>SQL -DQL分组查询</h3><p> 一、语法<br><code>SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];</code><br><img src="https://i.imgur.com/Yc0HkFs.png"><br><img src="https://i.imgur.com/CimetoU.png"></p>
<p><img src="https://i.imgur.com/jjcOpX4.png"><br>不明晰的分类<br><img src="https://i.imgur.com/3ukERIc.png"><br>统计<br><img src="https://i.imgur.com/AOWcRLs.png"><br>均值<br><img src="https://i.imgur.com/b8xnAQ6.png"><br><img src="https://i.imgur.com/3jxJERb.png"><br>筛选条件</p>
<h3 id="SQL-DQL排序查询"><a href="#SQL-DQL排序查询" class="headerlink" title="SQL -DQL排序查询"></a>SQL -DQL排序查询</h3><h4 id="一、语法-1"><a href="#一、语法-1" class="headerlink" title="一、语法"></a>一、语法</h4><p><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</code><br><img src="https://i.imgur.com/1wJvKu8.png"><br>升序<br><img src="https://i.imgur.com/FFf6v53.png"><br>降序<br><img src="https://i.imgur.com/XmJvbE3.png"><br>同样指标的二次排序</p>
<h3 id="SQL-DQL分页查询"><a href="#SQL-DQL分页查询" class="headerlink" title="SQL -DQL分页查询"></a>SQL -DQL分页查询</h3><p>SQL 中进行分页查询的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">```SQL</span><br><span class="line">SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/rlj4KQg.png"><br><img src="https://i.imgur.com/lq35fuz.png"><br><img src="https://i.imgur.com/Sb8AcUM.png"></p>
<p>练习：<br><img src="https://i.imgur.com/1XYX7ow.png"><br><img src="https://i.imgur.com/zN2T16r.png"><br><img src="https://i.imgur.com/3IztUw7.png"><br><img src="https://i.imgur.com/iKEBEmK.png"><br><img src="https://i.imgur.com/o4SCN7D.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数</span><br></pre></td></tr></table></figure>
<h2 id="2-1-4-DCL"><a href="#2-1-4-DCL" class="headerlink" title="2.1.4 DCL"></a>2.1.4 DCL</h2><p> 一、定义<br>DCL，英文全称Data Control Language，即数据控制语言 。其作用是管理数据库用户，控制数据库的访问权限。<br><img src="https://i.imgur.com/colPAeS.png"><br> 二、图示理解<br>从图中可见，存在不同用户（如itcast、heima ）与MySQL数据库服务器（包含A、B、C等数据存储部分）。DCL就是用来决定这些用户对数据库服务器中不同数据部分，拥有怎样的访问权限，比如哪些用户可以读取、写入特定的数据区域等。 </p>
<h3 id="SQL-DCL管理用户"><a href="#SQL-DCL管理用户" class="headerlink" title="SQL - DCL管理用户"></a>SQL - DCL管理用户</h3><h4 id="一、查询用户"><a href="#一、查询用户" class="headerlink" title="一、查询用户"></a>一、查询用户</h4><p>使用以下SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
<p>先切换到<code>mysql</code>数据库，再从<code>user</code>表中查询所有用户信息。<br><img src="https://i.imgur.com/vWnaMqM.png"><br><img src="https://i.imgur.com/1bQh10H.png"><br><img src="https://i.imgur.com/jt4uNXK.png"><br>默认四个用户</p>
<h4 id="二、创建用户"><a href="#二、创建用户" class="headerlink" title="二、创建用户"></a>二、创建用户</h4><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>用于创建新的数据库用户，需指定用户名、允许登录的主机以及用户密码。<br><img src="https://i.imgur.com/Cci0O5D.png"><br>只能在本机访问<br><img src="https://i.imgur.com/tpl1a4O.png"><br><img src="https://i.imgur.com/c6KFKv9.png"><br><img src="https://i.imgur.com/2BXITRy.png"><br>没有权限<br><img src="https://i.imgur.com/2DdKuyf.png"><br><img src="https://i.imgur.com/Pwzfm5O.png"></p>
<h4 id="三、修改用户密码"><a href="#三、修改用户密码" class="headerlink" title="三、修改用户密码"></a>三、修改用户密码</h4><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>可修改指定用户的登录密码，<code>mysql_native_password</code>是MySQL的一种密码验证插件 。<br><img src="https://i.imgur.com/T7h8JVs.png"></p>
<h4 id="四、删除用户"><a href="#四、删除用户" class="headerlink" title="四、删除用户"></a>四、删除用户</h4><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>用于删除指定的数据库用户。<br><img src="https://i.imgur.com/4JqbaHA.png"><br><img src="https://i.imgur.com/UO2cxIW.png"></p>
<h3 id="SQL-DCL权限控制"><a href="#SQL-DCL权限控制" class="headerlink" title="SQL - DCL权限控制"></a>SQL - DCL权限控制</h3><p>在MySQL中，DCL用于进行权限控制，常用权限如下：</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ALL, ALL PRIVILEGES</td>
<td>所有权限</td>
</tr>
<tr>
<td>SELECT</td>
<td>查询数据</td>
</tr>
<tr>
<td>INSERT</td>
<td>插入数据</td>
</tr>
<tr>
<td>UPDATE</td>
<td>修改数据</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除数据</td>
</tr>
<tr>
<td>ALTER</td>
<td>修改表</td>
</tr>
<tr>
<td>DROP</td>
<td>删除数据库&#x2F;表&#x2F;视图</td>
</tr>
<tr>
<td>CREATE</td>
<td>创建数据库&#x2F;表</td>
</tr>
</tbody></table>
<h1 id="SQL-DCL权限控制-1"><a href="#SQL-DCL权限控制-1" class="headerlink" title="SQL - DCL权限控制"></a>SQL - DCL权限控制</h1><p> 一、查询权限<br>使用语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>用于查看指定用户在对应主机上拥有的权限。<br><img src="https://i.imgur.com/4DtolMn.png"></p>
<p> 二、授予权限<br>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">TO</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>可将指定的权限（如SELECT、INSERT等 ）授予特定用户对指定数据库和表进行操作。<br><img src="https://i.imgur.com/2eSHrZp.png"></p>
<p> 三、撤销权限<br>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> 权限列表 <span class="keyword">ON</span> 数据库名.表名 <span class="keyword">FROM</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>用于收回指定用户对特定数据库和表的某些权限。 <img src="https://i.imgur.com/M4YFbCJ.png"><br><img src="https://i.imgur.com/5ri0lOF.png"></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库：第四章 约束</title>
    <url>/2025/05/11/%E6%95%B0%E6%8D%AE%E5%BA%93.%E7%AC%AC%E5%9B%9B%E7%AB%A0.%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h2 id="3-1-约束的概述"><a href="#3-1-约束的概述" class="headerlink" title="3.1 约束的概述"></a>3.1 约束的概述</h2><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p>
<h3 id="二、目的"><a href="#二、目的" class="headerlink" title="二、目的"></a>二、目的</h3><p>保证数据库中数据的正确、有效性和完整性。</p>
<h3 id="三、分类"><a href="#三、分类" class="headerlink" title="三、分类"></a>三、分类</h3><table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>非空约束</td>
<td>限制该字段的数据不能为 null</td>
<td>NOT NULL</td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证该字段的所有数据都是唯一、不重复的</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td>PRIMARY KEY</td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段的值，则采用默认值</td>
<td>DEFAULT</td>
</tr>
<tr>
<td>检查约束（8.0.16 版本之后）</td>
<td>保证字段值满足某一个条件</td>
<td>CHECK</td>
</tr>
<tr>
<td>外键约束</td>
<td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/T5Xz2fj.png"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="3-2-约束的演示"><a href="#3-2-约束的演示" class="headerlink" title="3.2 约束的演示"></a>3.2 约束的演示</h2><table>
<thead>
<tr>
<th>字段名</th>
<th>字段含义</th>
<th>字段类型</th>
<th>约束条件</th>
<th>约束关键字</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>ID 唯一标识</td>
<td>int</td>
<td>主键，并且自动增长</td>
<td>PRIMARY KEY, AUTO_INCREMENT</td>
</tr>
<tr>
<td>name</td>
<td>姓名</td>
<td>varchar(10)</td>
<td>不为空，并且唯一</td>
<td>NOT NULL, UNIQUE</td>
</tr>
<tr>
<td>age</td>
<td>年龄</td>
<td>int</td>
<td>大于 0，并且小于等于 120</td>
<td>CHECK</td>
</tr>
<tr>
<td>status</td>
<td>状态</td>
<td>char(1)</td>
<td>如果没有指定该值，默认为 1</td>
<td>DEFAULT</td>
</tr>
<tr>
<td>gender</td>
<td>性别</td>
<td>char(1)</td>
<td>无</td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://i.imgur.com/5MpJ4r7.png"><br>主键约束<br><img src="https://i.imgur.com/cdMXYyF.png"></p>
<h2 id="3-3-外键约束"><a href="#3-3-外键约束" class="headerlink" title="3.3 外键约束"></a>3.3 外键约束</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>外键用于在两张表的数据间建立连接，保障数据的一致性与完整性。</p>
<h3 id="示例（员工表-emp-）"><a href="#示例（员工表-emp-）" class="headerlink" title="示例（员工表 emp ）"></a>示例（员工表 emp ）</h3><table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
<th>job</th>
<th>salary</th>
<th>entrydate</th>
<th>managerid</th>
<th>dept_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>金庸</td>
<td>66</td>
<td>总裁</td>
<td>20800</td>
<td>2000 - 01 - 01</td>
<td><null></null></td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>张无忌</td>
<td>20</td>
<td>项目经理</td>
<td>12500</td>
<td>2005 - 12 - 05</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>杨逍</td>
<td>33</td>
<td>开发</td>
<td>8400</td>
<td>2000 - 11 - 03</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>韦一笑</td>
<td>48</td>
<td>开发</td>
<td>11000</td>
<td>2002 - 02 - 05</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>常遇春</td>
<td>43</td>
<td>开发</td>
<td>10500</td>
<td>2004 - 09 - 07</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td><img src="https://i.imgur.com/tigs9Lp.png"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/we1dUsD.png"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://i.imgur.com/ur3HOXQ.png"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>建立表</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="（一）添加外键-创建表时添加"><a href="#（一）添加外键-创建表时添加" class="headerlink" title="（一）添加外键 - 创建表时添加"></a>（一）添加外键 - 创建表时添加</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    字段名 数据类型,</span><br><span class="line">   ...</span><br><span class="line">    [<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="（二）添加外键-表创建后添加"><a href="#（二）添加外键-表创建后添加" class="headerlink" title="（二）添加外键 - 表创建后添加"></a>（二）添加外键 - 表创建后添加</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名);</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/p9RNjjx.png"><br><img src="https://i.imgur.com/PXH93Hn.png"><br>关联成功<br><img src="https://i.imgur.com/P46GUN6.png"></p>
<p>删除外键<br><img src="https://i.imgur.com/tYALbQK.png"><br>蓝色小钥匙已经消失<br><img src="https://i.imgur.com/qr29Jnf.png"></p>
<h3 id="外键约束行为"><a href="#外键约束行为" class="headerlink" title="外键约束行为"></a>外键约束行为</h3><table>
<thead>
<tr>
<th>行为</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NO ACTION</td>
<td>在父表删除 &#x2F; 更新记录时，先检查是否有对应外键，有则不允许操作，与 RESTRICT 一致</td>
</tr>
<tr>
<td><strong>RESTRICT</strong></td>
<td>同 NO ACTION，检查父表记录对应外键，有则禁止删除 &#x2F; 更新</td>
</tr>
<tr>
<td><strong>CASCADE</strong></td>
<td>父表删除 &#x2F; 更新记录时，若存在对应外键，同时删除 &#x2F; 更新子表中外键关联记录</td>
</tr>
<tr>
<td>SET NULL</td>
<td>父表删除记录时，若有对应外键，将子表中外键值设为 null（要求外键允许取 null ）</td>
</tr>
<tr>
<td>SET DEFAULT</td>
<td>父表变动时，子表外键设为默认值（InnoDB 不支持）</td>
</tr>
<tr>
<td><strong>语法格式</strong>：</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段) <span class="keyword">REFERENCES</span> 主表名(主表字段名) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/ArKz1Nx.png"><br><img src="https://i.imgur.com/Om3Tiwd.png"><br>外键和内键同时变化<br>set null<br><img src="https://i.imgur.com/kkvyhCo.png"><br><img src="https://i.imgur.com/JZRTlB9.png"><br>直接在图形化界面切换外键<br><img src="https://i.imgur.com/O4R6XsO.png"><br><img src="https://i.imgur.com/DjiFy1Q.png"></p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：树和二叉树</title>
    <url>/2024/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h3><p>树（Tree）是一种重要的非线性数据结构，由一组节点（Node）和边（Edge）组成，用于表示具有层次关系的数据。树具有以下几个特点：</p>
<ul>
<li><strong>层次性</strong>：树是一种分层结构，每个节点与其他节点之间有明确的父子关系。</li>
<li><strong>有根性</strong>：树中有且只有一个根节点（Root Node），它是树的起点，没有父节点。</li>
<li><strong>递归性</strong>：树结构具有递归的性质，每棵树由一个根节点和若干子树组成，每棵子树本身也是一棵树。</li>
<li><img src="https://i.postimg.cc/tRKdzdtV/36a04d2fc8f6a5d03173a01a27b4d451.png"></li>
</ul>
<h3 id="树的基本术语"><a href="#树的基本术语" class="headerlink" title="树的基本术语"></a>树的基本术语</h3><p><strong>节点（Node）</strong><br>节点是树中的基本元素，每个节点包含一个数据值，并且可能有零个或多个子节点。节点是树的基本构成单元。</p>
<p><strong>根节点（Root Node）</strong><br>根节点是树的起始节点，是层次结构中的最高层。根节点没有父节点，它是树的唯一入口点。</p>
<p><strong>子节点（Child Node）</strong><br>子节点是某个节点的直接后继节点。一个节点可以有多个子节点，表示树中的层次关系。</p>
<p><strong>父节点（Parent Node）</strong><br>父节点是某个节点的直接前驱节点。子节点与父节点之间由一条边连接。</p>
<p><strong>叶子节点（Leaf Node）</strong><br>叶子节点是没有子节点的节点，位于树的最底层，也称为终端节点。</p>
<p><strong>兄弟节点（Sibling Node）</strong><br>兄弟节点是同一个父节点的子节点，它们在树的层次结构中位于同一层。</p>
<p><strong>路径（Path）</strong><br>路径是从一个节点到另一个节点的边的序列。路径长度是路径上边的数量。</p>
<p><strong>深度（Depth）</strong><br>深度是从根节点到某个节点的路径长度，也可以理解为该节点的层数。</p>
<p><strong>高度（Height）</strong><br>高度是从该节点到叶节点的最长路径长度。树的高度是其根节点的高度。</p>
<p><strong>层（Level）</strong><br>层表示节点在树中的层级，根节点的层级为0，其子节点的层级为1，依此类推。</p>
<p><strong>度（Degree）</strong><br>度是一个节点拥有的子节点的数量。树的度是所有节点度的最大值。</p>
<p><strong>子树（Subtree）</strong><br>子树是树的一个子集，它由某个节点及其所有后代节点组成。子树本身也是一棵树。</p>
<p><strong>森林（Forest）</strong><br>森林是由多棵互不相连的树组成的集合。将树的根节点删除后会得到一个森林。</p>
<p>通过这些定义和基本术语，可以全面了解树这种数据结构及其在各种应用场景中的重要性。</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：哈希表（hash table）</title>
    <url>/2022/11/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++标准库"></a>C++标准库<unordered_map></unordered_map></h2><p>在c++中，<unordered_map>是标准模板库（STL）的一部分，提供了一种基于哈希表的键值对容器。</unordered_map></p>
<p>与 <code>std::map</code> 不同，<code>unordered_map</code> 不保证元素的排序，但通常提供更快的查找速度。</p>
<p><code>unordered_map</code> 是一个关联容器，它存储了键值对（key-value pairs），其中每个键（key）都是唯一的。<code>unordered_map</code> 使用哈希表来存储元素，这使得它在查找、插入和删除操作中具有平均常数时间复杂度。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unordered_map&lt;key_type, value_type&gt; map_name;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>key_type</code> 是键的类型。</li>
<li><code>value_type</code> 是值的类型。</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>unordered_map</code> 可以以多种方式构造：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造</span></span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造并初始化</span></span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::string&gt; myMap = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造并指定初始容量</span></span><br><span class="line"><span class="function">std::unordered_map&lt;<span class="type">int</span>, std::string&gt; <span class="title">myMap</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造并复制另一个 unordered_map</span></span><br><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::string&gt; anotherMap = myMap;</span><br></pre></td></tr></table></figure>

<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li>插入元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myMap.<span class="built_in">insert</span>(&#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>访问元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string value = myMap[<span class="number">1</span>]; <span class="comment">// 获取键为1的值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myMap.<span class="built_in">erase</span>(<span class="number">1</span>); <span class="comment">// 删除键为1的元素</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查找元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="number">2</span>); <span class="comment">// 查找键为2的元素</span></span><br><span class="line"><span class="keyword">if</span> (it != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 unordered_map，键为 int，值为 string</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一些键值对</span></span><br><span class="line">    myMap[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">    myMap[<span class="number">2</span>] = <span class="string">&quot;two&quot;</span>;</span><br><span class="line">    myMap[<span class="number">3</span>] = <span class="string">&quot;three&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问特定键的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value for key 2: &quot;</span> &lt;&lt; myMap[<span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键为1的元素</span></span><br><span class="line">    myMap.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次打印所有元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After erasing key 1:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : myMap) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‘’Key: 1, Value: one<br>Key: 2, Value: two<br>Key: 3, Value: three<br>Value for key 2: two<br>After erasing key 1:<br>Key: 2, Value: two<br>Key: 3, Value: three’‘</p>
<h2 id="C-容器类"><a href="#C-容器类" class="headerlink" title="C++容器类"></a>C++容器类<map></map></h2><p>在 C++ 中，<code>&lt;map&gt;</code> 是标准模板库（STL）的一部分，它提供了一种关联容器，用于存储键值对（key-value pairs）。</p>
<p><code>map</code> 容器中的元素是按照键的顺序自动排序的，这使得它非常适合需要快速查找和有序数据的场景。</p>
<h3 id="定义和特性"><a href="#定义和特性" class="headerlink" title="定义和特性"></a>定义和特性</h3><ul>
<li><strong>键值对</strong>：<code>map</code> 存储的是键值对，其中每个键都是唯一的。</li>
<li><strong>排序</strong>：<code>map</code> 中的元素按照键的顺序自动排序，通常是升序。</li>
<li><strong>唯一性</strong>：每个键在 <code>map</code> 中只能出现一次。</li>
<li><strong>双向迭代器</strong>：<code>map</code> 提供了双向迭代器，可以向前和向后遍历元素。</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="声明map容器"><a href="#声明map容器" class="headerlink" title="声明map容器"></a>声明map容器</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;key_type, value_type&gt; myMap;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>key_type</code> 是键的类型。</li>
<li><code>value_type</code> 是值的类型。</li>
</ul>
<h4 id="插入元素："><a href="#插入元素：" class="headerlink" title="插入元素："></a>插入元素：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myMap[key] = value;</span><br></pre></td></tr></table></figure>

<h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">value = myMap[key];</span><br></pre></td></tr></table></figure>

<h4 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a>遍历map</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::map&lt;key_type,value_type&gt;::iterator it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) </span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 map 容器，存储员工的姓名和年龄</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; employees;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入员工信息</span></span><br><span class="line">    employees[<span class="string">&quot;Alice&quot;</span>] = <span class="number">30</span>;</span><br><span class="line">    employees[<span class="string">&quot;Bob&quot;</span>] = <span class="number">25</span>;</span><br><span class="line">    employees[<span class="string">&quot;Charlie&quot;</span>] = <span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 map 并打印员工信息</span></span><br><span class="line">    <span class="keyword">for</span> (std::map&lt;std::string, <span class="type">int</span>&gt;::iterator it = employees.<span class="built_in">begin</span>(); it != employees.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot; years old.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Alice is <span class="number">30</span> years old.</span><br><span class="line">Bob is <span class="number">25</span> years old.</span><br><span class="line">Charlie is <span class="number">35</span> years old.</span><br></pre></td></tr></table></figure>

<h3 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h3><h4 id="检查键是否存在"><a href="#检查键是否存在" class="headerlink" title="检查键是否存在:"></a>检查键是否存在:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (myMap.<span class="built_in">find</span>(key) != myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 键存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素:"></a>删除元素:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myMap.<span class="built_in">erase</span>(key);</span><br></pre></td></tr></table></figure>

<h4 id="清空-map"><a href="#清空-map" class="headerlink" title="清空 map:"></a>清空 map:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myMap.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<h4 id="获取-map-的大小"><a href="#获取-map-的大小" class="headerlink" title="获取 map 的大小:"></a>获取 map 的大小:</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> size = myMap.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<p>使用自定义比较函数:</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">\<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(<span class="type">const</span> std::string&amp; a, <span class="type">const</span> std::string&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::map&lt;std::string, <span class="type">int</span>, std::function&lt;<span class="type">bool</span>(<span class="type">const</span> std::string&amp;, <span class="type">const</span> std::string&amp;)&gt;&gt; <span class="built_in">myMap</span>(myCompare);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他操作...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-容器类-1"><a href="#C-容器类-1" class="headerlink" title="C++ 容器类 &lt;unordered_set&gt;"></a>C++ 容器类 <code>&lt;unordered_set&gt;</code></h2><p>在C++中，<code>&lt;unordered_set&gt;</code> 是标准模板库（STL）的一部分，提供了一种基于哈希表的容器，用于存储唯一的元素集合。</p>
<p>与 <code>set</code> 不同，<code>unordered_set</code> 不保证元素的排序，但通常提供更快的查找、插入和删除操作。</p>
<p><code>unordered_set</code> 是一个模板类，其定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;unordered_set&gt;</span><br><span class="line"></span><br><span class="line">std::unordered_set&lt;Key, Hash = std::hash&lt;Key&gt;, Pred = std::equal_to&lt;Key&gt;, Alloc = std::allocator&lt;Key&gt;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Key</code> 是存储在 <code>unordered_set</code> 中的元素类型。</li>
<li><code>Hash</code> 是一个函数或函数对象，用于生成元素的哈希值，默认为 <code>std::hash&lt;Key&gt;</code>。</li>
<li><code>Pred</code> 是一个二元谓词，用于比较两个元素是否相等，默认为 <code>std::equal_to&lt;Key&gt;</code>。</li>
<li><code>Alloc</code> 是分配器类型，用于管理内存分配，默认为 <code>std::allocator&lt;Ke</code>语法</li>
</ul>
<p>以下是一些基本的 unordered_set 操作：</p>
<p>构造函数：创建一个空的 unordered_set。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unorered_set&lt;<span class="type">int</span>&gt; uset;</span><br></pre></td></tr></table></figure>

<p>插入元素：使用 insert() 方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">uset.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>查找元素：使用 find() 方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = uset.<span class="built_in">find</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (it != uset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="comment">// 元素存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除元素：使用 erase() 方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">uset.<span class="built_in">erase</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>大小和空检查：使用 size() 和 empty() 方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> size = uset.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">bool</span> isEmpty = uset.<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure>

<p>清空容器：使用 clear() 方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">uset.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<p>实例<br>下面是一个使用 unordered_set 的简单示例，包括输出结果。</p>
<p>实例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个整数类型的 unordered_set</span></span><br><span class="line">    std::unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">uset.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">uset.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">uset.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印 unordered_set 中的元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Elements in uset: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> elem : uset) &#123;</span><br><span class="line">    std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line"><span class="keyword">auto</span> it = uset.<span class="built_in">find</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">if</span> (it != uset.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element 20 found in uset.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element 20 not found in uset.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">uset.<span class="built_in">erase</span>(<span class="number">20</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;After erasing 20, elements in uset: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> elem : uset) &#123;</span><br><span class="line">    std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查大小和是否为空</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Size of uset: &quot;</span> &lt;&lt; uset.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Is uset empty? &quot;</span> &lt;&lt; (uset.<span class="built_in">empty</span>() ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空 unordered_set</span></span><br><span class="line">uset.<span class="built_in">clear</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;After clearing, is uset empty? &quot;</span> &lt;&lt; (uset.<span class="built_in">empty</span>() ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>}<br>输出结果:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Elements in uset: <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> </span><br><span class="line">Element <span class="number">20</span> found in uset.</span><br><span class="line">After erasing <span class="number">20</span>, elements in uset: <span class="number">10</span> <span class="number">30</span> </span><br><span class="line">Size of uset: <span class="number">2</span></span><br><span class="line">Is uset empty? No</span><br><span class="line">After clearing, is uset empty? Yes</span><br></pre></td></tr></table></figure>





<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>提示</p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map1;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map1.<span class="built_in">count</span>(target - nums[i]))</span><br><span class="line">                <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;i, map1[target - nums[i]]&#125;;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map1[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="排序加双指针"><a href="#排序加双指针" class="headerlink" title="排序加双指针"></a>排序加双指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        temp=nums;</span><br><span class="line">        <span class="type">int</span> n=temp.<span class="built_in">size</span>();</span><br><span class="line">       <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">       <span class="type">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;j)&#123;  </span><br><span class="line">           <span class="keyword">if</span>(temp[i]+temp[j]&gt;target)j--;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(temp[i]+temp[j]&lt;target)i++;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(i&lt;n&amp;&amp;nums[k]==temp[i])&#123;</span><br><span class="line">              ans.<span class="built_in">push_back</span>(k);</span><br><span class="line">              i=n;</span><br><span class="line">          &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(j&lt;n&amp;&amp;nums[k]==temp[j])&#123;</span><br><span class="line">              ans.<span class="built_in">push_back</span>(k);</span><br><span class="line">              j=n;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(i==n&amp;&amp;j==n)<span class="keyword">return</span> ans;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h2><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: strs = [<span class="string">&quot;eat&quot;</span>, <span class="string">&quot;tea&quot;</span>, <span class="string">&quot;tan&quot;</span>, <span class="string">&quot;ate&quot;</span>, <span class="string">&quot;nat&quot;</span>, <span class="string">&quot;bat&quot;</span>]</span><br><span class="line">输出: [[<span class="string">&quot;bat&quot;</span>],[<span class="string">&quot;nat&quot;</span>,<span class="string">&quot;tan&quot;</span>],[<span class="string">&quot;ate&quot;</span>,<span class="string">&quot;eat&quot;</span>,<span class="string">&quot;tea&quot;</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: strs = [<span class="string">&quot;&quot;</span>]</span><br><span class="line">输出: [[<span class="string">&quot;&quot;</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: strs = [<span class="string">&quot;a&quot;</span>]</span><br><span class="line">输出: [[<span class="string">&quot;a&quot;</span>]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 104</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 100</code></li>
<li><code>strs[i]</code> 仅包含小写字母</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string,vector&lt;string&gt;&gt; record;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string key=strs[i];</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(),key.<span class="built_in">end</span>());</span><br><span class="line">            record[key].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">		&#125;</span><br><span class="line">        vector&lt;vecotr&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it=record.<span class="built_in">begin</span>();it!=record.<span class="built_in">end</span>();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://p.sda1.dev/18/3f325de3275062c69b43c6dff869c02b/QQ_1721852523752.png"></p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>/2025/05/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="切换默认下载位置"><a href="#切换默认下载位置" class="headerlink" title="切换默认下载位置"></a><strong>切换默认下载位置</strong></h1><h3 id="1-使用国内镜像源（推荐）"><a href="#1-使用国内镜像源（推荐）" class="headerlink" title="1. 使用国内镜像源（推荐）"></a>1. <strong>使用国内镜像源</strong>（推荐）</h3><p>国内的 PyPI 镜像通常比默认的 PyPI 服务器快很多，尤其是像 TensorFlow 这样的大文件。你可以临时或永久使用国内源下载：</p>
<h4 id="临时使用（仅本次安装生效）："><a href="#临时使用（仅本次安装生效）：" class="headerlink" title="临时使用（仅本次安装生效）："></a><strong>临时使用</strong>（仅本次安装生效）：</h4><p>bash</p>
<p>复制编辑</p>
<p><code>pip install tensorflow -i https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
<h4 id="永久修改-pip-源（推荐）："><a href="#永久修改-pip-源（推荐）：" class="headerlink" title="永久修改 pip 源（推荐）："></a><strong>永久修改 pip 源</strong>（推荐）：</h4><p>修改 <code>pip</code> 的默认下载源，使所有 <code>pip install</code> 都加速：</p>
<p>bash</p>
<p>复制编辑</p>
<p><code>pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
<p>或者手动修改 <code>pip</code> 配置文件：</p>
<ul>
<li><p><strong>Windows</strong>：编辑 <code>C:\Users\你的用户名\pip\pip.ini</code>（如果不存在，就新建）：</p>
<p>  ini</p>
<p>  复制编辑</p>
<p>  <code>[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
</li>
<li><p><strong>Linux&#x2F;macOS</strong>：修改 <code>~/.pip/pip.conf</code>：</p>
<p>  ini</p>
<p>  复制编辑</p>
<p>  <code>[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple</code></p>
</li>
</ul>
<p>常见的国内镜像源：</p>
<table>
<thead>
<tr>
<th>镜像源</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>清华</td>
<td><code>https://pypi.tuna.tsinghua.edu.cn/simple</code></td>
</tr>
<tr>
<td>阿里</td>
<td><code>https://mirrors.aliyun.com/pypi/simple</code></td>
</tr>
<tr>
<td>豆瓣</td>
<td><code>https://pypi.doubanio.com/simple</code></td>
</tr>
<tr>
<td>腾讯</td>
<td><code>https://mirrors.cloud.tencent.com/pypi/simple</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="2-手动下载-whl-文件"><a href="#2-手动下载-whl-文件" class="headerlink" title="2. 手动下载 .whl 文件"></a>2. <strong>手动下载 <code>.whl</code> 文件</strong></h3><p>如果切换源仍然很慢，你可以手动下载 TensorFlow 的 <code>.whl</code> 文件，然后本地安装：</p>
<ol>
<li><p>访问 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/tensorflow/">https://pypi.tuna.tsinghua.edu.cn/simple/tensorflow/</a> 查找适合你的 Python 版本的 <code>.whl</code> 文件。</p>
</li>
<li><p>下载 <code>.whl</code> 文件到本地。</p>
</li>
<li><p>使用 <code>pip install</code> 安装：</p>
<p> bash</p>
<p> 复制编辑</p>
<p> <code>pip install 路径/文件名.whl</code></p>
</li>
</ol>
<p>试试看能否加速下载？如果有问题，可以贴出你的 Python 版本和操作系统，我帮你匹配正确的 TensorFlow 版本。</p>
<p>如果你想让 <code>pip</code> 在安装时下载到你电脑的指定目录，可以使用 <code>--download</code>（较老版本）或 <code>--cache-dir</code> 选项。</p>
<h3 id="方法-1：指定-cache-dir-存储下载文件"><a href="#方法-1：指定-cache-dir-存储下载文件" class="headerlink" title="方法 1：指定 --cache-dir 存储下载文件"></a><strong>方法 1：指定 <code>--cache-dir</code> 存储下载文件</strong></h3><p>你可以使用 <code>--cache-dir</code> 选项让 <code>pip</code> 下载的文件存储到特定目录：</p>
<p>bash</p>
<p>复制编辑</p>
<p><code>pip install tensorflow --cache-dir C:\my_downloads</code></p>
<p>这样 <code>pip</code> 在安装 TensorFlow 时，会先将文件下载到 <code>C:\my_downloads</code> 目录，再进行安装。</p>
<hr>
<h3 id="方法-2：手动下载-whl-文件"><a href="#方法-2：手动下载-whl-文件" class="headerlink" title="方法 2：手动下载 .whl 文件"></a><strong>方法 2：手动下载 <code>.whl</code> 文件</strong></h3><p>如果你想完全控制下载目录，可以手动下载 <code>.whl</code> 文件，然后本地安装：</p>
<ol>
<li><p>访问 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/tensorflow/">https://pypi.tuna.tsinghua.edu.cn/simple/tensorflow/</a></p>
</li>
<li><p>选择适合你的 Python 版本的 <code>.whl</code> 文件，手动下载到你的电脑某个目录，比如 <code>D:\tensorflow\</code></p>
</li>
<li><p>运行：</p>
<p> bash</p>
<p> 复制编辑</p>
<p> <code>pip install D:\tensorflow\tensorflow-2.x.x-cp39-cp39-win_amd64.whl</code></p>
<p> （请替换 <code>.whl</code> 文件名为你实际下载的文件名）</p>
</li>
</ol>
<hr>
<h3 id="方法-3：使用-pip-download-仅下载不安装"><a href="#方法-3：使用-pip-download-仅下载不安装" class="headerlink" title="方法 3：使用 pip download 仅下载不安装"></a><strong>方法 3：使用 <code>pip download</code> 仅下载不安装</strong></h3><p>如果你想 <strong>先下载再安装</strong>，可以用 <code>pip download</code>：</p>
<p>bash</p>
<p>复制编辑</p>
<p><code>pip download tensorflow -d C:\my_downloads</code></p>
<p>这样 TensorFlow 会下载到 <code>C:\my_downloads</code> 目录，但不会自动安装。然后你可以手动安装：</p>
<p>bash</p>
<p>复制编辑</p>
<p><code>pip install --no-index --find-links C:\my_downloads tensorflow</code></p>
<p>你希望下载到哪个具体路径？如果有问题，可以告诉我你的 Python 版本和系统环境，我帮你调整最优的下载方式！</p>
<h1 id="使用Pytorch搭建神经网络"><a href="#使用Pytorch搭建神经网络" class="headerlink" title="使用Pytorch搭建神经网络"></a><strong>使用Pytorch搭建神经网络</strong></h1><p>[[Python操作步骤]]</p>
<ol>
<li><p><strong>导入必要的库</strong>：首先，确保你已经安装了<code>pandas</code>和<code>numpy</code>等数据处理库，以及深度学习框架如<code>TensorFlow</code>或<code>PyTorch</code>。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf  <span class="comment"># 或者 import torch</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>读取CSV文件</strong>：使用<code>pandas</code>的<code>read_csv</code>函数读取CSV文件内容。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.read_csv(<span class="string">&#x27;your_file.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据预处理</strong>：根据模型的需求，对数据进行清洗和转换。例如，处理缺失值、归一化数值、编码分类变量等。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 示例：处理缺失值</span></span><br><span class="line">data = data.dropna()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：归一化数值</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">data_scaled = scaler.fit_transform(data)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>划分训练集和测试集</strong>：将数据集划分为训练集和测试集，以评估模型的性能。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(data_scaled[:, :-<span class="number">1</span>], data_scaled[:, -<span class="number">1</span>], test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>构建神经网络模型</strong>：使用所选的深度学习框架构建神经网络模型。例如，使用<code>TensorFlow</code>的<code>Keras</code>接口。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"></span><br><span class="line">model = Sequential([</span><br><span class="line">    Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(X_train.shape[<span class="number">1</span>],)),</span><br><span class="line">    Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">    Dense(<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>)  <span class="comment"># 根据具体任务调整激活函数和输出层神经元数量</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>编译和训练模型</strong>：设置优化器、损失函数和评估指标，然后训练模型。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;adam&#x27;</span>, loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">model.fit(X_train, y_train, epochs=<span class="number">10</span>, batch_size=<span class="number">32</span>, validation_split=<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>评估模型</strong>：使用测试集评估模型的性能。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss, accuracy = model.evaluate(X_test, y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Test Accuracy: <span class="subst">&#123;accuracy&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="Jupyterbook"><a href="#Jupyterbook" class="headerlink" title="Jupyterbook"></a>Jupyterbook</h1><p><strong>1. 安装 Jupyter Notebook</strong></p>
<p>如果你尚未安装 Jupyter Notebook，可以通过以下方式进行安装：</p>
<ul>
<li><p><strong>使用 Anaconda 安装</strong>：Anaconda 是一个集成了多种数据科学工具的发行版，其中包含了 Jupyter Notebook。</p>
<ul>
<li><p><strong>下载 Anaconda</strong>：前往 <a href="https://www.anaconda.com/">Anaconda 官方网站</a> 下载适用于你操作系统的安装包。</p>
</li>
<li><p><strong>安装 Anaconda</strong>：运行下载的安装包，按照提示完成安装。</p>
</li>
</ul>
</li>
<li><p><strong>使用 pip 安装</strong>：如果你已经安装了 Python 环境，可以使用 pip 来安装 Jupyter Notebook。</p>
<p>  bash</p>
<p>  复制编辑</p>
<p>  <code>pip install jupyter</code></p>
</li>
</ul>
<p><strong>2. 启动 Jupyter Notebook</strong></p>
<p>安装完成后，你可以通过以下方式启动 Jupyter Notebook：</p>
<ul>
<li><p><strong>使用 Anaconda Navigator</strong>：打开 Anaconda Navigator，点击 “Launch” 启动 Jupyter Notebook。</p>
</li>
<li><p><strong>使用命令行</strong>：打开命令提示符（Windows）或终端（macOS&#x2F;Linux），输入以下命令启动：</p>
<p>  bash</p>
<p>  复制编辑</p>
<p>  <code>jupyter notebook</code></p>
</li>
</ul>
<p>启动后，默认浏览器会自动打开 Jupyter Notebook 的主界面。</p>
<p><strong>3. 创建并运行 Python 代码</strong></p>
<p>在 Jupyter Notebook 中，你可以通过以下步骤创建并运行 Python 代码：</p>
<ul>
<li><p><strong>创建新笔记本</strong>：在 Jupyter Notebook 主界面，点击右上角的 “New” 按钮，然后选择 “Python 3” 创建一个新的笔记本。</p>
</li>
<li><p><strong>编写代码</strong>：在新建的笔记本中，你会看到一个单元格（cell）。在其中输入你的 Python 代码。例如：</p>
<p>  python</p>
<p>  复制编辑</p>
<p>  <code>print(&quot;Hello, Jupyter!&quot;)</code></p>
</li>
<li><p><strong>运行代码</strong>：按下键盘上的 <code>Shift + Enter</code>，或者点击工具栏中的 “Run” 按钮，来执行单元格中的代码。输出结果会显示在单元格下方。</p>
</li>
</ul>
<p><strong>4. 加载并运行外部 Python 文件</strong></p>
<p>如果你有现成的 <code>.py</code> 文件，想在 Jupyter Notebook 中运行，可以使用以下方法：<a href="https://blog.csdn.net/DoReAGON/article/details/100122750?utm_source=chatgpt.com">CSDN</a></p>
<ul>
<li><p><strong>使用 <code>%run</code> 魔法命令</strong>：在一个单元格中输入 <code>%run your_script.py</code>，然后运行该单元格即可执行 <code>your_script.py</code> 中的代码。</p>
<p>  python</p>
<p>  复制编辑</p>
<p>  <code>%run your_script.py</code></p>
</li>
</ul>
<p>请确保 <code>your_script.py</code> 文件位于当前 Jupyter Notebook 工作目录下，或者提供正确的文件路径。</p>
<ul>
<li><p><strong>使用 <code>%load</code> 魔法命令</strong>：在一个单元格中输入 <code>%load your_script.py</code>，然后运行该单元格。这会将 <code>your_script.py</code> 中的代码加载到单元格中，你可以在编辑后再运行。</p>
<p>  python</p>
<p>  复制编辑</p>
<p>  <code>%load your_script.py</code></p>
</li>
</ul>
<p>加载后，单元格中会显示 <code>your_script.py</code> 的内容。你可以根据需要修改代码，然后再运行该单元格。</p>
]]></content>
  </entry>
  <entry>
    <title>汉化：文言文句式</title>
    <url>/2024/08/06/%E6%B1%89%E5%8C%96%EF%BC%9A%E6%96%87%E8%A8%80%E6%96%87%E5%8F%A5%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="判斷句"><a href="#判斷句" class="headerlink" title="判斷句"></a>判斷句</h2><p>所謂判斷句，就是以名詞、代詞或名詞性短語為謂語對主語進行判斷的句式。</p>
<p><strong>1.“……者，……也”“……，……也”“……，……者也”“……者，……”“……者，……者也”“……，……”“……，……者”等形式。</strong>如：“廉頗者，趙之良將也。”</p>
<p>①陳勝者，陽城人也。</p>
<p>②項脊軒，舊南閣子也。</p>
<p>③南陽劉子驥，高尚士也。</p>
<p>④噌吰者，周景王之無射也。</p>
<p>⑤七略四庫，天子之書。</p>
<p>⑥宮中府中，俱為一體。</p>
<p>⑦梁，吾仇也，燕王，吾所立。</p>
<p>⑧此三者，吾遺恨也。</p>
<p>⑨賂秦而力虧，破滅之道也。</p>
<p>⑩斯用兵之效也。</p>
<p><strong>2.採用副詞“乃”“即”“則”“皆”“是”“誠”“為”等表示判斷。</strong>如：“此乃臣效命之秋也。”</p>
<p>①問今是何世，乃不知有漢。</p>
<p>②不知天上宮闕，今夕是何年。</p>
<p>③即今之傫然在墓者。</p>
<p>④梁父即楚將項燕。</p>
<p>⑤此則岳陽樓之大觀也。</p>
<p>⑥非死,則徙爾。</p>
<p>⑦此皆良實，志慮忠純。</p>
<p>⑧此誠危急存亡之秋也。</p>
<p>⑨如今人方為刀俎，我為魚肉。</p>
<p>⑩我本楚狂人，鳳歌笑孔丘。</p>
<p><strong>3.採用否定副詞“非”表示否定。</strong>如：“六國破滅，非兵不利，戰不善，弊在賂秦。”</p>
<p>①登高而招,臂非加長也,而見者遠。</p>
<p>②城非不高也,池非不深也,兵革非不堅利也。</p>
<p>③非挾太山以超北海之類也。</p>
<p><strong>4、語義上主謂直接判斷：</strong></p>
<p>①劉備天下梟雄。</p>
<p>②其劍自舟中墜於水，遽契其舟，曰：“是吾劍之所從墜。”</p>
<h2 id="被動句"><a href="#被動句" class="headerlink" title="被動句"></a>被動句</h2><p><strong>文言文中，有些語句的主語是動作的承受者，這種句式就是被動句。</strong></p>
<p>其常見類型有：</p>
<p><strong>1.“見”“……見……於”“於”表被動。</strong>如：“吾長見笑於大方之家。”</p>
<p>①臣誠恐見欺於王。</p>
<p>②秦城恐不可得，徒見欺。</p>
<p>③故內惑於鄭袖，外欺於張儀。</p>
<p>④李氏子藩，年十七，不拘於時，學於余。</p>
<p>⑤家叔以余貧苦，遂見用於小邑。</p>
<p><strong>2.“為”“為……所”表被動。</strong>如：“而身死國滅，為天下笑。”</p>
<p>① 父母宗族，皆為戮沒。</p>
<p>②為國者無使為積威之所劫哉。</p>
<p>③為予群從所得。</p>
<p>④恐為操所先。</p>
<p>⑤其後楚日以削,數十年,竟為秦所滅。</p>
<p><strong>3.“受”“受……於”表被動。</strong>如：“受制於人。”</p>
<h2 id="省略句"><a href="#省略句" class="headerlink" title="省略句"></a>省略句</h2><p><strong>文言文中，普遍存在着省略成分的情況，對省略成分的把握，有助於完整理解句子的意思。</strong></p>
<p>文言文中的省略句通常有：</p>
<p><strong>1.省略主語。</strong><br>（1）承前省。如：“永州之野產異蛇，（異蛇）黑質而白章。”<br>（2）承後省（也作蒙後省）。如：“沛公謂張良曰：‘（公）度我至軍中，公乃入。’”<br>（3）自述省。如：“（予）愛是溪，（予）得其尤絕者家焉。”<br>（4）對話省。如：“（孟子）曰：‘獨樂樂，與人樂樂，孰樂？’（王）曰：‘不若與人。’”</p>
<p><strong>2.省略謂語。</strong>如：“一鼓作氣，再（鼓）而衰，三（鼓）而竭。”</p>
<p><strong>3.省略賓語。</strong>如：“可燒而走（之）也。”</p>
<p><strong>4.省略介詞賓語。</strong>如：“公閲畢，即解貂覆生，為（之）掩户。”</p>
<p><strong>5.省略介詞“於”。</strong>如：“今以鐘磬置（於）水中，雖大風浪不能鳴焉。”<br>①冉氏嘗居也，故姓是溪為冉溪。<br>②故西門豹為鄴令,名聞天下。<br>③均之二策,寧許以負秦曲。<br>④皆出山下平地，蓋上出也。<br>⑤今當遠離,臨表涕零,不知所言。<br>⑥漁工水師雖知而不能言。<br>⑦國人莫敢言,道路以目。<br>⑧使將士更休,而自坐帷幕。<br>⑨士志於道而恥惡衣惡食者,未足與議也。</p>
<h2 id="倒裝句"><a href="#倒裝句" class="headerlink" title="倒裝句"></a>倒裝句</h2><p><strong>文言中的倒裝句，是相對於現代漢語的句序而言的，基於此，我們將文言倒裝句式分為賓語前置、定語後置、狀語後置、主謂倒裝等。</strong></p>
<p><strong>1.賓語前置</strong></p>
<p>所謂賓語前置，就是通常作賓語的成分，置於謂語動詞的前面，以示強調。如：“洎不之信”中的“之”就是前置的賓語。賓語前置通常分為四種情況。</p>
<p>（1）疑問句中，疑問代詞作賓語，賓語前置。如：“大王來何操？”</p>
<p>（2）否定句中，代詞作賓語，賓語前置。如：“古之人不余欺也。”</p>
<p>（3）藉助“之”“是”將賓語提前。如：“句讀之不知，惑之不解。”“孜孜焉唯進修是急,未之多見也。”</p>
<p>（4）介賓短語中賓語前置。如：“不然，籍何以至此？”</p>
<p><strong>2.定語後置</strong></p>
<p>通常定語應該放置於中心詞的前面，但文言語句中卻有很多句子將定語放在中心詞之後。如：“蚓無爪牙之利，筋骨之強，上食埃土，下飲黃泉，用心一也。”其中的“利”“強”都是後置定語。文言中的定語後置有以下幾種情況。</p>
<p>（1）用“者”的後置。如：“馬之千里者,一食或盡粟一石。”</p>
<p><strong>3.介賓短語後置 (狀語後置）</strong></p>
<p>文言文中，介詞結構作狀語往往都會置於句後作補語。如：“貧者語於富者曰”“於富者”就是置於句後作補語的介賓短語。</p>
<p>標誌詞：於、以</p>
<p><strong>4.主謂倒裝</strong></p>
<p>這種情況很少，往往是為了表示強烈的感嘆。如：“甚矣，汝之不惠。”“美哉,我少年中國。”</p>
<p>①保民而王，莫之能御也。</p>
<p>②王無異於百姓之以王為愛也。</p>
<p>③德何如，則可以王矣？</p>
<p>④何由知吾可也？</p>
<p>⑤甚矣，烏紗之橫，皂隸之俗哉！</p>
<p>⑥欲祠韋蘇州、白樂天諸公於其中</p>
<p>⑦故凡為愚者，莫我若也。</p>
<p>⑧凡人不能教子女者，亦非欲陷其罪惡。</p>
]]></content>
      <tags>
        <tag>汉化</tag>
      </tags>
  </entry>
  <entry>
    <title>汉化：中文敬语</title>
    <url>/2024/08/06/%E6%B1%89%E5%8C%96%EF%BC%9A%E4%B8%AD%E6%96%87%E6%95%AC%E8%AF%AD/</url>
    <content><![CDATA[<h2 id="中国古代常用敬词："><a href="#中国古代常用敬词：" class="headerlink" title="中国古代常用敬词："></a><strong>中国古代常用敬词：</strong></h2><h2 id="1、“拜”字族："><a href="#1、“拜”字族：" class="headerlink" title="1、“拜”字族："></a>1、“拜”字族：</h2><p>　　拜读：读对方作品；拜会：和对方见面；拜望：看望或探望对方；拜托：请对方帮忙；拜读：读对方作品。</p>
<h2 id="2、“奉”字族："><a href="#2、“奉”字族：" class="headerlink" title="2、“奉”字族："></a>2、“奉”字族：</h2><p>　　奉告：告诉对方；奉还：对方的物品归还；奉送：赠送对方礼物。</p>
<h2 id="3、“高”字族："><a href="#3、“高”字族：" class="headerlink" title="3、“高”字族："></a>3、“高”字族：</h2><p>　　高就：询问对方在哪里工作；高龄、高寿：指老人家年龄；高见：指对方的见解；高攀：和他人交朋友或结成亲戚；高堂：称对方父母。</p>
<p>　　高足：称对方的学生或徒弟；</p>
<h2 id="4、“贵”字族："><a href="#4、“贵”字族：" class="headerlink" title="4、“贵”字族："></a>4、“贵”字族：</h2><p>　　贵姓：询问对方的姓；贵庚：敬辞，问人年龄；贵恙：敬辞，称对方的病。</p>
<h2 id="5、“惠”字族："><a href="#5、“惠”字族：" class="headerlink" title="5、“惠”字族："></a>5、“惠”字族：</h2><p>　　惠赠：指对方赠予（财物）；惠存：多用于送对方相片、书籍等纪念品；惠顾：商家称顾客到来；惠临：敬辞，指对方到自己这里来；惠赠：敬辞，指对方赠予（财物）；惠允：敬辞，指对方允许自己做某事。</p>
<h2 id="6、“令”字族："><a href="#6、“令”字族：" class="headerlink" title="6、“令”字族："></a>6、“令”字族：</h2><p>　　令尊：尊称对方的父亲；令堂：敬辞，称对方的母亲；令爱（媛）：敬辞，称对方的女儿；令郎：敬辞，称对方的儿儿子；令亲：敬辞，称对方的亲戚。</p>
<h2 id="7、“宝”字族："><a href="#7、“宝”字族：" class="headerlink" title="7、“宝”字族："></a>7、“宝”字族：</h2><p>　　宝号：称对方的店铺；宝眷：称对方的家眷。</p>
<h2 id="8、“呈”字族："><a href="#8、“呈”字族：" class="headerlink" title="8、“呈”字族："></a>8、“呈”字族：</h2><p>　　呈正：指把自己的作品送交别人批评指正。呈报：指用公文向上级报告；呈请：指用公文向上级请示。</p>
<h2 id="9、“垂”字族："><a href="#9、“垂”字族：" class="headerlink" title="9、“垂”字族："></a>9、“垂”字族：</h2><p>　　垂询：称对方（多指顾客）对本企业事务的询问；垂问：敬辞，表示别人（多指长辈或上级）对自己的询问。垂爱：（书）敬辞，称对方（多指长辈或上级）对自己的爱护（多用于书信）。</p>
<h2 id="10、“光”字族："><a href="#10、“光”字族：" class="headerlink" title="10、“光”字族："></a>10、“光”字族：</h2><p>　　光临：称对方到来；光顾：商家多用以欢迎顾客。</p>
<h2 id="11、其它敬词："><a href="#11、其它敬词：" class="headerlink" title="11、其它敬词："></a>11、其它敬词：</h2><p>　　壁还：用于归还对方物品；俯就：请对方同意担任某一职务；斧正：请对方修改文章；恭候：用于等待对方；借问：用于向别人打听事情；雅正：把自己的书画等送人时表示请对方指教；鼎力：用于向对方表示感谢；华诞：称对方的生日；海涵：称对方写的字或画的画。</p>
<p><strong>中国古代常用谦词：</strong></p>
<h2 id="1、“家”字族："><a href="#1、“家”字族：" class="headerlink" title="1、“家”字族："></a>1、“家”字族：</h2><p>  用于对别人称比自己辈分高或年纪大的亲属。</p>
<p>　　家父、家严：谦辞，对别人称自己的父亲；家慈：称自己的母亲；家兄：称自己的兄长。</p>
<h2 id="2、“舍”字族："><a href="#2、“舍”字族：" class="headerlink" title="2、“舍”字族："></a>2、“舍”字族：</h2><p>　　用于对别人称比自己辈分低或年龄小的亲属。</p>
<p>　　舍侄：称自己的侄子；舍弟：称自己的弟弟；舍亲：称自己的亲人；舍间：谦称自己的家，也称“舍下”。</p>
<h2 id="3、“鄙”字族："><a href="#3、“鄙”字族：" class="headerlink" title="3、“鄙”字族："></a>3、“鄙”字族：</h2><p>　　鄙人：谦称自己；鄙意：自己的意见；鄙见：自己的见解。</p>
<h2 id="4、“愚”字族"><a href="#4、“愚”字族" class="headerlink" title="4、“愚”字族"></a>4、“愚”字族</h2><p>　　愚兄：向比自己年轻的人称自己；愚见：自己的见解。</p>
<h2 id="5、“敝”字族："><a href="#5、“敝”字族：" class="headerlink" title="5、“敝”字族："></a>5、“敝”字族：</h2><p>　　敝人：谦称自己；敝姓：谦称自己的姓；敝校：谦称自己的学校。</p>
<h2 id="6、“拙”字族："><a href="#6、“拙”字族：" class="headerlink" title="6、“拙”字族："></a>6、“拙”字族：</h2><p>　　拙笔：谦称自己的父亲或书画；拙著、拙作：谦称自己的文章；拙见：谦称自己的见解。</p>
<h2 id="7、“小”字族："><a href="#7、“小”字族：" class="headerlink" title="7、“小”字族："></a>7、“小”字族：</h2><p>　　小人：地位低的人自称；小店：谦称自己的商店。</p>
<h2 id="8、“敢”字族："><a href="#8、“敢”字族：" class="headerlink" title="8、“敢”字族："></a>8、“敢”字族：</h2><p>　　表示冒昧地请示别人：敢问：用于向对方询问问题；敢请：用于请求对方做某事；敢烦：用于麻烦对方做某事。</p>
<h2 id="9、“家”字族："><a href="#9、“家”字族：" class="headerlink" title="9、“家”字族："></a>9、“家”字族：</h2><p>　　家父：谦辞，对别人称自己的父亲；家母：谦辞，对别人称自己的母亲。</p>
<h2 id="10、“见”字族："><a href="#10、“见”字族：" class="headerlink" title="10、“见”字族："></a>10、“见”字族：</h2><p>　　见谅：客套话，表示请人谅解；</p>
<p>　　见教：客套话，指教（我），如“有何见教”。</p>
<h3 id="古代的生活雅语："><a href="#古代的生活雅语：" class="headerlink" title="古代的生活雅语："></a><strong>古代的生活雅语：</strong></h3><p>　　请人原谅说“包涵”；求人帮忙说“劳驾”；向人提问说“请教”；</p>
<p>　　得人惠顾说“借光”；归还物品说“奉还”；未及迎接说“失迎”；</p>
<p>　　需要考虑说“斟酌”；请人勿送说“留步”；对方到场说“光临”；</p>
<p>　　接受好意说“领情”；与人相见说“您好”；问人姓氏说“贵姓”；</p>
<p>　　问人住址说“府上”；请改文章说“斧正”；接受好意说“领情”；</p>
<p>　　求人指点说“赐教”；得人帮助说“谢谢”；祝人健康说“保重”；</p>
<p>　　向人祝贺说“恭喜”；老人年龄说“高寿”；身体不适说“欠安”；</p>
<p>　　自己住家说“寒舍”；女士年龄称“芳龄”；称人女儿为“千金”；</p>
<p>　　送礼给人说“笑纳”；送人照片说“惠存”；欢迎购买说“惠顾”；</p>
<p>　　希望照顾说“关照”；请人赴约说“赏光”；对方来信说“惠书”；</p>
<p>　　需要考虑说“斟酌”；无法满足说“抱歉”；请人协助说“费心”；</p>
<p>　　言行不妥“对不起”；慰问他人说“辛苦”；迎接客人说“欢迎”；</p>
<p>　　宾客来到说“光临”；等候别人说“恭候”；麻烦别人说“打扰”；</p>
<p>　　客人入座说“请坐”；陪伴朋友说“奉陪”；临分别时说“再见”；</p>
<p>　　中途先走说“失陪”；请人勿送说“留步”；送人远行说“平安”；</p>
<p>　　请人决定说“钧裁”；接受教益说“领教”；谢人爱意说“错爱”；</p>
<p>　　受人夸奖说“过奖”；交友结亲说“高攀”；祝人健康说“保重”；</p>
<p>　　书信结尾说“敬礼”；问候教师说“教祺”；致意编辑说“编安”。</p>
<p>　　与人相见说“您好”；问人住址说“府上”；初次见面说“久仰”；</p>
<p>　　长期未见说“久违”；求人帮忙说“劳驾”；向人询问说“请问”；</p>
<p>　　请人解答说“请教”；求人办事说“拜托”；称人夫妇为“伉俪”；</p>
<p>　　尊称老师为“恩师”；称人学生人“高足”；平辈年龄问“贵庚”。</p>
<h3 id="“别”之雅语"><a href="#“别”之雅语" class="headerlink" title="“别”之雅语"></a><strong>“别”之雅语</strong></h3><p>　　分手辞别曰“告别”；握手告辞曰“握别”；拱手辞别曰“揖别”；</p>
<p>　　挥手告辞曰“挥别”；亲吻离去曰“吻别”；叩拜辞行曰“拜别”；</p>
<p>　　设宴送行曰“饯别”，致谢告辞曰“谢别”，临别赠礼曰“赠别”；</p>
<p>　　离别留言曰“留别”；前往送行曰“送别”；丢开离去曰“抛别”；</p>
<p>　　不愿分别曰“惜别”、“恋别”；长久分别曰“阔别”、“长别”；</p>
<p>　　永久分别曰“永别”、“诀别”。</p>
<h3 id="“笔”之雅语"><a href="#“笔”之雅语" class="headerlink" title="“笔”之雅语"></a><strong>“笔”之雅语</strong></h3><p>　　开始写作叫“动笔”；提笔撰文和作画叫“命笔”；</p>
<p>　　轻松自如的文字叫“逸笔”；写作过程的中断叫“辍笔”；</p>
<p>　　文章臃肿的文字叫“赘笔”；个人亲自动手写叫“亲笔”；</p>
<p>　　对上写信的谦称叫“谨笔”；本人口授他人写叫“代笔”；</p>
<p>　　对下写信的谦称叫“草笔”；文章韵味风格叫“文笔”；</p>
<p>　　皇帝书写的文字叫“御笔”；读后感写的文字叫“随笔”；</p>
<p>　　与题旨无关的话叫“闲笔”；结束后补充文字的话叫“余笔”；</p>
<p>　　细致的文字绘画叫“工笔”；请人书画的稿酬叫“润笔”；</p>
<p>　　无聊庸俗的文字叫“歪笔”；动手拟订集体名义的文稿叫“执笔”；</p>
<p>　　文章写得好的地方叫“妙笔”；练习性的写作叫“练笔”；</p>
<p>　　愉快地作文或作画叫“欣然命笔”；</p>
<p>　　好的文章或语句叫“成功之笔”；</p>
<p>　　在前段文章中为后段文章埋伏的线索叫“伏笔”。</p>
<h3 id="中国古代其他谦词敬词雅语："><a href="#中国古代其他谦词敬词雅语：" class="headerlink" title="中国古代其他谦词敬词雅语："></a><strong>中国古代其他谦词敬词雅语：</strong></h3><p>　　台甫：敬辞，旧时用于问人的表字大号；台驾：敬辞，旧称对方；</p>
<p>　　台端：敬辞，旧时称对方，（多用于机关、团体等给个人的函件）；</p>
<p>　　台安、台祺、台馁：您安好、吉祥、平安；</p>
<p>　　台鉴：旧时书信套语，用在开头的称呼之后，表示请对方看信；</p>
<p>　　钧谕：书信中称尊长所说的话。还有钧裁、钧安等；</p>
<p>　　玉成：成全。例：深望玉成此事；</p>
<p>　　玉体、玉音：指对方身体或言行；</p>
<p>　　违教：指离开某人后未见面（多用于书信）；</p>
<p>　　雅教：称对方对自己的指教；拜教：恭敬地接受教诲；</p>
<p>　　昆玉：对别人弟兄的敬称；稽迟：拖延、不及时；</p>
<p>　　潭府：尊称他人的宅第。如潭第多福；</p>
<p>　　惠鉴、钧鉴、雅鉴、台鉴、台览：请您审阅、审查、指教；</p>
<p>　　谨悉：恭敬地知道；谨启：恭敬地陈述；</p>
<p>　　兹有：现在有；顷按、顷奉：刚刚接到；奉箴：接到来信；</p>
<p>　　鉴于：考虑到；本拟：本来打算；</p>
<p>　　业示：已经在；迳与：直接地同；赓即：接着立即；</p>
<p>　　不日：不久，不多天；不时：随时；</p>
<p>　　歉难：因不能满足对方的要求而表示歉意；</p>
<p>　　孔殷：十分急切；售罄：卖完；</p>
<p>　　鉴宥：请原谅；不克：不能；</p>
<p>　　瑕疵：微小的弱点；迭函：屡次发信；</p>
<p>　　为荷、是荷：接受你的恩惠（如复函为荷）；</p>
<p>　　寒门：称自己贫寒的家庭；寒舍：谦辞，称自己的家；</p>
<p>　　惠纳、笑纳：接受；卓夺：高明的决断；</p>
<p>　　时祉、近祉：现在幸福、近来蛮不错；</p>
<p>　　商安、教祺：经商、教书安好；</p>
<p>　　卫冕：指竞赛中保住上次获得的冠军称号；</p>
<p>　　借光：客套话，用于请别人给自己方便或向人询问；</p>
<p>　　借重：指借用其他人的力量，多用做敬辞；</p>
<p>　　金婚：欧洲风俗称结婚五十周年；</p>
<p>　　金兰：可用做结拜为兄弟姐妹的代称，如“义结金兰”；</p>
<p>　　问鼎：指谋图夺取政权（中性词）；</p>
<p>　　劳步：敬辞，用于谢别人来访；</p>
<p>　　蒙尘：（书）蒙受灰尘，（指君主因战乱逃亡大外）；</p>
<p>　　名讳：旧时指尊长或所尊敬的人的名字；</p>
<p>　　内眷：指女眷；内人：对别人称自己的妻子；</p>
<p>　　赏脸：客套话，用于请对方接受自己的要求或赠品；</p>
<p>　　泰山、泰水：岳父、岳母；</p>
<p>　　托福：客套话，依赖别人的富气使自己幸运；</p>
<p>　　当轴：旧时指政府领导者；挡驾：婉辞，谢绝来客访问；</p>
<p>　　丁忧：遭到父母的丧事；</p>
<p>　　鼎力：敬辞，大力（表示请托或感谢时用）；</p>
<p>　　斗胆：形容大胆（多用作谦词）；高堂：（书）指父母；</p>
<p>　　独夫：残暴无道为人民所憎恨的统治者；</p>
<p>　　方家：“大方之家”的简称，多指精通某种学问、艺术的人；</p>
<p>　　父执：父亲的朋友；付梓：把稿件交付刊印；</p>
<p>　　阁下：敬辞，称对方，多用于外交场合；更衣：婉辞，上厕所；</p>
<p>　　股肱：比喻左右辅助得力的人（书）；合卺（jǐn）：成婚；</p>
<p>　　归天、归西：婉辞，人死之称；归省：（书）回家省亲；</p>
<p>　　海涵：敬辞，大度包容（多用于请人特别原谅时）；</p>
<p>　　红案：厨工的分工上指做菜的工作；</p>
<p>　　白案：厨工的分工上指蒸饭之类的工作；</p>
<p>　　候光：敬辞，等候光临；候教：敬辞，等候指教；</p>
<p>　　后学：后进的学者或读书人，多用作谦辞；</p>
<p>　　麾下：将帅的部下，也作敬辞，称将帅；</p>
<p>　　刍荛（chúráo割草打柴的人）之见：称自己浅陋的看法；</p>
<p>　　过奖、过誉：用于自己受到表扬或夸奖；</p>
<p>　　马齿徒增：称自己白白增增长年岁；</p>
<p>　　涂鸦：称自己字写得不好或画画得不好；</p>
<p>　　借重：指借用其他人的力量，多用做敬辞；</p>
<p>　　托福：依赖别人的富气使自己幸运。更衣：婉辞，上厕所；</p>
<p>　　割爱：放弃心爱的东西（婉辞）；</p>
<p>　　割席：指与朋友绝交（典出管宁、华歆）；</p>
<p>　　进见：前去会见，（多指见首长）。晋见：即进见；</p>
<p>　　进言：向人提意见（尊敬或客气的口气），如“向您进一言”；</p>
<p>　　觐见：（书）朝见（君主）；</p>
<p>　　驾临：敬辞，称对方到来；</p>
<p>　　金兰：可用做结拜为兄弟姐妹的代称，如“义结金兰”；</p>
<p>　　问鼎：指谋图夺取政权（中性词）；</p>
<p>　　蒙尘：（书）蒙受灰尘，（指君主因战乱逃亡大外）；</p>
<p>　　名讳：旧时指尊长或所尊敬的人的名字；</p>
<p>　　外舅：（书）岳父。代字：女子尚示定亲，如“代字闺中”；</p>
<p>　　当轴：旧时指政府领导者挡驾：婉辞，谢绝来客访问；</p>
<p>　　独夫：残暴无道为人民所憎恨的统治者；</p>
<p>　　父执：父亲的朋友；付梓：把稿件交付刊印；</p>
<p>　　阁下：敬辞，称对方，多用于外交场合；</p>
<p>　　后裔：已经死去的人的子孙；</p>
<p>　　股肱：比喻左右辅助得力的人（书）；</p>
<p>　　桂冠：光荣的称号。</p>
<h3 id="文言文写作的方式"><a href="#文言文写作的方式" class="headerlink" title="文言文写作的方式"></a>文言文写作的方式</h3><h4 id="用词"><a href="#用词" class="headerlink" title="用词"></a>用词</h4><p>实词</p>
<p>虚词</p>
<p>助词</p>
<h4 id="句式"><a href="#句式" class="headerlink" title="句式"></a>句式</h4><p>倒装句</p>
<p>被动句</p>
<h1 id="信1"><a href="#信1" class="headerlink" title="信1"></a>信1</h1><p>新春の候、時下ますますご健勝のこととお慶び申し上げます。<br>时值新春，敬祝身体健康。<br>先日はわたくしのような者を訪ねてくださり、誠にありがとうございました。ろくなおもてなしも出来ぬまま、あなたのご期待に沿うこと能わず、申し訳なく思っております。<br>先日来访敝人，感激不尽。没有像样的招待，违背了您的期待，真是非常抱歉。<br>ですが、お許しください。わたくしはこの地で静かに過ごしていくのが分相応。もはや形骸ですらありませんが、凶月（きょうげつ）の里を離れるつもりはありません。<br>还请原谅，我正适合于此地安静生活，尽管连形骸已不复存，但我仍不打算离开凶月村。<br>まして新しき都に移るなどと……彼の地に居場所があるとは思えませぬし、求められているとも思えぬのです。<br>您有建议我移居新都等等……但我不觉得除此地以外还存在容身之所，也不觉得会有其他地方需要我。<br>無論、あなたがわたくしを思いやってくださったこと、理解しているつもりです。そのうえでどうかご寛恕くださいますようお願いしたく、こうして筆を執った次第にございます。<br>诚然，我愿意相信您是在为我着想。因此，我执笔于此，恳求得到您的谅解。<br>わたくしどもの汚名を晴らす。そう仰っていましたね。頂いた貴方の著書も、拝読させていただきました。<br>您说过想要雪清我等的污名。您所赠亲笔的著作，我已经拜读过了。<br>少し美文調がすぎるのと、過激な言葉が多いように感じますが、ええなかなか、特に竜胆（りんどう）様のご気性に関する考察は、正鵠（せいこく）を射ていると思います。<br>我觉得文辞有些优雅过头（华丽），激烈的言语也比较多（激进），但优点是有的，特别是关于竜胆大人性情的考察，正中靶心。<br>あの方は、非常に清廉な御人柄でありました。清すぎて魚が棲めぬ……その通りでしょう。高潔をもって鳴る士（さむらい）の頭領たる定めに順じ、息の仕方も忘れているようなところがございました。<br>那位大人是非常清廉的人，水至清则无鱼……正是如此。以高尚、洁净的品性遵循着武家头领的使命，甚至不留有喘息的余地。<br>ゆえに大義の何たるかを常に問い、彼女の水に耐えられぬ者らが生じてしまった。それについてはまったく然り。あの時分、わたくしどもから見ましても、竜胆様は異端でしかなかったのです。理解の及ばぬ御方であると、そう捉えていたことを否定はしません。<br>所以总是在质问大义为何，以至于有人忍受不了她这一池的水。其实可以理解（完全是这样的），在那时的我们看来，竜胆大人也不过只是异端，无法理解的人，这一点无法否认。<br>しかし、いえ、だからこそと言うべきでしょうか。<br>@0但是，也许正因为如此。<br>わたくしや兄様（あにさま）、そして覇吐（はばき）様は、芯から竜胆様を敬愛しておりました。無論、宗次郎（そうじろう）様、夜行（やこう）様、龍水（りゅうすい）様、紫織（しおり）様、皆同じであったと思います。<br>我与兄长大人，霸吐大人，都从心底敬爱着竜胆大人。当然，宗次郎大人，夜行大人，龍水大人，紫织大人，我想也是一样的。<br>それをもって烈士、英傑とあなたは称え、逆賊、奸賊と世人は言う。ですがその真実がどうであれ、すでに歴史上の人物と化してしまった今ではもう、どうでもいいのでございます。<br>因此他们被您称为烈士、英杰，而被世人称为逆贼、奸贼。但无论真相如何，对如今已化为历史人物的他们而言，已经无所谓了。<br>賢しらなことを言ってごめんなさい。あなたの志を軽く見ているわけではありません。この国の未来を背負う若者たちに、正しき過去を学ばせたい。誠、高邁（こうまい）な理想であると存じます。<br>抱歉，说了如同智者@一般的话。我绝没有小看您志向的意思。想让背负着这个国家未来的年轻人了解真正的历史。我深知这是高远的理想。<br>ですが、どうでしょう。あなたの生徒さんたちは、明日の食事に困るほど飢えているでしょうか？この寒空の下、粗末な着物一つで凍えているでしょうか？二親どころか家すらなく、孤独に震えているでしょうか？<br>但这是好是坏呢。您的学生们，有饥饿到为明天的食物困扰吗？有在这片寒冬中，只身穿一件布衣而冻僵吗？还是没有父母，没有家人，孤独地@颤抖着吗？<br>いいえ、そんなことはないでしょう。生まれや血筋の良し悪しで、差別などされていないと聞いています。そうした国になったのだと、他ならぬあなたが仰ったことなのですから。<br>应该没有吧，我听说已不再有人会因为出生血统的优劣而遭受歧视。如今已经成为了这样的国家，这不是别人，正是您告诉我的。<br>それで、わたくしは満足です。この凶月咲耶（きょうげつさくや）、娘の時分に願った夢が叶えられたと知りました。<br>这足以让我满足了。凶月咲耶，已经实现了处子之时祈望的梦想。<br>言ってしまえば、わたくしどもはもう救われているのです。竜胆様に率いられ、あの東征に参加したのは偏に稚拙な恋心……その一心でございました。<br>换言之，我等已经得到了救赎。被竜胆大人率领，参加那场东征纯粹是因为稚拙的爱慕之情……唯此恋心@一颗而已。<br>名利を求めたということも否定はしません。ですがそれは、生きるため。歪み者として生まれた己が、せめて人並みの幸せを得るために必要なことだと信じたからです。ええ、特に兄様はそうでした。この咲耶を愛してくださり……<br>不否定其中有追求名利的意图。但那是为了活着。我相信这是对于生而身负扭曲的我们，为了得到与常人一样的幸福而必要的信念。是的，特別是对兄长大人而言。深爱着咲耶……<br>いえ、やめましょう。老女の惚気など見苦しいだけですね。<br>还是算了吧，老女人的滥情只会让人觉得难看。<br>ともかくわたくしが言いたいのは、昔日の我々が求めた世が、今こうしてあるということ。現在を生きているあなたからすれば不満もあるのでしょうけれど、それは今の世代が解決すべき問題です。年寄りを担ぎ上げるものではありません。<br>我想说的是。我们往日所追求的世界，已然成为了现实。对于活在当下的您而言，可能仍有不满之处吧。但那是当今世代该解決的问题，不该再由老人肩负。<br>ただ、こうも思います。あの輝ける日々、色褪せない情景、わたくしにとって何よりも大切な、黄金の記憶……<br>只是，我是这么想的。那些闪耀着的日子，永不褪色的光景。对我而言，都是无比重要的，黄金色的记忆……<br>それが凄烈で、凄惨で、目を背けるような悲劇を内包していたことも踏まえたうえで、やはり振り返ってみれば美しいと……楽しく、幸せで、夢のようなものであったと、わたくしは思うのでございます。<br>那些壮烈、凄惨，让人想要掩目而过的悲剧@。如今回顾起来，却是非常美丽……快乐、幸福、如同梦幻一般。<br>ゆえによろしければ、優しいあなた。遠く離れた世代の友人。この咲耶が語る夢の話に、お付き合いいただけないものでしょうか。<br>如果可以的话，温柔的您啊。身处远方的忘年之友。可否奉陪一下咲耶的天方夜潭？<br>我が意を得たりと、ほくそ笑んではいけませんよ。こんなことは、今の世の誰一人として信じられぬ話でしょうから。<br>可别因为是正如您意，就傻笑出来哦。毕竟这是如今世界的人不会相信的故事。<br>ええ、おそらくはあなたさえ、悪質な空言であると眉を顰めることでしょう。それくらい、正史からは外れている幻想の類。逸史に彩られた、これは化外（けがい）の物語。<br>就算是您也会觉得是性质恶劣的玩笑，而皱紧眉头吧。就是如此偏离正史的，如幻想般的，被逸史点缀@的化外的故事。<br>伝奇小説の題材としては、それ相応に優秀でしょうね。あなたにそうした才があるなら、本にしてみるのもよいでしょう。そのときは楽しく拝読させていただきます。<br>以传奇小说类而言，应该相当优秀吧。如果您有意的话就写成书吧，届时我会乐意拜读的。<br>では、よいでしょうか？長くなりましたが、これからさらに長大な文（ふみ）となります。<br>那么，可以开始了吗？虽然会变得比较冗长，但接下来的文章会更长。<br>この手の技能は夜行様が飛び抜けていらっしゃいましたが、わたくしも話が長いことに関しては兄様をよく閉口させていた身です。あなたが途中で匙を投げないことだろうかと、そんな心配を禁じ得ません。<br>这种长篇大论是夜行大人最擅长的，而我的多言，也是令兄长厌烦不已的。我不禁担心，您会不会在中途弃读。<br>紫織様や竜胆様なら、おそらく数行で纏めるでしょう。龍水様は愚痴の多い方でしたから、すぐに取り留めがなくなるかしら？宗次郎様はどうでしょう？覇吐様なら総てを笑い話になさるでしょうね。<br>紫织大人和竜胆大人的话，应该能于几行内总结出来吧。龍水大人是爱抱怨的人，应该会立刻度废话连篇吧。宗次郎大人会如何呢，霸吐大人大概会把一切都讲成笑话吧。<br>ああ本当に、なんと愛しく誇らしい、わたくしの同志たちであったでしょう。惚気はしないと言った傍からこのような……どうかお許しください。今、咲耶の心は娘の時分に立ち返りつつあるのです。<br>啊啊，何等令人怜爱，自豪，我昔日的同志们啊。明明刚说了不要滥情，立刻又这样了……还请原谅。现在，咲耶的心又回到了处子的时候。<br>そう、筆を止めれば聴こえてくる、深々と積もる雪の音。それに既知感を覚えるのです。<br>是的，一停下笔就能听见。厚雪不断堆积的声音，让我产生了一种既知感。<br>ええ、既知感。当時のわたくしはそんなものを知らなかったし、正しく言えば概念自体この世に存在しなかったのです。<br>没错，既知感，当时的我并不知道这种概念，准确来讲，<em>这个概念本身就不存在于世间</em>。<br>面食らっておられるかしら？意味が分からぬと首を捻っていることでしょう。ですがこの程度で違和を覚えているようですと、これから先に付き合っていくのは辛いでしょうね。<br>感到一头雾水了吗？因不明所以而歪头@了吧。但只是这种程度就感到不适了的话，可是没法继续读下去的。<br>たとえば輪廻、たとえば修羅道、そして悲想天、八大地獄……人の行き着く先、魂の結末。どれもあなたからすれば死後という概念に当て嵌る一例として、真偽はともかく常識の範疇であるはず。<br>比如轮回，比如修罗道，以及悲想天，八大地狱……人的归宿，灵魂的终末。在你看来，无论哪个都是死后的这一概念的例证，不说真假，全都应该在常识的范畴。<br>ですがわたくしどもが生きたとき、それらは根こそぎ何処にも存在しませんでした。<br>但是，在我们的时代，是不存在这些的。<br>想像してみるとよいでしょう。罰も救いも再起も何も、一切存在しない無道の世を。法（かみ）がいないということを。<br>试着想象一下吧，没有惩罚，没有救赎，没有重来，一切都不存在的无道之世，没有[法则]（神明）。<br>死はただ、暗黒。無明であり、ゆえに信心というものが生まれない。畏れというものが何処にもない。<br>死亡唯有黒暗。无明，也自然不会诞生信仰。畏惧@也不复存在。<br>人たるものが本来持ちえる、潜在的な敬虔さ。高みの何者かに見られているかもしれないから、行動に制限をかけるという枷が無いこと。<br>人本应具备的，潜意识下的敬畏、虔诚。因为也许被高位的存在所注视着，而行动有所限制。这种枷锁一旦消失的话……<br>自分を律するものは自分でしかないということ。<br>能约束自己的也唯有自己。<br>平たく言えば、誰もが神を僭称していたと表現すればよいでしょうか。このわたくしも例外ではなく、凶月咲耶の宇宙のみを絶対の法として生きていました。それがどれだけ危険なことか、あなたならお分かりでしょう。<br>简言之，我们可以说所有人都自诩为神，我也不例外，以凶月咲耶这个宇宙的绝对法则而活着。你应该明白这是多么危险的事吧。<br>自己愛性人格障害……昨今ではそういう名で呼ばれる病理だそうで。あなたが著書の中で我々をそう分析していらしたこと、素直に感銘を受けています。当時は、それがごく当たり前な人の在り方だったのですから。<br>自恋性人格障碍……现在似乎用这个名字来称呼这种病，您在著作中也如此分析了我们。我由衷地感谢您（铭感）为在那时，人的生活方式莫过于此。<br>夜行様曰く、天狗道。これはそうした世を生きたわたくしどもの物語。<br>夜行大人有言，名为天狗道。这是我等生活于此世的故事。<br>あの意地悪く、洒落者で、純粋だけれど酷く濁った陰陽師殿……我々の中でもっとも天狗の世に適応して見えた彼は、こう仰っていました。<br>那个爱捉弄人，洒脱@、纯粹却又极度浑浊的阴阳师殿下……乍看之下在我们之中最适合天狗之世的他，曾这样说过。<br>神など不要。<br>不需要神。<br>そして竜胆様は、こう仰っていました。<br>然后，竜胆大人这么说了。<br>人には神が必要だ。<br>人需要神。<br>紫織様と宗次郎様は言ったものです。<br>紫织大人和宗次郎大人则是这样说的。<br>もう適当な奴が神になれ。<br>谁@来当神都行。<br>おかしいでしょう？これについては意見が本当にばらばらで、龍水様など最後まで議論に加わらなかったくらいです。<br>很可笑吧？意见四分五裂，甚至龍水大人直到最后都没有参加讨论。<br>ただどんな結論になろうとも、それに付き合ってやると言わんばかりの態度は、まあその、わたくしの目から見ても愛らしくありましたが……<br>那种无论结论如何，自己都会奉陪的态度，该怎么说呢，在我看来，是非常可爱……<br>覇吐様と兄様が、どんな意見であったかはまだ伏せておきます。そしてもちろん、わたくしも。<br>霸吐大人和兄长大人的意见暂且埋个伏笔。当然，我也一样。<br>この文を読み終えたとき、あなたがどのような感想を持ったか、よければお聞かせ願いたく。これより逸史を紐解いていきたいと思います。<br>当您读完这句话时，您有产生什么感想吗？如果您愿意的话，还请告诉我。接下来，我要解开逸史上的绳系。<br>そう、あれは、新春の候。今と同じく、雪の降る秀真の都が始まりでした。<br>没错，那是，新春之时，和现在一样，在雪花飘落着的秀真之都，一切开始了。<br>我々の出逢い。我々の定め。思えばあの瞬間に、総ては決まっていたのかもしれません。<br>现在回首，也许我们的相遇，我们的命运，在那一瞬间已经定下了。<br>春が来れば、この雪も消え去るように。<br>正如春阳消瑞雪一般。@<br>狂い咲く、刹那の徒花が散りゆくように……<br>正如狂放盛开，刹那凋零的徒花一般……</p>
<h1 id="信2"><a href="#信2" class="headerlink" title="信2"></a>信2</h1><p>こうしてわたくしたちの東征は、圧倒的な大敗というかたちでその緒戦を終えました。<br>就这样，我们的东征初战以压倒性的大败告终。<br>さあ、どうでございましょう。すでにあなたは、困惑しておられるのではないでしょう。<br>觉得如何？想必您已感到困惑了吧。<br>自分が知らされている歴史と違う。穢土不和之関。いえ、今風に言うなら関ヶ原でしょうか。そこで交戦の記録などなかったはずだと。<br>与您所知道的历史不符，在秽士的不和之关，不，现在该称之为关原吧，那里并没有留下任何交战记录。<br>いやそれ以前に、化外の描写がまりにも荒唐無稽で、たちの悪い冗談としか思えない。そう考えておられることと存じます。<br>在此之前，对化外的描都写过于荒谬，只能让人以为是性质恶劣的玩笑，我知道您也是这么想的。<br>あなた方の認識では、化外すなわち異民族。朝（ちょう）に臣従していない穢土の原住民というものでしかなく、夷（えびす）と言ったところで結局は人。このような超常の魔物然とした存在など、現実的に有り得ない。馬鹿げていると思うはずです。<br>在你们的认知中，化外即为异族。只是不归化的秽土土著，尽管被鄙为蛮夷，但终究还是人。而在故事中这种超越常理的魔物在现实中必不可能存在，只会让人觉得是戏弄之言。<br>歪みという概念も、穢土との混血児をさした蔑称にすぎないと。。。今ではそのように解釈されていますからね。早々からついていけないと呆れられても、仕方がないと思っております。<br>扭曲者这一概念也不过是对秽土混血儿的蔑称……现在的认知就是这样的。您觉得跟不上节奏，陷入无奈，也是没办法的事。<br>ええ、実際に、あなた方の認識も間違ってはおりません。当時のわたくしたちよりも、あるいは正答に近いとさえ言えるでしょう。<br>其实，你们的认知并没有错。甚至可以说比当时的我们更接近真相。<br>しかしその上で断言します。これは総て真実であり、わたくしにあなたをからかう意図などまったくないと。<br>但我敢在此之上断言，这些全都是真实的，其中绝无一丝一毫捉弄您的意思。<br>まあ、信じるのは難しい話でしょうし、それを強要するつもりもありませんが、この緒戦における大敗が歴史から抹消されているという件については、幾らか理解も及ぶでしょう。<br>嘛，应该很难相信吧。我也不打算强行让您认可，但是关于这次惨遭大败的初战在历史上被抹消一事，您或许有所理解了吧。<br>早い話、外聞が悪いということですね。はためく皇旗のもと、陛下の神兵たる東征軍は破竹の勢いで進軍した。ということにしておきたい政治。あからさまに言えば見栄と申しましょうか。少なからず、史書にはそういう面があるということ。常識のはずです。<br>简而言之就是面子。在高扬的皇旗之下，陛下的神兵东征军以破竹之势胜利进军……政治上必须得如此。直白地说，可以称之为虚荣作祟吗，不少的史书都有这样一面，也是常识。<br>実際、竜胆様は歴史に名を残そうなどと考えていたわけではないでしょうから。。。最初に申しました通り、今現在のわたくしどもがどのように評価されているかは、どうでもいいのでございます。<br>事实上，竜胆大人应该没有想过在史书上留名这样的事吧……正如我在开始所说的，事到如今，无论我们被予以什么样的评价，都已无所谓了。<br>しかしこうして振り返ってみるに、あのときの大敗で亡くなった方々を史上から消すというのは、竜胆様のお好みではないとも思いました。<br>但如今回首，将那次大败中的牺牲的烈士从历史上抹消一事，想必竜胆大人绝不会认可吧。<br>そしてもちろん、このわたくしも、生涯初の禍憑きで引き起こされた惨劇を忘れたことなどありませんし、今も重く受け止めています。<br>无论，我也一样，从未忘记今生第一次引发灾凭所造成的惨剧。现在也觉得非常沉重。<br>そうした意味で、あなたには知ってほしい。そのよう願うのは、図々しいことでしょうか。<br>这种意义上，我希望您能知道。这种请求能被算作是厚脸皮吗？<br>我々のことはどうでもいい。ですがあそこで斃れた方々を、初めから居なかったようには思わないでほしい。他の何を信じていただかなくても構いませんが、それだけは、どうか切に願います。<br>我们的事情已经无所谓了，但是我不想让那些阵亡的烈士被认为一开始就不曾存在过。即使不相信其他事也好，但这一点请您务必相信。<br>それくらい、あれは凄惨な出来事で、現実にわたくしたちは壊滅しました。<br>就是如此惨烈，现实意义上我们也遭到了毁灭。<br>総員死傷。一万名からなる東征の第一陣で無傷な者など一人もおらず、死者は九割を超えました。事実上の全滅と、そう言って何ら問題はないでしょう。<br>全员的死伤，一万东征军初阵中无人无伤，战死者超过九成。说是事实上全灭也没有问题。<br>我々も、当然無事ではすみませんでした。しかしあなたが、もしもここまでの話を信じていらっしゃるのなら、逆に解せぬとお思いかもしれません。<br>当然我们也不可能幸免。但如果您能相信这些事的话，反而会感到困惑不解吧。<br>では、どうしておまえは生きていると。それほどの敵に蹂躙されて、なぜその程度で済んでいると。<br>所以，为什么我还活着，受到如此敌人的蹂躏，为何只有这些。<br>ええ、まさしく然り。当時のわたくしたちにしましても、それが最大の謎でした。<br>嗯，确实如此。在当时的我们看来，这也是最大的谜团。<br>両腕を失った紫織様。猛毒に冒された宗次郎様。光を失った夜行様。原形を保てなくなった爾子様に丁禮様。<br>紫织大人失去了双臂，宗次郎大人遭到剧毒侵蚀，夜行大人失去了光明，还有无法维持原形的尔子和丁礼大人……<br>兄様は禍憑きの力そのものを失いましたし、わたくしも精神の均衡を崩しました。それぞれ最大の武器を奪われたも同然でしたが、しかし生きている。死んではいない<br>兄长大人失去了灾凭之力，我的精神也崩溃了。各自被剥夺了最强的武器，但仍然活着，并没有死。<br>その事実に、誰よりも首を傾げていたのは他ならぬわたくしたち自信です。最前線で天魔と戦い、完膚なきまでに打ちのめされて、命を拾うなど有り得ない。<br>对这个事实感到大惑不解的人，不是别人，正是我们自己。在最前线与天魔战斗，被打得体无完肤，不可能活命。<br>それほどまでにあれは絶望的なものでしたし、そもそも彼らがなぜ退いたのかも分からない。<br>当时就是如此绝望，甚至也不知道他们为什么会撤退。<br>生き残りに気付かなかった？大方を潰したので満足した？いいえ、絶対にない話です。あれはそのように甘い存在ではありません。<br>是因为没有注意到幸存者吗？还是仅仅击溃了大部分就满足了？绝无此事，他们不会天真如此。<br>では誰かが撃退したのかと言われれば、それこそ一番有り得ない。ええ、本当に謎だったのです。少なくともあのときは。<br>那么，是有其他人击退了他们吗？这正是最不可能的。嗯，真是个谜团啊，至少当时是……<br>それについての真相はいずれ明らかになりますが、今はまだ伏せましょう。単に死ななかったというだけの我々よりも、さらに奇怪なことがありましたから。<br>关于此事的真相早晚会水落石出，暂且个伏笔吧。比起仅是没有死掉的我们，有着更为离奇的事。<br>竜胆様と覇吐様は、このとき間違いなく死んでたのです。なにの比喩でもなく、そのままの意味で、御二方は亡くなられました。<br>竜胆大人和霸吐大人，那个时候绝对是死了的，不是比喻，而是真正意义上的死亡。<br>ではなぜ？当然の疑問でしょうが、それにつきましてもここで語ることは出来ません。<br>那是为何？抱有此问理所当然。于此相关的事现在也无法吐露。<br>ただこの敗北が、我々にとって決定的な契機となったこと。異常な状態からの再起が、必然としてわたくしたちに変質を求めたこと。<br>只是这次的败北，成为了我们决定性的契机，于窘态之中再度奋起，必然会是相应的质变。<br>東征戦争はまだ終わらない。ゆえに前へ進まなければならない。疑問も不安も押し込めて、先へ先へ、勝利するまで。<br>东征还未结束，于此我们必须前进，咽下疑问与不安，不断前行，直至胜利……<br>当時のわたくしたちがどうだったかを、嘘偽りなく記していきたく思いますので、諸々の謎は棚上げにしたままとさせてください。<br>我想不带谎言地真实记录下当时的真实情况， 还请容我将这些谜团暂且搁置吧。<br>しかし、あなたはもう辟易とされておられるかもしれませんし、読み手の気分を無視したまま駄文を書き連ねる愚は控えたいともいます。<br>或许您已有些吃不消了吧，考虑到读者的心情，我也不想进行多余的废话。<br>ゆえにひとまず、ここで中断としておきましょう。この後も逸史の物語を知るか否かはあなたの判断にお任せします。<br>所以暂且止步于此吧。接下来是否要了解逸史的故事，将取决给您的判断。<br>壊滅した我々のもとへ、東征の本隊を引き連れた中院冷泉様が現れたのは数日後。続きを書くなら、きっとそこからになるでしょうね。<br>跟随在溃败的我们脚步之后，中院冷泉大人率领的东征本队于数日到达……若故事还要继续下去的话，果然得从这里开始。<br>先に申し上げた通り、このときのわたくしは精神の均衡を失っておりましたから、あくまでも伝聞ということになりますが。<br>就如我之前所说，当时的我精神已经崩溃了，至少是之后听人说的。<br>皆様、相当な衝撃を受けておられたと聞いています。わたくしも含めて、あまり格好の良い状態でなかったことは確かですね。<br>据说大家都受到了相当的冲击，包含我在内，当时的状态确实不太好。<br>そうした脆さは、思えば当然のことでしょう。何よりも己を信じ、愛していた我々ですから、自負を砕かれるということは世界の崩壊に等しかったのです。<br>这种脆弱也是理所当然的。正因为我们无比相信自己，爱着自己。自负被打破等同着世界的崩溃。<br>誰（た）がために立たんとするや。どなたも、それが見えなくなっていたのでしょう。ただお一人を除いては。<br>为谁而立……无论是谁都看不清这一点了吧。唯一人除外。<br>竜胆様は本当にお強いの御方、あの方だけは、やはり我々と質が違う。<br>竜胆大人当真是心性强大之人，唯那位大人有着与我们质的不同啊。<br>皆、強くそのように思った日のこと。<br>大家都强烈地感悟到的那一天。<br>この続きを、まだ知りたいと思われるか。そしてその場合、どちら側の話がよろしいか。<br>您还想了解接下来的故事吗？ 在这种情况下，您想知道哪边的故事？<br>わたくしたち女の側と、覇吐様たちの殿御側の。。。このときは、なにやらそのようになっていたらしいのです。どうも少し、気恥ずかしいことですね。<br>是我们女子同胞的故事？还是霸吐大人他们那些男人的故事？在当时事情好像就变成了这个样子，总觉得有点不好意思。<br>おそらく無意識に、お互い顔を合わせたくなかったのでしょう。本当、格好の悪いこと。今思い返すと、微笑ましくさえ感じるほどです。<br>也许是由于彼此下意识地忌讳着见到对方吧。真是难看啊。现在回首，不禁觉得好笑。<br>さあ、それではそういうことで、お返事を待っております。<br>那么就是这样吧，我敬候着您的回信。<br>あなたはいったい、どうされますか？<br>您到底会作何选择呢？</p>
<h1 id="信3"><a href="#信3" class="headerlink" title="信3"></a>信3</h1><p>そして<br>然后<br>わたくしたちの東征は、そのように終わりました。<br>我们的东征，以这样的形式结束了<br>戦の結末だけを見るならば、勝利したのはわたくしたち、穢土を制圧し、化外を斃すという当初の目的は見事果たされ、この神州に新たな世が訪れることは、確かに約束されたのです。<br>以战斗的结果来看的话是我们获胜了。压制秽土讨伐化外这样最初的目的精彩地完成了，神州大地将迎来崭新的世界，确实如承诺一般。<br>ええ、これより世界は変わっていきます。穢土という異物がなくなったことで純化され、本当の理が動き始める。<br>对，世界将就此改变。随着秽土这一异物的消失而得到纯化，正当的理将开始运作了。<br>それを夜明けと言うのは違うでしょう。なぜなら、黄昏の後にくるのは無名の闇。。。事実このときのわたくしたちは、そうした夜の中にいたのです。光を失ったことにより、前に進むことが出来なくなっておりました。<br>若说这是黎明不太合适吧。因为在这片黄昏之后，到来的是无名的黑暗……事实上在这个时候我们就处在这样的长夜之中。失去了光明，难以在这片黑暗中前行。<br>そう、特に覇吐様は誰よりも自己を責めて消沈され、許されるなら抱いてやりたいと、心より思ったほどでございます。<br>是的，特别是霸吐大人比谁都自责而消沉无比，如果能被允许的话真想拥抱他，我发自内心地想着。<br>ですが、そのようなことは出来なかった。わたくしの都合ではなく、覇吐様がそれを望んでなどいなかったから。<br>但这是做不到的。不是考虑到我的情况，而是霸吐大人并不希望这样。<br>あの方を癒せるのは、竜胆様しかいないのだと分かっていたから。<br>我明白能治愈那位大人的唯有竜胆大人一人。<br>我々の将、東征を率いた気高い姫、久雅竜胆はもういない。その事実が皆に重くのしかかり、勝利を祝う気持ちなど持てなかった。<br>我等的主将，率军东征的高贵公主，久雅竜胆已经不在了。这个沉重的事实压垮了我们，连祝胜的心情也全无。<br>わたくしや龍水様はもちろんのこと、あのいつも独立独歩な宗次郎さまや紫織様、夜行様でさえ気抜けしておられたのを覚えています。はい、言うまでもなく兄様も。。。<br>自不用说我和龍水大人，就连一直以来我行我素的宗次郎大人，紫织大人，甚至夜行大人都有些气馁。是的，不用说兄长大人也是如此……<br>どこか弛緩し、覇気を持てず、まるで糸の切れた凧のようにとでも言うべきでしょうか。<br>松懈着，失去了霸气，说是如短线的风筝一般最贴切吧。<br>ああいったものをこそ、敗北感を表現するのだろうと思います。戦に勝利はしたものの、このときのわたくしたちは間違いなく敗兵でした。<br>这样一副败相，可以说是败北感吧。纵然取得了战斗的胜利，但此时的我们却是毫无疑问的败北之兵。<br>胸に誉れの温かみはなく、輝けるものを見出せず、ただ漠然とした不安、恐怖、これから何か恐ろしいことが始まりそうだ。。。<br>胸中没有荣誉加身的激动，眼中亦无丝毫光彩。有的只是模糊的不安感与恐惧。<br>程度の差はあれ、皆がそういったものを背負っていました。なぜなら、あのときいったい何があったかまったく理解できなかったのですから。<br>程度参差，大家都背负着这种心情。毕竟，那时发生的一切我们都没能理解。<br>なぜ竜胆様は逝ったのだろう。その身に何が起こったのだろう。答えは不明。どれだけ考えても分からない。<br>为何竜胆大人逝世了？她身上到底发生了什么？问答不明，不管怎么想都无从得知。<br>強いて言うなら夜行様、あの方だけは推論を立てられていたのかもしれません。帰還のの間に何度か議論もしましたが、そこでの態度を振り返るに、そうだったのではと思います。<br>非要说的话夜行大人，那位大人也许推测出来了什么。在归程途中也讨论过几次，如今回想那时他的态度，原来如此。<br>そしてそれは、夜行様でも明言を避けたということ。いつも謎めいたことを仰る方でしたが、基本的には饒舌な彼が言葉を濁すなど初めてで。。。つまりそこまで事態は重い。<br>而且，就连夜行大人也回避着明言。总是说些神秘的话，向来饶舌的他却头一次地含糊其辞。也就是说，事态已经严重到这种地步了。<br>夢や冗談ではないのだと痛感した我々は、秀真への距離が近づくごとに言葉少なくなっていき、ある種の疎外感覚えるようになっていました。<br>既非梦境也非玩笑，深知如此的我们。随着离秀真愈近愈加缄口无言，像是存在着某种疏离感一般。<br>いいえ、あれは嫌悪感だったのかもしれません。<br>不，也许是厌恶感吧。<br>わたくしたち以外の者は、皆一様に笑い昂ぶり、万歳、万歳、目出度い、目出度いと、それしか言おうとしなかったから。<br>除我们之外的人都放声大笑着，高呼着万岁，可喜可贺，只是这副样子。<br>まるでそう、彼らがカラクリ細工のようで。。。<br>他们就好像是一种机关工艺品一样……<br>竜胆様の死を悼まない、その不条理に疑問を持たなければ怒りもしない。<br>既不为竜胆大人的死哀痛，也不对这不合理的事抱有疑问，也自然没有悲愤。<br>なんでこれは。どういうことだ。この者たちは本当に自分と同じ人間なのか。<br>为什么会这样？到底怎么回事？这些人真的和我们一样同为有血有肉的人类吗？<br>などと。。。ええ、思いましたとも。身が震えるほどに恐怖と嫌悪を感じながら。<br>等等……这样想过。一边感受着令人颤抖的恐惧与厌恶。<br>思えばそれが、この後に繋がる総ての兆候だったのかもしれません。<br>如今想来，这也许就是连接着之后一切的征兆吧。<br>竜胆様がそうであったように。異端と呼ばれた彼女の魅せられていた我々は、彼女のいない空下で異端と成り果てたのでしょう。<br>正如竜胆大人一样。被她的，世人称之为异端的灵魂所吸引的我等，在她不在的这片天空下也被当作了异端。<br>それを後悔はしていません。恥であるとも思いません。ただこのときは悲しかった。なぜ我々しかいないのだと。<br>但我并不后悔，也不觉羞耻。当时有的只是悲愤。为何会如此作想的只有我们？<br>竜胆様に率いられたのは皆同じなのに、なぜあなた達のなかには彼女のの欠片がないのだと。<br>明明都由竜胆大人率领着东征，为何你们的心中不曾有过她的一块残片？<br>それほどまでに、久雅竜胆という存在は軽いのかと。<br>久雅竜胆这个存在对你们来说就这种份量吗？<br>忘れないで。捨てないで。我らの将を当たり前に風化させようとしないでほしい。<br>不要忘记，不要舍弃。不要理所当然地将我们的主将淡忘。<br>なぜあなた達は、自分のことしか考えぬのだ。。。<br>为何你们的眼中只有自己……<br>と、笑ってしまう話です。ほんのついこの間までは、己も彼らと同じものであったくせに。<br>就是这样惹人发笑的事。就在不久之前，明明我们也跟他们一样。<br>自己愛のみで駆動する、意志なき軍勢。黄昏を消した後にひしめき合う無明の群体。。。<br>这些由自爱所驱动着，无意志的士卒。在这片黄昏消逝之后，聚集在一起无明的群体……<br>初めてそれを認識し、初めて恐ろしいと思った日のこと。<br>那是我初次认识到，也是初次感到恐惧的一天。<br>秀真に帰り着いた我々が、その後どのようになっていたか。。。あなたもご存知のことでしょう。そこは概ね、史書の通りでございます。<br>而回到秀真的我们，在那这之后遭遇了什么呢……您应该有所耳闻吧。大致上如史书所记载的一样。<br>そう、あの論功行賞。冬は開けて春となり、出陣の日から丸一年が経過していた卯月の某日。<br>是的，那次论功行赏。冬去春至，时隔出征一年卯月的一天。<br>それぞれ功に見合った冠位を授けると仰った、中院の御当主様。<br>说着要依据各自的功劳授予应得冠位的中院当家主。<br>御所において、皇主陛下を初めとした文武百官そろったその場で、己こそがここの主と言わんばかりの彼の諌める者などは、一人たりともいなかったのです。<br>在皇宫里，以皇主陛下为首的文武百官齐聚的会场上，他把自己视为这里的主人一般，而没有一个人敢于劝谏。<br>あの場の中院冷泉様は、何か名状しがたく鬼気迫った、穢土の天魔たちを遙かに在する禍々しいものであるかのように見えたのです。<br>那个场合的中院冷泉大人，像是被某种难以名状的鬼气凭依，甚至远比秽土的天魔众更为不祥。<br>そしてそれに追従する、この国というものに失望し。。。<br>于是我们对追随在他之后的这个国家失望了。<br>竜胆様の血で濡れた褒賞を、その犠牲がどれだけ重く尊いか理解しない者の手によって渡される。そのようなこと、許容できるはずもなかったから。<br>沾染着竜胆大人鲜血的奖赏，经由不知其牺牲之重，毫无敬意的人之手交付。我们绝不可能容许这样的的行为。<br>ええ、あとは申しましたように史書の通り。。。<br>是的，之后的发展正如之前所说，如史书上所写的一样……<br>これより、逆賊としてのわたくしたちが始まったのです。<br>从这里开始，作为逆贼的我们的故事开始了。</p>
<h1 id="信4"><a href="#信4" class="headerlink" title="信4"></a>信4</h1><p>さあ、どうだったでしょう。これにてわたくしたちの物語、神咒神威神楽は終わりです。<br>那么，您觉得如何呢？至此我们的故事，神咒神威神乐就结束了。<br>疑問な点はお有りでしょうか？信じられないことなら星の数ほどお有りでしょうし、それにつきましてはそちらのご判断に任せすることにしておりますが、単に説明の不備を指摘されたらどうしようかと、少し心配しております。<br>您或许有很多疑问吧？难以置信之事多如繁星，还请将这些都交给您的自主判断吧。虽然有些担心如果被您指责解释不足，到时又该如何谢罪呢。<br>まあ、おおよそ察しはつくのですが。おそらくそれは新世界の法、新たな色は具体的にどのようなものであるかということではないかと思います。<br>嗯，您大抵也猜到了吧。也许那就是新世界的法，抑或新世界的色彩到底又怎样一回事呢。<br>ですが、そのことについて、黙秘というわけにはいかないでしょうか。これは単なるわたくしの怠慢ではなく、相応に熟慮したうえでの考えなのです。<br>但是关于这点，还请容许我保密吧。并非是因为怠慢，而是我在深思熟虑后得出的结论。<br>大欲界天狗道。。。波旬は斃され、座が代わった。そしてその理が今を照らしているのですから。今を生きるあなたに知らせて良いものかと思うのです。<br>大欲界天狗道……波旬被打倒，座已然更替。新的理照耀着如今的世界，而让活在当下的您知道此事是否为好呢。<br>あなたがわたくしの話を信じる信じないは別にして、それが座に関わったものの責任でしょう。わたくしどもには、次代の若者たちを見守っていく義務があります。<br>无论您是否相信我的话，那都是和座有牵连之人的责任。我们有着守望下一代年轻人的义务。<br>これは夜刀様。。。いいえ、本当はもっと凛々しいお名前の方のですが、彼が遺してくれた気概と誇りを重んじてのこと。それを受け継いだ者の一人として、美風を絶やしたくはないのです。<br>这正是夜刀大人……不，他的真名其实更为飒爽，所遗留下的气概和荣耀，我们视其为瑰宝。作为继承者之一，我不希望这种风骨断绝。<br>おまえたちはそんなことを知らなくてよいから、ただ日々の刹那を精一杯駆け抜けろ。。。と、あの方は仰るでしょうね。わたくしも同感です。<br>你们没必要知道，尽情度过每日之刹那便好……那位大人应该会这样说吧。我也是同感。<br>それにこれは勘ですが、おそらくあなたの周りにも、似たようなことを仰りそうな方がおられるのではないでしょうか。お心当たりがあるのなら、試しに尋ねてみるのを勧めます。<br>不过这只是我的直觉，也许您的身边也有人会说出类似的话吧。如果您有头绪的话，不妨试着去寻找一下。<br>ええ、きっとわたくしに賛同してくださるだろうと思いますので、それはもう、間違いなく。<br>相信对方肯定也会赞同我的吧，这一点上我已确信无疑。<br>近々、ご友人方の結婚式がお有りだと伺いました。なんでも花嫁は、あなたの再従姉（はとこ）にあたるそうで。きっとその方も、同意見のような気がいたしますよ？<br>听闻您的朋友最近要举办婚礼了，而且新娘还是您的表姐。相信那位大人也会赞同吧。<br>では、もうこのあたりで、これ以上は、年寄の無駄話にしかならぬように思いますから、筆を置かせていただきます。<br>那么，就到此为止吧。继续下去的话也只会是老人的唠叨话，便于此置笔。<br>ああ、しかし、一つ言い忘れておりました。確か冒頭において、わたくしが思う座の有り様というものを、はぐらかしたままでしたね。それを語っていませんでした。<br>啊，不过有点事忘记说了，在开头提到的关于座的形态之事有些含糊不清。<br>そう、あくまでわたくし個人の心情ならば、どんな座が望ましいか。。。<br>是的，至少就我个人来言，希望能有怎么样的座呢……<br>覇と覇の共存は、黄昏の女神以外、絶対に成されない。そして波旬に滅ばされた魂は、やはり絶対に再生できない。<br>除黄昏女神以外，霸道与霸道间的共存是不可能的。而被波旬所毁灭的灵魂也不可能再生。<br>それらの鉄則を踏まえた上で、言わせていただければ唯一つ。<br>在这些铁则的前提下，我能说的唯有一点。<br>座に記憶されている歴代神格たちの理を、一つに纏めて法と成すこと。<br>将记录在座上历代神格之理，统一为一种法则。<br>明星も黄金も水銀も、そして黄昏ももういない。彼らをを蘇らせることは出来ませんが、その治世がどのようなものであったかは再現することができるのです。<br>明星、黄金、水银，还有黄昏都已不复存在了。我们没有方法让他们复生，但可以再现他们的治世。<br>ゆえに各々、人の魂が行き着く先はその人それぞれが選べるように、何を求め、何を感じながら生きたのか。。。もっとも引力を感じる理に自然と魂が引かれるように。<br>因此让每个人灵魂的末路皆由自己选择，无论是追求着什么，抑或感受着什么而活……灵魂被这种自然而然的引力所引导……<br>他者を認める多様性。各々の役割を明確にした住み分けと、変化次第でいかようにも移住が可能という自由性。<br>容纳他者的多样性，明确地各担其责，能根据需求而做出改变的自由性。<br>化外を生まぬ八百万（やおよろず）、他者の法もあってこそ、初めて機能する絆の覇道。。。とでも言うべきでしょうか。わたくしの好みとしては、そのようなものがあればよいと思います。<br>不会造就化外的八百万，正因是接容他者的法则才能构成牵绊之霸道……这样称呼比较合适吧。而于我个人而言这样便好。<br>まるで今の世に、数多の宗教観が存在しているのと同様に。<br>就如当下之世，共存着各种的宗教观一样。<br>随分と長く生きたわたくしも、そろそろお迎えがくるでしょう。そのとき懐かしい仲間たちに、また会えればよいなと思います。<br>已度过漫长光阴岁月的我也将一样迎来自己的终章了吧。但愿届时能够再见怀念已久的同伴们。<br>ずっと、ずっと、先延ばしになったままで、かなりのことお待たせしている約束がありますから。<br>那个一直，一直被拖延至今的约定，已经让大家久等了。<br>では、今度こそお別れです。この凶月咲耶、現実のあなたに出会えてよかった。奥羽では、お世話になりましたね。<br>那么，这次是真的再见了。凶月咲耶，能在现实中遇到您真的是太好了。<br>綾瀬　香純様。<br>绫濑香纯大人。</p>
]]></content>
      <tags>
        <tag>汉化</tag>
      </tags>
  </entry>
  <entry>
    <title>汉化：文言虚词</title>
    <url>/2024/08/06/%E6%B1%89%E5%8C%96%EF%BC%9A%E6%96%87%E8%A8%80%E8%99%9A%E8%AF%8D/</url>
    <content><![CDATA[<p><strong>一、 之</strong></p>
<p>01、作助词用。主要用法有三种类型：</p>
<p>(1)相当于“的”，是定语的标志。</p>
<p>例如：①菊之爱，陱后鲜有闻。③水陆草木之花。</p>
<p>(2)用在主谓之间，取消句子独立性，起舒缓语气作用，无实义。</p>
<p>例如：①予独爱莲之出淤泥而不染。②无丝竹之乱耳，无案牍之劳形。</p>
<p>(3)起补足调音节和舒缓语气作用，无实义。</p>
<p>例如：①公将鼓之。②久之。③怅恨久之。</p>
<p>02、作代词用。（可以代人，代事，代物）</p>
<p>(1)人称代词，相当于现代汉语“我”、“他们”、“她们”、“它”、“它们”。</p>
<p>例如：①具答之。②亲戚畔之。③彼竭我盈，故克之。</p>
<p>(2)指示代词，相当于现代汉语“这”、“这样”“这件事”、“那”、“那样”等。</p>
<p>例如：①渔为甚异之。</p>
<p>(3)作动词用。相当于“到”、“往”、“去”。</p>
<p>例如：①辍耕之垄上。②送杜少府之任蜀州。</p>
<p>03、语法作用。</p>
<p>（1）宾语前置的标志，无实义。例如：①何陋之有？②宋何罪之有？</p>
<p>（2）定语后置标志，无实义。如：①马之千里者。②居庙堂之高则忧其民。</p>
<p><strong>二、 乎</strong></p>
<p>(1)语气词（一般用在句未）</p>
<p>表提问或反问，也可表猜测、感叹。如：</p>
<p>①死国可乎？②王侯将相宁有种乎？③是亦不可以已乎！</p>
<p>(2)介词（一般用在句中）</p>
<p>类似于“于”的用法。如：</p>
<p>①在乎山水之间也②颓然乎其间者</p>
<p><strong>三、 者</strong></p>
<p>1、结构助词</p>
<p>译“……的人”“……的事物”“……的情况”等，相当于名词性短语。如：</p>
<p>①若有作奸犯科及为忠善者，宜付有司论其刑赏。</p>
<p>2、语气助词，</p>
<p>用在作主语的名词或名词性短语之后表示停顿，谓语部分一般用“也”字结尾，起判断作用。如：</p>
<p>①陈胜者，阳城人也，字涉。②北山愚公者，年且九十。</p>
<p><strong>四、以</strong></p>
<p><strong>1、用作介词</strong></p>
<p>表示动作行为所涉及的的工具、物件、时间等可以译为“把”、“用”、“拿”、“在”、“从”等，或表示动作、行为所凭借的条件，译为“靠”、“凭借”、“根据”等。如：</p>
<p>（1）何以战？&#x2F;&#x2F;域民不以封疆之界。——凭借</p>
<p>（2）虽不能察，必以情。&#x2F;&#x2F;策之不以其道。——根据</p>
<p><strong>2、作连词</strong></p>
<p>表目的时，可译作“（用）来”,“以便”； 表顺接时，相当于“而”；表结果时，可译作“以致”；</p>
<p>表原因时，可译作“由于”、“因为”。如：</p>
<p>（1）属予作文以记之——（用）来</p>
<p>（2）以伤先帝之明——以致</p>
<p>（3）不以物喜，不以己悲。——因为</p>
<p>（4）卷石底以出。——相当于“而”</p>
<p><strong>3、用作动词</strong></p>
<p>可译作“认为”。如：</p>
<p>（1）皆以美于徐公。</p>
<p><strong>4、特殊用法：</strong></p>
<p>通假字，通“已”,已经。如：固以怪之矣。</p>
<p><strong>五、而</strong></p>
<p>1表顺接关系的连词</p>
<p>1、并列关系，一般不译，有时可译为“又”。</p>
<p>如：温故而知新，可以为师矣 《（论语）十则》）</p>
<p>2、承接关系</p>
<p>可译作“就”“接着”，或不译。</p>
<p>如：环而攻之而不胜。前一个“而”就表示承接关系。</p>
<p>3、递进关系</p>
<p>译作“而且”“并且”或不译。</p>
<p>如： ①饮少辄醉，而年又最高，故自号曰醉翁也（《醉翁亭记》）</p>
<p>②学而时习之，不亦说乎？</p>
<p>4、修饰关系</p>
<p>可译为“地”“着”，或不译。</p>
<p>如：①河曲智叟笑而止之曰②面山而居。</p>
<p>表转接关系的连词，译作“但是”“可是”“却”。</p>
<p>如：(1)可远观而不可亵玩焉。</p>
<p>(2)人不知而不愠，不亦君子乎？</p>
<p>(3)学而不思则罔</p>
<p><strong>六、其</strong></p>
<p><strong>1、代词</strong></p>
<p>(1)表示第三人称，译作“他”“他的”“他们”“他们的”“它”“它们”“它们的”。</p>
<p>①择其善者而从之，其不善者而改之。</p>
<p>(2)指示代词，可译为“那”“那个”“那些”“那里”；也可表示“其中的”，后面多为数词。</p>
<p>①其人视端容寂，若听茶声然。</p>
<p>②复前行，欲穷其林。</p>
<p>③其一犬坐于前。</p>
<p><strong>2、副词</strong></p>
<p>放在句首或句中，表示测度、反诘、婉商、期望等语气，常和放在句末的语气词配合，视情况可译为“大概”“或许”“恐怕”“一定”“怎么”“难道”等，或省去。</p>
<p>①其真无马耶？可译作：“难道”</p>
<p>②其真不知马也。可译为：大概</p>
<p>③其必曰：“先天下之忧而忧，后天下之乐而乐”乎。其：可译为“恐怕”。</p>
<p>④安陵君其许寡人！其：可译为“一定”。</p>
<p><strong>七、为</strong></p>
<p><strong>1、作介词时</strong></p>
<p>除表被动外都读作wèi，可译作“被”、“对”、“给”、“替”、“当”，“为了”、“因为”等。</p>
<p>如：①舌一吐而二虫尽为所吞&#x2F;&#x2F;山峦为晴雪所洗（wéi，被。）</p>
<p>②不足为外人道也。（wèi“向”“对”）</p>
<p>③为楚造云梯之械。（wèi，“给”）</p>
<p>④为其来也，臣请缚一人过王而行。(wèi，“当”)</p>
<p>⑤问渠哪得清如许，为有源头活水来（《观书有感》wèi，因为，由于）</p>
<p><strong>2、当“为”作动词时</strong></p>
<p>读wéi，可依据语境的不同，译成各种相应的动词，如：“做”，“当作”、“成为”，“雕刻”，“是”等。如：</p>
<p>①中峨冠而多髯者，为东坡。（是）</p>
<p>②温故而知新，可以为师矣。（当，成为）</p>
<p>③为宫室、器皿。（雕刻）</p>
<p>④通计一舟，为人五，为窗八。（有）</p>
<p>⑤橘生淮南则为橘，生淮北则为枳（称为，叫做）</p>
<p>⑥为小门于大门之侧而延晏子（造）</p>
<p><strong>3、特殊用法：</strong></p>
<p>或异二者之为，何哉？（名词，心理活动）</p>
<p><strong>八、于</strong></p>
<p><strong>1、引进动作</strong></p>
<p>时间、处所、范围、对象、方面、原因等，可灵活地译为“在”、“向”、“到”、“从”、“跟”、“对”、“给”等。例如：</p>
<p>①苟全性命于乱世，不求闻达于诸侯。（在）</p>
<p>②未尝不叹息痛恨于桓灵也（对）</p>
<p>③舜发于畎亩之中（从）</p>
<p>④欲报之于陛下也（向）</p>
<p><strong>2、放在形容词之后</strong></p>
<p>表示比较，一般可译为“比”，有时可译为“胜过”。</p>
<p>例如：①人固有一死，或重于太山，或轻于鸿毛</p>
<p>②皆以美于徐公。</p>
<p><strong>九、焉</strong></p>
<p><strong>1、疑问代词</strong></p>
<p>相当于“怎么”“哪里”。如：不入虎穴，焉得虎子（熟语）</p>
<p><strong>2、语气助词</strong></p>
<p>如：寒暑易节，始一反焉（《愚公移山》</p>
<p><strong>3、代词</strong></p>
<p>相当于“之”。如：忽啼求之，父异焉（《伤仲永》）</p>
<p><strong>4、兼词</strong></p>
<p>相当于“于何”“在哪里”。如：且焉置土石（《愚公移山》）</p>
<p><strong>5、兼词</strong></p>
<p>相当于“于此”“在这里”“在那里”。如：夫大国，难测也，惧有伏焉（《曹刿论战》）</p>
<p><strong>十、虽</strong></p>
<p>连词“虽”在文言文中主要有两种用法。</p>
<p><strong>1、表示假设，可译为“即使”。</strong></p>
<p>如：①虽千里弗敢易也，岂止五百里哉（《唐雎不辱使命》）</p>
<p>②虽乘奔御风，不以疾也（《三峡》）</p>
<p><strong>2、表示转折，可译为“虽然”</strong></p>
<p>如：故余虽愚，卒获有所闻（《送东阳马生序》）</p>
<p><strong>十一、然</strong></p>
<p><strong>1、代词，起指示作用，译作“这样”“如此”。</strong></p>
<p>如：父利其然也（《伤仲永》）</p>
<p><strong>2、连词，表转折关系，译作“然而”“但是”等。</strong></p>
<p>如：①然足下卜之鬼乎（《陈涉世家》）</p>
<p>②然侍卫之臣不懈于内《出师表》</p>
<p><strong>3、助词</strong></p>
<p>（1）用在形容词之后，作为词尾，译作“……的样子”。如：</p>
<p>翼然临于泉上、颓然乎其间者&#x2F;&#x2F;　望之蔚然而深秀者</p>
<p>（2）用于句尾，常与“如”“若”连用，构成“如……然”“若……然”格式，相当于“……的样子”“好像……似的”。如：</p>
<p>其人视端容寂，若听茶声然（《核舟记》）</p>
<p><strong>十二、以</strong></p>
<p><strong>1. 用作介词</strong></p>
<p>表示凭借，译为“凭、靠”。例：乃入见。问：“何以战？”（《曹刿论战》）</p>
<p>表示工具、方式、方法，译为“用、拿、把、按照”。策之不以其道。（《马说》）</p>
<p><strong>2. 用作连词</strong></p>
<p>表示并列、承接、修饰，“以”相当于“而”。</p>
<p>例：俯身倾耳以请</p>
<p>表示目的，译为“来、用来”。例：属予作文以记之 （《岳阳楼记》）</p>
<p>表示动作、行为产生的原因，可译为“因”，“因为”，“由于”。</p>
<p>例：不以物喜，不以己悲。（《岳阳楼记》）</p>
<p><strong>3. 用作副词</strong></p>
<p>译为“已”，“已经”。例：固以怪之矣。（《陈涉世家》）</p>
<p><strong>十三：则</strong></p>
<p><strong>1．连词</strong></p>
<p>（1）表示承接关系，可译为“就”。</p>
<p>例：居庙堂之高则忧其民。（《岳阳楼记》）</p>
<p>（2）表示假设关系，可译为“如果”，“那么”。</p>
<p>例：万众则不辩礼义而受之。（《鱼我所欲也》）&#x2F;</p>
<p>诚如是，则霸业可成。（《出师表》）</p>
<p>（3）表示转折关系，可译为“却”。</p>
<p>例：余则蕴袍敝衣处其间。（《送东阳马生序》）</p>
<p><strong>2．表示判断，可译为“就是”。</strong></p>
<p>例：此则岳阳楼之大观也。（《岳阳楼记》）</p>
<p><strong>十四、因</strong></p>
<p><strong>1. 连词，表示顺接上文，可译为“于是”、“就”。</strong></p>
<p>例：安陵君因使唐雎使于秦。（《唐雎不辱使命》）</p>
<p><strong>2. 介词，表示动作、行为发生的原因</strong></p>
<p>依据、方式，可分别译为“由于”、“凭借”、“依靠”。例：高祖因之以成帝业。（《隆中对》）</p>
<p><strong>3. 介词，可译为“根据”、“依照”。</strong></p>
<p>例：罔不因势象形。（《核舟记》）</p>
<p><strong>4. 副词，可译为“因此”。</strong></p>
<p>例：因以为号焉。（《五柳先生传》）</p>
<p><strong>十五、且</strong></p>
<p><strong>1. 副词</strong></p>
<p>（1）用在动词或数词前，表示动作行为将要发生，可译为“将”，“将要”、“将近”。</p>
<p>例：北山愚公者，年且九十。（《愚公移山》）</p>
<p>（2）表示行为的状态，可译为“姑且”、“暂且”。</p>
<p>例：存着且偷生，死者长已矣。（《石壕吏》）</p>
<p><strong>2．连词</strong></p>
<p>（1）表示递进，可译为“况且”。例：且焉置土石？（《愚公移山》）</p>
<p>（2）表示让步，可译为“尚且”、“还”。例：且欲与常马等不可得。（《马说》）</p>
<p>（3）表示并列或递进，可译为“和”、“而且”、“并且”。例：盖余之勤且艰若此。</p>
<p><strong>十六、乃</strong></p>
<p><strong>1．副词</strong></p>
<p>（1）可译为“竟然”。例：乃不知有汉，无论魏晋。（《桃花源记》）</p>
<p>（2）可译为“于是”、“才”、“就”。</p>
<p>例：乃重修岳阳楼。（于是，就）（《岳阳楼记》）</p>
<p><strong>2．判断词，可译为“是”、“就是”。</strong></p>
<p>当立者乃公子扶苏。（《陈涉世家》）</p>
<p><strong>3．第二人称代词，可译为“你”、“你的”。</strong></p>
<p>例：家祭无忘告乃翁。（《示儿》）</p>
<p><strong>十七、矣</strong></p>
<p><strong>1．句末语气词，表示肯定或判断推测语气，</strong>相当于“了”、“啊”。</p>
<p>例： 温故而知新，可以为师矣。（了）（《论语》十则）</p>
<p><strong>2．句末语气词，表示感叹语气，相当于“了”。</strong></p>
<p>例：甚矣，汝之不惠！（了）</p>
<p><strong>3．语气词，表命令或请求，相当于“了”、“啦”</strong></p>
<p>例：登轼而望之，曰：“可矣。”</p>
]]></content>
      <tags>
        <tag>汉化</tag>
      </tags>
  </entry>
  <entry>
    <title>汉化：文言文固定句式</title>
    <url>/2024/08/06/%E6%B1%89%E5%8C%96%EF%BC%9A%E6%96%87%E8%A8%80%E6%96%87%E5%9B%BA%E5%AE%9A%E5%8F%A5%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="無乃……乎？"><a href="#無乃……乎？" class="headerlink" title="無乃……乎？"></a>無乃……乎？</h3><p>這是一種表示測度語氣的固定格式，它表明的是對某種情況的估計或者對某件事情的認識。一般可譯為「恐怕……吧」或者「只怕……吧」。例子是很多的。如：</p>
<p>①勞師以襲遠，非所聞也。師勞力竭，遠主備之，無乃不可乎？（應譯為：使軍隊疲勞去襲擊遠方的國家，沒有聽到過這樣的事。軍隊疲勞力量竭盡，遠方的君主對這件事有準備，恐怕不行吧？）《崤之戰》。</p>
<p>②暮婚而晨別，無乃太匆忙？（應譯為：晚上結婚而早上就得離別，只怕太匆忙了吧？）《新婚別》</p>
<p>教材中有一篇古文叫《季氏將伐顓臾》，其中有一句話，也屬於這種固定格式。「求！無乃爾是過與？」（句中劃線句應譯為：冉求！恐怕該責備的是你們吧？）</p>
<h3 id="……孰與……"><a href="#……孰與……" class="headerlink" title="……孰與……"></a>……孰與……</h3><p>這是一種用來表比較的固定格式，用來比較兩個人的高下、優劣或兩件事的得失、好壞。它又可以分為兩類。一類是句中提出了比較內容的，一類是句中沒有提出比較內容的。前者應翻譯成：「……與……相比，誰（哪一樣）……」，後者應譯為：「……與……比較起來怎麼樣」。這種格式在古文中出現的頻率是非常高的。如下面的例子：</p>
<p>①吾孰與城北徐公美？《鄒忌諷齊王納諫》（我跟城北的徐公相比誰更漂亮？）</p>
<p>②沛公曰：「孰與君少長？」《鴻門宴》（（項伯）跟你相比，誰的年紀大，誰的年紀小？）</p>
<p>③公之視廉將軍孰與秦王？《廉頗藺相如列傳》（你們看廉將軍跟秦王相比，怎麼樣？）</p>
<p>④某業所就，孰與仲多？《原君》（我所完成的功業跟二哥相比，誰更多？）</p>
<p>文中的三個加線句均應譯為「你跟我比怎麼樣呢」。</p>
<h3 id="……之謂也-其……之謂也"><a href="#……之謂也-其……之謂也" class="headerlink" title="……之謂也 其……之謂也"></a>……之謂也 其……之謂也</h3><p>這是賓語提前的一種固定格式，是一種表示總結性的判斷句。應該強調一下的是在這種格式中的「之」屬於結構助詞，起到的是提賓的作用。句首有「其」的也屬於這種格式，而「其」屬於句首語氣助詞，表推測，應譯為「大概」。這種固定格式可譯為「說的就是……啊」，或者譯為「大概說的就是……啊」。請看下面例句：</p>
<p>①聞道百，以為莫己若者，我之謂也。《莊子·秋水》（聽到了一些道理，以為天下沒有誰超過自己了，說的就是我這種人啊！）</p>
<p>②詩曰：「他人有心，予忖度之。」——夫子之謂也。《孟子·齊桓晉文之事》（《詩經》上說：「別人有什麼心思，我猜測得到它。」說的就是夫子這樣的人啊！）</p>
<h3 id="……之謂也-其……之謂也-1"><a href="#……之謂也-其……之謂也-1" class="headerlink" title="……之謂也 其……之謂也"></a>……之謂也 其……之謂也</h3><p>這是賓語提前的一種固定格式，是一種表示總結性的判斷句。應該強調一下的是在這種格式中的「之」屬於結構助詞，起到的是提賓的作用。句首有「其」的也屬於這種格式，而「其」屬於句首語氣助詞，表推測，應譯為「大概」。這種固定格式可譯為「說的就是……啊」，或者譯為「大概說的就是……啊」。請看下面例句：</p>
<p>①聞道百，以為莫己若者，我之謂也。《莊子·秋水》（聽到了一些道理，以為天下沒有誰超過自己了，說的就是我這種人啊！）</p>
<p>②詩曰：「他人有心，予忖度之。」——夫子之謂也。《孟子·齊桓晉文之事》（《詩經》上說：「別人有什麼心思，我猜測得到它。」說的就是夫子這樣的人啊！）</p>
<p>③太史公曰：「傳曰：『其身正，不令則行；其身不正，雖令不從。』其李將軍之謂也。《史記·李將軍列傳》（太史公說：「《論語》上說：『他自身端正，不下達命令人民就會行動；他自身不端正，即使下達命令他的百姓也不會聽從。』大概說的就是李將軍這樣的人吧！」）</p>
<h3 id="得無……乎？-得無……耶？"><a href="#得無……乎？-得無……耶？" class="headerlink" title="得無……乎？ 得無……耶？"></a>得無……乎？ 得無……耶？</h3><p>這是一種表揣測疑問語氣的固定格式，表示對某種情況的推測。應譯為現代漢語的下面三種格式：恐怕……吧； 莫非……吧； 該不會……吧</p>
<p>這種格式在古文中出現的頻率也是相當高的。請看下面的例子：</p>
<p>①覽物之情，得無異乎？《岳陽樓記》（看到自然景物所產生的思想感情，恐怕不一樣吧？）</p>
<p>②得無教我獵蟲所耶？《促織》（莫非告訴我捕捉蟋蟀的地方吧？）</p>
<p>③若輩得無苦貧乎？《記王忠肅公翱事》（你們恐怕被窮困所苦吧？）</p>
<p>④得無楚之水土使民善盜耶？《晏子使楚》（莫非楚國的水土使老百姓善於偷盜吧？）</p>
<p>⑤日飲食得無衰乎？《觸龍說趙太后》（每天的飲食該不會減少吧？）</p>
<h3 id="奈……何-如……何-若……何"><a href="#奈……何-如……何-若……何" class="headerlink" title="奈……何 如……何 若……何"></a>奈……何 如……何 若……何</h3><p>這三個格式的用法是一樣的，都表示怎樣對待或處置某人某事。需要強調的是，「奈」、「如」、「若」是動詞，含有「對付」、「處置」、「辦理」一類的意思；而「何」則是補語，作「怎麼」、「怎樣」講。在中間插入的內容屬於「奈」、「如」、「若」的賓語。整個格式可譯為「把……怎麼樣」，或「對……怎麼辦」。先看下面例句。</p>
<p>①以君之力，曾不能損魁父之丘，如王屋、太行何？（《愚公移山》）</p>
<p>②試問古來幾曾見破鏡能重圓？則較死為苦也，將奈之何？（《與妻書》）</p>
<p>③力拔山兮氣蓋世，時不力兮騅不逝。騅不逝兮可奈何？虞兮虞兮奈若何？（《垓下歌》）</p>
<p>上面的三個例句中加線的句子應分別譯為：</p>
<p>①把太行山和王屋山能怎麼樣呢？</p>
<p>②（我們）對這種情況怎麼辦呢？</p>
<p>③虞姬虞姬把你怎麼樣呢？</p>
<h3 id="何有於……？"><a href="#何有於……？" class="headerlink" title="何有於……？"></a>何有於……？</h3><p>這是一種表反問的固定格式。需要強調的是，這種格式究其實質是兩種特殊句式的緊縮和移位。一是由介詞「於」與它的賓語構成的介賓短語後置，在原句作補語，翻譯過來必須還原到動詞謂語之前充當狀語；一是疑問句中疑問代詞作賓語謂賓前置，也就是說「有」的賓語是疑問代詞「何」，它前置了，在翻譯的時候，也必須還原到「有」的前面。知道了這一點再去理解這種格式就容易得多了。這種固定格式的意思是：「對於……來說，又有什麼……呢？」請看下面的例句。</p>
<p>例句：子曰：「默而識之，學而不厭，誨人不倦，何有於我哉？」（應譯為「對於我來說又有什麼呢？」）</p>
<h3 id="何……為？"><a href="#何……為？" class="headerlink" title="何……為？"></a>何……為？</h3><p>這種固定格式的正確翻譯為：「還要……做什麼？」或者：「要……幹什麼？」請看下面例句：</p>
<p>例句：①如今人方為刀俎，我為魚肉，何辭為？（《史記·項羽本紀》）劃線句應譯為：「還要告辭做什麼呢？」</p>
<p>例句：②項王笑曰：「天之王我，我何渡為？」（《史記·項羽本紀》）劃線句應譯為：「這是上天要滅亡我，我還要渡江做什麼呢？」</p>
<h3 id="不亦……乎？"><a href="#不亦……乎？" class="headerlink" title="不亦……乎？"></a>不亦……乎？</h3><p>這是一種表示反問的固定格式。最需要強調的是這種格式中的「亦」。這是一個很容易產生誤解的詞，稍一疏忽就可能把它理解為副詞，其實，它是一個助詞，沒有實在意義，只有加強語氣的作用。這種固定格式可譯為：「不是……嗎？」或者譯為：「豈不是……嗎？」</p>
<p>在古文中，這種固定格式的出現頻率是很高的。下面的幾個例句：</p>
<p>①舟已行矣，而劍不行，求劍若此，不亦惑乎？（《呂氏春秋·察今》）句中的化線處應譯為：「像這樣尋找劍，豈不是太糊塗了嗎？」</p>
<p>②吾射不亦精乎？（《賣油翁》）句中的劃線處應譯為：「我射箭的本領不是很高明嗎？」</p>
<p>③子曰：「學而時習之，不亦說乎？有朋自遠方來，不亦樂乎？人不知而不慍，不亦君子乎？」（《論語》）句中的劃線處應譯為：「學習並且不時地溫習它，不是很快樂了的嗎？有同學從遠方來，不也是很高興的事嗎？別人不了解自己而不惱怒，不也是君子嗎？」</p>
<h3 id="有……者"><a href="#有……者" class="headerlink" title="有……者"></a>有……者</h3><p>這種固定格式常用於敘事的開頭，以突出敘事的對象。必須強調的是，這種格式還有兩種情況。一是敘述的對象「人」在句首出現了，如「楚人有涉江者」，此刻，「有……者」屬於定語後置；二是敘述的對象在句中沒有出現，不屬於定語後置，如「杭有賣柑者」。請看下面例子：</p>
<p>人有亡斧者。（《韓非子》）在這個句子中，「人」出現了，因此，「有……者」屬於定語後置，應譯為：「有一個丟了斧子的人。」</p>
<p>邑有成名者，操童子業，久不售。（《促織》）在這個句子中，敘述的對象沒有出現，因而不屬於定語後置，應譯為：「城裏有個叫成名的人。」</p>
<h3 id="何……之有？"><a href="#何……之有？" class="headerlink" title="何……之有？"></a>何……之有？</h3><p>這也是一種賓語提前的固定格式。句中的「何……」是「有」的賓語，「之」屬於結構助詞，表示提賓。這種格式可譯為：「有什麼……呢？」如下面的例子：</p>
<p>①宋何罪之有？（《墨子·公輸》）應譯為：「宋國有什麼罪過呢？」</p>
<p>②子曰：「君子居之，何陋之有？」（《論語》）應譯為：「君子住在裏面，有什麼簡陋呢？</p>
<p>③夫晉，何厭（通「饜」）之有？（《左傳·崤之戰》）應譯為：「那晉國有什麼可滿足的呢？」</p>
<p>④若不憂德之不建，而患貨之不足，將吊不暇，何賀之有？」（《叔向賀貧》）應譯為：「如果不憂慮德行沒有完善，卻憂慮財物不足，將要哀悼還來不及，有什麼可祝賀的呢？」</p>
<h3 id="唯（惟）……是……-惟……之為……"><a href="#唯（惟）……是……-惟……之為……" class="headerlink" title="唯（惟）……是…… 惟……之為……"></a>唯（惟）……是…… 惟……之為……</h3><p>這種固定格式也是一種賓語提前的格式。需要再強調一下的是，在這種格式中的「是」與「之為」，均屬於結構助詞，起到的是提賓作用；而唯（惟），表示的則是動作的唯一性，譯為「只」。這種格式在成語中使用的頻率是很高的。請看下面的例句：</p>
<p>① 惟命是從；</p>
<p>② 惟利是圖；</p>
<p>③ 唯你是問；</p>
<p>④ 唯仁是親；</p>
<p>⑤ 唯才是舉；</p>
<p>⑥ 無乃爾是過與？</p>
<h3 id="所以……-所以……者"><a href="#所以……-所以……者" class="headerlink" title="所以…… 所以……者"></a>所以…… 所以……者</h3><p>所＋介詞（以、從、與）＋動詞（或動詞性短語）</p>
<p>這是古文中十分常見的固定格式，是一種名詞性的「所」字短語。首先我們得知道，在古文中的「所以」與現代漢語中的「所以」是完全不同的，現代漢語中的「所以」是一個複音虛詞，用在因果複句的後一分句，表結果，而在古代漢語中，可以說什麼都可以表示，就是不能表示結果。那麼，他都能表示什麼呢？它可以表示動作所涉及到的原因、根據、工具、處所、辦法、憑藉等。下面我們來看一些例子：</p>
<p>①吾所以為此者，以先國家之急而後私仇也。（《廉頗藺相如列傳》）（表原因）</p>
<p>②故釋先王之成法，而法其所以為法者。（《呂氏春秋·察今》）（表根據）</p>
<p>③筆，所以書也。（表工具）</p>
<p>④是吾劍之所從墜。（《呂氏春秋·察今》）（表處所）</p>
<p>⑤吾知所以距（通「拒」）子者，吾不言。（《墨子·公輸》）（表辦法）</p>
<p>⑥師者，所以傳道受業解惑也。（《師說》）（表憑藉）</p>
<p>⑦聖者，非所與熙（通「嬉」）也。（《墨子》·公輸》）（表憑藉。應譯為：「聖人是不能與他隨便開玩笑的。」）</p>
<p>⑧此所以學者不可以不深思而慎取之也。（《游褒禪山記》）(表原因)</p>
<p>⑨天地之所以養人者，原不過此數也。（《治平篇》）（表方法）</p>
<p>⑩臣所以去親戚而事君者，徒慕君之高義。（《史記·廉頗藺相如列傳》）（表原因）</p>
<h3 id="……何所……"><a href="#……何所……" class="headerlink" title="……何所……"></a>……何所……</h3><p>這是一種表疑問的固定格式，是「所……者（為）何」的緊縮和移位。懂得了這一點，也就等於知道了在閱讀古文中遇上了這種固定格式時應該如何翻譯了。請看下面的例子：</p>
<p>①問女何所思？問女何所憶？（《木蘭詩》）</p>
<p>②賣炭得錢何所營？（《賣炭翁》）</p>
<p>③白雪飄飄何所似？</p>
<p>④我有親父母，逼迫兼弟兄。以我應他人，君還何所望？（《孔雀東南飛》）</p>
<h3 id="有所……-無所……"><a href="#有所……-無所……" class="headerlink" title="有所…… 無所……"></a>有所…… 無所……</h3><p>這兩種固定格式在古文中出現的頻率就更高了，可以說比比皆是。需要強調的是，「有」、「無」是動詞，「所……」是名詞性的「所」字短語作它們的賓語。這兩種固定格式的翻譯比較靈活。請看下面的例子。</p>
<p>①財物無所取，婦女無所幸。（《鴻門宴》）可譯為：「對財物沒有取什麼，對婦女沒有寵幸誰」</p>
<p>②吾家後日當甚貧，貧無所苦，清淨過日而已。（《與妻書》）句中劃線的地方，可譯為：「貧困沒有什麼可苦惱的。」</p>
<p>③吾入關，秋毫不敢有所近。（同上）句中劃線處，可譯為：「一絲一毫的財物都不敢接近。」</p>
<h3 id="有以……-無以……"><a href="#有以……-無以……" class="headerlink" title="有以…… 無以……"></a>有以…… 無以……</h3><p>這兩種固定格式與上面講的實際上是一回事，因為「有以」與「無以」是「有（所）以」與「無（所）以」的省寫。「有」、「無」仍是動詞，「（所）以……」是「有」或「無」的賓語。如「軍中無以為樂」，就是「軍中無所以為樂」，但不必機械地譯為「軍中沒有用來作樂的東西」，可改變語法結構譯成「軍中沒有什麼用來作樂的」。「有以……」的譯法類同。如下面的例子：</p>
<p>①故不積跬步，無以至千里；不積小流，無以成江海。（《勸學》）可靈活地譯為「沒有用來達到千里的方法」和「沒有用來匯聚成的江海的方法」。</p>
<p>②臣乃得有以報太子。（《荊軻刺秦王》）可譯為：「我才有用來報答太子的方法。」</p>
<p>還應該強調一下，「有以」常和「未」連用，此時，與「有以」的用法相同。</p>
<p>如：臣未有以報也。（《莊暴見孟子》）</p>
]]></content>
      <tags>
        <tag>汉化</tag>
      </tags>
  </entry>
  <entry>
    <title>汉化：文言实词</title>
    <url>/2024/08/06/%E6%B1%89%E5%8C%96%EF%BC%9A%E6%96%87%E8%A8%80%E5%AE%9E%E8%AF%8D/</url>
    <content><![CDATA[<p><strong>1、爱</strong><br>（1）名词。恩惠。（古之遗爱也《左传》）<br>（2）动词<br>①加惠于人。（吴广素爱人。《陈涉世家》）<br>（此四君者，皆明智而忠信，宽厚而爱人。《过秦论》）<br>②喜爱，爱护。<br>（父母之爱子，则为之计深远。《触龙说赵太后》）<br>（爱其子，择师而教之。《师说》）<br>③吝惜，舍不得。<br>（齐国虽褊小，吾何爱一牛。《齐桓晋文之事》）<br>（不爱珍器重宝肥饶之地。《过秦论》）<br>④怜惜。<br>爱其二毛（怜惜鬓发花白的老人）。（《左传》）<br>国事至此，予不得爱身。（《〈指南录〉后序》）<br>⑤通””，隐蔽，躲藏。<br>爱而不见，搔首踟躇。（《静女》）<br>（3）形容词。吝啬。<br>百姓皆以王为爱也。（《齐桓晋文之事》）</p>
<p><strong>2、安</strong><br>（1）形容词。<br>①舒适，安适。<br>君子食无求饱，居无求安。（《论语•述而》）<br>予出官二年，怡然自安。（《琵琶行》）<br>②安稳。<br>风雨不动安如山。（《茅屋为秋风所破歌》）<br>③安全。<br>谢庄遂安。（《冯婉贞》）<br>④安定。<br>不患寡而患不均，不患贫而患不安。（《季氏将伐颛臾》）<br>（2）动词。<br>①养生。<br>衣食所安，弗敢专也，必以分人。（《曹刿论战》）<br>②安置，安放。<br>离山十里有王平安营。（《失街亭》）<br>③使……安定。<br>既来之，则安之。（《季氏将伐颛臾》）<br>（3）代词。哪里，怎麽。<br>沛公安在。（《鸿门宴》）<br>燕雀安知鸿鹄之志哉！（《陈涉世家》）</p>
<p><strong>3、被</strong><br>（1）名词。被子。<br>一日昼寝帐中，落被于地。（《杨修之死》）<br>（2）动词。<br>①覆盖。<br>大雪逾岭，被南越中数州。（《答韦中立论师道书》）<br>未几，成归，闻妻言，如被冰雪。（《促织》）<br>②遭受，遇到。<br>秦王复击轲，被八创。（《荆轲刺秦王》）<br>世之有饥穰，天之行也，禹、汤被之矣。（《论积贮疏》）<br>③施加，施及。<br>去乱而被之以治。（《荀子•不苟》）<br>（3）介词。表示被动。<br>信而见疑，忠而被谤。（《屈原列传》）<br>（4）pi ，通”披”，动词。<br>①穿在身上或披在身上。<br>将军身披坚执锐。（《陈涉世家》）<br>②披散，披着。<br>屈原至于江滨，被发行吟泽畔。（《屈原列传》）</p>
<p><strong>4、倍</strong><br>（1）动词。<br>①加倍。<br>虽倍赏累罚而不免于乱。（《五蠹》）<br>一人予二十金，骨微伤……一人倍之，伤肤。（《狱中杂记》）<br>②增加。<br>焉用亡邻以倍郑。（《烛之武退秦师》）<br>③通”背”，背向。<br>管仲反，入，倍屏而立，公不与言。（《管子•中匡》）<br>右背山陵。（《淮阴侯列传》）<br>④通”背”，违背。<br>倍道而行，则天下不能使之吉。（《荀子•天论》）<br>⑤背叛。<br>愿伯具言臣之不敢倍德也。（《鸿门宴》）<br>（2）量词。照原数加一次。<br>然言其户口，则视三十年以前增五倍焉。（《治平篇》）<br>今吾以十倍之地，请广于君。（《唐雎不辱使命》）<br>（3）副词。越发，更加，倍加。<br>独在异乡为异客，每逢佳节倍思亲。（《九月九日忆山东兄弟》）</p>
<p><strong>5、本</strong><br>（1）名词。<br>①草木的根。<br>芙蕖与草木诸花似觉稍异，然有根无树。（《芙蕖》）<br>②草木的干茎。<br>摇其本，以观其疏密。（《种树郭橐驼传》）<br>③根本。<br>父母者，人之本也。（《屈原列传》）<br>然墨之道，兼爱为本。（《中山狼传》）<br>④本业，指农桑。<br>强本而节用。（《天论》）<br>今背本而趋末，食者甚众，是天下之大残也。（《论积贮疏》）<br>⑤稿本。<br>今存其本不忍废。（《〈指南录〉后序》<br>⑥版本。<br>已后典籍皆为板本。（《活板》）<br>⑦奏本。<br>别具本章。（《狱中杂记》）<br>（2）量词。<br>①草木花卉一株称一本。<br>新松郁郁三千本。（陆游诗）<br>②书籍一册称一本。<br>若印数十百千本，则极为神速。（《活板》）<br>（3）动词。推究本原，考查。<br>抑本其成败之迹，而皆自于人欤。（《伶官传序》）<br>（4）形容词。原来的。<br>刘媪本姓实存。（《汉书》）<br>（5）副词。本来，原来。<br>本在冀州之南。（《愚公移山》）<br>柳敬亭者，扬之泰州人，本姓曹。（《刘敬亭传》）<br>（6）复合词。本心：指心的自然状态，本性（即所谓人所固有的羞恶廉耻之心）。<br>此其谓失其本心。（《鱼我所欲也》）<br>（7）介词。本着，根据。<br>本之《书》以求其质。（《答韦中立论师道书》）</p>
<p><strong>6、鄙</strong><br>（1）名词。边界地方。<br>蜀之鄙有二僧。（《为学》）<br>（2）动词。<br>①以……为边界（边邑）。<br>越国以鄙远，君知其难也。（《烛之武退秦师》）<br>②动词。轻视，看不起。<br>孔子鄙其小器。（《训俭示康》）<br>过我而不假道，鄙我也。（《左传》）<br>（3）形容词。鄙陋，见识浅，庸俗。<br>肉食者鄙。（《曹刿论战》）<br>人贱物亦鄙，不足迎后人。（《孔雀东南飞》）<br>（4）复合词。<br>①鄙人。<br>ⅰ、自称的谦词。<br>唐谢曰：”鄙人不知忌讳。”（《史记•冯唐列传》）<br>ⅱ、鄙俗，不开化的人。<br>北蛮夷之鄙人，未尝见天子，故振慑。（《荆轲刺秦王》）<br>ⅲ、乡下人。<br>余目睹将军悛悛（质朴的样子）如鄙人，口不能道辞。（《史记•李将军列传》）<br>②鄙贱：粗野而又地位低微。<br>鄙贱之人，不知将军宽之至此。（《廉颇蔺相如列传》）</p>
<p><strong>7、兵</strong><br>（1）名词。<br>①兵器。<br>收天下之兵，聚之咸阳。（《过秦论》）<br>②士兵，军队。<br>可汗大点兵。（《木兰诗》）<br>赵亦盛设兵以待秦，秦不敢动。（《廉颇蔺相如列传》）<br>③战略战术。<br>公不论兵，必大困。（《战国策》）<br>④战争。<br>兵旱相乘，天下大屈。（《论积贮疏》）<br>（2）动词。<br>①侵略。<br>无岁不受兵。（《十八史略》）<br>②以兵器杀人。<br>左右欲兵之。（《史记》）<br>（3）复合词。兵符：古代调兵用的凭证。用铜、玉或木石等制成，状如虎，又称虎符，剖成两半，国君和统帅各掌握一半，以便对证。<br>赢闻晋鄙之兵符常在王卧内。（《信陵君窃符救赵》）</p>
<p><strong>8、病</strong><br>（1）名词。<br>①重病。<br>君之病在肠胃。（《扁鹊见蔡桓公》）<br>②弊病，缺点。<br>人皆嗤吾固陋，吾不以为病。（《训俭示康》）<br>圣人非所以与熙也，寡人反取病焉。（《晏子使楚》）<br>（2）动词。<br>①生病。<br>凡人不病则不畏惧。（《订鬼》）<br>②使成病态。<br>以夭梅、病梅为业以求钱也。（《病梅馆记》）<br>③担心，忧虑。<br>君子病无能焉，不病人之不己知也。（《论语》）<br>④受困。<br>在陈绝粮，从者病。（《论语》）<br>⑤损害。<br>夫粜，二十病农，九十病末。（《史记•货殖列传》）<br>⑥责备，羞辱。<br>古人以俭为美德，今人乃以俭相诟病。（《训俭示康》）<br>（3）形容词。<br>①困苦。<br>向吾不为斯役，则久已病矣。（《捕蛇者说》）<br>②疲劳。<br>今日病矣，予助苗长矣。（《揠苗助长》）</p>
<p><strong>9、伯</strong><br>（1）名词。<br>①排行第一的，老大，古人同辈间的伯（孟）、仲、叔、季来排行老大、老二、老三、老四。<br>侯主侯伯，侯亚侯旅。（《诗经•周颂•载芟》）<br>②伯父。<br>汝泊何由发如漆。（杜甫《醉歌行》）<br>③女子对丈夫的尊称。<br>自伯之东，首如飞蓬。（《诗经•卫风•伯兮》）<br>④古代五等爵位的第三等。<br>秦伯素服郊次，乡师而哭。（《崤之战》）<br>⑤古代管理一方的长官。<br>二百一十国为州，州有伯。（《礼记•王制》）<br>⑥bà 通”霸”，春秋时诸侯国联盟的盟主。<br>桓公，五伯之上（首）也，争国而杀兄，其利大也。（《韩非子•难四》）<br>（2）副词。表尊敬。<br>若为河伯娶妇。（《西门豹治邺》）<br>（3）bǎi 数词。通”佰”，一百。<br>亡（没有）农夫之苦，有仟佰之得。（《论贵粟疏》）<br>（4）复合词。伯仲：原指兄弟的次第，后用以比喻不相上下的事物。</p>
<p><strong>10、曾</strong><br>（1）céng 副词。表时间的过去。曾经，已经，才。<br>江南好，风景旧曾谙。（白居易《忆江南》）<br>（2）zēng<br>①名词。指与自己隔着两代的亲属。<br>是高、曾时为一户者，至曾元时不分至十户不止。（《治平篇》）<br>②动词。通”增”，增加。<br>行拂乱其所为，所以动心忍性，曾益其所不能。（《生于忧患 死于安乐》）<br>③副词。表意外。竟然，居然，简直。<br>汝心之固，固不可彻，曾不若孀妻弱子。（《愚公移山》）</p>
<p><strong>11、察</strong><br>（1）动词。<br>①细看。<br>徐而察之。（《石钟山记》）<br>②看清楚。<br>明足以察秋毫之末，而不见舆薪。（《齐桓晋文之事》）<br>③详审。<br>向察众人之议，专欲误将军。（《赤壁之战》）<br>④明察，了解。<br>小人之狱，虽不能察，必以情。（《曹刿论战》）<br>⑤考察后加以推荐。<br>察臣孝廉。（《陈情表》）<br>（2）形容词。精明。<br>水至清则无鱼，人至察则无徒。（东方朔《答客难》）<br>（3）叠词。察察：洁净的样子。<br>人谁又能以身之察察，受物之汶汶者乎？（《屈原列传》）</p>
<p><strong>12、长cháng</strong><br>（1）名词。<br>①长度。<br>舟首尾长约八分有奇。（《核舟记》）<br>②高度。<br>孔子长九尺有六寸。（《史记》）<br>③长处，专长。<br>兼花之长而各去其短。（《芙蕖》）<br>（2）形容词。<br>①长的。<br>北市买长鞭。（《木兰诗》）<br>②高的。<br>今日被驱谴，小姑如我长。（《孔雀东南飞》）<br>③久。<br>天长地久有时尽。（《长恨歌》）<br>④远。<br>道阻且长。（《诗经》）<br>⑤大。<br>愿乘长风破万里浪。（《南史》）<br>⑥辽阔。<br>秋水共长天一色。（《滕王阁序》）<br>（3）动词。擅长。<br>西人长火器而短技击。（《冯婉贞》）<br>（4）副词。常，经常。<br>出师未捷身先死，长使英雄泪满襟。（杜甫《蜀相》）<br>zhǎng （1）动词。<br>①生长。<br>用叶者取叶初长足时。（《采草药》）<br>②抚育。<br>长吾女与汝女，待其嫁，如此而已。（《祭十二郎文》）<br>③增进。<br>教学相长。（《学记三则》）<br>（2）形容词。<br>①年龄大。<br>孰与君少长。（《鸿门宴》）<br>②排行第一的。<br>而长子迈将赴饶之德兴尉，送之至湖口。（《石钟山记》）<br>（3）名词。头领。<br>以三宝勇而多艺，推为长。（《冯婉贞》）</p>
<p><strong>13、朝</strong><br>cháo<br>（1）动词。<br>①诸侯在春天拜见天子，或臣属在早晨拜见国君。引申为朝见。<br>王夺郑伯政，郑伯不朝。（《左传》）<br>相如每朝时，常称病。（《廉颇蔺相如列传》）<br>②拜访。<br>临邛令谬为恭敬，日往朝相如。（《史记》）<br>③归。<br>江汉朝宗于海。（《尚书》）<br>（2）名词。<br>①朝廷。<br>于是入朝见威王。（《邹忌讽齐王纳谏》）<br>②朝代。指整个王朝，也指某一皇帝的一代。<br>三顾茅庐天下计，两朝开济老臣心。（杜甫《蜀相》）<br>③政事。<br>期年不听朝。（《吕氏春秋》）<br>（3）介词。对，向。<br>坐南朝北。<br>Zhāo<br>（1）名词。早晨。<br>朝发白帝，暮到江陵。（《三峡》）<br>（2）量词。天，日。<br>虽与之天下，不能一朝居也。（《孟子•告子下》）</p>
<p><strong>14、乘</strong><br>chéng<br>（1）动词，<br>①驾，坐。<br>乘犊车，从吏卒。（《赤壁之战》）<br>独与迈乘小舟至绝壁下。（《石钟山记》）<br>②升，登。<br>乘鄂渚而反顾兮，欤秋冬之绪风。（《涉江》）<br>③趋，顺应。<br>因利乘便，宰割天下，分裂山河。（《过秦论》）<br>④冒着。<br>余以乾隆三十九年十二月，自京师乘风雪，……至于泰安。（《登泰山记》）<br>⑤凭恃、依仗。<br>愿乘长风，破万里浪。（沈括《宋书》）<br>⑥交加，连接。<br>兵旱相乘，天下大屈。（《论积贮疏》）<br>（2）名词。佛教的教派或教法。<br>大乘佛教。<br>shèng<br>（1）名词。<br>①一车四马的总称。<br>致万乘之势，序八州而朝同列。（《过秦论》）<br>②春秋时晋国的史书叫”乘”。后称史书为”史乘”。<br>（2）量词。辆。<br>超乘者三百乘。（《崤之战》）<br>（3）数词。四。<br>以乘韦先，牛二十犒师。（《崤之战》）</p>
<p><strong>15、城</strong><br>（1）名词。<br>①城墙。<br>城非不高也，池非不深也。（《得道多助，失道寡助》）<br>②城市。<br>今日割五城，明日割十城，然后得一夕安寝。（《六国论》）<br>（2）动词。<br>①修筑城墙。<br>是月，城西宁。（《明史•太祖本纪》）<br>②守城。<br>（李）应庚发两路兵城南城。（《宋史•李庭芝传》）</p>
<p><strong>16、诚</strong><br>（1）名词。诚心诚意。<br>帝感其诚，命夸娥氏二子负二山。（《愚公移山》）<br>（2）副词。表肯定。确定，的确。<br>臣诚知不如徐公美。（《邹季讽齐王纳谏》）<br>（3）连词。表假设推论。果真，如果。<br>诚如是，则霸业可成，汉室可兴矣。（《隆中对》）</p>
<p><strong>17、池</strong><br>（1）名词。水塘，湖。<br>山顶有大池，相传以为燕荡。（《雁荡山》）<br>（2）名词。护城河。<br>山非不高也，池非不深也。（《得道多助，失道寡助》）</p>
<p><strong>18、除</strong><br>（1）名词。<br>①殿阶。<br>登自东除。（张衡《两京赋》）<br>②台阶。<br>黎明即起，洒扫庭除。（《朱子家训》）<br>③门屏之间。<br>扶辇下除。（《汉书》）<br>（2）动词。<br>①去掉，除去。<br>兴利除弊。（《答司马谏议书》）<br>除残去秽。（《赤壁之战》）<br>②修治。<br>即除魏阉废祠之址以葬之。（《五人墓碑记》）<br>③拜官授职。<br>予除右丞相兼枢密使。（《〈指南录〉后序》）</p>
<p><strong>19、传</strong><br>chuán<br>（1）动词。<br>①传送，传递。<br>得璧，传之美人。（《廉颇蔺相如列传》）<br>②传授。<br>师者，所以传道授业解惑也。（《师说》）<br>③流传。<br>此世所以不传也。（《石钟山记》）<br>④传达。<br>传上言谓康熙、乾隆、咸丰有开议勤殿故事。（《谭嗣同》）<br>⑤传位。<br>不传于贤而传于子。（《孟子》）<br>⑥动词。延续。<br>人人自安，无战争之患，传之万世。（《史记•秦始皇本纪》）<br>（2）名词。传闻，传说。<br>其所见焉，犹可欺也，而况于世之传也。（《荀子•非柏》）<br>zhuàn<br>名词。<br>（1）客舍。<br>舍相如广成传舍。（《廉颇蔺相如列传》）<br>（2）驿车，传达命令的马车。<br>横惧，乘传诣洛阳。（《汉书•高帝纪下》）<br>（3）传记。<br>作七十列传。（《史记•太史公自序》）<br>（4）注释或阐述经文的文字。<br>六艺经传皆通习之。（《师说》）</p>
<p><strong>20、辞</strong><br>（1）名词。<br>①诉讼的供词。<br>狱辞无谋故者。（《狱中杂记》）<br>②口实。<br>欲加之罪，其无辞乎？（《左传•僖公十年》）<br>③言辞，文辞。<br>而侯生曾无一言半辞送我。（《信陵君窃符救赵》）<br>④托辞，借口。<br>君子疾夫舍曰”欲之”而必为之辞。（《季氏将伐颛臾》）<br>⑤命令。<br>近者奉辞罚罪，旗麾南指，刘琮束手。（《赤壁之战》）<br>⑥名词。一种文体。<br>《归去来兮辞》<br>（2）动词。<br>①说话。<br>挟天子以征四方，动以朝廷为辞。（《赤壁之战》）<br>②告别，辞别。<br>今者出，未辞也，为之奈何。（《鸿门宴》）<br>③推辞，辞去。<br>如姬之欲为公子死，无所辞。（《信陵君窃符救赵》）<br>④计较。<br>大礼不辞小让。（《鸿门宴》）<br>（3）复合词。辞令：应酬的语言、文辞。<br>然皆祖屈原之从容辞令，莫敢直谏。（《屈原列传》）</p>
<p><strong>21、从</strong><br>cóng 动词。<br>①跟随。<br>一狼得骨止，一狼仍从。（《狼》）<br>②依顺，听从。<br>民弗从也。（《曹刿论战》）<br>臣从其计。（《廉颇蔺相如列传》）<br>③参与。<br>弟走从军阿姨死。（《琵琶行》）<br>④追赶。<br>佯北勿从。（《孙子•军争》）<br>⑤依傍，紧挨着。<br>樊哙从良坐。（《鸿门宴》）<br>⑥采取某种原则。<br>从宽、从严、从简、从缓<br>cóng，旧读zòng<br>（1）名词。<br>①随从的人。<br>其从如云。（《诗经》）<br>②副职。<br>魏从九品分正从。（《文献通考》）<br>③指堂房亲属。<br>昇死，其印为予群从所得。（《活板》）<br>（2）形容词。从属的。<br>从犯。<br>Zòng通”纵”<br>（1）形容词。直的。<br>衡（横）纵其亩。（《诗经》）<br>（2）名词。合纵的盟约。<br>于是从散约败，争割地而赂秦。（《过秦论》）<br>（3）动词。放纵。<br>欲不可从。（《礼记》）</p>
<p><strong>22、达</strong><br>（1）动词。<br>①通，透。<br>屋极有窗以达气。（《狱中杂记》）<br>②畅达。<br>撰长书以为贽，辞甚畅达。（《送东阳马生序》）<br>③至、到。<br>自昏达曙。（《促织》）<br>④到达。<br>指通豫南，达于汉阴，可乎？（《愚公移山》）<br>⑤通晓，明白。<br>仆山海狂人，不达世务。（《南史》）<br>⑥得志。<br>不求闻达于诸侯。（闻达：得志扬名。）（《出师表》）<br>⑦表达，告知。<br>词不达意。<br>（2）形容词。<br>①显贵的。<br>达官贵人。<br>②豁达。<br>高祖不修文学，而性明达。（《汉书》）<br>（3）复合词。达人：显达的人。<br>昔正考父煮粥以糊口，孟僖子知其后必有达人。（《训俭示康》）</p>
<p><strong>23、怠</strong><br>形容词。<br>（1）懈怠，松懈。<br>天大寒，砚水坚，手指不可屈伸，弗之怠。（《送东阳马生序》）<br>（2）轻慢，不恭敬。<br>守卒皆怠炎。（炎：人名）（《宋史•杨愿传》）<br>（3）疲倦。<br>怠而后游于清池。（《史记》）</p>
<p>24、殆<br>（1）形容词。<br>①危险。<br>知己知彼，百战不殆。（《孙子•谋攻》）<br>②精神疲倦而无所得。<br>学而不思则罔，思而不学则殆。（《论语•为政》）<br>③通”怠”，懒惰。<br>农者殆则土地荒。（《商君书•农战》）<br>（2）副词。<br>①表测度或不肯定。大概，恐怕。<br>郦元之所见，殆与余同，而言之不详。（《石钟山记》）<br>②表约略。几乎，接近，差不多。<br>扬州城下，进退不由，殆例送死。（《〈指南录〉后序》）</p>
<p><strong>25、当</strong><br>dāng<br>（1）动词。<br>①两者相抵。<br>募有能捕之者，当其租入。（《捕蛇者说》）<br>②抵御，抵抗。<br>非刘豫州莫可以当曹操者。（《赤壁之战》）<br>料大王士卒足以当项王乎。（《鸿门宴》）<br>③占据，把守。<br>一夫当关，万夫莫开。（《蜀道难》）<br>④阻拦。<br>有狼当道，人立而啼。（《中山狼传》）<br>⑤承担。<br>当仁不让于师。（《论语》）<br>⑥主持，执掌。<br>北邀当国者相见。（《〈指南录〉后序》）<br>⑦应当。<br>诸将吏敢复有言当迎操者，与此案同。（《赤壁之战》）<br>⑧判决，判罪。<br>吏当广所失亡多。（《李将军列传》）<br>（2）介词。<br>①表处所。对着，面对。<br>当窗理云鬓，对镜贴花黄。（《木兰辞》）<br>②表时间。值，在，正在。<br>当时时也，商君佐之。（《过秦论》）<br>（3）副词。<br>①表必然。必定，一定。<br>不久当归还，还必相迎取。（《孔雀东南飞》）<br>②表时间的未来。将，将要。<br>今当远离，临表涕零，不知所言。（《出师表》）<br>dàng<br>（1）动词。<br>①符合。<br>惴惴恐不当意。（《促织》）<br>②当作。<br>安步当车。（《战国策》）<br>③以为。<br>我当是相公呢！<br>（2）形容词。适宜。<br>此殊未当。（《采草药》）</p>
<p><strong>26、道</strong><br>（1）名词。<br>①道路。<br>会天大雨，道不通。（《陈涉世家》）<br>②途径，方法。<br>策之不以其道。（《马说》）<br>③风尚。<br>师道之不传也久已。（《师说》）<br>④道义。<br>伐无道，诛暴秦。（《陈涉世家》）<br>⑤思想，学说。<br>墨之道，兼爱为本。（《中山狼传》）<br>⑥道理，规律。<br>臣之所好也，道也。（《庖丁解牛》）<br>⑦意向。<br>道不同，不相为谋。（《论语》）<br>⑧历史上的行政区划名。唐分全国为十五道，隶属于中央。清末和民国初分一省为数道。<br>（2）动词。<br>①取道。<br>从郦山下，道芷阳间行。（《鸿门宴》）<br>②走路，赶路。<br>闻操已向荆州晨夜兼道。（《赤壁之战》）<br>③说，讲。<br>何可胜道也哉？（《游褒禅山记》）<br>④料想。<br>故园谁有书来。<br>⑤通”导”，引导。<br>道之以政。（《论语》）<br>⑥通”导”，疏导。<br>不如小决（决口），使道。（《左传》）</p>
<p><strong>27、得</strong><br>（1）名词。收获。<br>不如自行搜觅，冀有万一之得。（《促织》）<br>（2）动词。<br>①取得，获得。<br>遂不得履。（《郑人买履》）<br>②得意。<br>意气扬扬，甚自得也。（《史记》）<br>③所愿。 于彼计则得。（《中山狼》）</p>
<p><strong>28、度</strong><br>1、尺寸，量长短的标准。（吾忘持度）<br>2、限度，尺度。（生之有时而用之无度）<br>3、规章制度。（内立法度，务耕织，修守战之具）<br>4、越过。（万里赴戎机，关山度若飞 度日如年）<br>5、duó ,计算。（试使山东之国与陈涉度长絜大 度德量力）<br>6、duó ,揣度，估计。（平心而度之，吾果无一失乎）<br>7、duó ,考虑。（度义而后功）</p>
<p><strong>29、短</strong><br>1、短，与“长”相对。<br>2、不足；欠缺。（戎狄之所长，而中国之所短。）<br>3、缺点；短处。<br>4、诋毁。（短屈原于顷襄王）</p>
<p><strong>30、多</strong><br>1、数量大，与“寡”或“少”相对。<br>2、称赞；赞美。（故传天下不足多也。《论积贮疏》）<br>3、增加。（因物而多之，孰与骋能而化之？《荀子》）<br>4、大都，大多。</p>
<p><strong>31、发</strong><br>1、发射。（百发百中）<br>2、出，出发。（朝发夕至）<br>3、派遣。（发闾左谪戍渔阳九百人）<br>4、起，起用。（舜发于畎畝之中《孟子•告子下》）<br>5、打开，掀开。（涂有饿莩而不知发）<br>6、拿出。（有贤士大夫发五十金）<br>7、发觉，泄露。（恐前语发）<br>8、拨动。（施关发机）<br>9、发动。（非常之谋难于猝发）<br>10、发出，抒发。（发其志士之悲哉 发号施令）<br>11、花开。（野芳发而幽香，佳木秀而繁阴）</p>
<p><strong>32、方</strong><br>1、周围。（今齐地方千里《邹》<br>2、并排。（今操方连船舰《赤》）<br>3、正直。（方正之不容也《屈》）<br>5、方位、方向。（乃令史官记地动所从方起《张》）<br>6、当……时候。（方此之时）<br>7、正在。<br>8、将要。</p>
<p><strong>33、非</strong><br>1、不是。（六国破灭，非兵不利，战不善，弊在赂秦 非人不传 非亲非故）<br>2、不。（谪戍之众，非抗于九国之师也 非同小可）<br>3、过错，不对。（实迷途其未远，觉今是而昨非）<br>4、责怪，反对。（是是非非）<br>5、没，无。（才能不及中人，非有仲尼、墨翟之贤）</p>
<p><strong>34、复</strong><br>1返回；回来。（昭王南征而不复）<br>2恢复（更若役，复若赋，则何如）<br>3再，又（明年复攻赵，杀二万人）<br>4重复（山重水复疑无路）<br>5回答（王辞而不复）<br>6报复（有北面复匈奴之志。）<br>7免除赋税徭役（沛幸得复，丰未得复。）<br>8通”覆”，遮盖，盖上（复之以掌，虚若无物。）<br>9复算，追究（而翁归，自与汝复算耳。）</p>
<p><strong>35、负</strong><br>1背东西，以背载物（颁白者不负戴于道路矣）<br>2担负，使……承担（均之二策，宁许以负秦曲）<br>3依仗，凭借（秦贪，负其强，）<br>4对不起，辜负（臣诚恐见欺于王而负赵）<br>5违背，背弃（相如度秦王虽斋，决负约不偿城，乃使其从者衣褐，）<br>6失败（不知彼而知已，一胜一负）<br>7覆盖（苍山负雪，明烛天南。）<br>8亏欠，拖受，责通“债”（ 通家尚负责。）</p>
<p><strong>36、盖</strong><br>1、白茅编成的覆盖物。<br>2、建筑房屋。（盖屋）<br>3、车盖，车蓬。（日初出大如车盖）<br>4、遮盖，掩盖。（日月欲明而浮云盖之。《淮南子》）<br>5、崇尚。（盖威）<br>6、超过，胜过。（况刘豫州王室之胄，英才盖世，众士仰慕，若水之归海　　盖世无双）<br>7、加上。（盖章）<br>8、承接上文，表原因，“因为”。（盖失强援，不能独完）<br>9、承接上文，表推测，“大概”。（盖其至又深，则其至又加少矣）<br>10、通“盍”，何，何不。（技盖至此哉）</p>
<p><strong>37、鼓</strong><br>1、击鼓。（百姓闻王钟鼓之声《孟》齐人三鼓《曹刿论战》）<br>2、振动。（微风鼓浪《石》）<br>3、鼓（乐器）。瞽奏鼓（《书•胤征》）<br>4、弹奏。（赵王鼓瑟《廉》今王鼓乐于此《孟》）<br>5、古代夜间计时。（戊申晦，五鼓《登泰山记》）</p>
<p><strong>38、故</strong><br>1、事，事故。（父母俱存，兄弟无故）<br>2、旧，与”新”相对。（以故法为其国与此同）<br>3、衰老。（暮去朝来颜色故）<br>4、仍然。（累官故不失州郡也）<br>5、老朋友，引申为交情。（君安与项伯有故）<br>6、原因，缘故。（既克，公问其故）<br>7、故意，特意。（故遣将守关者）<br>8、原来 ，本来。（此物故非西产）<br>9、所以，因此。（故臣复取璧）<br>10、故事：旧事，前例。（而从六国破亡之故事）<br>11、死亡。（病故，物故）</p>
<p><strong>39、顾</strong><br>1、回头看；回头。（赢得仓皇北顾）<br>2、看。（顾野有麦场）<br>3、探问，拜访。（三顾臣于草庐之中）<br>4、顾惜，顾念。（子布、元表诸人各顾妻子）<br>5、考虑。（大行不顾细谨）<br>6、但是。（顾念蓄劣物终无所用&#x2F;顾吾念之，强秦之所以不敢加兵于赵者）<br>7、仔细端详。（顾玩）<br>8、表轻微转折（吾每念常痛于骨髓，顾不知计所出耳）<br>9、反而，难道（人之立志，顾不如蜀鄙之僧哉）</p>
<p><strong>40、固</strong><br>1、险固，坚固，坚牢。（秦孝公居崤函之固）<br>2、牢固。（君臣固守）<br>3、坚持，坚决。（乃辞谢，固请）<br>4、巩固，安定。（固国不以山溪之险）<br>5、固执，顽固。（汝心之固，固不可彻 固执己见）<br>6、必，一定。（女能固纳公乎《孟子•梁惠王上》）<br>7、本来。（至于颠覆，理固宜然）<br>8、乃，岂，表反诘。（仁人固如是乎《孟子•万章上》）<br>9、通“姑”，姑且。（将欲翕之，必固张之；将欲弱之，必固强之《老子》）</p>
<p><strong>41、归</strong><br>1、返回。（津泽皆归其根《梦》 予不得归矣《指》）<br>2、归还。（归璧于赵《廉》）<br>3、旧称女子出嫁。（吾妻来归《项》）</p>
<p><strong>42、国</strong><br>1、国家，国家的。（国破山河在，城春草木深）<br>2、诸侯国。（六国破灭，非兵不利）<br>3、国都。（京城登斯楼也，则有去国怀乡）<br>4、地区，地域。（逝将去女，适彼乐国）<br>5、国事。（等死，死国可乎）</p>
<p><strong>43、过</strong><br>1、走过，经过。（臣请缚一人过王而行 过目不忘 ）<br>2、超过，胜过。（过犹不及 矫枉过正）<br>3、过分。（以其境过清，不可久居 过甚其词）<br>4、过失，过错。（是谁之过与 闭门思过）<br>5、责备。（无乃尔是过与）<br>6、过访，访问，探望。（近腊月下，景气和畅，故山殊可过）</p>
<p><strong>44、何</strong><br>1、代词，哪里。（却看妻子愁何在）<br>2、什么，代词。（何时眼前突兀见此屋）<br>3、怎么，为什么，状语。（又何间焉）<br>4、何如：怎样，怎么样。（今日之事何如）<br>5、奈何：怎么办，奈—何：对—怎么办。（取吾璧，不予我城，奈何）<br>6、如–何：把—怎么办。（如太行王屋何）<br>7、多么。（水何澹澹，山岛竦峙。）<br>8、hè背、扛。（何蓑何笠）</p>
<p><strong>45、恨</strong><br>1、遗憾。（不满意辍耕之垄上，怅恨久之&#x2F;未尝不叹息痛恨于桓、灵也）<br>2、怨恨。（此恨绵绵无决期）<br>3、感到遗憾。（以是知公子恨之复返也）<br>4、恨恨：惆怅、悲伤。（生人作死别，恨恨那可论。）<br>区别：恨，憾，怨。“恨”和“憾”都表示遗憾。“怨”表示仇视、怀恨</p>
<p><strong>46、后</strong><br>1、 君主；君主的正妻。<br>2、 后代。<br>3、 后面。<br>4、 以后。<br>5、 落后。<br>6、 以……为后。（后天下之乐而乐）</p>
<p><strong>47、胡</strong><br>1、什么。（国胡以相恤）<br>2、为什么，怎么。（胡取禾三百廛兮）<br>3、古代我国西北部民族的统称。（胡人不敢南下而牧马）</p>
<p><strong>48、患</strong><br>1、忧虑，担心。（欲勿予，即患秦兵之来《廉颇蔺相如列传》则秦之所大欲，诸侯之所大患，固不在战矣。《六国论》）<br>2、祸患，祸害，灾祸。（为操后患《赤壁之战》夫祸患常积于忽微，而智勇多困于所溺）<br>3、危害。（故君之所以患于军者三）<br>4、疾病。（愈膏肓之患难 茜有眼患）<br>5、讳忌。（此数者用兵之患也）<br>6、厌恨。（赵宣子骤谏，公患之）<br>7、生病。（时有患疟疾者）</p>
<p><strong>49、或</strong><br>1、有人。（或曰：六国互丧，率赂秦也）<br>2、有的。（或以为死，或以为亡）<br>3、或许，也许。（则胜负之数，存亡之理，当与秦相较，或未易量）<br>4、有时，偶或。（马之千里者，一食或尽粟一石）<br>5、作语助，不译。（残贼公行，莫之或止）</p>
<p><strong>50、疾</strong><br>1、病。（君有疾在腠里，不治将恐深 讳疾忌医 慷慨得志之徒，其疾病而死《五》）<br>2、痛苦，疾病。（疾首蹙额）<br>3、缺点，毛病。（寡人有疾，寡人好色）<br>4、厌恶，憎恨。（君子疾夫舍曰“欲之”而必为之辞 《论》 屈平疾王听之不聪 《屈》 疾恶如仇）<br>5、通“嫉”，妒忌。（膑至，庞涓恐其贤于己，疾之）<br>6、急速。（鸟起马惊，疾逸道左《柳》）<br>7、加强。（声非加疾也《劝》）</p>
<p><strong>51、及</strong><br>1、赶上，追上。（追张仪，不及）<br>2、到，至。（微夫人之力不及此）<br>3、达到。（及里城）<br>4、涉及，牵连。（一人飞升，仙及鸡犬 此其近者祸及身）<br>5、趁着。（而不及令今有功于国）<br>6、比得上，赶得上。（徐公何能及君也）<br>7、和，并。（凡我父兄昆弟及国子姓）</p>
<p><strong>52、即</strong><br>1、靠近，接近。（匪来贸丝，来即我谋）<br>2、立即，马上。（项伯即入见沛公）<br>3、当，当时。（项王即日因留沛公与饮）<br>4、倘若，如果。（虏多且近，即有急，奈何）<br>5、与”则”的用法相同，相当于”那就”的意思。（且壮士不死即已，死即举大名耳）<br>6、即使。（其伤于缚者，即幸留）<br>7、就，就是。（闻鸡鸣。即起盥栉）<br>8、登上帝位。（昭帝即位，数年，匈奴与汉和亲）</p>
<p><strong>53、既</strong><br>1、尽，完。（言未既）<br>2、已经，—以后。（既克，公问其故）<br>3、既然。（将军既帝室之胄）<br>4、既—-又—并列关系。（三军既惑且疑）<br>5、既而：不久。（既而得其尸于井）<br>6、全、都。（肴核既尽，杯盘狼藉）<br>7、既望：农历每月十六日。（壬之秋，七月既望。苏子与客泛舟）</p>
<p><strong>54、假</strong><br>1、不真，虚伪，假装。（乃悟前狼假寐，盖以诱敌 弄假成真 假仁假义）<br>2、借。（以是人多以书假余）<br>3、凭借，借助。（君子生非异也，善假于物也 狐假虎威）<br>4、犹“贷”，宽容，原谅。（愿大王少假借之）<br>5、给予。（遂乃开仓廪，假贫民《汉书•龚遂传》）<br>6、假如，如果。（假有人焉，举我言复我，亦必疑其诳）</p>
<p><strong>55、间</strong><br>1、两事物的当中。（凡天地之间）<br>2、中间，期间。（奉命于危难之间）<br>3、一会儿。（扁鹊见蔡桓公，立有间）<br>4、指房屋的间数。（安得广厦千万间）<br>5、间隙，空隙。（彼节者有间）<br>6、隔离。（遂与外人间隔）<br>7、间或。（间以诗记所遭）<br>8、离间。（谗人间之可谓穷矣）<br>9、参与。（肉食者谋之，又何间焉）<br>10、间月：隔月，一个月以上。（骨微伤，病间月）<br>11、间关：形容鸟声宛转。（间关莺语花底滑）<br>12、间谍。（秦间来人，赵奢善食而遣之）<br>13、表时间有时、偶然。（数月之后，时时而间进）<br>14、表状态，从小路。（从郦山下，道芷阳间行）<br>15、表情态，秘密地、悄悄地。（侯生乃屏人间语曰）</p>
<p><strong>56、见</strong><br>1、看见。（昨夜见军帖，可汗大点兵）<br>2、召见。（曹刿请见）<br>3、拜见。（冉有、季路见于孔子曰）<br>4、会见。（一日不见，如三秋矣）<br>5、见识，见解。（真知灼见 一得之见）<br>6、被。（信而见疑，忠而被谤）<br>7、听见，听说。（从兹耳界应清静，免见啾啾毁誉声——白居易）<br>8、知道，觉得。（何以见得）</p>
<p><strong>57、解</strong><br>1、剖开，分解动物的肢体。（庖丁为文惠君解牛）<br>2、把系着的东西解开。（悉埋于地，解其棕缚）<br>3、解开，使分开。（少年大骇，急解令休止）<br>4、解释，解答。（师者，所以传道受业解惑也）<br>5、理解，懂得。（其为惑也，终不解矣）<br>6、消散、离散。（得选兵八万人，进兵击秦军，秦军解去，遂救邯郸，存赵）<br>7、分裂、涣散。（天下土崩瓦解）<br>8、解救、消除。（今有一言，可以解燕国之患，而报军之仇者，何如）<br>9、通“懈”，松解，懈怠。（胡虏益解）</p>
<p><strong>58、进</strong><br>1、前进。（余船以次俱进《赤》其进愈难《游》）<br>2、进献。（群臣进谏《邹》相如前进缶《廉》）<br>3、出来做官。（进亦忧、退亦忧《岳阳楼记》）</p>
<p><strong>59、尽</strong><br>1、完了；没有了。<br>2、死。<br>3、全部用出。<br>4、竭尽；使……完尽。（智者尽其谋）<br>5、尽头。<br>6、穷尽。<br>7、明白。（听其言，曰而尽。）<br>8、极；全。（尽善尽美）</p>
<p><strong>60、就</strong><br>1、接近，依靠。（金就砺则利）<br>2、赴任，就职。（连辟公府不就）<br>3、完成，达到目的。（轲自知事不就）<br>4、成就。（当”日知其所亡”以就懿德）<br>5、即，随即。（已股落腹裂，斯须就毙）<br>6、走向，走上。（若无罪而就死地）<br>7、上车、上路。（荆轲遂就车而去）</p>
<p><strong>61、举</strong><br>1、举起，抬起。（举所佩玉玦以示之者三 举案齐眉 举足轻重）<br>2、举出，提出。（举类迩而见义远 举一反三）<br>3、举行，发动。（今亡亦死，举大计亦死）<br>4、推举，举荐。（孙叔敖举于海）<br>5、攻下，占领。（南取汉中，西举巴蜀）<br>6、拿。（吾不能举全吴之地）<br>7、全，尽。（杀人如不能举 举国上下）</p>
<p><strong>62、绝</strong><br>1、断绝。（不绝如缕 络绎不绝 韦编三绝）<br>2、终止，消失。（忽然抚尺一下，群响毕绝）<br>3、隔断。（自云先世避秦时乱，率妻子邑人来此绝境）<br>4、穷尽。（绝处逢生）<br>5、极，最，非常。（佛印绝类弥勒）<br>6、到了极点。（以为妙绝）<br>7、完全，绝对。（绝无踪响 绝无仅有）<br>8、横渡。（假舟楫者，非能水也，而绝江河）</p>
<p><strong>63、堪</strong><br>1、经得起，忍受。（更那堪冷落清秋节）<br>2、能够，可以。（可堪回首，佛狸祠下）<br>3、能够，可以。（出师一表真名世，千载谁堪伯仲间）<br>4、胜任。（不堪吏人妇，岂合今郎君）</p>
<p><strong>64、克</strong><br>1、能够。（如其克谐，天下可定也）<br>2、战胜，攻破。（然操遂能克绍）<br>3、克制。（克已复礼为仁）<br>4、肩负，引申为担当、胜任，担当家务。（子克家）<br>5、克制、约束。（克已奉公）<br>6、限定、约定。（与克期俱至）<br>7、通“刻”，刀刻、雕刻。（更克画，平斗斛度量文章）</p>
<p><strong>65、类</strong><br>1、种类。（有植土龛岩，亦此类耳）<br>2、事例。（举类迩而见义远）<br>3、类似，象。（中会殿阁，类兰若）<br>4、类推。（义不杀少而杀众，不可谓知类）<br>5、条例。（法不能独立，类不能自行）<br>6、大都、大多。（近岁风俗尤多侈靡，走卒类士服，农夫蹑丝履）</p>
<p><strong>66、怜</strong><br>1、怜悯，同情。（独不怜公子姊耶？）<br>2、可怜：可爱。（自名秦罗敷，可怜体无比）<br>3、疼爱、爱惜。（丈夫亦爱怜其少子乎）<br>4、爱戴。（项燕为楚将，数有功，爱士卒，楚人怜之）<br>5、值得同情。（可怜身上衣正单，心忧炭贱愿天寒）<br>6、可惜。（戍卒叫，函谷举，楚人一炬，可怜焦土）</p>
<p><strong>67、临</strong><br>1、从高处朝向低处，面对。（据亿丈之城，临不测之渊，以为固）<br>2、面对。（未尝不临文嗟悼，不能喻之于怀 如临大敌）<br>3、到。（双喜临门 身临其境）<br>4、正当，将要。（先帝知臣谨慎，故临崩寄臣以大事也 临阵磨枪 临渴掘井）</p>
<p><strong>68、弥 弥</strong><br>1、满，遍。（夜雪初霁，荠麦弥望）<br>2、越，更加。（奉之弥繁，侵入愈急）<br>3、弥留：病危将死。（病日至秦。既弥留）<br>4、经、终。（既而弥月不雨，民方以为忧）</p>
<p><strong>69、名</strong><br>1、名字，名称。（有五谷之实而不有其名《芙》盖当时未有雁荡山之名《梦》）<br>2、取名，得名。（以其乃华山之阳名之也《游》而此独以钟名《石》皆后人以贯休诗名之也《梦》）</p>
<p><strong>70、末</strong><br>1、&lt;名&gt;树梢。《左传·昭公十一年》：“末大必折。”<br>2、&lt;名&gt;事情、物件的端或尾。《齐桓晋文之事》：“明足以察秋毫之末。”<br>3、&lt;名&gt;末尾；尽头。《核舟记》：“鲁直左手执卷末，右手指卷。”<br>4、&lt;名&gt;不重要的或非根本的。《论积贮疏》：“使天下各食其力，末技游食之民，转而缘南亩。”<br>5、&lt;名&gt;时间或顺序在后。贾思勰《树木》：“吴末，甘橘成，岁得绢数千匹。”</p>
<p><strong>71、莫</strong><br>1、通”暮”读mu，日落的时候，傍晚。（至莫夜月明）<br>2、没有（谁），没有（什么）。（非刘豫州莫可以当曹操者）<br>3、不，不要。（一夫当关，万夫莫开）<br>4、莫如：不如。（莫如以吾所长攻敌短）<br>5、通”漠”，广大。（今子有大树，患其无用，何不树之无何有之乡，广莫之野）<br>6、表测度、或许。（其事体莫须有）</p>
<p><strong>72、乃</strong><br>1、副词，可译为“是”“就是”，表判断。（以其乃华山之阳名之也）<br>2、你，你的。（与尔三矢，尔其无忘乃父之志　　　家祭无忘告乃翁——陆游）<br>3、如此。（子无乃称。《庄子》）<br>4、仅。（至东城乃有二十八骑）<br>5、于是，就。（良乃入，具告沛公）<br>6、才。（于是为长安君约车百乘，质于齐，兵乃出）<br>7、竟，竟然，居然。（巫医乐师百工之人，君子不齿，今其智乃反不能及，何也）</p>
<p><strong>73、内</strong><br>1、里面，跟“外”相对。（少间，帘内掷一纸出）<br>2、内部，常指国家内部，朝廷内部。（然侍卫之臣不懈于内）<br>3、内心。（今将军外托服从之名而内怀犹豫之计）<br>4、内室。（家有一堂二内）<br>5、通“纳”，接纳。（距关毋内诸侯）<br>6、通“纳”，放进。（内狼于囊）<br>8、交纳。（百姓内粟千石，拜爵一级）</p>
<p><strong>74、判</strong><br>1、古代官职。<br>2、判词。<br>3、分开；分离。（遂判十二国，合为七国）<br>4、分辨。（强弱胜负已判）<br>5、裁判狱讼。</p>
<p><strong>75、期</strong><br>1、限定和约定的时间、时日。（名词）（道不通，度以失期 后会有期）<br>2、约定。（动词）（君与家君期日中，日中不至，则是无信 不期而遇）<br>3、希望。（非相仇也，期有得耳）<br>4、限度。（征敛无期）<br>5、必，至。（况修短随化，终期于尽）<br>6、jī,周，整。（期年之后，虽欲言，无可进者）</p>
<p><strong>76、奇</strong><br>1、奇特的，罕见的，不平常的。（以事秦之心礼天下之奇才）<br>2、以—-为奇，惊异。（大将军邓骘奇其才）<br>3、零数。（舟首尾长约八分有奇）<br>4、适宜，适合。（今日违情义，恐此事非奇）<br>5、珍贵的。（此奇货可居）<br>6、使人不测的。（若兵来则出奇兵击之）<br>7、佳、好、宜。（奇文共欣赏，疑义相与析）<br>8、怪物、异物。（奇生怪）</p>
<p><strong>77、迁</strong><br>1、迁移。（战，守，迁皆不及施）<br>2、改变。（终继五国迁灭，何哉）<br>3、调动官职。（再迁为太史令）<br>4、贬谪，放逐。（是夕始觉有迁谪意）</p>
<p><strong>78、请</strong><br>1、请求，请求对方做某件事。（君不如肉袒伏斧质请罪）<br>2、请求，相当于请允许我，请让我。（请奉盆缶秦王以相娱乐）<br>3、请教，请示。（诸将请所之）<br>4、宴请。（乃置酒请之）<br>5、请命：①请求保全生命或解除疾苦②请示③请求任命官职<br>6、愿意。（请献十金）<br>7、谒见、谒问。（公子闻之，往请，欲厚遗之，不肯受）<br>8、邀请、约请。（乃请宾客，约车骑百余乘，欲以客往赴秦军）</p>
<p><strong>79、穷</strong><br>1、困窘，处境困难。（人穷则反本，故劳苦倦极）<br>2、不得志，不显贵，与”达”相对。（穷则独善其身，达则兼济天下）<br>3、贫困。（所识穷乏者得我欤）<br>4、穷尽。（穷予生之光阴以疗梅也哉）<br>5、寻求到尽头。（复前行，欲穷其林）<br>6、僻、荒。（穷巷陋室穷山恶水）<br>7、困窘。（公孙衍穷张仪）<br>8、穷冬，严冬。（穷冬烈风，大雪深数尺，足肤皲裂而不知）</p>
<p><strong>80、求</strong><br>1、寻求、需求。（求人可使报秦者《廉》以斧斤考击而求之《石》）<br>2、请求。（求而不得者也送）</p>
<p><strong>81、去</strong><br>1、离开。（欲呼张良与俱去）<br>2、过去的。（我从去年辞帝京，谪居卧病浔阳城）<br>3、除去，除掉。（为汉家除残去秽）<br>4、距，距离。（沛公军在霸上，相去四十里）<br>5、表示动作的趋势。（风流总被雨打风吹去）<br>6、丢弃、厌弃、失掉。（人所畔者，天所去也）<br>7、前往、到……去。（公然抱茅入竹去）<br>8、去去：越去越远，往前走了又走。（念去去，千里烟波，暮霭沈沈楚天阔）</p>
<p><strong>82、劝</strong><br>1、勉励，奖励。（一曰主用足，二曰民赋少，三曰劝农功）<br>2、劝说。（时周瑜受使至番阳，肃劝权召瑜还）<br>3、受到鼓励。（夫有功者必赏，则爵禄厚必劝）</p>
<p><strong>83、却</strong><br>1、退，退回。（相如因持壁却立）<br>2、使……退，击退。（后秦击赵者再，李牧连却之）<br>3、拒绝，推却。（却之为不恭）<br>4、还，再。（何当共剪西窗烛，却话巴山夜雨时）<br>5、回头。（却看妻子愁何在，漫卷诗书喜欲狂）<br>6、去掉、消除。（医得眼前疮，剜却心头肉）<br>7、但是、可是。（逢人渐觉乡音异，却恨莺声似故山）</p>
<p><strong>84、如</strong><br>1、依照，遵从，顺。（万事如意 如愿以偿 如法炮制）<br>2、好像，如同。（杀人如不能举，刑人如恐不胜 如出一辙 如此而已 如饥似渴 如丧考妣）<br>3、及，比得上。（沛公默然，曰：“固不如也”）<br>4、到……去。（沛公起如厕，因招樊哙出）<br>5、若，假如。（如有离违，宜别图之，以济大事）</p>
<p><strong>85、若</strong><br>1、似乎，好像。（山有小口，仿佛若有光）<br>2、假如。（若舍郑以为东道主）<br>3、你。（不者，若属皆且为所虏）<br>4、及，比得上。（曾不若孀妻弱子）<br>5、至于，至如。（若夫霪雨霏霏，连月不开）</p>
<p><strong>86、善</strong><br>1、好事，好的行为。（积善成德，而神明自得）<br>2、友好，亲善。（素善留侯张良）<br>3、擅长：善于。（君子生非异也，善假于物也）<br>4、通”缮”，修治。引申为揩拭。（善刀而藏之）<br>5、表示同意的答词，可译为”好””对”。（先主曰”善”）<br>6、善才：唐时著名琵琶师，后也作以指琵琶师或曲师。（尝学琵琶于穆、曹二善才）<br>7、优点、长处。（采儒墨之善，撮明法之要）<br>8、做好 、处理好。（工欲善其事，必先利其器）<br>9、喜欢、羡慕。善乃物之得时，感吾生之行休（）</p>
<p><strong>87、稍</strong><br>1、官府发给的粮食。（县官日有廪稍之供）<br>2、逐渐；慢慢地。稍出近之）<br>3、稍微。</p>
<p><strong>88、少</strong><br>1、数量小，不多。（少私寡欲）<br>2、不足，缺少。（少条失敬：缺少教养，没有规矩。）<br>3、轻视。（显王左右素习知苏秦，皆少之《史记•苏秦列传》）<br>4、表示时间很短，不多时。（少时，一狼径去）<br>5、稍微，略微。（太后之色少解 少安毋躁）<br>6、shào ，年轻，年轻人。（老臣贱息舒祺，最少，不肖）</p>
<p><strong>89、涉</strong><br>1、徒步渡水；引申为渡过。（楚人有涉江者）<br>2、进入，到。（驱中国士众远涉江湖之间）<br>3、经历，经过。（今少卿抱不测罪，涉旬月，迫季东）<br>4、涉猎：泛览群书而不一定求其精</p>
<p><strong>90、胜</strong><br>1、能承受，胜任，禁得起。（驴不胜怒，蹄之）<br>2、尽。（不违农时，谷不可胜食也 不可胜数 美不胜收 不胜枚举）<br>3、胜利。（此所谓战胜于朝廷 百战百胜）<br>4、超过，胜过。（日出江花红胜火，春来江水绿如蓝 略胜一筹）<br>5、优美的。（予观夫巴陵胜状，在洞庭一湖 引人入胜）</p>
<p><strong>91、识</strong><br>1、懂得，认识。（相逢何必曾相识）<br>2、知识，见识。（鄙夫寡识）<br>3、记住。（因笑谓迈曰：”汝识之乎”）</p>
<p><strong>92、使</strong><br>1、派遣，命令。（怀王使屈原造为宪令）<br>2、使，让。（不如因而厚遇之，使归赵）<br>3、出使。（是时屈平既疏，不复在位，使于齐）<br>4、使唤。（人皆得以隶使之）<br>5、使者。（大王派一介之使至赵）<br>6、使命。（时周瑜受使至番阳）<br>7、主使，指使。（周公之逮所由使也）<br>8、假使。（向使三国各爱其地）</p>
<p><strong>93、是</strong><br>1、正确，不错，与“非”相对。（觉今是而昨非 是非分明）<br>2、以为是。（各行其是）<br>3、判断词，是。（同行十二年，不知木兰是女郎）<br>4、这。（是社稷之臣也，何以伐为）<br>5、作语助。（唯利是图）</p>
<p><strong>94、适</strong><br>1、到……去。（余自齐安舟行适临汝）<br>2、女子，出嫁。（贫贱有此女，始适还家门）<br>3、顺从，适合。（处分适兄意，那得自任专）<br>4、恰好。（从上观之适与地平）<br>5、刚才。（适为虞人逐）<br>6、同“谪”，被流放。（发闾左适戍渔阳九百人）<br>7、流放，贬职。（又以适去，竟不自得）</p>
<p><strong>95、书</strong><br>1、写，记下。（乃丹书帛曰”陈胜王”）<br>2、文字。（卒买鱼烹食，得鱼腹中书）<br>3、书信。（烽火连三月，家书抵万金）<br>4、书籍，书。（家贫，无以致书以观）<br>5、国书。（拜送书于庭）<br>6、书法、字体。（举世唯知其书）<br>7、特指《尚书》，泛指一切经书。”（《书》曰：“满招损，谦得益）</p>
<p><strong>96、孰</strong><br>1、通”熟”，仔细。（唯大王与群臣孰计议之）<br>2、谁，哪个。（人非生而知之者，孰能无惑）<br>3、孰与：与……比，哪一个更……，哪里比得上。（我孰与城北徐公美）<br>4、成熟。（寒暑和节，而五谷以孰）<br>5、 孰若：哪如、哪里比得上</p>
<p><strong>97、属</strong><br>1、连接，连缀。（衡少善属文，游于三辅）<br>2、通”嘱”嘱托。（属予作文以记之）<br>3、隶属。（十三学得琵琶成，名属教坊第一部）<br>4、掌管。（在骨髓，司命之所属）<br>5、类。（忠之属也，可以一战）<br>6、等、辈。（若属皆且为所虏）<br>7、系、是。（查明属实，事属可行）</p>
<p><strong>98、数</strong><br>1、数目。（愿令得补黑衣之数）<br>2、若干。（数口之家，可以无饥矣）<br>3、命运。（则胜负之数，存亡之理，当与秦相较，或未易量）<br>4、shǔ ,计算。（蒙冲斗舰乃以千数 不可胜数 数九寒天 数典忘祖）<br>5、shǔ ，列举罪状。（数吕师孟叔侄为逆）<br>6、shuò ,屡次。（扶苏以数谏故，上使外将兵 数见不鲜）<br>7、cù ，密。（数罟不入洿池）</p>
<p><strong>99、遂</strong><br>1、水道。<br>2、通达。<br>3、成功。<br>4、称心。<br>5、于是；就。（遂逐齐师(出自《曹刿论战》)<br>6、终于；竟。（裴矩遂能廷折,不肯面从）</p>
<p><strong>100、率</strong><br>1、遵循；遵从。<br>2、率领。<br>3、给……做榜样。<br>4、大概；大致。<br>5、一概；全部。<br>6、率疲弊之卒，将数百之众（带领，率领）<br>7、大率用根者，若有宿根，须取无茎叶时采（大致，一般，这个意义又说成”大率”）<br>8、六国互丧，率赂秦耶（全都，一概）<br>9、将率不能（主将）<br>10、此吾所以敢率性就死不顾汝也（顺着、沿着）<br>11、有军功者各以率受上爵（规格、标准）<br>12、建始以来，日食地震，以率言之，三倍春秋（频率、比率）</p>
<p><strong>101、说</strong><br>1、陈述，告诉。（及郡下，诣太守，说如此）<br>2、杂说（一种文体）。（故为之说，以俟夫观人风者得焉）<br>3、学说，主张。（著书立说）<br>4、shuì,劝别人听从自己的意见。（游说）<br>5、通“悦”，喜欢，高兴。（秦伯说，与郑人盟）</p>
<p><strong>102、私</strong><br>1、私下。（私握臣手《廉》从道旁私语《柳》）<br>2、偏爱。（吾妻之美我者，私我也《邹》）<br>3、与“公”相对。（公私之积犹可哀痛《论》）</p>
<p><strong>103、素</strong><br>1、白色的生绢。（十三能织素，十四学裁衣）<br>2、白色的。（则素湍绿潭，回清倒影）<br>3、空，白白地。（彼君子兮，不素餐兮）<br>4、向来，一向。（素善留侯张良）<br>5、真情、本心。（披心腹，见情素）<br>6、没有文采的。（秦伯素服郊次，乡师而哭）</p>
<p><strong>104、汤</strong><br>1、热水，开水。（臣请就汤镬）<br>2、汤药。（臣侍汤药，未曾废离）<br>3、同”烫”，用热水焐。（疾在腠里，汤慰之所及也）<br>4、汤池：1就温泉砌成的浴池2防守严密的护城河。<br>5、汤汤：大水急流的样子。（浩浩汤汤，横无际涯）</p>
<p><strong>105、涕</strong><br>1、眼泪。（蒋氏大戚，汪然出涕曰）<br>2、哭泣。士皆垂泪涕泣（）<br>3、涕零：流泪。（临表涕零，不知所言）<br>4、鼻涕。（目泪下，鼻涕长一尺）</p>
<p><strong>106、通</strong><br>1、到达。<br>2、交往；往来。<br>3、畅通；来往无阻。（我可以往，彼可以来，曰通）<br>4、流通；交换。<br>5、通晓；懂得。<br>6、通婚。<br>7、共同的；普通的。<br>8、量词。</p>
<p><strong>107、徒</strong><br>1、同伙，一类人。（郯子之徒，其贤不及孔子）<br>2、徒然，白白地。（秦城恐不可得，徒见欺）<br>3、只，仅仅。（徒以吾两人在也）<br>4、步行。（班白者多徒行）<br>5、徒属：所属的人。（召令徒属曰：”公等遇雨，皆已失期”）<br>6、门人、弟子。（仲尼之徒无道桓文之事者，是以后世无传焉）<br>7、指服劳役的犯人。（高祖亭长，为送徒郦山）</p>
<p><strong>108、图</strong><br>1、地图；图画。<br>2、谋划；想办法。（入则与王图议国事）<br>4、图谋；谋取。<br>5、预料；料想。（不图子自归）<br>6、绘画。<br>7、摹拟；模仿。</p>
<p><strong>109、退</strong><br>1、退却；后退。（进退无颜仪）<br>2、退回；返回。（敬亭退而凝神定气）<br>3、离去。（贤人进而奸人退）<br>4、减退。<br>5、引退。（是进亦忧，退亦忧）</p>
<p><strong>110、亡</strong><br>1、逃亡，逃跑。（亡去不义，不可不语 亡命之徒）<br>2、逃跑的（士兵）。（追亡逐北，伏尸百万）<br>3、丢失。（秦无亡矢遗镞之费，而天下诸侯以困矣 亡羊补牢 名存实亡）<br>4、死亡。（会刘表新亡）<br>5、灭亡。（亡国之音）<br>6、通“无”，没有。（河曲智叟亡以应）</p>
<p><strong>111、王</strong><br>1 、一国的君主。（三十日不还，则请立太子为王）<br>2、称王，统治天下。（沛公欲王关中）<br>3、王子：君主的儿子，也指贵族子弟。（妃嫔媵嫱，王子皇孙）<br>4、王师：封建时代政府的军队。（王师北定中原日，家祭毋忘告乃翁）</p>
<p><strong>112、望</strong><br>1、向远处看。（吾尝跂而望矣，不如登高之博见也 望尘莫及）<br>2、看。（望文生义）<br>3、盼望，希望。（日夜望将军至，岂敢反乎 望子成龙 喜出望外）<br>4、名望。（先达德隆望尊）<br>5、农历每月十五日。（适冬之望日前后）</p>
<p><strong>113、恶</strong><br>1、厌恶，嫉妒。（表恶其能而不能用也）<br>2、丑，劣，不好的。（廉君宣恶言）<br>3、怎么，哪。（以小易大，彼恶知之）</p>
<p><strong>114、微</strong><br>1、细小，轻微。（则名微而众寡）<br>2、贫贱。（虞舜侧微《书•舜典序》）<br>3、衰败。（故夫三桓之子孙微矣《论语•季氏》）<br>4、隐匿。（白公奔山而缢，其徒微之《左传•哀公十六年》）<br>5、暗暗的。（微闻有鼠作作索索）<br>6、稍微，略微。（见其发矢十中八九，但微颔之）</p>
<p><strong>115、闻</strong><br>1、听见。（顺风而呼，声非加疾也，而闻者彰 耳闻目见 闻鸡起舞）<br>2、见闻，知识。（博闻强识）<br>3、达，传报。（举吏民能假贷贫民者以名闻《汉书•武帝纪》）<br>4、嗅。（闻到香味）<br>5、声誉，名声。（不能称前时之闻）</p>
<p><strong>116、相</strong><br>1、互相。（当与秦相较 相依如命 相敬如宾 心心相印）<br>2、表示动作只涉及一方，有指代作用。（狼不敢前，眈眈相向）<br>3、xiàng ,观察，仔细看。（相机而动）<br>4、xiàng ,相貌，容貌。（相貌堂堂 凶相毕露）<br>5、xiàng ,帮助，辅助。（吉人天相）<br>6、xiàng ,辅佐君主的大臣，宰相。（王侯将相宁有种乎）</p>
<p><strong>117、谢</strong><br>1、推辞，谢绝。（阿母谢媒人 闭门谢客）<br>2、道歉。（旦日不可不蚤自来谢项王）<br>3、辞别，辞谢。（乃令张良留谢）<br>4、感谢。（哙拜谢，起，立而饮之 谢天谢地）<br>5、告诉。（使君谢罗敷：“宁可共载不？”）<br>6、凋谢，凋落。（花开花谢）</p>
<p><strong>118、悉</strong><br>1、都，全。（赵王悉召群臣议）<br>2、周全，详尽。（古之治天下，至孅至悉也）<br>3、知道。（丞相亮其悉朕意）<br>4、尽其所有。（料大王之卒，悉之不过三十万）<br>5、详尽地叙述。（书不能悉意，略陈固陋）</p>
<p><strong>119、信</strong><br>1、诚实，不欺，讲信用。（言而有信）<br>2、信任。（愿陛下亲之信之）<br>3、相信。（忌不自信）<br>4、信用。（小信未孚，神弗福也）<br>5、使者，送信的人。（自可断来信，徐徐更谓之）<br>6、凭证，凭据。（是皆不足以执信也）<br>7、确实，的确。（烟涛微茫信难求 信赏必罚）<br>8、随意。（低眉信手续续弹 信口雌黄 信口开河 信笔涂鸦）<br>9、shēn，同“伸”，伸张。（欲信大义于天下）</p>
<p><strong>120、兴</strong><br>1、起来，兴起：风雨兴焉(劝) 忧劳可以兴国，逸豫可以亡身（伶）<br>2、发动：抑王兴甲兵， 危士臣（齐）大兴师伐秦(屈)<br>3、兴致：遥襟甫畅，逸兴遄飞（滕）</p>
<p><strong>121、行</strong><br>1、行动：大行不顾细谨（鸿）<br>2、品德行为：辱人贱行(五) 其行廉(屈)<br>3、实行，做：余嘉其能行古道（师）<br>4、行走：道芷阳间行(鸿) 草行露宿(指)<br>5、将要：行将为人所并(赤)<br>6、行列：涕 落百余行(孔)<br>7、军队编制：蹑足行伍之间(过)<br>8、经：行年四岁，舅夺母志（陈）<br>9、行李：出使的人：行李之往来，共其乏困（烛）</p>
<p><strong>122、幸</strong><br>1、幸而：大王亦幸•赦臣（廉）故幸•来告良（鸿）<br>2、宠爱：缦立远视，而望幸•焉（阿）如姬最幸•（信）<br>3、宠信：君幸•于赵王（廉）</p>
<p><strong>123、修</strong><br>1、饰，装饰。（美要眇兮宜修《楚辞•九歌•湘君》）<br>2、理，整治。（内立法度，务耕织，修守战之具）<br>3、兴建，修建。（乃重修岳阳楼，增其旧制）<br>4、编撰，撰写。（修史）<br>5、学习，研究。（自修）<br>6、善，美好。（伊中情之信修兮）<br>7、长，高。（邹忌修八尺有余 此地有崇山峻岭，茂林修竹）</p>
<p><strong>124、徐</strong><br>1、不徐不疾（迟缓）<br>2、清风徐来，水波不兴（慢慢地、缓缓地）</p>
<p><strong>125、许</strong><br>1、答应、允许。（宁许以负秦曲《廉》）<br>2、大约。（潭中鱼可百许头《小石潭记》 高可二黍许《核舟记》）<br>3、期望。（塞上长城空自许，镜中衰鬓已先斑）<br>4、处所。（不知何许人也）</p>
<p><strong>126、阳</strong><br>1、山的南面，水的北面。（以其乃华山之阳名之也）<br>2、阳光，太阳。（斜阳草树，寻常巷陌）<br>3、温暖。（春日载阳，有鸣仓庚）<br>4、通“佯”，表面上，假装。（儋阳为傅其奴）<br>5、出的，外露的。（周秦古玺，多作阳文）</p>
<p><strong>127、要</strong><br>1、重要，简要。（增减要语，奉行者莫辨也）<br>2、险要。（筑石寨土堡于要隘）<br>3、需要，符合，适合。（凡先王之法，有要于时也）<br>4、同”邀”，邀请。（张良出，要项伯）<br>5、要挟。（惟大辟无吏可要，然犹质其首）<br>6、相约，誓约。（虽与府吏要，渠会永无缘）<br>7、要点、关键。（要在安国家，利人民）<br>8、希望。（若要人不知，除非已莫为）<br>9、总括、概括。（要之，治平之久，天地不能不生人）<br>10、约束、控制。（然地亦穷险，唯京师要其道）</p>
<p><strong>128、宜</strong><br>1、适宜，合适。（将军禽操，宜在今日）<br>2、应当，应该。（诚宜开张圣听）<br>3、表推测，大概。（今阴阳不调，宜更历之过也）</p>
<p><strong>129、遗</strong><br>1、遗失，丢失。（秦无亡矢遗镞之费，而天下诸侯以困矣）<br>2、遗失之物。（夜不闭户，路不拾遗）<br>3、遗留，剩下。（蒙故业，因遗策 不遗余力）<br>4、wèi ，给予。（是以先帝简拔以遗陛下）<br>5、剩余的。（地有遗利，民有遗力）</p>
<p><strong>130、贻</strong><br>1、赠给；送给。（尝贻予核舟一，盖大苏泛赤壁云）<br>2、遗留。（贻训 我之怀矣。自贻伊戚）</p>
<p><strong>131、易</strong><br>1、交换；互换。（秦以十五城请易寡人之璧《廉》 罢夫羸老易子而咬其骨《论》）<br>2、改变。（缙绅而能不易其志者《五》）<br>3、容易。（由俭入奢易《训》 岂得之难而失之易欤《伶》）<br>3、轻视。（是以古之易财《五》）<br>4、地势，平坦，平易。（由是贼中险易远近虚实尽知之）<br>5、很，非常。（荣禄固操、莽之才，绝世之雄，待之恐不易易）</p>
<p><strong>132、阴</strong><br>1、山的北面，水的南面。（指通豫南，达于汉阴）<br>2、阴暗。（朝晖夕阴，气象万千）<br>3、阴冷，寒。（阴风怒号，浊浪排空）<br>4、阴影，树荫。（故审堂下之阴，而知日月之行）<br>5、暗中，暗地里。（阴知奸党名姓，一时收禽）<br>6、凹入的。（惟汉印多用阴文）<br>7、阴险。（性阴密，忍诛杀，不见喜怒）</p>
<p><strong>133、引</strong><br>1、引导：左右引•相如至（廉）<br>2、牵引、拽：或欲引•相如去（廉）见人方引•婴儿欲投之江中（察）<br>3、后退：相如引•车避匿（廉）引•次江北（赤）</p>
<p><strong>134、右</strong><br>1、右边，与“左”相对。（然视其左右，来而记之者已少）<br>2、高；上。明代以前的右为尊贵位。（在廉颇之右(廉)位）<br>3、古代战车上坐在右边担任警卫的叫车右。（梁弘御戎，莱驹为右）<br>4、尊重；重视。（守成尚文，遭遇右武）<br>5、赞助；亲近。（右韩而左文）<br>6、古称世家大族为”右族”、”右姓”。（时国王骄奢，又多豪右，共为不轨）</p>
<p><strong>135、逾</strong><br>1、超过，越过。（老翁逾墙走）<br>2、过分；过度。</p>
<p><strong>136、狱</strong><br>1、案件；官司。（小大之狱，虽不能察，必以情。）<br>2、监狱。<br>3、罪状；过失。（有某姓兄弟，以把持公仓，法应立决，监狱具矣）</p>
<p><strong>137、再</strong><br>1、第二次。（一鼓作气，再而衰）<br>2、二；两。</p>
<p><strong>138、造</strong><br>1、到……去。（径造庐访成，视成所蓄）<br>2、不知便可登峰造极不（到达某一境界）<br>3、制造；建造。（因造玉清宫，伐山取材）<br>4、制定。（怀王使屈原造为宪令）<br>5、培养，造就。（小子有造）<br>6、造化：指天地、大自然。（造化钟神秀，阴阳割昏晓）</p>
<p><strong>139、知</strong><br>1、知道，了解。（人非生而知之者，孰能无惑）<br>2、识别。（其真不知马也）<br>3、感觉，觉得。（不知口体之奉不若人）<br>4、主持。（子产其知政矣）<br>5、交好；相亲。（公孙明知叔孙于齐）<br>6、见解；知识。（孰谓汝多知乎？）<br>7、交情。（绝宾客之知。）<br>8、朋友。（悲歌辞旧爱，衔泪觅新知）<br>9、通“智”。智慧；聪明。（则知明而行无过矣）</p>
<p><strong>140、置</strong><br>1、安置。（今以钟磬置水中）<br>2、设立。（内外多置小门）<br>3、购置，添置。（郑人有且置履者。）<br>4、放弃。（沛公则置车骑，脱身独骑）<br>5、驿站。</p>
<p><strong>141、致</strong><br>1、送达，送来。（存问致赐《汉书•武帝纪》）<br>2、表达，表示。（论天下事势，致殷勤之意）<br>3、达到。（假舆马者，非利足也，而致千里）<br>4、得到，取得。（每岁致数百金）<br>5、招致。（不爱珍器重宝肥饶之地，以致天下之士）<br>6、致使，使。（何意致不厚）<br>7、尽，极。（衡善机巧，尤致思于天文阴阳历算 专心致志）<br>8、情趣，情致。（所以兴怀，其致一也 闲情逸致）</p>
<p><strong>142、质</strong><br>1、质问。（余立侍左右，援疑质理）<br>2、质地。（永州之野产异蛇，黑质而白章）<br>3、刑具。杀人时作垫用的砧板。（君不如肉袒伏斧质请罪）<br>4、通“贽”；见面礼。名词（厚币委质事楚）<br>5、本质。（非天质之卑 形者神之质）<br>6、人质。（有复言令长安君为质者）<br>7、正、刚刚。（质明，避哨竹林中）</p>
<p><strong>143、治</strong><br>1、治理，管理。（故治国无法则乱）<br>2、医治。（君有疾在腠理，不治将恐深）<br>3、惩处。（不效则治臣之罪）<br>4、部署，训练。（今治水军八十万众）<br>5、讲究，研究。（奚暇治礼义哉？）<br>6、对付。（同心一意，共治曹操）<br>7、治理得好，与”乱”相对。（明于治乱，娴于辞令）<br>8、整理。（于是约车治装，载券契而行）</p>
<p><strong>144、诸</strong><br>1、众多；各个。（诸如此类 赵王与大将军廉颇诸大臣谋）<br>2、相当于“之于”。（投诸渤海之尾）<br>3、第三人称，他、她、它（们）。（告诸往者而知来者）</p>
<p><strong>145、贼</strong><br>1、祸患。（淫侈之俗日日以长，是天下之贼也）<br>2、强盗。（贼二人得我，我幸皆杀之矣）<br>3、杀人者；作乱的人。（几落贼手死）<br>4、狠毒。（董卓狼戾贼忍）<br>5、伤害；杀害。（二人相憎，而欲相贼也）<br>6、作乱叛国或外来侵犯的人。（忍能对面为盗贼）<br>7、凶狠，残忍。（董卓狼戾 贼忍）</p>
<p><strong>146、族</strong><br>1、家族；同姓的亲属。<br>2、类。（士大夫之族，曰师曰弟子云者）<br>3、灭族。（族秦者秦也）<br>4、丛聚、集结之处。（虽然，每至于族，吾见其难为）</p>
<p><strong>147、卒</strong><br>1、士兵；吏卒；古代军队的编制，一百人为卒。（夫以疾病之卒御狐疑之众）<br>2、死；完毕。（初，鲁肃闻刘表卒）<br>3、终于，最终。（卒相与欢，为刎颈之交）<br>4、cu通“猝”。突然，仓促。（五万兵难卒合）</p>
<p><strong>148、走</strong><br>1、跑。（双兔傍地走，安能辨我是雄雌）<br>2、逃跑。（老翁逾墙走，老妇出门看）<br>3、仆人。（太史公牛马走司马迁再拜言）<br>4、轻快。（豫备走舸，系于其尾）<br>5、奔向、趋附。（窃计欲亡赵走燕）1（古代指疾行，即跑）<br>6、谦称、我。（走虽为敏）</p>
<p><strong>149、左</strong><br>1、左边，与“右”相对。<br>2、较低的地位。（余左迁九江郡司马）<br>3、不正；邪僻。（执左道而乱政）<br>4、不合。（身正而事左）<br>5、不赞助。（右韩而左魏）</p>
<p><strong>150、坐</strong><br>1|、座位。（公子引侯生坐上坐《信》）<br>2、坐着，坐下。（项王，项伯东向坐）<br>3、犯罪或错误。（何坐？曰坐盗《晏子使楚》）<br>4、通”座”。（座位因击沛公于坐）<br>5、因为。（由于停车坐爱枫林晚）<br>6、坐守。（与其坐而待亡，孰若起而拯之）<br>7、坐落，位置所在。（坐北朝南）</p>
]]></content>
      <tags>
        <tag>汉化</tag>
      </tags>
  </entry>
  <entry>
    <title>汉化：词类活用</title>
    <url>/2024/08/06/%E6%B1%89%E5%8C%96%EF%BC%9A%E8%AF%8D%E7%B1%BB%E6%B4%BB%E7%94%A8/</url>
    <content><![CDATA[<p>文言文中有個難關，就是<strong>詞類活用</strong>。</p>
<p>若果不能理解詞類活用，你很有可能會被一兩個字纏著，甚至解錯文章。</p>
<p>所以，小編就爲大家整理了詞類活用全攻略！</p>
<h2 id="詞類活用-是什麽？"><a href="#詞類活用-是什麽？" class="headerlink" title="詞類活用 是什麽？"></a>詞類活用 是什麽？</h2><p><img src="https://learnsmart.edu.hk/wp-content/uploads/2022/08/download-27.png.webp" alt="詞類活用"></p>
<p><strong>在特定的語言環境中，文言文部分詞語的詞性會被臨時改變。</strong></p>
<p><strong>在文言文中，詞類活用現象是非常普遍，****是文言文語法特點之一。</strong></p>
<h2 id="詞類活用-類型"><a href="#詞類活用-類型" class="headerlink" title="詞類活用 類型"></a>詞類活用 類型</h2><p>詞類活用主要有：</p>
<p><strong>名詞活用為動詞</strong></p>
<p><strong>動詞活用為名詞</strong></p>
<p><strong>形容詞活用為動詞</strong></p>
<p><strong>數詞活用為動詞等</strong></p>
<h2 id="名詞活用為動詞"><a href="#名詞活用為動詞" class="headerlink" title="名詞活用為動詞"></a>名詞活用為動詞</h2><p>名詞活用為動詞，一般情況下是<strong>兩個名詞連用，必有一個名詞作動詞；副詞（adverb）後面直接帶名詞，名詞就活用為動詞。</strong></p>
<p>活用後的意義仍和這個名詞的意義密切相關，只是動作化而已。</p>
<p>例如：</p>
<p>吾從而<strong>師</strong>之。</p>
<p>原意：名詞 老師，活用為動詞 以……為老師、向……..學習</p>
<p>其他例子：</p>
<p>其<strong>下</strong>聖人也遠矣</p>
<p>原意：名詞 下方，活用為動詞 不及、不如</p>
<p>“一狼洞其中”（《狼》）中的“洞”，原為名詞，洞穴，轉化為動詞“打洞”之義。</p>
<p>婦撫兒乳（《口技》）“乳”轉化為動詞“喂乳”。</p>
<p><strong>禮</strong>天下之奇才 “禮”轉化為動詞“禮待”。</p>
<p>不能名其一處也（《口技》）“名”轉化為動詞“說出”。</p>
<h2 id="一般名詞作狀語"><a href="#一般名詞作狀語" class="headerlink" title="一般名詞作狀語"></a>一般名詞作狀語</h2><p>①表示動作行為發生的處所。如“途中兩狼，綴行甚遠”（《狼》）中的“途”，原意為道路，這裏作狀語，是“在道路上”的意思。</p>
<p>②表示動作行為的依據、手段或工具。如“失期，法皆斬”（《陳涉世家》）中的“法”，原意是“法律”，這裏作狀語，修飾動詞“斬”，表示行為的依據，是“按照法律”的意思。</p>
<p>③表示行為的身份或對待的方式。如“君為我呼入，吾得兄事之”（《項羽本紀》）中的“兄”，本為名詞，轉化為狀語，是“用對待兄長的禮節”的意思。</p>
<p>④表示動作行為的特征或狀態。如“其一犬坐於前”（《狼》）中的“犬”，本是名詞“狗”，在這兒作狀語，意思是“像狗一樣”。</p>
<h2 id="動詞活用為名詞"><a href="#動詞活用為名詞" class="headerlink" title="動詞活用為名詞"></a>動詞活用為名詞</h2><p><strong>動詞出現在主語或賓語的位置上，表示與這個動作行為有關的人或事，這時它就活用作名詞。</strong></p>
<p>例子：</p>
<p>吾射不亦精乎”（《賣油翁》）中的“射”，本是動詞“射箭”，這裏轉化為名詞“射箭的本領”。</p>
<h2 id="形容詞活用為名詞"><a href="#形容詞活用為名詞" class="headerlink" title="形容詞活用為名詞"></a>形容詞活用為名詞</h2><p><strong>在句子中，形容詞如果處於主語或賓語的位置，具有明顯的表示人或身份的特征和意義，形容詞就轉化為名詞。</strong></p>
<p>例子：</p>
<p>是故<strong>聖</strong>益聖，<strong>愚</strong>益愚</p>
<p><strong>聖</strong> 原意 形容詞 具有智慧、道德 活用為名詞 聖人</p>
<p><strong>愚</strong> 原意 形容詞 愚昧 活用為名詞 愚昧的人</p>
<h2 id="形容詞作動詞"><a href="#形容詞作動詞" class="headerlink" title="形容詞作動詞"></a>形容詞作動詞</h2><p><strong>形容詞後面帶了賓語（Object），形容詞就轉化為動詞。</strong></p>
<p>例：復前行，欲<strong>窮</strong>其林。（陶淵明《桃花源記》）<br>（<strong>窮</strong>：原為形容詞，這裡活用為動詞，可譯為「走完」）</p>
<p><strong>其他例子：</strong></p>
<p>“天下苦秦久矣”（《陳涉世家》）中的“苦”，因帶賓語“秦”，意為“（對秦王朝的殘暴統治）感到苦惱”</p>
<p>於其身也則<strong>恥</strong>師焉</p>
<p>原爲 恥辱、可恥，活用為動詞當作可恥</p>
]]></content>
      <tags>
        <tag>汉化</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学：逻辑与证明（1）</title>
    <url>/2024/08/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<p>113</p>
<h2 id="第⼀章-逻辑与证明-Logic-and-Proof"><a href="#第⼀章-逻辑与证明-Logic-and-Proof" class="headerlink" title="第⼀章 逻辑与证明 Logic and Proof"></a>第⼀章 逻辑与证明 Logic and Proof</h2>]]></content>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章：Java入门</title>
    <url>/2025/05/12/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AJava%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h2><hr>
<h3 id="步骤-1：安装和配置开发环境"><a href="#步骤-1：安装和配置开发环境" class="headerlink" title="步骤 1：安装和配置开发环境"></a><strong>步骤 1：安装和配置开发环境</strong></h3><ol>
<li><p><strong>下载并安装JDK（Java Development Kit）</strong>：</p>
<ul>
<li><p>JDK 是 Java 开发的核心工具包，包含了编译器（javac）、运行时环境（JRE）和其他工具。<img src="https://i.imgur.com/HpmE69n.png"></p>
</li>
<li><p>下载地址：<a href="https://www.oracle.com/java/technologies/javase-downloads.html">Oracle官网</a> 或 <a href="https://openjdk.org/">OpenJDK</a>。</p>
</li>
<li><p>安装完成后，检查是否成功安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/kJXdppu.png"><br><img src="https://i.imgur.com/IEoX5f9.png"><br>通过网盘分享的文件：7、重生之我用AI学Java<br>链接: <a href="https://pan.baidu.com/s/1ZENcAEPtcBKuAr9qnsWgIQ">https://pan.baidu.com/s/1ZENcAEPtcBKuAr9qnsWgIQ</a> 提取码: llxx<br>–来自百度网盘超级会员v3的分享<br><img src="https://i.imgur.com/YG1ao0r.png"><br><img src="https://i.imgur.com/MDQxv35.png"></p>
</li>
</ul>
</li>
<li><p><strong>配置环境变量</strong>：</p>
<ul>
<li>将 JDK 的 <code>bin</code> 目录路径添加到系统的 <code>PATH</code> 环境变量中。</li>
<li>配置完成后，可以在命令行中直接使用 <code>java</code> 和 <code>javac</code> 命令。<br><img src="https://i.imgur.com/Gm8NtQx.png"><br><img src="https://i.imgur.com/MgAoMsU.png"><br><img src="https://i.imgur.com/Nk89dRR.png"><br><img src="https://i.imgur.com/jofyAL7.png"><br>javac：编译工具<br>java：执行程序</li>
</ul>
</li>
</ol>
<ul>
<li><strong>JVM（Java Virtual Machine）</strong>：即 Java 虚拟机，是真正运行 Java 程序的地方 。</li>
<li><strong>核心类库</strong>：是 Java 已编写好，供程序员在自己程序中调用的程序 。</li>
<li><strong>JRE（Java Runtime Environment）</strong>：Java 的运行环境，由 JVM 和核心类库组成 。</li>
<li><strong>JDK（Java Development Kit）</strong>：Java 开发工具包，包含 JRE 以及开发工具（如 Java、Javac 等 ）。<br><img src="https://i.imgur.com/JPkyjrQ.png"><br><img src="https://i.imgur.com/GhW0WU1.png"><br>便于维护</li>
</ul>
<ol>
<li><strong>选择开发工具</strong>（可选）：<ul>
<li>初学者可以选择轻量级的文本编辑器（如 Notepad++、VS Code）。</li>
<li>如果想更高效地开发，可以使用集成开发环境（IDE），例如 IntelliJ IDEA、Eclipse 或 NetBeans。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="步骤-2：编写代码"><a href="#步骤-2：编写代码" class="headerlink" title="步骤 2：编写代码"></a><strong>步骤 2：编写代码</strong></h3><ol>
<li><strong>创建一个 Java 文件</strong>：<ul>
<li>每个 Java 程序都必须保存在一个 <code>.java</code> 文件中。</li>
<li>文件名必须与类名一致（区分大小写）。<br><img src="https://i.imgur.com/s27Egyx.png"><br><img src="https://i.imgur.com/yrNMX50.png"><br>加回车<br><img src="https://i.imgur.com/YUucSbm.png"><br>写一半按tab补充<br>成功了</li>
</ul>
</li>
<li><strong>编写代码</strong>：<ul>
<li>以下是一个简单的 “Hello, World!” 程序：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>代码解析</strong>：<ul>
<li><code>public class HelloWorld</code>：定义了一个名为 <code>HelloWorld</code> 的公共类。</li>
<li><code>public static void main(String[] args)</code>：这是程序的入口点，所有 Java 程序从这里开始执行。</li>
<li><code>System.out.println(&quot;Hello, World!&quot;);</code>：打印一条消息到控制台。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="步骤-3：编译代码"><a href="#步骤-3：编译代码" class="headerlink" title="步骤 3：编译代码"></a><strong>步骤 3：编译代码</strong></h3><ol>
<li>打开命令行（Windows 的 CMD 或 macOS&#x2F;Linux 的 Terminal）。</li>
<li>导航到保存 <code>.java</code> 文件的目录。例如：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\YourName\JavaProjects</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>javac</code> 命令编译代码：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure>
<ul>
<li>编译成功后，会生成一个同名的 <code>.class</code> 文件（字节码文件），例如 <code>HelloWorld.class</code>。</li>
</ul>
</li>
</ol>
<p><img src="https://i.imgur.com/sxnyvtR.png"><br>编译完成<br><img src="https://i.imgur.com/cGTySrO.png"></p>
<hr>
<ul>
<li><strong>编译过程</strong>：Java 程序通过 <code>javac</code> 编译成 Class 文件。</li>
<li><strong>跨平台特性</strong>：实现 “一次编译，处处可用”。<ul>
<li>Class 文件可在不同操作系统对应的 JVM 虚拟机上运行，如 Windows 版 JVM 虚拟机、Linux 版 JVM 虚拟机、MacOS 版 JVM 虚拟机。</li>
</ul>
</li>
</ul>
<h3 id="步骤-4：运行程序"><a href="#步骤-4：运行程序" class="headerlink" title="步骤 4：运行程序"></a><strong>步骤 4：运行程序</strong></h3><ol>
<li>使用 <code>java</code> 命令运行程序：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java HelloWorld</span><br></pre></td></tr></table></figure></li>
<li>输出结果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p>运行代码<br><img src="https://i.imgur.com/Z4HoAD7.png"></p>
<h3 id="步骤-5：调试与改进"><a href="#步骤-5：调试与改进" class="headerlink" title="步骤 5：调试与改进"></a><strong>步骤 5：调试与改进</strong></h3><ol>
<li><p><strong>检查错误</strong>：</p>
<ul>
<li>如果编译或运行时出现错误，请仔细阅读错误信息，通常它会告诉你问题所在。</li>
<li>常见问题包括拼写错误、缺少分号、文件名与类名不匹配等。</li>
</ul>
</li>
<li><p><strong>改进代码</strong>：</p>
<ul>
<li>在熟悉基本语法后，可以尝试修改程序，比如让用户输入名字并打印个性化的问候语：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入你的名字: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;你好, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结：开发入门程序的完整流程"><a href="#总结：开发入门程序的完整流程" class="headerlink" title="总结：开发入门程序的完整流程"></a><strong>总结：开发入门程序的完整流程</strong></h3><ol>
<li><strong>安装 JDK 并配置环境变量</strong>。</li>
<li><strong>编写 Java 源代码</strong>（保存为 <code>.java</code> 文件）。</li>
<li><strong>使用 <code>javac</code> 编译代码</strong>，生成 <code>.class</code> 文件。</li>
<li><strong>使用 <code>java</code> 运行程序</strong>。</li>
<li><strong>调试并改进代码</strong>。</li>
</ol>
<h2 id="1-2-IDE工具"><a href="#1-2-IDE工具" class="headerlink" title="1.2 IDE工具"></a>1.2 IDE工具</h2><h3 id="企业常用-Java-开发工具（IDE-）"><a href="#企业常用-Java-开发工具（IDE-）" class="headerlink" title="企业常用 Java 开发工具（IDE ）"></a>企业常用 Java 开发工具（IDE ）</h3><ul>
<li><strong>定义</strong>：集成了 JDK、代码编写窗、编译、执行等多种功能的开发工具。</li>
<li><strong>常用工具</strong><ul>
<li><strong>IntelliJ IDEA</strong>：由 JetBrains 开发，代码智能提示、分析、重构功能强，对 Maven、Git 等集成好。有社区版（免费 ）和终极版（付费 ），受专业开发者青睐。</li>
<li><strong>Eclipse</strong>：开源，适合 Java 开发，生态系统庞大，插件丰富可定制。启动速度和内存占用受诟病，但仍被众多企业和个人选用。</li>
<li><strong>Apache NetBeans</strong>：开源免费，提供全面开发环境，适合各层次开发者，对 Java EE 和 Web 应用支持佳，界面友好易上手。</li>
<li><strong>Visual Studio Code（配合 Java 插件 ）</strong>：本身是轻量级编辑器，安装 Java Development Pack 等扩展后，可成为功能强大的 Java 开发环境，受喜欢轻巧编辑器的开发者欢迎。<br>  <img src="https://i.imgur.com/4fBeU9Y.png"></li>
</ul>
</li>
</ul>
<h3 id="IDEA的下载与安装"><a href="#IDEA的下载与安装" class="headerlink" title="IDEA的下载与安装"></a>IDEA的下载与安装</h3><p><a href="https://www.jetbrains.com/idea/">https://www.jetbrains.com/idea/</a><br><img src="https://i.imgur.com/N6o03bo.png"><br>破解完成的IDEA<br><img src="https://i.imgur.com/q8jF84e.png"></p>
<h3 id="Java项目结构概念"><a href="#Java项目结构概念" class="headerlink" title="Java项目结构概念"></a>Java项目结构概念</h3><ul>
<li><strong>Project（工程 ）</strong>：Java开发中最大的组织单元，是一个完整的软件项目集合，包含代码、配置文件等所有相关资源 。</li>
<li><strong>Module（模块 ）</strong>：工程的子单元，可将大型工程按功能或业务逻辑拆分为多个模块，便于管理和维护，模块可独立开发、测试和部署 。 </li>
<li><strong>Package（包 ）</strong>：用于组织类和接口，避免命名冲突，控制访问权限。类似文件夹结构，对相关类进行分组管理 。 </li>
<li><strong>Class（类 ）</strong>：Java基本编程单元，封装数据和方法，实现具体功能，是面向对象编程核心概念 。</li>
</ul>
<h4 id="以淘宝系统为例理解Java项目结构"><a href="#以淘宝系统为例理解Java项目结构" class="headerlink" title="以淘宝系统为例理解Java项目结构"></a>以淘宝系统为例理解Java项目结构</h4><ul>
<li><strong>Project（工程 ）</strong>：淘宝系统整体可看作一个工程，是整个项目的集合，涵盖所有相关代码、资源等。</li>
<li><strong>Module（模块 ）</strong><ul>
<li><strong>首页模块</strong>：负责淘宝首页相关功能展示与交互，包含多个包和类，如 <code>package包1</code> 下的 <code>class类1</code>、<code>class类2</code> 等 。</li>
<li><strong>购物车模块</strong>：处理购物车相关操作，有 <code>package包1</code>、<code>package包2</code>、<code>package包3</code> 等不同包，每个包下又有多个类，如 <code>class类1</code>、<code>class类2</code> 等 。</li>
<li><strong>订单模块</strong>：管理订单相关业务逻辑，包含 <code>package包1</code> 等包及其下的类，如 <code>class类1</code>、<code>class类2</code> 等 。</li>
</ul>
</li>
<li><strong>Package（包 ）</strong>：用于组织模块内的类，避免命名冲突，控制访问权限，如各模块内不同功能相关的类分别放在不同包中。 </li>
<li><strong>Class（类 ）</strong>：实现具体功能，如首页展示逻辑、购物车操作逻辑、订单处理逻辑等，都由具体类来完成 。<br><img src="https://i.imgur.com/nNYFaNO.png"><br>建立工程<br><img src="https://i.imgur.com/Gvc9EtP.png"><br>建立模块<br><img src="https://i.imgur.com/kat7GUK.png"><br>建包<br><img src="https://i.imgur.com/uWAoLVZ.png"><br>新建类写程序<br><img src="https://i.imgur.com/wtkksg4.png"><br>[[JavaWeb&#x2F;Java&#x2F;Complement 1|Complement 1]]<br><img src="https://i.imgur.com/VMKBuPn.png"></li>
</ul>
<p>成功<br><img src="https://i.imgur.com/QQgxcpW.png"><br>看到class文件<br><img src="https://i.imgur.com/QrZRWNF.png"></p>
<h2 id="1-3-IDEA安装AI编程插件（插件）"><a href="#1-3-IDEA安装AI编程插件（插件）" class="headerlink" title="1.3 IDEA安装AI编程插件（插件）"></a>1.3 IDEA安装AI编程插件（插件）</h2><h3 id="IDEA安装AI插件"><a href="#IDEA安装AI插件" class="headerlink" title="IDEA安装AI插件"></a>IDEA安装AI插件</h3><ul>
<li><strong>IDEA之前编程方式</strong>：程序编码需程序员自行思考、逐行编写。</li>
<li><strong>AI出现后的变化</strong>：IDEA可集成多种辅助编程的AI插件。<ul>
<li><strong>Github Copilot</strong>：能依据上下文智能生成代码 。</li>
<li><strong>阿里巴巴 通义灵码</strong>：助力代码编写、检查等开发环节 。 </li>
<li><strong>科大讯飞 星斗AI</strong>：为编程提供智能化支持 。</li>
</ul>
</li>
</ul>
<ul>
<li>进入设置<br><img src="https://i.imgur.com/XmzGjwg.png"><br><img src="https://i.imgur.com/UZjLKT3.png"><br><img src="https://i.imgur.com/HistUBt.png"><br>等待下载安装<br><img src="https://i.imgur.com/R4H9WOI.png"><br>安装完毕<br><img src="https://i.imgur.com/toa7sGD.png"></li>
<li>登录结束<br><img src="https://i.imgur.com/oYloIsY.png"></li>
<li>试运行<br><img src="https://i.imgur.com/jyFOAtn.png"></li>
<li>功能<br><img src="https://i.imgur.com/3j6j0qj.png"></li>
</ul>
<h3 id="IDEA字体、背景之类的设置"><a href="#IDEA字体、背景之类的设置" class="headerlink" title="IDEA字体、背景之类的设置"></a>IDEA字体、背景之类的设置</h3><p><img src="https://i.imgur.com/GlWgGa4.png"><br>背景<br><img src="https://i.imgur.com/Nh1LptV.png"><br>字体<br><img src="https://i.imgur.com/WfrQyWh.png"><br><img src="https://i.imgur.com/cMYtTRH.png"><br>调色<br><img src="https://i.imgur.com/gbgpZi9.png"></p>
<table>
<thead>
<tr>
<th>快捷键组合</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>psvm</code> + <code>Tab</code> 或 <code>Enter</code></td>
<td>快速生成 <code>public static void main</code> 方法</td>
</tr>
<tr>
<td><code>sout</code> + <code>Tab</code> 或 <code>Enter</code></td>
<td>快速生成 <code>System.out.println()</code> 语句</td>
</tr>
<tr>
<td><code>Ctrl + D</code></td>
<td>复制当前行到下一行</td>
</tr>
<tr>
<td><code>Ctrl + Y</code></td>
<td>删除当前行</td>
</tr>
<tr>
<td><code>Ctrl + X</code></td>
<td>剪切当前行</td>
</tr>
<tr>
<td><code>Ctrl + Alt + L</code></td>
<td>格式化代码</td>
</tr>
<tr>
<td><code>Alt + Shift + ↑ / ↓</code></td>
<td>上下移动当前行</td>
</tr>
<tr>
<td><code>Ctrl + /</code></td>
<td>添加或取消单行注释</td>
</tr>
<tr>
<td><code>Ctrl + Shift + /</code></td>
<td>添加或取消多行注释</td>
</tr>
<tr>
<td><img src="https://i.imgur.com/xZpqw8s.png"></td>
<td></td>
</tr>
</tbody></table>
<h2 id="1-4-IDEA的其他操作"><a href="#1-4-IDEA的其他操作" class="headerlink" title="1.4 IDEA的其他操作"></a>1.4 IDEA的其他操作</h2><h3 id="打开工程"><a href="#打开工程" class="headerlink" title="打开工程"></a>打开工程</h3><p>打开别人的工程<br>直接把别人的工程打开，然后点击信任，新窗口打开就成功了。</p>
<h3 id="关闭工程"><a href="#关闭工程" class="headerlink" title="关闭工程"></a>关闭工程</h3><p>直接关闭窗口</p>
<h3 id="删除类文件"><a href="#删除类文件" class="headerlink" title="删除类文件"></a>删除类文件</h3><p>直接右键选择删除<br><img src="https://i.imgur.com/DFyUH5k.png"></p>
<h3 id="修改类名称"><a href="#修改类名称" class="headerlink" title="修改类名称"></a>修改类名称</h3><p>直接右键选择修改名称<br><img src="https://i.imgur.com/Vuay4kf.png"></p>
<h3 id="修改模块"><a href="#修改模块" class="headerlink" title="修改模块"></a>修改模块</h3><p><img src="https://i.imgur.com/1CMxc18.png"></p>
<h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><ul>
<li>直接复制过后导入的不能直接使用</li>
<li>我们需要进来选择已有的资源进行导入</li>
<li><img src="https://i.imgur.com/vfkr23f.png"><br>其他的方法不可以实现，现在还没有分配合适的JDK给它用<br><img src="https://i.imgur.com/DsRzFzq.png"></li>
</ul>
<h3 id="删除模块"><a href="#删除模块" class="headerlink" title="删除模块"></a>删除模块</h3><p><img src="https://i.imgur.com/Wp7dpXp.png"><br>先解除连接，再进行Delete。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章：环境安装</title>
    <url>/2025/05/12/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="1-1-CONDA环境安装"><a href="#1-1-CONDA环境安装" class="headerlink" title="1.1 CONDA环境安装"></a>1.1 CONDA环境安装</h2><h3 id="Conda"><a href="#Conda" class="headerlink" title="Conda"></a>Conda</h3><ul>
<li><strong>定义</strong>：data science package &amp; environment manager（数据科学包和环境管理器 ）</li>
<li><strong>创建环境</strong><ul>
<li>命令：<code>conda create --name python3 python=3</code></li>
</ul>
</li>
<li><strong>切换环境</strong><ul>
<li><strong>Windows</strong>：<code>activate python3</code></li>
<li><strong>Linux&#x2F;macOS</strong>：<code>source activate python3</code></li>
</ul>
</li>
<li><strong>官方地址</strong>：<a href="https://www.anaconda.com/download/">https://www.anaconda.com/download/</a><br><img src="https://i.imgur.com/1SMCfgh.png"></li>
</ul>
<p>Anaconda 作为一款流行的 Python 发行版，拥有诸多优势，使其在数据科学、机器学习等领域备受欢迎：</p>
<ol>
<li><p><strong>包管理</strong>: Anaconda 最大的优势之一是其强大的包管理功能。它使用 conda 作为包管理器，可以轻松地安装、更新、卸载和管理各种 Python 包及其依赖项。Conda 能够很好地处理包之间的依赖关系，避免版本冲突，这对于复杂的项目来说非常重要。</p>
</li>
<li><p><strong>环境管理</strong>: Anaconda 允许你创建独立的虚拟环境，每个环境都可以有自己独立的 Python 版本和软件包。这使得你可以在同一台机器上同时运行多个项目，而不用担心它们之间的依赖关系冲突。</p>
</li>
<li><p><strong>预装常用包</strong>: Anaconda 预装了大量常用的数据科学和机器学习包，例如 NumPy、Pandas、Scikit-learn、Matplotlib 等。这意味着你安装 Anaconda 后，就可以立即开始进行数据分析和建模工作，而无需手动安装这些包。</p>
</li>
<li><p><strong>跨平台</strong>: Anaconda 支持 Windows、macOS 和 Linux 等多种操作系统，这使得你可以在不同的平台上使用相同的工具和环境。</p>
</li>
<li><p><strong>开源免费</strong>: Anaconda 是开源的，并且提供了免费的社区版，这使得任何人都可以免费使用它。</p>
</li>
<li><p><strong>Anaconda Navigator</strong>: Anaconda 提供了一个图形用户界面（GUI）工具 Anaconda Navigator，可以让你更方便地管理环境、安装包和启动应用程序，例如 Jupyter Notebook、Spyder 等。</p>
</li>
<li><p><strong>社区支持</strong>: Anaconda 拥有庞大的用户社区，你可以很容易地找到相关的文档、教程和支持。</p>
</li>
</ol>
<p>总而言之，Anaconda 的优势在于其强大的包管理、环境管理功能，以及预装的常用包，使得数据科学家和机器学习工程师可以更高效地进行开发和实验。</p>
<h2 id="1-2-JupyterBook"><a href="#1-2-JupyterBook" class="headerlink" title="1.2 JupyterBook"></a>1.2 JupyterBook</h2><p><img src="https://i.imgur.com/Vv3lu7L.png"><br><img src="https://i.imgur.com/9BzCU7e.png"><br><img src="https://i.imgur.com/KK7cR3F.png"><br><img src="https://i.imgur.com/pChJgaI.png"><br><img src="https://i.imgur.com/RJkkwFV.png"><br>markdown</p>
<!--⚠️Imgur upload failed, check dev console-->
<p>![[Pasted image 20250420062609.png]]</p>
<h2 id="1-3-matplotlib"><a href="#1-3-matplotlib" class="headerlink" title="1.3 matplotlib"></a>1.3 matplotlib</h2><p>Matplotlib 是 Python 中一个非常流行和强大的绘图库，主要用于创建静态、交互式和动画可视化的图表。它可以生成各种类型的图表，包括折线图、散点图、柱状图、饼图、直方图、等高线图、3D 图形等等。</p>
<p>以下是 Matplotlib 的一些关键特性和优点：</p>
<ul>
<li><strong>灵活性</strong>: Matplotlib 提供了丰富的绘图选项，可以让你高度定制图表的外观，包括颜色、线条样式、字体、标签、标题等等。</li>
<li><strong>多种输出格式</strong>: Matplotlib 可以将图表保存为多种格式，包括 PNG、JPG、PDF、SVG 等，方便你在不同的场景中使用。</li>
<li><strong>与 NumPy 和 Pandas 集成</strong>: Matplotlib 可以很好地与 NumPy 和 Pandas 集成，可以直接使用 NumPy 数组和 Pandas DataFrame 中的数据进行绘图。</li>
<li><strong>易于使用</strong>: Matplotlib 提供了简单易用的 API，可以让你快速创建基本的图表。</li>
<li><strong>交互式绘图</strong>: Matplotlib 支持交互式绘图，可以在图表中进行缩放、平移、旋转等操作。</li>
<li><strong>广泛的应用</strong>: Matplotlib 被广泛应用于数据分析、科学研究、工程计算等领域。</li>
</ul>
<p>以下是一些 Matplotlib 的常用模块：</p>
<ul>
<li><code>matplotlib.pyplot</code>: 提供了类似于 MATLAB 的绘图接口，是 Matplotlib 最常用的模块。</li>
<li><code>matplotlib.axes</code>: 提供了 Axes 类，用于创建和管理图表中的坐标轴。</li>
<li><code>matplotlib.figure</code>: 提供了 Figure 类，用于创建和管理图表中的图形。</li>
<li><code>matplotlib.cm</code>: 提供了颜色映射表，用于将数据值映射到颜色。</li>
</ul>
<p>总而言之，Matplotlib 是 Python 中一个非常重要的绘图库，可以帮助你将数据可视化，从而更好地理解数据和发现数据中的规律。</p>
<h3 id="Matplotlib-绘图基础"><a href="#Matplotlib-绘图基础" class="headerlink" title="Matplotlib 绘图基础"></a>Matplotlib 绘图基础</h3><ol>
<li><strong>导入模块</strong><ul>
<li><code>from matplotlib import pyplot as plt</code> ：导入 <code>pyplot</code> 模块并简写为 <code>plt</code> ，方便后续调用。</li>
</ul>
</li>
<li><strong>数据准备</strong><ul>
<li><code>x = range(2,26,2)</code> ：表示数据在 x 轴的位置，是可迭代对象，生成从 2 开始到 26（不包含 26），步长为 2 的整数序列。</li>
<li><code>y = [15,13,14.5,17,20,25,26,26,24,22,18,15]</code> ：表示数据在 y 轴的位置，是可迭代对象。x 轴和 y 轴的数据一起组成要绘制的坐标，如 <code>(2,15)</code> 、<code>(4,13)</code> 等。</li>
</ul>
</li>
<li><strong>绘图与展示</strong><ul>
<li><code>plt.plot(x,y)</code> ：传入 x 和 y 数据，通过 <code>plot</code> 函数绘制折线图。</li>
<li><code>plt.show()</code> ：在程序执行时展示绘制好的图形。<br> <img src="https://i.imgur.com/nAyMMyW.png"><br> x轴没有刻度<a href="%E6%8F%92%E5%85%A5x%E7%9A%84%E5%88%BB%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A">^1</a></li>
</ul>
</li>
</ol>
<h3 id="Matplotlib绘图待解决问题"><a href="#Matplotlib绘图待解决问题" class="headerlink" title="Matplotlib绘图待解决问题"></a>Matplotlib绘图待解决问题</h3><ol>
<li><strong>图片大小</strong>：设置合适尺寸以获取高清大图。</li>
<li><strong>保存本地</strong>：掌握保存绘图到本地的方法。 </li>
<li><strong>描述信息</strong>：标注 x 轴、y 轴含义及图形意义。 </li>
<li><strong>刻度间距</strong>：调整 x 轴或 y 轴刻度间距。 </li>
<li><strong>线条样式</strong>：设定线条颜色、透明度等样式。 </li>
<li><strong>标记特殊点</strong>：标记图形最高点、最低点等特殊点。 </li>
<li><strong>添加水印</strong>：添加水印防伪防盗用。</li>
</ol>
<h3 id="Python使用Matplotlib绘图笔记"><a href="#Python使用Matplotlib绘图笔记" class="headerlink" title="Python使用Matplotlib绘图笔记"></a>Python使用Matplotlib绘图笔记</h3><ol>
<li><strong>导入模块</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>导入<code>matplotlib.pyplot</code>模块并起别名<code>plt</code>，方便后续调用函数。</li>
</ul>
<ol start="2">
<li><strong>创建Figure对象</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize=(<span class="number">20</span>,<span class="number">8</span>),dpi=<span class="number">80</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>figure</code>：图形图标的意思，这里指绘制的图。</li>
<li>通过实例化一个<code>figure</code>并传递参数，能在后台自动使用该<code>figure</code>实例。</li>
<li><code>dpi</code>参数：在图像模糊时传入，可让图片更清晰 。<code>dpi</code>即每英寸点数（dots per inch），值越大图像越清晰。</li>
</ul>
<ol start="3">
<li><strong>准备数据</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">26</span>,<span class="number">2</span>)</span><br><span class="line">y = [<span class="number">15</span>,<span class="number">13</span>,<span class="number">14.5</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">26</span>,<span class="number">26</span>,<span class="number">24</span>,<span class="number">22</span>,<span class="number">18</span>,<span class="number">15</span>]</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>x</code>：使用<code>range</code>函数生成从2开始，到26结束（不包含26），步长为2的整数序列，作为横坐标数据。</li>
<li><code>y</code>：手动定义的列表，作为纵坐标数据。</li>
</ul>
<ol start="4">
<li><strong>绘制图形</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(x,y)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>使用<code>plot</code>函数绘制折线图，传入<code>x</code>和<code>y</code>数据。</li>
</ul>
<ol start="5">
<li><strong>保存图形</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.savefig(<span class="string">&quot;./sig_size.png&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>savefig</code>函数用于保存图片。</li>
<li>可以保存为<code>svg</code>这种矢量图格式，矢量图放大不会有锯齿 。</li>
</ul>
<ol start="6">
<li><strong>显示图形</strong><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>show</code>函数用于在运行脚本或交互式环境中显示绘制的图形。</li>
</ul>
<p><img src="https://i.imgur.com/gVSs6zh.png"><br>输出图像<br><img src="https://i.imgur.com/8Nuy101.png"><br><img src="https://i.imgur.com/aBv8zSD.png"><br>生成图片<br><img src="https://i.imgur.com/j2XIwOT.png"><br>调整y的刻度</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.imgur.com/U82vqXZ.png"><br>一个语法<br><img src="https://i.imgur.com/qJ9Yr0d.png"></p>
<h3 id="Matplotlib-设置中文显示笔记"><a href="#Matplotlib-设置中文显示笔记" class="headerlink" title="Matplotlib 设置中文显示笔记"></a>Matplotlib 设置中文显示笔记</h3><p><img src="https://i.imgur.com/M8gyjJv.png"></p>
<h4 id="一、无法显示中文原因"><a href="#一、无法显示中文原因" class="headerlink" title="一、无法显示中文原因"></a>一、无法显示中文原因</h4><p>matplotlib 默认不支持中文字符，因为其默认英文字体无法显示汉字。</p>
<h4 id="二、查看-Linux-Mac-支持字体方法"><a href="#二、查看-Linux-Mac-支持字体方法" class="headerlink" title="二、查看 Linux&#x2F;Mac 支持字体方法"></a>二、查看 Linux&#x2F;Mac 支持字体方法</h4><ol>
<li><strong>查看所有支持字体</strong>  <a href="windows%E7%9A%84%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%EF%BC%9A">^2</a><br> 使用命令<code>fc - list</code> 。</li>
<li><strong>查看支持的中文字体</strong><br> 使用命令<code>fc - list :lang=zh</code>（冒号前面有空格） 。<br> <img src="https://i.imgur.com/sxdWAgI.png"></li>
</ol>
<h4 id="三、修改-matplotlib-默认字体方法"><a href="#三、修改-matplotlib-默认字体方法" class="headerlink" title="三、修改 matplotlib 默认字体方法"></a>三、修改 matplotlib 默认字体方法</h4><ol>
<li><strong>通过 matplotlib.rc 修改</strong><br> 具体方法需参见源码（适用于 windows&#x2F;linux 系统）。</li>
<li><strong>通过 font_manager 修改</strong><br> 利用 matplotlib 下的 font_manager，适用于 windows、linux、mac 系统。<br> <img src="https://i.imgur.com/EXiaQ9z.png"><br> 点击F12，查看rc函数的源码</li>
</ol>
<p>查看当前电脑中文字体路径的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os  </span><br><span class="line">from fontTools.ttLib import TTFont  </span><br><span class="line">  </span><br><span class="line"># Windows 字体目录  </span><br><span class="line">font_dir = r&#x27;C:\Windows\Fonts&#x27;  </span><br><span class="line">  </span><br><span class="line"># 列出字体文件  </span><br><span class="line">for font_file in os.listdir(font_dir):  </span><br><span class="line">    if font_file.endswith((&#x27;.ttf&#x27;, &#x27;.otf&#x27;)):  </span><br><span class="line">        font_path = os.path.join(font_dir, font_file)  </span><br><span class="line">        try:  </span><br><span class="line">            # 打开字体文件  </span><br><span class="line">            font = TTFont(font_path)  </span><br><span class="line">  </span><br><span class="line">            # 检查字体是否支持中文字符  </span><br><span class="line">            cmap = font[&#x27;cmap&#x27;].getcmap(3, 1)  # 获取 Unicode BMP 平面映射  </span><br><span class="line">            if cmap:  </span><br><span class="line">                chars = cmap.cmap.keys()  </span><br><span class="line">                # 检查是否存在中文字符（Unicode 范围：0x4E00-0x9FFF）  </span><br><span class="line">                if any(0x4E00 &lt;= char &lt;= 0x9FFF for char in chars):  </span><br><span class="line">                    print(font_path)  </span><br><span class="line">        except Exception as e:  </span><br><span class="line">            print(f&quot;Error processing &#123;font_path&#125;: &#123;e&#125;&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">![](https://i.imgur.com/iLt2pAs.png)</span><br><span class="line">添加图形的描述信息</span><br><span class="line"></span><br><span class="line">![](https://i.imgur.com/F2v4rxT.png)</span><br><span class="line"></span><br><span class="line">![](https://i.imgur.com/0jvAbPQ.png)</span><br><span class="line">绘制网格</span><br><span class="line"></span><br><span class="line">&lt;!--⚠️Imgur upload failed, check dev console--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![[Pasted image <span class="number">20250420171454.</span>png]]</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 数据准备  </span></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]  </span><br><span class="line">b = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]  </span><br><span class="line">x = <span class="built_in">range</span>(<span class="number">11</span>, <span class="number">31</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 字体设置  </span></span><br><span class="line">my_font = font_manager.FontProperties(fname=<span class="string">&quot;C:\\Windows\\Fonts\\Deng.ttf&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建图形  </span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>), dpi=<span class="number">80</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 绘制折线图  </span></span><br><span class="line">plt.plot(x, a, label=<span class="string">&quot;我自己&quot;</span>, marker=<span class="string">&#x27;o&#x27;</span>)  <span class="comment"># 自己的数据  </span></span><br><span class="line">plt.plot(x, b, label=<span class="string">&quot;我同桌&quot;</span>, marker=<span class="string">&#x27;s&#x27;</span>)  <span class="comment"># 同桌的数据  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置x轴刻度和标签  </span></span><br><span class="line">_xtick_labels = [<span class="string">&quot;&#123;&#125;岁&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> x]  </span><br><span class="line">plt.xticks(<span class="built_in">list</span>(x), _xtick_labels, rotation=<span class="number">45</span>, fontproperties=my_font)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置y轴刻度  </span></span><br><span class="line">plt.yticks(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">9</span>))  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加网格  </span></span><br><span class="line">plt.grid(alpha=<span class="number">0.4</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加描述性信息  </span></span><br><span class="line">plt.xlabel(<span class="string">&quot;岁数/岁&quot;</span>, fontproperties=my_font)  </span><br><span class="line">plt.ylabel(<span class="string">&quot;个数/个&quot;</span>, fontproperties=my_font)  </span><br><span class="line">plt.title(<span class="string">&quot;不同岁数的男女朋友数量对比&quot;</span>, fontproperties=my_font)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加图例  </span></span><br><span class="line">plt.legend(prop=my_font)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 保存并显示图表  </span></span><br><span class="line">plt.savefig(<span class="string">&quot;./friends_comparison.svg&quot;</span>)  </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/J1T1ioG.png"></p>
<h2 id="🎨-自定义绘制图形的风格（Matplotlib）"><a href="#🎨-自定义绘制图形的风格（Matplotlib）" class="headerlink" title="🎨 自定义绘制图形的风格（Matplotlib）"></a>🎨 自定义绘制图形的风格（Matplotlib）</h2><p>在使用 <code>plt.plot()</code> 绘图时，可以通过参数设置线条的颜色、风格、粗细和透明度，实现风格自定义。</p>
<h3 id="📌-示例代码："><a href="#📌-示例代码：" class="headerlink" title="📌 示例代码："></a>📌 示例代码：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(</span><br><span class="line">    x,  <span class="comment"># 横坐标数据</span></span><br><span class="line">    y,  <span class="comment"># 纵坐标数据</span></span><br><span class="line">    color=<span class="string">&#x27;r&#x27;</span>,        <span class="comment"># 线条颜色（红色）</span></span><br><span class="line">    linestyle=<span class="string">&#x27;--&#x27;</span>,   <span class="comment"># 线条风格（虚线）</span></span><br><span class="line">    linewidth=<span class="number">5</span>,      <span class="comment"># 线条粗细</span></span><br><span class="line">    alpha=<span class="number">0.5</span>         <span class="comment"># 透明度（0~1之间）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🎨-颜色字符速查表："><a href="#🎨-颜色字符速查表：" class="headerlink" title="🎨 颜色字符速查表："></a>🎨 颜色字符速查表：</h3><table>
<thead>
<tr>
<th>字符</th>
<th>颜色</th>
</tr>
</thead>
<tbody><tr>
<td><code>r</code></td>
<td>红色</td>
</tr>
<tr>
<td><code>g</code></td>
<td>绿色</td>
</tr>
<tr>
<td><code>b</code></td>
<td>蓝色</td>
</tr>
<tr>
<td><code>w</code></td>
<td>白色</td>
</tr>
<tr>
<td><code>c</code></td>
<td>青色</td>
</tr>
<tr>
<td><code>m</code></td>
<td>洋红</td>
</tr>
<tr>
<td><code>y</code></td>
<td>黄色</td>
</tr>
<tr>
<td><code>k</code></td>
<td>黑色</td>
</tr>
</tbody></table>
<p><em>也可使用 16 进制颜色（如：<code>#00ff00</code>）或灰度值字符串（如：<code>0.8</code>）</em></p>
<hr>
<h3 id="✨-线条风格字符："><a href="#✨-线条风格字符：" class="headerlink" title="✨ 线条风格字符："></a>✨ 线条风格字符：</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>-</code></td>
<td>实线</td>
</tr>
<tr>
<td><code>--</code></td>
<td>虚线、破折线</td>
</tr>
<tr>
<td><code>-.</code></td>
<td>点划线</td>
</tr>
<tr>
<td><code>:</code></td>
<td>点线（虚线）</td>
</tr>
<tr>
<td><code>&#39;&#39;</code></td>
<td>空字符串表示无线条</td>
</tr>
</tbody></table>
<hr>
<p>需要的时候直接在 <code>plt.plot()</code> 里加上这些参数就能控制线的样式啦~<br>是不是超方便呢？✧<em>｡٩(ˊᗜˋ</em>)و✧*｡</p>
<p>如果你还有别的绘图问题，也可以继续问小汐喔！</p>
<h3 id="一个好用的网站"><a href="#一个好用的网站" class="headerlink" title="一个好用的网站"></a>一个好用的网站</h3><p><a href="https://matplotlib.org/stable/gallery/index">https://matplotlib.org/stable/gallery/index</a><br><img src="https://i.imgur.com/FNMzhX5.png"></p>
<h3 id="对比常用统计图"><a href="#对比常用统计图" class="headerlink" title="对比常用统计图"></a>对比常用统计图</h3><ol>
<li><strong>折线图</strong><ul>
<li><strong>定义</strong>：以折线的上升或下降来表示统计数量增减变化的统计图。</li>
<li><strong>特点</strong>：能够显示数据的变化趋势，反映事物的变化情况。关键词：变化</li>
</ul>
</li>
<li><strong>直方图</strong><ul>
<li><strong>定义</strong>：由一系列高度不等的纵向条纹或线段表示数据分布的情况，一般用横轴表示数据范围，纵轴表示分布情况 。</li>
<li><strong>特点</strong>：绘制连续性的数据，展示一组或多组数据的分布状况。关键词：统计、连续性</li>
</ul>
</li>
<li><strong>条形图</strong><ul>
<li><strong>定义</strong>：排列在工作表的列或行中的数据可绘制到条形图中。 </li>
<li><strong>特点</strong>：绘制离散的数据，能一眼看出各个数据的大小，便于比较数据之间的差别。关键词：统计、离散</li>
</ul>
</li>
<li><strong>散点图</strong><ul>
<li><strong>定义</strong>：用两组数据构成多个坐标点，考察坐标点的分布，判断两变量之间是否存在某种关联或总结坐标点的分布模式。</li>
<li><strong>特点</strong>：判断变量之间是否存在数量关联趋势，展示离群点。关键词：分布规律</li>
</ul>
</li>
</ol>
<pre><code>plt.eticks(x)
</code></pre>
<pre><code>     Add-Type -AssemblyName System.Drawing
     [System.Drawing.FontFamily]::Families | Select-Object Name
</code></pre>
<h2 id="绘制散点图"><a href="#绘制散点图" class="headerlink" title="绘制散点图"></a>绘制散点图</h2><p><img src="https://i.imgur.com/5RSqq6W.png"><br><img src="https://i.imgur.com/YRvtT1M.png"><br>import matplotlib.pyplot as plt<br>from matplotlib import font_manager</p>
<h3 id="初始化数据列表a和b，分别代表两个数据序列"><a href="#初始化数据列表a和b，分别代表两个数据序列" class="headerlink" title="初始化数据列表a和b，分别代表两个数据序列"></a>初始化数据列表a和b，分别代表两个数据序列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">11</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">21</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">22</span>,<span class="number">22</span>,<span class="number">23</span>]</span><br><span class="line">b =[<span class="number">26</span>,<span class="number">26</span>,<span class="number">28</span>,<span class="number">19</span>,<span class="number">21</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">19</span>,<span class="number">18</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">19</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">15</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">6</span>]</span><br><span class="line">x=<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">32</span>)</span><br><span class="line">x_2=<span class="built_in">range</span>(<span class="number">40</span>,<span class="number">71</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载本地字体文件，用于支持中文显示</span></span><br><span class="line">my_font = font_manager.FontProperties(fname=<span class="string">&quot;C:\\Windows\\Fonts\\Deng.ttf&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的图像对象，指定图像大小和分辨率</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">8</span>),dpi=<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制散点图，红色标记数据序列a</span></span><br><span class="line">plt.scatter(x,a,s=<span class="number">50</span>,c=<span class="string">&#x27;r&#x27;</span>,marker=<span class="string">&#x27;o&#x27;</span>,label=<span class="string">&#x27;point&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制散点图，蓝色标记数据序列b</span></span><br><span class="line">plt.scatter(x_2,b,s=<span class="number">50</span>,c=<span class="string">&#x27;b&#x27;</span>,marker=<span class="string">&#x27;o&#x27;</span>,label=<span class="string">&#x27;point&#x27;</span>)</span><br><span class="line"></span><br><span class="line">_x=<span class="built_in">list</span>(x)+<span class="built_in">list</span>(x_2)</span><br><span class="line"><span class="comment"># 生成x轴标签，表示月份</span></span><br><span class="line">_xtick_labels = [<span class="string">&quot;10月&#123;&#125;日&quot;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> _x]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x轴标签，旋转45度，使用自定义字体</span></span><br><span class="line">plt.xticks(_x[::<span class="number">3</span>],_xtick_labels[::<span class="number">3</span>],rotation=<span class="number">45</span>,fontproperties=my_font)</span><br><span class="line"></span><br><span class="line">plt.yticks(a)</span><br><span class="line"></span><br><span class="line">plt.legend(loc=<span class="string">&quot;upper left&quot;</span>,prop=my_font)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;十月/日&quot;</span>,fontproperties=my_font)</span><br><span class="line">plt.ylabel(<span class="string">&quot;温度/摄氏度&quot;</span>,fontproperties=my_font)</span><br><span class="line">plt.title(<span class="string">&quot;温度变化&quot;</span>,fontproperties=my_font)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图像为SVG格式文件</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;points.svg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 绘制柱状图，x轴为电影索引，y轴为票房数据  </span></span><br><span class="line">plt.barh(<span class="built_in">range</span>(<span class="built_in">len</span>(a)),b,height=<span class="number">0.5</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="绘制条形图"><a href="#绘制条形图" class="headerlink" title="绘制条形图"></a>绘制条形图</h2><p><img src="https://i.imgur.com/XSBid9n.png"></p>
<p><img src="https://i.imgur.com/3RSjJdh.png"><br>竖着的条形图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 导入绘图库和字体管理器</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载自定义字体文件</span></span><br><span class="line">my_font = font_manager.FontProperties(fname=<span class="string">&quot;C:\\Windows\\Fonts\\Deng.ttf&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备电影名称和对应的票房数据</span></span><br><span class="line">a = [<span class="string">&quot;战狼2&quot;</span>,<span class="string">&quot;速度与激情8&quot;</span>,<span class="string">&quot;功夫瑜伽&quot;</span>,<span class="string">&quot;西游伏妖篇&quot;</span>,<span class="string">&quot;变形金刚5：最后的骑士&quot;</span>,<span class="string">&quot;摔跤吧！爸爸&quot;</span>,<span class="string">&quot;加勒比海盗5：死无对证&quot;</span>,<span class="string">&quot;金刚：骷髅岛&quot;</span>,<span class="string">&quot;极限特工：终极回归&quot;</span>,<span class="string">&quot;生化危机6：终章&quot;</span>,<span class="string">&quot;乘风破浪&quot;</span>,<span class="string">&quot;神偷奶爸3&quot;</span>,<span class="string">&quot;智取威虎山&quot;</span>,<span class="string">&quot;大闹天竺&quot;</span>,<span class="string">&quot;金刚狼3：殊死一战&quot;</span>,<span class="string">&quot;蜘蛛侠：英雄归来&quot;</span>,<span class="string">&quot;悟空传&quot;</span>,<span class="string">&quot;银河护卫队2&quot;</span>,<span class="string">&quot;情圣&quot;</span>,<span class="string">&quot;新木乃伊&quot;</span>]</span><br><span class="line">b = [<span class="number">56.02</span>, <span class="number">26.94</span>, <span class="number">17.53</span>, <span class="number">16.49</span>, <span class="number">15.45</span>, <span class="number">12.96</span>, <span class="number">11.8</span>, <span class="number">11.61</span>, <span class="number">11.28</span>, <span class="number">11.12</span>, <span class="number">10.49</span>, <span class="number">10.3</span>, <span class="number">8.75</span>, <span class="number">7.55</span>, <span class="number">7.32</span>, <span class="number">6.99</span>, <span class="number">6.88</span>, <span class="number">6.86</span>, <span class="number">6.58</span>, <span class="number">6.23</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个新的图形对象，并设置图形的大小和分辨率</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">15</span>),dpi=<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制柱状图，x轴为电影索引，y轴为票房数据</span></span><br><span class="line">plt.bar(<span class="built_in">range</span>(<span class="built_in">len</span>(a)),b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x轴标签，使用自定义字体并旋转90度以适应长文本</span></span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="built_in">len</span>(a)),a,fontproperties=my_font,rotation=<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存图形到文件</span></span><br><span class="line">plt.savefig(<span class="string">&quot;./test1.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>横的条形图<br><img src="https://i.imgur.com/KWacwnN.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入绘图库和字体管理器  </span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 加载自定义字体文件  </span></span><br><span class="line">my_font = font_manager.FontProperties(fname=<span class="string">&quot;C:\\Windows\\Fonts\\Deng.ttf&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 准备电影名称和对应的票房数据  </span></span><br><span class="line">a = [<span class="string">&quot;战狼2&quot;</span>,<span class="string">&quot;速度与激情8&quot;</span>,<span class="string">&quot;功夫瑜伽&quot;</span>,<span class="string">&quot;西游伏妖篇&quot;</span>,<span class="string">&quot;变形金刚5：最后的骑士&quot;</span>,<span class="string">&quot;摔跤吧！爸爸&quot;</span>,<span class="string">&quot;加勒比海盗5：死无对证&quot;</span>,<span class="string">&quot;金刚：骷髅岛&quot;</span>,<span class="string">&quot;极限特工：终极回归&quot;</span>,<span class="string">&quot;生化危机6：终章&quot;</span>,<span class="string">&quot;乘风破浪&quot;</span>,<span class="string">&quot;神偷奶爸3&quot;</span>,<span class="string">&quot;智取威虎山&quot;</span>,<span class="string">&quot;大闹天竺&quot;</span>,<span class="string">&quot;金刚狼3：殊死一战&quot;</span>,<span class="string">&quot;蜘蛛侠：英雄归来&quot;</span>,<span class="string">&quot;悟空传&quot;</span>,<span class="string">&quot;银河护卫队2&quot;</span>,<span class="string">&quot;情圣&quot;</span>,<span class="string">&quot;新木乃伊&quot;</span>]  </span><br><span class="line">b = [<span class="number">56.02</span>, <span class="number">26.94</span>, <span class="number">17.53</span>, <span class="number">16.49</span>, <span class="number">15.45</span>, <span class="number">12.96</span>, <span class="number">11.8</span>, <span class="number">11.61</span>, <span class="number">11.28</span>, <span class="number">11.12</span>, <span class="number">10.49</span>, <span class="number">10.3</span>, <span class="number">8.75</span>, <span class="number">7.55</span>, <span class="number">7.32</span>, <span class="number">6.99</span>, <span class="number">6.88</span>, <span class="number">6.86</span>, <span class="number">6.58</span>, <span class="number">6.23</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建一个新的图形对象，并设置图形的大小和分辨率  </span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">8</span>),dpi=<span class="number">80</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 绘制柱状图，x轴为电影索引，y轴为票房数据  </span></span><br><span class="line">plt.barh(<span class="built_in">range</span>(<span class="built_in">len</span>(a)),b,height=<span class="number">0.5</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置x轴标签，使用自定义字体并旋转90度以适应长文本  </span></span><br><span class="line">plt.yticks(<span class="built_in">range</span>(<span class="built_in">len</span>(a)),a,fontproperties=my_font,rotation=<span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 保存图形到文件  </span></span><br><span class="line">plt.savefig(<span class="string">&quot;./test1.png&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示图形  </span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/Bg0KpVn.png"></p>
<h2 id="绘制多重条形图"><a href="#绘制多重条形图" class="headerlink" title="绘制多重条形图"></a>绘制多重条形图</h2><p><img src="https://i.imgur.com/xWxn5Y2.png"></p>
<p><img src="https://i.imgur.com/5HStiWy.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入绘图库和字体管理器  </span></span><br><span class="line">x_14=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(a)))  </span><br><span class="line">x_15=[i+bar_height <span class="keyword">for</span> i <span class="keyword">in</span> x_14]  </span><br><span class="line">x_16=[i+bar_height*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> x_14]  </span><br></pre></td></tr></table></figure>
<h2 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h2><p><img src="https://i.imgur.com/vWzAaG8.png"></p>
<h1 id="绘制直方图学习笔记"><a href="#绘制直方图学习笔记" class="headerlink" title="绘制直方图学习笔记"></a>绘制直方图学习笔记</h1><h2 id="一、直方图展示示例"><a href="#一、直方图展示示例" class="headerlink" title="一、直方图展示示例"></a>一、直方图展示示例</h2><p>图中展示了 [具体数量] 部电影的时长分布直方图，横坐标为电影时长，纵坐标为数量，直观呈现电影时长在不同区间的分布情况。</p>
<h2 id="二、关键概念"><a href="#二、关键概念" class="headerlink" title="二、关键概念"></a>二、关键概念</h2><h3 id="（一）组数"><a href="#（一）组数" class="headerlink" title="（一）组数"></a>（一）组数</h3><ul>
<li><strong>定义</strong>：将数据分组的数量。</li>
<li><strong>分组原则</strong>：当数据在 100 个以内时，一般按数据多少分 5 - 12 组 。组数要适当，太少会有较大统计误差，太多则规律不明显。</li>
<li><strong>计算方法</strong>：通过数据的极差（最大值 - 最小值）除以组距得到。</li>
</ul>
<h3 id="（二）组距"><a href="#（二）组距" class="headerlink" title="（二）组距"></a>（二）组距</h3><ul>
<li><strong>定义</strong>：每个小组的两个端点的距离。</li>
<li><strong>公式</strong>：组距 &#x3D; 极差 &#x2F; 组数 。</li>
</ul>
<h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><h3 id="（一）参数设置"><a href="#（一）参数设置" class="headerlink" title="（一）参数设置"></a>（一）参数设置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bin_width = <span class="number">3</span>  <span class="comment"># 设置组距为 3</span></span><br><span class="line">num_bins = <span class="built_in">int</span>((<span class="built_in">max</span>(a) - <span class="built_in">min</span>(a)) / bin_width)  <span class="comment"># 根据极差和组距计算分为多少组</span></span><br></pre></td></tr></table></figure>
<h3 id="（二）绘制直方图"><a href="#（二）绘制直方图" class="headerlink" title="（二）绘制直方图"></a>（二）绘制直方图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.hist(a, num_bins) </span><br><span class="line"><span class="comment"># 传入需要统计的数据 a 以及计算得到的组数 num_bins</span></span><br><span class="line"><span class="comment"># 若想传入自定义分组依据（用于组距不均匀时），可使用</span></span><br><span class="line"><span class="comment"># plt.hist(a, [min(a)+i*bin_width for i in range(num_bins)]) </span></span><br><span class="line"><span class="comment"># normed 参数：bool 类型，设置是否绘制频率分布直方图，默认绘制频数直方图，如需绘制频率分布直方图，可设为 normed=1</span></span><br></pre></td></tr></table></figure>
<h3 id="（三）坐标轴刻度设置"><a href="#（三）坐标轴刻度设置" class="headerlink" title="（三）坐标轴刻度设置"></a>（三）坐标轴刻度设置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.xticks(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">min</span>(a), <span class="built_in">max</span>(a))[::bin_width]), rotation=<span class="number">45</span>) </span><br><span class="line"><span class="comment"># 设置 x 轴刻度，从数据最小值到最大值，按组距选取刻度值，并将刻度标签旋转 45 度</span></span><br></pre></td></tr></table></figure>
<h3 id="（四）显示网格"><a href="#（四）显示网格" class="headerlink" title="（四）显示网格"></a>（四）显示网格</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.grid(<span class="literal">True</span>, linestyle = <span class="string">&quot;-.&quot;</span>, alpha=<span class="number">0.5</span>) </span><br><span class="line"><span class="comment"># 显示网格，linestyle 设置网格线样式为点划线，alpha 设置透明度为 0.5</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/O0C5ugX.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 加载自定义字体  </span></span><br><span class="line">my_font = font_manager.FontProperties(fname=<span class="string">&quot;C:\\Windows\\Fonts\\Deng.ttf&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 数据样本，用于绘制直方图  </span></span><br><span class="line">a = [<span class="number">131</span>, <span class="number">98</span>, <span class="number">125</span>, <span class="number">131</span>, <span class="number">124</span>, <span class="number">139</span>, <span class="number">131</span>, <span class="number">117</span>, <span class="number">128</span>, <span class="number">108</span>, <span class="number">135</span>, <span class="number">138</span>, <span class="number">131</span>, <span class="number">102</span>, <span class="number">107</span>, <span class="number">114</span>, <span class="number">119</span>, <span class="number">128</span>, <span class="number">121</span>, <span class="number">142</span>, <span class="number">127</span>, <span class="number">130</span>, <span class="number">124</span>, <span class="number">101</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">110</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">115</span>, <span class="number">99</span>, <span class="number">136</span>, <span class="number">126</span>, <span class="number">134</span>, <span class="number">95</span>, <span class="number">138</span>, <span class="number">117</span>, <span class="number">111</span>, <span class="number">78</span>, <span class="number">132</span>, <span class="number">124</span>, <span class="number">113</span>, <span class="number">150</span>, <span class="number">110</span>, <span class="number">117</span>, <span class="number">86</span>, <span class="number">95</span>, <span class="number">144</span>, <span class="number">105</span>, <span class="number">126</span>, <span class="number">130</span>, <span class="number">126</span>, <span class="number">130</span>, <span class="number">126</span>, <span class="number">116</span>, <span class="number">123</span>, <span class="number">106</span>, <span class="number">112</span>, <span class="number">138</span>, <span class="number">123</span>, <span class="number">86</span>, <span class="number">101</span>, <span class="number">99</span>, <span class="number">136</span>, <span class="number">123</span>, <span class="number">117</span>, <span class="number">119</span>, <span class="number">105</span>, <span class="number">137</span>, <span class="number">123</span>, <span class="number">128</span>, <span class="number">125</span>, <span class="number">104</span>, <span class="number">109</span>, <span class="number">134</span>, <span class="number">125</span>, <span class="number">127</span>, <span class="number">105</span>, <span class="number">120</span>, <span class="number">107</span>, <span class="number">129</span>, <span class="number">116</span>, <span class="number">108</span>, <span class="number">132</span>, <span class="number">103</span>, <span class="number">136</span>, <span class="number">118</span>, <span class="number">102</span>, <span class="number">120</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">115</span>, <span class="number">132</span>, <span class="number">145</span>, <span class="number">119</span>, <span class="number">121</span>, <span class="number">112</span>, <span class="number">139</span>, <span class="number">125</span>, <span class="number">138</span>, <span class="number">109</span>, <span class="number">132</span>, <span class="number">134</span>, <span class="number">156</span>, <span class="number">106</span>, <span class="number">117</span>, <span class="number">127</span>, <span class="number">144</span>, <span class="number">139</span>, <span class="number">139</span>, <span class="number">119</span>, <span class="number">140</span>, <span class="number">83</span>, <span class="number">110</span>, <span class="number">102</span>, <span class="number">123</span>, <span class="number">107</span>, <span class="number">143</span>, <span class="number">115</span>, <span class="number">136</span>, <span class="number">118</span>, <span class="number">139</span>, <span class="number">123</span>, <span class="number">112</span>, <span class="number">118</span>, <span class="number">125</span>, <span class="number">109</span>, <span class="number">119</span>, <span class="number">133</span>, <span class="number">112</span>, <span class="number">114</span>, <span class="number">122</span>, <span class="number">109</span>, <span class="number">106</span>, <span class="number">123</span>, <span class="number">116</span>, <span class="number">131</span>, <span class="number">127</span>, <span class="number">115</span>, <span class="number">118</span>, <span class="number">112</span>, <span class="number">135</span>, <span class="number">115</span>, <span class="number">146</span>, <span class="number">137</span>, <span class="number">116</span>, <span class="number">103</span>, <span class="number">144</span>, <span class="number">83</span>, <span class="number">123</span>, <span class="number">111</span>, <span class="number">110</span>, <span class="number">111</span>, <span class="number">100</span>, <span class="number">154</span>, <span class="number">136</span>, <span class="number">100</span>, <span class="number">118</span>, <span class="number">119</span>, <span class="number">133</span>, <span class="number">134</span>, <span class="number">106</span>, <span class="number">129</span>, <span class="number">126</span>, <span class="number">110</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">141</span>, <span class="number">120</span>, <span class="number">117</span>, <span class="number">106</span>, <span class="number">149</span>, <span class="number">122</span>, <span class="number">122</span>, <span class="number">110</span>, <span class="number">118</span>, <span class="number">127</span>, <span class="number">121</span>, <span class="number">114</span>, <span class="number">125</span>, <span class="number">126</span>, <span class="number">114</span>, <span class="number">140</span>, <span class="number">103</span>, <span class="number">130</span>, <span class="number">141</span>, <span class="number">117</span>, <span class="number">106</span>, <span class="number">114</span>, <span class="number">121</span>, <span class="number">114</span>, <span class="number">133</span>, <span class="number">137</span>, <span class="number">92</span>, <span class="number">121</span>, <span class="number">112</span>, <span class="number">146</span>, <span class="number">97</span>, <span class="number">137</span>, <span class="number">105</span>, <span class="number">98</span>, <span class="number">117</span>, <span class="number">112</span>, <span class="number">81</span>, <span class="number">97</span>, <span class="number">139</span>, <span class="number">113</span>, <span class="number">134</span>, <span class="number">106</span>, <span class="number">144</span>, <span class="number">110</span>, <span class="number">117</span>, <span class="number">137</span>, <span class="number">111</span>, <span class="number">104</span>, <span class="number">117</span>, <span class="number">100</span>, <span class="number">111</span>, <span class="number">101</span>, <span class="number">110</span>, <span class="number">105</span>, <span class="number">129</span>, <span class="number">137</span>, <span class="number">110</span>, <span class="number">112</span>, <span class="number">120</span>, <span class="number">113</span>, <span class="number">133</span>, <span class="number">112</span>, <span class="number">83</span>, <span class="number">94</span>, <span class="number">146</span>, <span class="number">133</span>, <span class="number">101</span>, <span class="number">131</span>, <span class="number">116</span>, <span class="number">111</span>, <span class="number">84</span>, <span class="number">137</span>, <span class="number">115</span>, <span class="number">122</span>, <span class="number">106</span>, <span class="number">144</span>, <span class="number">109</span>, <span class="number">123</span>, <span class="number">116</span>, <span class="number">111</span>, <span class="number">111</span>, <span class="number">133</span>, <span class="number">150</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建图形，设置图形大小和分辨率  </span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>), dpi=<span class="number">80</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 计算直方图的分组间隔  </span></span><br><span class="line">lim = (<span class="built_in">max</span>(a) - <span class="built_in">min</span>(a)) / <span class="number">10</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 初始化分组宽度，并寻找合适的分组宽度  </span></span><br><span class="line">d = <span class="number">2</span>  </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">max</span>(a) - <span class="built_in">min</span>(a)) % d != <span class="number">0</span> <span class="keyword">or</span> d &lt;= lim:  </span><br><span class="line">    d += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 根据分组宽度计算分组数  </span></span><br><span class="line">num_bins = (<span class="built_in">max</span>(a) - <span class="built_in">min</span>(a)) // d  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 输出数据范围  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(a) - <span class="built_in">min</span>(a))  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 绘制直方图  </span></span><br><span class="line">plt.hist(a, num_bins, rwidth=<span class="number">0.9</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 输出分组宽度  </span></span><br><span class="line"><span class="built_in">print</span>(d)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置x轴标签，使用自定义字体  </span></span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>, fontproperties=my_font)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 设置x轴刻度，使用自定义字体并旋转45度  </span></span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="built_in">min</span>(a), <span class="built_in">max</span>(a) + d, d), rotation=<span class="number">45</span>, fontproperties=my_font)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加网格，设置透明度  </span></span><br><span class="line">plt.grid(alpha=<span class="number">0.4</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示图形  </span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>缺数字的<br><img src="https://i.imgur.com/f4kGuTt.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> font_manager  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 字体设置  </span></span><br><span class="line"><span class="comment"># 加载本地字体文件，用于图形中的中文显示  </span></span><br><span class="line">my_font = font_manager.FontProperties(fname=<span class="string">&quot;C:\\Windows\\Fonts\\Deng.ttf&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 定义区间、宽度和数量列表  </span></span><br><span class="line"><span class="comment"># interval代表数据区间的上限值  </span></span><br><span class="line">interval = [<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">40</span>, <span class="number">45</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">150</span>]  </span><br><span class="line"><span class="comment"># width代表每个区间的数据宽度，大部分区间宽度为5，部分区间较宽  </span></span><br><span class="line">width = [<span class="number">5</span>] * <span class="number">10</span> + [<span class="number">15</span>, <span class="number">30</span>, <span class="number">60</span>]  </span><br><span class="line"><span class="comment"># quantity代表每个区间的数据数量  </span></span><br><span class="line">quantity = [<span class="number">836</span>, <span class="number">2737</span>, <span class="number">3723</span>, <span class="number">3926</span>, <span class="number">3596</span>, <span class="number">1438</span>, <span class="number">3273</span>, <span class="number">642</span>, <span class="number">824</span>, <span class="number">613</span>, <span class="number">215</span>, <span class="number">47</span>, <span class="number">23</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印宽度、数量和区间列表的长度，用于调试  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(width), <span class="built_in">len</span>(quantity),<span class="built_in">len</span>(interval))  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建图形，设置图形大小和清晰度  </span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">8</span>),dpi=<span class="number">80</span>)  </span><br><span class="line"><span class="comment"># 绘制柱状图  </span></span><br><span class="line"><span class="comment"># 使用quantity列表的数据，x轴为quantity列表的索引，y轴为quantity的值，柱子宽度为1  </span></span><br><span class="line">plt.bar(<span class="built_in">range</span>(<span class="built_in">len</span>(quantity)) ,quantity,width=<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 计算x轴标签位置，标签位于每个区间的中间  </span></span><br><span class="line">_x=[i-<span class="number">0.5</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>)]  </span><br><span class="line"><span class="comment"># 设置x轴标签，使其显示为定义的区间值  </span></span><br><span class="line">_xtick_labels =interval+[<span class="number">150</span>]  </span><br><span class="line">plt.xticks(_x,_xtick_labels)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 添加网格，alpha参数设置网格的透明度，便于观察图形细节  </span></span><br><span class="line">plt.grid(alpha=<span class="number">0.4</span>)  </span><br><span class="line"><span class="comment"># 显示图形  </span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="其他的图形"><a href="#其他的图形" class="headerlink" title="其他的图形"></a>其他的图形</h2><p><a href="https://plotly.com/python/line-and-scatter/">https://plotly.com/python/line-and-scatter/</a><br><a href="https://echarts.apache.org/handbook/zh/get-started/">https://echarts.apache.org/handbook/zh/get-started/</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算x轴标签位置，标签位于每个区间的中间  </span></span><br><span class="line">_x=[i-<span class="number">0.5</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">14</span>)]  </span><br><span class="line"><span class="comment"># 设置x轴标签，使其显示为定义的区间值  </span></span><br><span class="line">_xtick_labels =interval+[<span class="number">150</span>]  </span><br><span class="line">plt.xticks(_x,_xtick_labels)  </span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章：Pandas</title>
    <url>/2025/05/12/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9APandas/</url>
    <content><![CDATA[<p>&#x2F;Pandas 是一个强大的 Python 数据分析和处理库。它提供了快速、灵活和富有表现力的数据结构，旨在使处理结构化（表格化、多维数组、时间序列）和非结构化数据变得简单直观。</p>
<p><strong>Pandas 的核心数据结构：</strong></p>
<ol>
<li><p><strong>Series（序列）</strong></p>
<ul>
<li>Series 是一种一维带标签的数组，可以存储任何数据类型（整数、浮点数、字符串、Python 对象等）。</li>
<li>它类似于 NumPy 的一维数组，但多了标签（索引）功能。</li>
<li>索引可以是数字、字符串或任何其他不可变对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从列表创建 Series</span></span><br><span class="line">data = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]</span><br><span class="line">s = pd.Series(data)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># 0    10</span></span><br><span class="line"><span class="comment"># 1    20</span></span><br><span class="line"><span class="comment"># 2    30</span></span><br><span class="line"><span class="comment"># 3    40</span></span><br><span class="line"><span class="comment"># 4    50</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从字典创建 Series (键变为索引)</span></span><br><span class="line">data = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">20</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">30</span>&#125;</span><br><span class="line">s = pd.Series(data)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># a    10</span></span><br><span class="line"><span class="comment"># b    20</span></span><br><span class="line"><span class="comment"># c    30</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定索引</span></span><br><span class="line">s = pd.Series(data, index=[<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># b    20.0</span></span><br><span class="line"><span class="comment"># c    30.0</span></span><br><span class="line"><span class="comment"># d     NaN</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DataFrame（数据框）</strong></p>
<ul>
<li>DataFrame 是一个二维带标签的数据结构，可以看作是 Series 的容器。</li>
<li>它类似于电子表格或 SQL 表格，由行和列组成。</li>
<li>每一列可以是不同的数据类型。</li>
<li>DataFrame 是 Pandas 中最常用的数据结构。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从字典创建 DataFrame</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">28</span>],</span><br><span class="line">    <span class="string">&#x27;City&#x27;</span>: [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;London&#x27;</span>, <span class="string">&#x27;Paris&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment">#        Name  Age      City</span></span><br><span class="line"><span class="comment"># 0     Alice   25  New York</span></span><br><span class="line"><span class="comment"># 1       Bob   30    London</span></span><br><span class="line"><span class="comment"># 2  Charlie   28     Paris</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从列表的列表创建 DataFrame</span></span><br><span class="line">data = [[<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;New York&#x27;</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;London&#x27;</span>], [<span class="string">&#x27;Charlie&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;Paris&#x27;</span>]]</span><br><span class="line">df = pd.DataFrame(data, columns=[<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;City&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment">#        Name  Age      City</span></span><br><span class="line"><span class="comment"># 0     Alice   25  New York</span></span><br><span class="line"><span class="comment"># 1       Bob   30    London</span></span><br><span class="line"><span class="comment"># 2  Charlie   28     Paris</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>Pandas 的主要功能：</strong></p>
<ul>
<li><p><strong>数据导入&#x2F;导出：</strong></p>
<ul>
<li>Pandas 可以从各种格式的文件中读取数据，例如 CSV、Excel、SQL 数据库、JSON 等。</li>
<li>也可以将数据导出到这些格式。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取 CSV 文件</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 Excel 文件</span></span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;data.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入 CSV 文件</span></span><br><span class="line">df.to_csv(<span class="string">&#x27;output.csv&#x27;</span>, index=<span class="literal">False</span>) <span class="comment"># index=False 避免写入索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入 Excel 文件</span></span><br><span class="line">df.to_excel(<span class="string">&#x27;output.xlsx&#x27;</span>, sheet_name=<span class="string">&#x27;Sheet1&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义文件路径，使用原始字符串避免转义问题</span></span><br><span class="line">file_path = <span class="string">r&#x27;F:\PythonProject2\numpy\youtube_video_data\GB_video_data_numbers.csv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查文件是否存在</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(file_path):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 尝试使用 UTF-8 编码读取 CSV 文件</span></span><br><span class="line">        df = pd.read_csv(file_path, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="comment"># 打印 DataFrame 的前几行，用于预览数据</span></span><br><span class="line">        <span class="built_in">print</span>(df.head())</span><br><span class="line">    <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">        <span class="comment"># 如果 UTF-8 解码失败，则尝试使用 GBK 编码</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;UTF-8 decoding failed, trying GBK...&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 尝试使用 GBK 编码读取 CSV 文件</span></span><br><span class="line">            df = pd.read_csv(file_path, encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">            <span class="comment"># 打印 DataFrame 的前几行，用于预览数据</span></span><br><span class="line">            <span class="built_in">print</span>(df.head())</span><br><span class="line">        <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">            <span class="comment"># 如果 GBK 解码失败，则尝试使用 Latin-1 编码</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;GBK decoding failed, trying latin1...&quot;</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 尝试使用 Latin-1 编码读取 CSV 文件</span></span><br><span class="line">                df = pd.read_csv(file_path, encoding=<span class="string">&#x27;latin1&#x27;</span>)</span><br><span class="line">                <span class="comment"># 打印 DataFrame 的前几行，用于预览数据</span></span><br><span class="line">                <span class="built_in">print</span>(df.head())</span><br><span class="line">            <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">                <span class="comment"># 如果所有解码尝试都失败，则提示用户检查文件编码</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;All decoding attempts failed.  Please check the file encoding.&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 捕获其他可能发生的异常，并打印错误信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;An error occurred: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 如果文件不存在，则打印错误信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: File not found at <span class="subst">&#123;file_path&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>数据清洗：</strong></p>
<ul>
<li>处理缺失值（<code>dropna()</code>, <code>fillna()</code>）</li>
<li>删除重复值（<code>drop_duplicates()</code>）</li>
<li>数据类型转换（<code>astype()</code>）</li>
<li>字符串处理（<code>str</code> 属性，例如 <code>str.lower()</code>, <code>str.replace()</code>）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 处理缺失值</span></span><br><span class="line">df.dropna()  <span class="comment"># 删除包含缺失值的行</span></span><br><span class="line">df.fillna(<span class="number">0</span>) <span class="comment"># 用 0 填充缺失值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除重复行</span></span><br><span class="line">df.drop_duplicates()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据类型转换</span></span><br><span class="line">df[<span class="string">&#x27;Age&#x27;</span>] = df[<span class="string">&#x27;Age&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串处理</span></span><br><span class="line">df[<span class="string">&#x27;Name&#x27;</span>] = df[<span class="string">&#x27;Name&#x27;</span>].<span class="built_in">str</span>.lower() <span class="comment"># 将 Name 列转换为小写</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据选择和过滤：</strong></p>
<ul>
<li>使用标签（<code>loc[]</code>）或位置（<code>iloc[]</code>）选择数据</li>
<li>使用条件表达式过滤数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用标签选择行和列</span></span><br><span class="line">df.loc[<span class="number">0</span>, <span class="string">&#x27;Name&#x27;</span>]  <span class="comment"># 选择第一行 &#x27;Name&#x27; 列的值</span></span><br><span class="line">df.loc[<span class="number">1</span>:<span class="number">3</span>, [<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>]] <span class="comment"># 选择 2-4 行的 &#x27;Name&#x27; 和 &#x27;Age&#x27; 列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用位置选择行和列</span></span><br><span class="line">df.iloc[<span class="number">0</span>, <span class="number">0</span>]  <span class="comment"># 选择第一行第一列的值</span></span><br><span class="line">df.iloc[<span class="number">1</span>:<span class="number">3</span>, <span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 选择 2-3 行的 1-2 列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用条件表达式过滤数据</span></span><br><span class="line">df[df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">25</span>] <span class="comment"># 选择 Age 大于 25 的行</span></span><br><span class="line">df[(df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">25</span>) &amp; (df[<span class="string">&#x27;City&#x27;</span>] == <span class="string">&#x27;London&#x27;</span>)] <span class="comment"># 选择 Age 大于 25 且 City 为 London 的行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据转换：</strong></p>
<ul>
<li>添加&#x2F;删除列（<code>df[&#39;NewColumn&#39;] = ...</code>, <code>df.drop(&#39;Column&#39;, axis=1)</code>）</li>
<li>排序（<code>sort_values()</code>）</li>
<li>分组（<code>groupby()</code>）</li>
<li>聚合（<code>sum()</code>, <code>mean()</code>, <code>count()</code>, <code>min()</code>, <code>max()</code>）</li>
<li>透视表（<code>pivot_table()</code>）</li>
<li>应用自定义函数（<code>apply()</code>）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加新列</span></span><br><span class="line">df[<span class="string">&#x27;Salary&#x27;</span>] = df[<span class="string">&#x27;Age&#x27;</span>] * <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除列</span></span><br><span class="line">df = df.drop(<span class="string">&#x27;City&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line">df = df.sort_values(<span class="string">&#x27;Age&#x27;</span>, ascending=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分组和聚合</span></span><br><span class="line">grouped = df.groupby(<span class="string">&#x27;City&#x27;</span>)[<span class="string">&#x27;Age&#x27;</span>].mean() <span class="comment"># 按 City 分组，计算 Age 的平均值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 透视表</span></span><br><span class="line">pivot_table = pd.pivot_table(df, values=<span class="string">&#x27;Age&#x27;</span>, index=<span class="string">&#x27;City&#x27;</span>, columns=<span class="string">&#x27;Name&#x27;</span>, aggfunc=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用自定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">categorize_age</span>(<span class="params">age</span>):</span><br><span class="line">    <span class="keyword">if</span> age &lt; <span class="number">25</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Young&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> age &lt; <span class="number">35</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Adult&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Senior&#x27;</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;AgeCategory&#x27;</span>] = df[<span class="string">&#x27;Age&#x27;</span>].apply(categorize_age)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据合并&#x2F;连接：</strong></p>
<ul>
<li><code>concat()</code>：沿轴连接 Pandas 对象</li>
<li><code>merge()</code>：类似于 SQL 的 JOIN 操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># concat</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>], <span class="string">&#x27;B&#x27;</span>: [<span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="number">5</span>, <span class="number">6</span>], <span class="string">&#x27;B&#x27;</span>: [<span class="number">7</span>, <span class="number">8</span>]&#125;)</span><br><span class="line">df = pd.concat([df1, df2])</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;ID&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&#x27;ID&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], <span class="string">&#x27;Salary&#x27;</span>: [<span class="number">50000</span>, <span class="number">60000</span>, <span class="number">70000</span>]&#125;)</span><br><span class="line">df = pd.merge(df1, df2, on=<span class="string">&#x27;ID&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>) <span class="comment"># 左连接</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>时间序列分析：</strong></p>
<ul>
<li>Pandas 对时间序列数据有很好的支持。</li>
<li>可以创建时间序列索引，进行时间序列的切片、重采样、移动窗口统计等操作。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建时间序列</span></span><br><span class="line">dates = pd.date_range(<span class="string">&#x27;2023-01-01&#x27;</span>, periods=<span class="number">10</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">ts = pd.Series(<span class="built_in">range</span>(<span class="number">10</span>), index=dates)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重采样</span></span><br><span class="line">ts.resample(<span class="string">&#x27;W&#x27;</span>).<span class="built_in">sum</span>() <span class="comment"># 按周重采样，计算每周的总和</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Pandas 的优势：</strong></p>
<ul>
<li><strong>易于使用：</strong> Pandas 提供了简洁直观的 API，使得数据处理变得容易。</li>
<li><strong>高性能：</strong> Pandas 基于 NumPy 构建，底层使用 C 语言实现，因此具有很高的性能。</li>
<li><strong>功能强大：</strong> Pandas 提供了丰富的功能，可以满足各种数据分析和处理需求。</li>
<li><strong>与其他库集成：</strong> Pandas 可以与 NumPy、Matplotlib、Scikit-learn 等其他 Python 库无缝集成。</li>
</ul>
<p><strong>学习 Pandas 的建议：</strong></p>
<ul>
<li>从 Pandas 的官方文档开始：<a href="https://pandas.pydata.org/docs/">https://pandas.pydata.org/docs/</a></li>
<li>学习 Pandas 的核心数据结构：Series 和 DataFrame。</li>
<li>掌握 Pandas 的主要功能：数据导入&#x2F;导出、数据清洗、数据选择和过滤、数据转换、数据合并&#x2F;连接、时间序列分析。</li>
<li>多做练习，通过实际项目来巩固所学知识。</li>
</ul>
<p>Pandas 是数据科学领域中不可或缺的工具。 掌握 Pandas 可以让你更高效地处理和分析数据，从而做出更好的决策。</p>
]]></content>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章：程序流程的控制</title>
    <url>/2025/05/12/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>Java 的分支结构允许程序根据不同的条件执行不同的代码块。 主要有两种类型的分支结构：</p>
<p><strong>1. <code>if</code> 语句</strong></p>
<p><code>if</code> 语句是最基本的分支结构。 它根据一个布尔表达式的值来决定是否执行一个代码块。</p>
<ul>
<li><p><strong><code>if</code> 语句的基本语法:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔表达式) &#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式为 true，则执行这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>示例:</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;你已经成年了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>if-else</code> 语句:</strong></p>
<p><code>if-else</code> 语句在 <code>if</code> 条件不满足时，执行 <code>else</code> 代码块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔表达式) &#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式为 true，则执行这里的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式为 false，则执行这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>示例:</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;你已经成年了&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;你还没有成年&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>if-else if-else</code> 语句:</strong></p>
<p><code>if-else if-else</code> 语句允许你检查多个条件。  它按顺序评估每个 <code>if</code> 和 <code>else if</code> 的布尔表达式，如果找到一个为 <code>true</code> 的表达式，则执行相应的代码块。 如果所有条件都不满足，则执行 <code>else</code> 代码块（如果存在）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (布尔表达式<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式1为 true，则执行这里的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (布尔表达式<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式2为 true，则执行这里的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (布尔表达式<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式3为 true，则执行这里的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果所有布尔表达式都为 false，则执行这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>示例:</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">85</span>;</span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">90</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">80</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;中等&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. <code>switch</code> 语句</strong></p>
<p><code>switch</code> 语句提供了一种更简洁的方式来根据一个变量的值执行不同的代码块。  它通常用于处理多个离散值的情况。</p>
<ul>
<li><p><strong><code>switch</code> 语句的基本语法:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 如果表达式的值等于 值1，则执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 如果表达式的值等于 值2，则执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">        <span class="comment">// 如果表达式的值等于 值3，则执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 如果表达式的值与所有 case 值都不匹配，则执行这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>表达式</code>:</strong>  必须是一个可以转换为 <code>int</code>、<code>short</code>、<code>byte</code>、<code>char</code>、<code>String</code> (Java 7 及以上) 或 <code>enum</code> 类型的表达式。</li>
<li><strong><code>case 值</code>:</strong>  必须是与表达式类型兼容的常量值。</li>
<li><strong><code>break</code> 语句:</strong>  <code>break</code> 语句用于在执行完一个 <code>case</code> 代码块后跳出 <code>switch</code> 语句。 如果省略 <code>break</code> 语句，程序将继续执行下一个 <code>case</code> 代码块，直到遇到 <code>break</code> 语句或 <code>switch</code> 语句结束（称为 “fall-through”）。</li>
<li><strong><code>default</code> 语句:</strong>  <code>default</code> 语句是可选的。  如果表达式的值与所有 <code>case</code> 值都不匹配，则执行 <code>default</code> 代码块。</li>
</ul>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">String dayName;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        dayName = <span class="string">&quot;星期一&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        dayName = <span class="string">&quot;星期二&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        dayName = <span class="string">&quot;星期三&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        dayName = <span class="string">&quot;星期四&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        dayName = <span class="string">&quot;星期五&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        dayName = <span class="string">&quot;星期六&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        dayName = <span class="string">&quot;星期日&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        dayName = <span class="string">&quot;无效的日期&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;今天是：&quot;</span> + dayName);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>if</code> 语句 vs. <code>switch</code> 语句:</strong></p>
<ul>
<li><strong><code>if</code> 语句:</strong>  更灵活，可以处理更复杂的条件，例如范围检查和逻辑组合。</li>
<li><strong><code>switch</code> 语句:</strong>  更简洁，更易于阅读，适用于处理多个离散值的情况。  但 <code>switch</code> 语句的表达式类型有限制。</li>
</ul>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>Java 的循环结构允许你重复执行一段代码，直到满足特定条件为止。 Java 提供了三种主要的循环结构：</p>
<p><strong>1. <code>for</code> 循环</strong></p>
<p><code>for</code> 循环通常用于在知道循环次数的情况下重复执行代码块。</p>
<ul>
<li><p><strong><code>for</code> 循环的基本语法:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 条件; 更新) &#123;</span><br><span class="line">    <span class="comment">// 循环体：要重复执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>初始化:</strong>  在循环开始前执行一次。 通常用于声明和初始化循环计数器。</li>
<li><strong>条件:</strong>  在每次循环迭代之前评估。 如果条件为 <code>true</code>，则执行循环体。 如果条件为 <code>false</code>，则循环结束。</li>
<li><strong>更新:</strong>  在每次循环迭代之后执行。 通常用于更新循环计数器。</li>
</ul>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子会打印出 i 从 0 到 9 的值。</p>
</li>
<li><p><strong>增强型 <code>for</code> 循环 (也称为 “for-each” 循环):</strong></p>
<p>增强型 <code>for</code> 循环用于遍历数组或集合中的元素。  它简化了遍历过程，无需手动管理索引。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (元素类型 元素变量 : 数组或集合) &#123;</span><br><span class="line">    <span class="comment">// 循环体：使用 元素变量 访问当前元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>示例:</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> number : numbers) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;number = &quot;</span> + number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子会打印出数组 <code>numbers</code> 中的每个元素。</p>
</li>
</ul>
<p><strong>2. <code>while</code> 循环</strong></p>
<p><code>while</code> 循环在条件为 <code>true</code> 的情况下重复执行代码块。  它通常用于在循环次数未知的情况下重复执行代码。</p>
<ul>
<li><p><strong><code>while</code> 循环的基本语法:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 循环体：要重复执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>条件:</strong>  在每次循环迭代之前评估。 如果条件为 <code>true</code>，则执行循环体。 如果条件为 <code>false</code>，则循环结束。</li>
</ul>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子会打印出 count 从 0 到 4 的值。</p>
</li>
</ul>
<p><strong>3. <code>do-while</code> 循环</strong></p>
<p><code>do-while</code> 循环与 <code>while</code> 循环类似，但它保证循环体至少执行一次，即使条件一开始就为 <code>false</code>。</p>
<ul>
<li><p><strong><code>do-while</code> 循环的基本语法:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体：要重复执行的代码</span></span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>条件:</strong>  在每次循环迭代之后评估。 如果条件为 <code>true</code>，则继续循环。 如果条件为 <code>false</code>，则循环结束。</li>
</ul>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;number = &quot;</span> + number);</span><br><span class="line">    number++;</span><br><span class="line">&#125; <span class="keyword">while</span> (number &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>这个例子会打印出 number &#x3D; 10，即使 number 一开始就大于 5。</p>
</li>
</ul>
<p><strong>循环控制语句:</strong></p>
<ul>
<li><p><strong><code>break</code> 语句:</strong>  <code>break</code> 语句用于立即终止循环，并跳出循环体。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 当 i 等于 5 时，终止循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>continue</code> 语句:</strong>  <code>continue</code> 语句用于跳过当前循环迭代的剩余代码，并开始下一次迭代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 当 i 是偶数时，跳过本次迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i); <span class="comment">// 只打印奇数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>选择哪种循环结构:</strong></p>
<ul>
<li><strong><code>for</code> 循环:</strong>  当你知道循环次数时，使用 <code>for</code> 循环。</li>
<li><strong>增强型 <code>for</code> 循环:</strong>  当需要遍历数组或集合时，使用增强型 <code>for</code> 循环。</li>
<li><strong><code>while</code> 循环:</strong>  当循环次数未知，并且需要在循环开始前检查条件时，使用 <code>while</code> 循环。</li>
<li><strong><code>do-while</code> 循环:</strong>  当循环次数未知，并且需要保证循环体至少执行一次时，使用 <code>do-while</code> 循环。</li>
</ul>
<p><strong>注意事项:</strong></p>
<ul>
<li><strong>避免无限循环:</strong>  确保循环条件最终会变为 <code>false</code>，否则循环将永远执行下去。</li>
<li><strong>循环体内的代码:</strong>  确保循环体内的代码能够正确地更新循环条件，以便循环能够正常结束。</li>
<li><strong>循环嵌套:</strong>  可以在一个循环内部嵌套另一个循环。  但是，要小心嵌套循环的复杂性，避免出现性能问题。</li>
</ul>
<h2 id="跳转关键字"><a href="#跳转关键字" class="headerlink" title="跳转关键字"></a>跳转关键字</h2><p>在 Java 中，跳转关键字用于改变程序的执行流程，使其跳转到代码中的其他位置。 主要有以下三个跳转关键字：</p>
<p><strong>1. <code>break</code></strong></p>
<ul>
<li><p><strong>作用:</strong> <code>break</code> 语句用于立即终止循环（<code>for</code>、<code>while</code>、<code>do-while</code>）或 <code>switch</code> 语句的执行。</p>
</li>
<li><p><strong>用法:</strong></p>
<ul>
<li><strong>在循环中:</strong> <code>break</code> 语句会跳出当前循环，程序会继续执行循环之后的代码。</li>
<li><strong>在 <code>switch</code> 语句中:</strong> <code>break</code> 语句用于防止 “fall-through” 行为，即在执行完一个 <code>case</code> 代码块后，跳出 <code>switch</code> 语句。</li>
</ul>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在循环中使用 break</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 当 i 等于 5 时，终止循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// i = 0</span></span><br><span class="line"><span class="comment">// i = 1</span></span><br><span class="line"><span class="comment">// i = 2</span></span><br><span class="line"><span class="comment">// i = 3</span></span><br><span class="line"><span class="comment">// i = 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 switch 语句中使用 break</span></span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">String dayName;</span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        dayName = <span class="string">&quot;星期一&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        dayName = <span class="string">&quot;星期二&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        dayName = <span class="string">&quot;星期三&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        dayName = <span class="string">&quot;未知&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;今天是：&quot;</span> + dayName); <span class="comment">// 输出: 今天是：星期三</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. <code>continue</code></strong></p>
<ul>
<li><p><strong>作用:</strong> <code>continue</code> 语句用于跳过当前循环迭代的剩余代码，并开始下一次迭代。</p>
</li>
<li><p><strong>用法:</strong> <code>continue</code> 语句只能在循环中使用（<code>for</code>、<code>while</code>、<code>do-while</code>）。</p>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 当 i 是偶数时，跳过本次迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;i = &quot;</span> + i); <span class="comment">// 只打印奇数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// i = 1</span></span><br><span class="line"><span class="comment">// i = 3</span></span><br><span class="line"><span class="comment">// i = 5</span></span><br><span class="line"><span class="comment">// i = 7</span></span><br><span class="line"><span class="comment">// i = 9</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3. <code>return</code></strong></p>
<ul>
<li><p><strong>作用:</strong> <code>return</code> 语句用于从方法中返回。  它可以返回一个值（如果方法声明了返回类型），或者不返回任何值（如果方法声明为 <code>void</code>）。</p>
</li>
<li><p><strong>用法:</strong> <code>return</code> 语句可以在任何方法中使用。  当执行到 <code>return</code> 语句时，方法会立即终止，并将控制权返回给调用者。</p>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不返回任何值 (void 方法)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 可选，通常省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum); <span class="comment">// 输出: Sum: 8</span></span><br><span class="line"></span><br><span class="line">    printMessage(<span class="string">&quot;Hello, world!&quot;</span>); <span class="comment">// 输出: Hello, world!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>总结:</strong></p>
<ul>
<li><code>break</code> 用于终止循环或 <code>switch</code> 语句。</li>
<li><code>continue</code> 用于跳过当前循环迭代。</li>
<li><code>return</code> 用于从方法中返回。</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章：Java程序的基本语法</title>
    <url>/2025/05/12/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9AJava%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Java 中的注释主要有三种类型：</p>
<ol>
<li><p><strong>单行注释</strong>：使用 <code>//</code> 开始，直到行尾的所有内容都会被视为注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个单行注释</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 这也是一个单行注释</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多行注释</strong>：使用 <code>/*</code> 开始，以 <code>*/</code> 结束。可以跨越多行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这是一个多行注释。</span></span><br><span class="line"><span class="comment"> * 可以用来解释一段代码的功能或者其他信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文档注释</strong>：使用 <code>/**</code> 开始，以 <code>*/</code> 结束。这种注释类型主要用于生成 API 文档（例如，使用 Javadoc 工具）。文档注释可以包含特定的标签（例如 <code>@param</code>, <code>@return</code>, <code>@throws</code> 等）来描述类、方法、字段等的详细信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个文档注释。</span></span><br><span class="line"><span class="comment"> * 用于描述类或方法的用途。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a  第一个参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> b  第二个参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>   返回两个参数的和</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总结：</p>
<ul>
<li><code>//</code>：单行注释</li>
<li><code>/* ... */</code>：多行注释</li>
<li><code>/** ... */</code>：文档注释 (用于 Javadoc)</li>
</ul>
<p>可以使用代码自动生成注释</p>
<h2 id="认识字面量"><a href="#认识字面量" class="headerlink" title="认识字面量"></a>认识字面量</h2><p>Java 中的字面量（Literals）是指在源代码中直接表示固定值的符号。它们是程序中直接使用的数据值，不需要计算或转换。Java 支持多种类型的字面量，包括：</p>
<ol>
<li><p><strong>整数字面量</strong>：</p>
<ul>
<li>十进制：直接写数字，如 <code>10</code>, <code>123</code>, <code>4567</code>。</li>
<li>八进制：以 <code>0</code> 开头，如 <code>012</code> (十进制的 10)。</li>
<li>十六进制：以 <code>0x</code> 或 <code>0X</code> 开头，如 <code>0xA</code> (十进制的 10), <code>0xFF</code> (十进制的 255)。</li>
<li>二进制：以 <code>0b</code> 或 <code>0B</code> 开头（Java 7+），如 <code>0b1010</code> (十进制的 10)。</li>
<li>长整型：在数字后加 <code>L</code> 或 <code>l</code>，如 <code>1234567890123L</code>。</li>
</ul>
</li>
<li><p><strong>浮点数字面量</strong>：</p>
<ul>
<li>单精度浮点数（float）：在数字后加 <code>F</code> 或 <code>f</code>，如 <code>3.14F</code>, <code>2.0f</code>。</li>
<li>双精度浮点数（double）：直接写数字，或者在数字后加 <code>D</code> 或 <code>d</code>，如 <code>3.14</code>, <code>2.0d</code>, <code>2.0D</code>。</li>
</ul>
</li>
<li><p><strong>布尔字面量</strong>：</p>
<ul>
<li><code>true</code> 和 <code>false</code>。</li>
</ul>
</li>
<li><p><strong>字符字面量</strong>：</p>
<ul>
<li>用单引号括起来的单个字符，如 <code>&#39;A&#39;</code>, <code>&#39;9&#39;</code>, <code>&#39;#&#39;</code>。</li>
<li>转义字符：用反斜杠 <code>\</code> 开头的特殊字符，如 <code>&#39;\n&#39;</code> (换行), <code>&#39;\t&#39;</code> (制表符), <code>&#39;\\&#39;</code> (反斜杠), <code>&#39;\&#39;&#39;</code> (单引号), <code>&#39;\&quot;&#39;</code> (双引号)。</li>
</ul>
</li>
<li><p><strong>字符串字面量</strong>：</p>
<ul>
<li>用双引号括起来的字符序列，如 <code>&quot;Hello&quot;</code>, <code>&quot;Java&quot;</code>, <code>&quot;123&quot;</code>。</li>
</ul>
</li>
<li><p><strong>空字面量</strong>：</p>
<ul>
<li><code>null</code>：表示一个空引用，即没有任何对象。</li>
</ul>
</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">decimalInt</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">octalInt</span> <span class="operator">=</span> <span class="number">012</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">hexInt</span> <span class="operator">=</span> <span class="number">0xA</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">binaryInt</span> <span class="operator">=</span> <span class="number">0b1010</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">longInt</span> <span class="operator">=</span> <span class="number">1234567890123L</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="variable">floatNum</span> <span class="operator">=</span> <span class="number">3.14F</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">doubleNum</span> <span class="operator">=</span> <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">boolValue</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">charValue</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">newline</span> <span class="operator">=</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">stringValue</span> <span class="operator">=</span> <span class="string">&quot;Hello, Java!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">nullObject</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>字面量是源代码中直接表示值的符号。</li>
<li>Java 支持整型、浮点型、布尔型、字符型、字符串型和空字面量。</li>
<li>不同类型的字面量有不同的表示方式和规则。</li>
</ul>
<h2 id="认识变量"><a href="#认识变量" class="headerlink" title="认识变量"></a>认识变量</h2><p>变量是计算机程序中用于存储和表示数据的命名存储位置。你可以把变量想象成一个容器，它可以存放不同类型的信息，例如数字、文本、列表等等。在程序执行过程中，变量的值可以改变。</p>
<p>以下是关于变量的一些关键概念：</p>
<ul>
<li><strong>命名：</strong> 每个变量都有一个唯一的名称，用于在程序中引用它。变量名应该具有描述性，能够清晰地表达变量所代表的含义。</li>
<li><strong>类型：</strong> 变量具有数据类型，例如整数、浮点数、字符串、布尔值等。数据类型决定了变量可以存储的数据种类以及可以对变量执行的操作。</li>
<li><strong>赋值：</strong> 使用赋值运算符（例如 <code>=</code>）将值存储到变量中。例如，<code>x = 10</code> 将整数值 <code>10</code> 赋值给变量 <code>x</code>。</li>
<li><strong>作用域：</strong> 变量的作用域指的是变量在程序中可见和可访问的范围。变量的作用域可以是全局的（在整个程序中可见）或局部的（仅在特定的代码块中可见）。</li>
</ul>
<h3 id="变量的特点"><a href="#变量的特点" class="headerlink" title="变量的特点"></a>变量的特点</h3><p>变量有以下几个主要特点：</p>
<ol>
<li><strong>可变性：</strong> 变量的值可以在程序执行过程中被修改。这是变量最核心的特性。</li>
<li><strong>命名性：</strong> 每个变量都有一个唯一的名称（标识符），通过这个名称可以在程序中引用和访问变量。</li>
<li><strong>类型性：</strong> 变量具有特定的数据类型，例如整数、浮点数、字符串等。变量的类型决定了它可以存储的数据种类以及可以执行的操作。</li>
<li><strong>存储性：</strong> 变量在计算机内存中占据一定的存储空间，用于存储变量的值。</li>
<li><strong>作用域：</strong> 变量的作用域定义了变量在程序中可以被访问的范围。变量可以是全局的（在整个程序中可见）或局部的（仅在特定代码块中可见）。</li>
<li><strong>生命周期：</strong> 变量的生命周期指的是变量从创建到销毁的时间段。变量在声明时被创建，并在超出其作用域时被销毁。</li>
</ol>
<h3 id="变量里数据的存储原理"><a href="#变量里数据的存储原理" class="headerlink" title="变量里数据的存储原理"></a>变量里数据的存储原理</h3><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>好的，下面我来介绍一下二进制：</p>
<p><strong>什么是二进制？</strong></p>
<p>二进制是一种基于 2 的数字系统，这意味着它只使用两个数字：0 和 1。这与我们日常生活中使用的十进制（基于 10，使用数字 0 到 9）不同。</p>
<p><strong>为什么计算机使用二进制？</strong></p>
<p>计算机使用二进制是因为它很容易用电子设备来实现。在计算机内部，信息以电信号的形式表示。</p>
<ul>
<li>0 可以表示为“无电压”或“关闭”</li>
<li>1 可以表示为“有电压”或“打开”<br>这种简单的“开&#x2F;关”状态使得计算机能够可靠地存储和处理信息。</li>
</ul>
<p><strong>二进制的计数方式</strong></p>
<p>在十进制中，每一位代表 10 的幂（例如，个位是 10⁰，十位是 10¹，百位是 10²，等等）。</p>
<p>在二进制中，每一位代表 2 的幂（例如，个位是 2⁰，第二位是 2¹，第三位是 2²，等等）。</p>
<p>以下是一些二进制数及其对应的十进制数：</p>
<ul>
<li>二进制 <code>0</code> &#x3D; 十进制 0</li>
<li>二进制 <code>1</code> &#x3D; 十进制 1</li>
<li>二进制 <code>10</code> &#x3D; (1 x 2¹) + (0 x 2⁰) &#x3D; 2 + 0 &#x3D; 十进制 2</li>
<li>二进制 <code>11</code> &#x3D; (1 x 2¹) + (1 x 2⁰) &#x3D; 2 + 1 &#x3D; 十进制 3</li>
<li>二进制 <code>100</code> &#x3D; (1 x 2²) + (0 x 2¹) + (0 x 2⁰) &#x3D; 4 + 0 + 0 &#x3D; 十进制 4</li>
<li>二进制 <code>101</code> &#x3D; (1 x 2²) + (0 x 2¹) + (1 x 2⁰) &#x3D; 4 + 0 + 1 &#x3D; 十进制 5</li>
</ul>
<p><strong>二进制的应用</strong></p>
<p>二进制是计算机科学的基础，它被用于：</p>
<ul>
<li><strong>数据存储：</strong> 计算机内存和硬盘使用二进制来存储数据。</li>
<li><strong>数据传输：</strong> 网络通信使用二进制来传输数据。</li>
<li><strong>逻辑运算：</strong> 计算机使用二进制来进行逻辑运算（例如 AND、OR、NOT）。</li>
<li><strong>程序指令：</strong> 计算机程序中的指令也是以二进制形式存储和执行的。</li>
</ul>
<p><strong>1. 文本文件 (Text File)</strong></p>
<ul>
<li><strong>存储方式：</strong> 文本文件存储的是可读的字符数据。文本文件通常使用 ASCII、UTF-8 或其他字符编码来存储字符。</li>
<li><strong>示例：</strong><ul>
<li><code>.txt</code>, <code>.csv</code>, <code>.html</code>, <code>.java</code>, <code>.py</code></li>
</ul>
</li>
</ul>
<p><strong>2. 图像文件 (Image File)</strong><br><img src="https://i.imgur.com/1sSzyr3.png"></p>
<ul>
<li><strong>存储方式：</strong> 图像文件存储的是图像的像素数据。图像文件可以使用多种格式来存储，例如：<ul>
<li><strong>位图格式 (Bitmap)：</strong> 例如 <code>.bmp</code>，存储的是每个像素的颜色值。</li>
<li><strong>JPEG 格式：</strong> 例如 <code>.jpg</code>, <code>.jpeg</code>，使用有损压缩算法来减小文件大小。</li>
<li><strong>PNG 格式：</strong> 例如 <code>.png</code>，使用无损压缩算法来减小文件大小。</li>
<li><strong>GIF 格式：</strong> 例如 <code>.gif</code>，支持动画。</li>
</ul>
</li>
<li><strong>示例：</strong><ul>
<li><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg/400px-Mona_Lisa%2C_by_Leonardo_da_Vinci%2C_from_C2RMF_retouched.jpg" alt="JPEG image example"></li>
<li><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/47/PNG_transparency_demonstration_1.png/220px-PNG_transparency_demonstration_1.png" alt="PNG image example"></li>
</ul>
</li>
</ul>
<p><strong>3. 音频文件 (Audio File)</strong><br><img src="https://i.imgur.com/uknNxYx.png"></p>
<ul>
<li><strong>存储方式：</strong> 音频文件存储的是声音的波形数据。音频文件可以使用多种格式来存储，例如：<ul>
<li><strong>WAV 格式：</strong> 存储的是未经压缩的原始音频数据。</li>
<li><strong>MP3 格式：</strong> 使用有损压缩算法来减小文件大小。</li>
<li><strong>AAC 格式：</strong> 也是一种有损压缩格式，通常比 MP3 格式具有更好的音质。</li>
</ul>
</li>
<li><strong>示例：</strong><ul>
<li><code>.wav</code>, <code>.mp3</code>, <code>.aac</code></li>
</ul>
</li>
</ul>
<p><strong>4. 视频文件 (Video File)</strong></p>
<ul>
<li><strong>存储方式：</strong> 视频文件存储的是一系列图像帧和音频数据。视频文件可以使用多种格式来存储，例如：<ul>
<li><strong>MP4 格式：</strong> 一种常用的视频格式，使用 H.264 或 H.265 编码来压缩视频数据。</li>
<li><strong>AVI 格式：</strong> 一种较老的视频格式。</li>
<li><strong>MOV 格式：</strong> 苹果公司开发的视频格式。</li>
</ul>
</li>
<li><strong>示例：</strong><ul>
<li><code>.mp4</code>, <code>.avi</code>, <code>.mov</code></li>
</ul>
</li>
</ul>
<p><strong>5. 可执行文件 (Executable File)</strong></p>
<ul>
<li><strong>存储方式：</strong> 可执行文件存储的是计算机程序的可执行指令。可执行文件的格式取决于操作系统，例如：<ul>
<li><strong>Windows 操作系统：</strong> 使用 <code>.exe</code> 或 <code>.dll</code> 格式。</li>
<li><strong>Linux 操作系统：</strong> 使用 ELF 格式。</li>
<li><strong>macOS 操作系统：</strong> 使用 Mach-O 格式。</li>
</ul>
</li>
</ul>
<p><strong>其他文件类型</strong></p>
<p>除了以上常见的文件类型，还有其他许多文件类型，例如：</p>
<ul>
<li><strong>压缩文件：</strong> 例如 <code>.zip</code>, <code>.rar</code>, <code>.tar.gz</code>，用于将多个文件或目录压缩成一个文件，以减小文件大小。</li>
<li><strong>文档文件：</strong> 例如 <code>.doc</code>, <code>.docx</code>, <code>.pdf</code>，用于存储文档数据。</li>
<li><strong>数据库文件：</strong> 例如 <code>.db</code>, <code>.mdb</code>，用于存储数据库数据。</li>
</ul>
<h4 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h4><p><strong>什么是 ASCII？</strong></p>
<p>ASCII (American Standard Code for Information Interchange，美国信息交换标准代码) 是一种基于拉丁字母的字符编码，用于在计算机和通信设备中表示文本。它定义了 128 个字符，每个字符对应一个唯一的数字代码。</p>
<p><strong>ASCII 的历史</strong></p>
<p>ASCII 最初于 1963 年被标准化，并在 1968 年进行了更新。它是计算机历史上最常用的字符编码之一，对计算机技术的发展产生了深远的影响。</p>
<p><strong>ASCII 的字符集</strong></p>
<p>ASCII 字符集包含以下几类字符：</p>
<ul>
<li><strong>控制字符 (0-31)：</strong> 用于控制计算机或通信设备的行为，例如换行、回车、制表符等。</li>
<li><strong>数字 (48-57)：</strong> 表示数字 0 到 9。</li>
<li><strong>大写字母 (65-90)：</strong> 表示大写字母 A 到 Z。</li>
<li><strong>小写字母 (97-122)：</strong> 表示小写字母 a 到 z。</li>
<li><strong>标点符号和特殊字符 (32-47, 58-64, 91-96, 123-126)：</strong> 包括空格、标点符号、运算符等。</li>
</ul>
<p><strong>ASCII 的编码方式</strong></p>
<p>ASCII 使用 7 位二进制数来表示每个字符。这意味着 ASCII 可以表示 2⁷ &#x3D; 128 个不同的字符。</p>
<p><strong>ASCII 的局限性</strong></p>
<p>ASCII 的局限性在于它只能表示英语字符和一些常用的符号。对于其他语言，例如中文、日文、韩文等，ASCII 无法表示。</p>
<p><strong>ASCII 的扩展</strong></p>
<p>为了解决 ASCII 的局限性，人们开发了许多 ASCII 的扩展编码，例如 ISO-8859 系列编码。这些扩展编码使用 8 位二进制数来表示字符，可以表示 2⁸ &#x3D; 256 个不同的字符。</p>
<p><strong>Unicode 的出现</strong></p>
<p>最终，Unicode 的出现解决了所有字符编码的问题。Unicode 使用 16 位或更多位二进制数来表示字符，可以表示世界上几乎所有的字符。</p>
<p><strong>总结</strong></p>
<p>ASCII 是一种简单而常用的字符编码，它是计算机技术的基础。虽然 ASCII 有其局限性，但它对计算机技术的发展产生了深远的影响。现在，Unicode 已经成为最常用的字符编码，但 ASCII 仍然在某些场合中使用。<br><img src="https://i.imgur.com/H0SPsKy.png"></p>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>Okay, let’s learn about number system conversions in Java. Java provides some built-in methods and classes that make it easy to perform conversions between different number systems.</p>
<p><strong>1. 十进制转其他进制</strong></p>
<p>Java 提供了 <code>Integer</code> 类的静态方法来进行十进制到其他进制的转换：</p>
<ul>
<li><strong><code>Integer.toBinaryString(int i)</code>：</strong> 将十进制整数转换为二进制字符串。</li>
<li><strong><code>Integer.toOctalString(int i)</code>：</strong> 将十进制整数转换为八进制字符串。</li>
<li><strong><code>Integer.toHexString(int i)</code>：</strong> 将十进制整数转换为十六进制字符串。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">decimalNumber</span> <span class="operator">=</span> <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">binaryString</span> <span class="operator">=</span> Integer.toBinaryString(decimalNumber); <span class="comment">// &quot;11111111&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">octalString</span> <span class="operator">=</span> Integer.toOctalString(decimalNumber);   <span class="comment">// &quot;377&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hexString</span> <span class="operator">=</span> Integer.toHexString(decimalNumber);     <span class="comment">// &quot;ff&quot;</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Binary: &quot;</span> + binaryString);</span><br><span class="line">System.out.println(<span class="string">&quot;Octal: &quot;</span> + octalString);</span><br><span class="line">System.out.println(<span class="string">&quot;Hex: &quot;</span> + hexString);</span><br></pre></td></tr></table></figure>

<p><strong>2. 其他进制转十进制</strong></p>
<p>Java provides the <code>Integer.parseInt(String s, int radix)</code> method to convert a string representing a number in another base (radix) to a decimal integer. The <code>radix</code> parameter specifies the base of the string <code>s</code>.</p>
<ul>
<li><code>radix = 2</code>：二进制</li>
<li><code>radix = 8</code>：八进制</li>
<li><code>radix = 16</code>：十六进制</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">binaryString</span> <span class="operator">=</span> <span class="string">&quot;11111111&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">octalString</span> <span class="operator">=</span> <span class="string">&quot;377&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">hexString</span> <span class="operator">=</span> <span class="string">&quot;ff&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">decimalFromBinary</span> <span class="operator">=</span> Integer.parseInt(binaryString, <span class="number">2</span>); <span class="comment">// 255</span></span><br><span class="line"><span class="type">int</span> <span class="variable">decimalFromOctal</span> <span class="operator">=</span> Integer.parseInt(octalString, <span class="number">8</span>);   <span class="comment">// 255</span></span><br><span class="line"><span class="type">int</span> <span class="variable">decimalFromHex</span> <span class="operator">=</span> Integer.parseInt(hexString, <span class="number">16</span>);     <span class="comment">// 255</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Decimal from binary: &quot;</span> + decimalFromBinary);</span><br><span class="line">System.out.println(<span class="string">&quot;Decimal from octal: &quot;</span> + decimalFromOctal);</span><br><span class="line">System.out.println(<span class="string">&quot;Decimal from hex: &quot;</span> + decimalFromHex);</span><br></pre></td></tr></table></figure>

<p><strong>3. 其他进制之间的转换</strong></p>
<p>如果需要在二进制、八进制和十六进制之间进行转换，可以先将原始进制转换为十进制，然后再将十进制转换为目标进制。</p>
<p>示例：将二进制字符串转换为十六进制字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">binaryString</span> <span class="operator">=</span> <span class="string">&quot;10101010&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">decimalValue</span> <span class="operator">=</span> Integer.parseInt(binaryString, <span class="number">2</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">hexString</span> <span class="operator">=</span> Integer.toHexString(decimalValue);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Hex from binary: &quot;</span> + hexString); <span class="comment">// &quot;aa&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 注意事项</strong></p>
<ul>
<li><code>Integer.parseInt()</code> 方法在解析字符串时可能会抛出 <code>NumberFormatException</code> 异常，如果字符串不符合指定的进制规则，或者字符串表示的数值超出了 <code>int</code> 类型的范围。</li>
<li>在将十六进制字符串转换为十进制整数时，十六进制字符串中的字母（A-F）不区分大小写。</li>
</ul>
<p>总而言之，Java 提供了方便的方法来进行进制转换。你可以根据需要选择合适的方法来进行转换。希望这些信息对你有所帮助！</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://i.imgur.com/LqEVlM5.png"></p>
<ol>
<li><p><strong>基本数据类型 (Primitive Data Types):</strong></p>
<ul>
<li><strong>整数类型 (Integer Types):</strong><ul>
<li><code>int</code>: 用于存储整数，例如：<code>10</code>, <code>-5</code>, <code>0</code>。</li>
<li><code>long</code>: 用于存储较大范围的整数。</li>
<li><code>short</code>: 用于存储较小范围的整数。</li>
<li><code>byte</code>: 用于存储非常小范围的整数。</li>
</ul>
</li>
<li><strong>浮点数类型 (Floating-Point Types):</strong><ul>
<li><code>float</code>: 用于存储单精度浮点数，例如：<code>3.14</code>, <code>-2.5</code>。</li>
<li><code>double</code>: 用于存储双精度浮点数，提供更高的精度。</li>
</ul>
</li>
<li><strong>字符类型 (Character Type):</strong><ul>
<li><code>char</code>: 用于存储单个字符，例如：<code>&#39;A&#39;</code>, <code>&#39;z&#39;</code>, <code>&#39;9&#39;</code>。</li>
</ul>
</li>
<li><strong>布尔类型 (Boolean Type):</strong><ul>
<li><code>boolean</code>: 用于存储布尔值，即 <code>true</code> 或 <code>false</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>复合数据类型 (Composite Data Types):</strong></p>
<ul>
<li><strong>数组 (Arrays):</strong><ul>
<li>用于存储相同类型的多个元素的集合。例如，整数数组、字符数组等。</li>
</ul>
</li>
<li><strong>字符串 (Strings):</strong><ul>
<li>用于存储文本数据，本质上是字符的序列。</li>
</ul>
</li>
<li><strong>结构体 (Structures):</strong><ul>
<li>用于将不同类型的数据组合成一个单一的单元。</li>
</ul>
</li>
<li><strong>指针 (Pointers):</strong><ul>
<li>用于存储变量的内存地址。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>其他数据类型:</strong></p>
<ul>
<li><strong>枚举 (Enumerations):</strong><ul>
<li>用于定义一组命名的整数常量。</li>
</ul>
</li>
<li><strong>联合体 (Unions):</strong><ul>
<li>允许在相同的内存位置存储不同的数据类型。</li>
</ul>
</li>
<li><strong>空类型 (Void):</strong><ul>
<li>表示没有类型，通常用于函数不返回任何值的情况。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="标识符-关键字"><a href="#标识符-关键字" class="headerlink" title="标识符-关键字"></a>标识符-关键字</h2><p><strong>标识符 (Identifiers)</strong></p>
<p>标识符是程序员在代码中用来给变量、函数、类、模块或其他程序实体命名的符号。简单来说，标识符就是你给事物起的名字。</p>
<p><strong>标识符的命名规则 (Naming Rules):</strong></p>
<ul>
<li><strong>组成:</strong> 标识符通常由字母（A-Z, a-z）、数字（0-9）和下划线（_）组成。</li>
<li><strong>开头:</strong> 标识符必须以字母或下划线开头，不能以数字开头。</li>
<li><strong>大小写敏感:</strong> 大多数编程语言（如C++, Java, Python）是大小写敏感的，这意味着 <code>myVariable</code> 和 <code>MyVariable</code> 会被认为是不同的标识符。</li>
<li><strong>长度限制:</strong> 某些语言可能对标识符的长度有限制，但通常这个限制非常大，可以忽略。</li>
<li><strong>避免使用保留字:</strong> 标识符不能与编程语言的关键字（见下文）相同。</li>
<li><strong>可读性:</strong> 尽量选择有意义、易于理解的名称，提高代码的可读性。例如，使用 <code>studentName</code> 代替 <code>sn</code>。</li>
</ul>
<p><strong>示例 (Examples):</strong></p>
<p>合法的标识符:</p>
<ul>
<li><code>myVariable</code></li>
<li><code>_count</code></li>
<li><code>student_name</code></li>
<li><code>x123</code></li>
<li><code>MAX_VALUE</code></li>
</ul>
<p>非法的标识符:</p>
<ul>
<li><code>123variable</code> (以数字开头)</li>
<li><code>my-variable</code> (包含非法字符 <code>-</code>)</li>
<li><code>if</code> (与关键字冲突)</li>
</ul>
<p><strong>关键字 (Keywords)</strong></p>
<p>关键字是编程语言中预定义的、具有特殊含义的单词。它们被编译器或解释器用于识别语言的结构和控制程序的流程。关键字不能用作标识符。</p>
<p><strong>关键字的特点 (Characteristics):</strong></p>
<ul>
<li><strong>预定义:</strong> 关键字是语言设计者预先定义好的。</li>
<li><strong>特殊含义:</strong> 每个关键字都有其特定的用途和含义。</li>
<li><strong>不可重定义:</strong> 程序员不能改变关键字的含义。</li>
<li><strong>保留字:</strong> 关键字是保留字，不能作为变量名、函数名等标识符使用。</li>
</ul>
<p><strong>常见关键字示例 (Common Examples):</strong></p>
<p>不同的编程语言有不同的关键字集合，以下是一些常见编程语言的关键字示例：</p>
<ul>
<li><strong>C&#x2F;C++:</strong> <code>int</code>, <code>float</code>, <code>char</code>, <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>return</code>, <code>struct</code>, <code>class</code>, <code>void</code>, <code>switch</code>, <code>case</code>, <code>break</code>, <code>continue</code>, <code>default</code>, <code>typedef</code>, <code>const</code>, <code>static</code>, <code>extern</code>, <code>sizeof</code>, <code>new</code>, <code>delete</code>, <code>try</code>, <code>catch</code>, <code>throw</code>, <code>template</code>, <code>namespace</code>, <code>using</code>, <code>virtual</code>, <code>friend</code>, <code>public</code>, <code>private</code>, <code>protected</code></li>
<li><strong>Java:</strong> <code>int</code>, <code>float</code>, <code>char</code>, <code>boolean</code>, <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>return</code>, <code>class</code>, <code>interface</code>, <code>void</code>, <code>switch</code>, <code>case</code>, <code>break</code>, <code>continue</code>, <code>default</code>, <code>public</code>, <code>private</code>, <code>protected</code>, <code>static</code>, <code>final</code>, <code>abstract</code>, <code>implements</code>, <code>extends</code>, <code>try</code>, <code>catch</code>, <code>finally</code>, <code>throw</code>, <code>throws</code>, <code>new</code>, <code>this</code>, <code>super</code>, <code>package</code>, <code>import</code>, <code>instanceof</code>, <code>synchronized</code>, <code>volatile</code>, <code>transient</code>, <code>assert</code>, <code>enum</code>, <code>strictfp</code></li>
<li><strong>Python:</strong> <code>and</code>, <code>as</code>, <code>assert</code>, <code>async</code>, <code>await</code>, <code>break</code>, <code>class</code>, <code>continue</code>, <code>def</code>, <code>del</code>, <code>elif</code>, <code>else</code>, <code>except</code>, <code>False</code>, <code>finally</code>, <code>for</code>, <code>from</code>, <code>global</code>, <code>if</code>, <code>import</code>, <code>in</code>, <code>is</code>, <code>lambda</code>, <code>None</code>, <code>nonlocal</code>, <code>not</code>, <code>or</code>, <code>pass</code>, <code>raise</code>, <code>return</code>, <code>True</code>, <code>try</code>, <code>while</code>, <code>with</code>, <code>yield</code></li>
</ul>
<h2 id="Java的method"><a href="#Java的method" class="headerlink" title="Java的method"></a>Java的method</h2><p><strong>什么是方法 (What is a Method)?</strong></p>
<p>在 Java 中，方法是一段包含一条或多条语句的代码块，用于执行特定的任务。方法是组织代码的基本单元，允许你将程序分解为更小、更易于管理的部分。方法可以被多次调用，从而避免代码重复，提高代码的重用性和可读性。</p>
<p><strong>方法的组成 (Method Structure):</strong></p>
<p>一个 Java 方法通常由以下几个部分组成：</p>
<ol>
<li><p><strong>方法签名 (Method Signature):</strong></p>
<ul>
<li><strong>访问修饰符 (Access Modifier):</strong>  指定方法的访问权限，例如 <code>public</code>, <code>private</code>, <code>protected</code> 或默认（package-private）。</li>
<li><strong>返回类型 (Return Type):</strong>  指定方法返回的数据类型。如果方法不返回任何值，则使用 <code>void</code>。</li>
<li><strong>方法名 (Method Name):</strong>  方法的名称，遵循标识符的命名规则。</li>
<li><strong>参数列表 (Parameter List):</strong>  方法接受的参数，包括参数类型和参数名。参数是可选的，方法可以没有参数。</li>
</ul>
</li>
<li><p><strong>方法体 (Method Body):</strong></p>
<ul>
<li>包含实际执行的代码块，用花括号 <code>&#123;&#125;</code> 括起来。</li>
<li>方法体中的代码用于实现方法的具体功能。</li>
</ul>
</li>
</ol>
<p><strong>方法定义的语法 (Method Definition Syntax):</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">访问修饰符 返回类型 方法名(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">    <span class="comment">// 可以包含一条或多条语句</span></span><br><span class="line">    <span class="keyword">return</span> 返回值; <span class="comment">// 如果返回类型不是 void，则必须有 return 语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例 (Example):</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 一个简单的加法方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个不返回任何值的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法的调用 (Method Invocation):</strong></p>
<p>要执行一个方法，你需要调用它。方法的调用方式取决于方法是否是静态的 (static) 以及方法所属的类。</p>
<ol>
<li><p><strong>调用静态方法 (Calling Static Methods):</strong></p>
<ul>
<li>静态方法属于类，而不是类的实例。</li>
<li>可以通过类名直接调用静态方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名.方法名(参数);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>调用实例方法 (Calling Instance Methods):</strong></p>
<ul>
<li>实例方法属于类的实例（对象）。</li>
<li>需要先创建类的实例，然后通过实例调用实例方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line">对象名.方法名(参数);</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>示例 (Example):</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用静态方法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Math.max(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// Math 是 Java 标准库中的一个类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Max: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用实例方法</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> obj.add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);</span><br><span class="line">        obj.printMessage(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法的类型 (Types of Methods):</strong></p>
<ol>
<li><p><strong>静态方法 (Static Methods):</strong></p>
<ul>
<li>使用 <code>static</code> 关键字声明。</li>
<li>属于类，而不是类的实例。</li>
<li>可以直接通过类名调用。</li>
<li>不能访问实例变量，只能访问静态变量。</li>
</ul>
</li>
<li><p><strong>实例方法 (Instance Methods):</strong></p>
<ul>
<li>没有 <code>static</code> 关键字声明。</li>
<li>属于类的实例（对象）。</li>
<li>需要通过类的实例调用。</li>
<li>可以访问实例变量和静态变量。</li>
</ul>
</li>
<li><p><strong>构造方法 (Constructors):</strong></p>
<ul>
<li>用于创建类的实例。</li>
<li>方法名与类名相同。</li>
<li>没有返回类型（即使是 <code>void</code> 也不行）。</li>
<li>可以有参数，也可以没有参数。</li>
</ul>
</li>
<li><p><strong>抽象方法 (Abstract Methods):</strong></p>
<ul>
<li>使用 <code>abstract</code> 关键字声明。</li>
<li>没有方法体。</li>
<li>必须在抽象类中声明。</li>
<li>子类必须实现抽象方法，除非子类也是抽象类。</li>
</ul>
</li>
</ol>
<p><strong>方法的重载 (Method Overloading):</strong></p>
<ul>
<li>在同一个类中，可以有多个方法具有相同的方法名，但参数列表必须不同。</li>
<li>参数列表的不同可以是参数的类型、数量或顺序不同。</li>
<li>方法的重载允许你使用相同的方法名来执行不同的任务，提高代码的灵活性。</li>
</ul>
<p><strong>示例 (Example):</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>什么是方法重载？</strong></p>
<p>方法重载（Method Overloading）是指在一个类中定义多个方法，它们具有<strong>相同的名称</strong>，但具有<strong>不同的参数列表</strong>。  编译器会根据调用方法时提供的参数类型和数量来决定调用哪个重载方法。</p>
<p><strong>方法重载的规则：</strong></p>
<p>要使方法构成重载，必须满足以下条件：</p>
<ol>
<li><strong>方法名称必须相同。</strong></li>
<li><strong>参数列表必须不同。</strong>  参数列表的不同体现在以下几个方面：<ul>
<li><strong>参数的数量不同。</strong></li>
<li><strong>参数的类型不同。</strong></li>
<li><strong>参数的顺序不同。</strong></li>
</ul>
</li>
<li><strong>返回类型可以相同也可以不同。</strong>  返回类型不是方法签名的一部分，因此不能仅通过返回类型来区分重载方法。</li>
<li><strong>访问修饰符可以相同也可以不同。</strong>  访问修饰符（例如 <code>public</code>、<code>private</code>、<code>protected</code>）不是方法签名的一部分，因此不能仅通过访问修饰符来区分重载方法。</li>
<li><strong>可以重载在同一个类中声明的方法，也可以重载从超类继承的方法。</strong></li>
</ol>
<p><strong>方法签名:</strong></p>
<p>方法签名由方法的名称和参数列表组成。  编译器使用方法签名来区分不同的方法。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法1：两个整数相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2：三个整数相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法3：两个浮点数相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法4：一个整数和一个浮点数相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法5：一个浮点数和一个整数相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(calculator.add(<span class="number">1</span>, <span class="number">2</span>));       <span class="comment">// 调用方法1：输出 3</span></span><br><span class="line">        System.out.println(calculator.add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));    <span class="comment">// 调用方法2：输出 6</span></span><br><span class="line">        System.out.println(calculator.add(<span class="number">1.5</span>, <span class="number">2.5</span>));   <span class="comment">// 调用方法3：输出 4.0</span></span><br><span class="line">        System.out.println(calculator.add(<span class="number">1</span>, <span class="number">2.5</span>));     <span class="comment">// 调用方法4：输出 3.5</span></span><br><span class="line">        System.out.println(calculator.add(<span class="number">1.5</span>, <span class="number">2</span>));     <span class="comment">// 调用方法5：输出 3.5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Calculator</code> 类定义了五个名为 <code>add</code> 的方法，它们具有不同的参数列表。  编译器会根据调用 <code>add</code> 方法时提供的参数类型和数量来决定调用哪个重载方法。</p>
<p><strong>方法重载的优点：</strong></p>
<ul>
<li><strong>提高代码的可读性：</strong>  使用相同的方法名称来执行相似的操作，可以使代码更易于理解。</li>
<li><strong>提高代码的重用性：</strong>  可以为不同的数据类型提供相同的功能，而无需创建不同的方法名称。</li>
<li><strong>灵活性：</strong>  允许使用不同数量或类型的参数来调用方法。</li>
</ul>
<p><strong>方法重载的注意事项：</strong></p>
<ul>
<li><strong>不要仅仅通过返回类型来区分重载方法。</strong>  这会导致编译错误。</li>
<li><strong>避免创建过于相似的重载方法。</strong>  这可能会导致编译器无法确定应该调用哪个方法。</li>
<li><strong>在使用可变参数（varargs）时要小心。</strong>  可变参数可能会与其他重载方法产生歧义。</li>
</ul>
<p><strong>示例：可变参数的重载</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarargsExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Varargs method&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            System.out.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String arg1, String arg2)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Two-argument method&quot;</span>);</span><br><span class="line">        System.out.println(arg1);</span><br><span class="line">        System.out.println(arg2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VarargsExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VarargsExample</span>();</span><br><span class="line">        example.print(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);       <span class="comment">// 调用 Two-argument method</span></span><br><span class="line">        example.print(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>);  <span class="comment">// 调用 Varargs method</span></span><br><span class="line">        example.print(<span class="string">&quot;Hello&quot;</span>);                <span class="comment">// 调用 Varargs method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法的参数传递 (Parameter Passing):</strong></p>
<p>在 Java 中，方法的参数传递有两种方式：</p>
<ol>
<li><p><strong>按值传递 (Pass by Value):</strong></p>
<ul>
<li>对于基本数据类型（如 <code>int</code>, <code>float</code>, <code>char</code>, <code>boolean</code>），传递的是变量的值的副本。</li>
<li>在方法内部修改参数的值不会影响原始变量的值。</li>
</ul>
</li>
<li><p><strong>按引用传递 (Pass by Reference):</strong></p>
<ul>
<li>对于对象类型（如数组、类实例），传递的是对象的引用（内存地址）的副本。</li>
<li>在方法内部修改对象的属性会影响原始对象。</li>
</ul>
</li>
</ol>
<p><strong>示例 (Example):</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParameterPassing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyValue</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        x = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside method: x = &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyObject</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside method: arr[0] = &quot;</span> + arr[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method: a = &quot;</span> + a);</span><br><span class="line">        modifyValue(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method: a = &quot;</span> + a);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method: numbers[0] = &quot;</span> + numbers[<span class="number">0</span>]);</span><br><span class="line">        modifyObject(numbers);</span><br><span class="line">        System.out.println(<span class="string">&quot;After method: numbers[0] = &quot;</span> + numbers[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><strong>什么是类型转换？</strong></p>
<p>类型转换（Type Conversion）是指将一个数据类型的值转换为另一个数据类型的值。 在 Java 中，类型转换分为两种：</p>
<ol>
<li><strong>隐式类型转换（Implicit Type Conversion）</strong>，也称为自动类型转换（Automatic Type Conversion）或拓宽转换（Widening Conversion）。</li>
<li><strong>显式类型转换（Explicit Type Conversion）</strong>，也称为强制类型转换（Casting）或窄化转换（Narrowing Conversion）。</li>
</ol>
<p><strong>1. 隐式类型转换（自动类型转换）</strong></p>
<ul>
<li><p><strong>定义：</strong> 当将一个较小范围的数据类型的值赋给一个较大范围的数据类型变量时，Java 编译器会自动进行类型转换，无需显式指定。</p>
</li>
<li><p><strong>方向：</strong> 总是从较小范围的类型转换为较大范围的类型，以避免数据丢失。</p>
</li>
<li><p><strong>适用情况：</strong></p>
<ul>
<li><code>byte</code> -&gt; <code>short</code> -&gt; <code>int</code> -&gt; <code>long</code> -&gt; <code>float</code> -&gt; <code>double</code></li>
<li><code>char</code> -&gt; <code>int</code></li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> intValue; <span class="comment">// 隐式类型转换，int 转换为 long</span></span><br><span class="line"><span class="type">float</span> <span class="variable">floatValue</span> <span class="operator">=</span> longValue; <span class="comment">// 隐式类型转换，long 转换为 float</span></span><br><span class="line"><span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> floatValue; <span class="comment">// 隐式类型转换，float 转换为 double</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">charValue</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">intFromChar</span> <span class="operator">=</span> charValue; <span class="comment">// 隐式类型转换，char 转换为 int (A 的 ASCII 码是 65)</span></span><br><span class="line"></span><br><span class="line">System.out.println(intValue);      <span class="comment">// 输出 100</span></span><br><span class="line">System.out.println(longValue);      <span class="comment">// 输出 100</span></span><br><span class="line">System.out.println(floatValue);     <span class="comment">// 输出 100.0</span></span><br><span class="line">System.out.println(doubleValue);    <span class="comment">// 输出 100.0</span></span><br><span class="line">System.out.println(intFromChar);    <span class="comment">// 输出 65</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>2. 显式类型转换（强制类型转换）</strong></p>
<ul>
<li><p><strong>定义：</strong> 当将一个较大范围的数据类型的值赋给一个较小范围的数据类型变量时，需要使用强制类型转换运算符 <code>(目标类型)</code> 显式地进行类型转换。</p>
</li>
<li><p><strong>方向：</strong> 总是从较大范围的类型转换为较小范围的类型。</p>
</li>
<li><p><strong>风险：</strong> 可能会导致数据丢失或精度降低，因为较大范围的值可能超出较小范围类型的表示范围。</p>
</li>
<li><p><strong>适用情况：</strong></p>
<ul>
<li><code>double</code> -&gt; <code>float</code> -&gt; <code>long</code> -&gt; <code>int</code> -&gt; <code>short</code> -&gt; <code>byte</code></li>
<li><code>int</code> -&gt; <code>char</code></li>
</ul>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> <span class="number">123.456</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> (<span class="type">int</span>) doubleValue; <span class="comment">// 显式类型转换，double 转换为 int (小数部分被截断)</span></span><br><span class="line"><span class="type">long</span> <span class="variable">longValue</span> <span class="operator">=</span> <span class="number">2147483648L</span>; <span class="comment">// 大于 int 的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">intFromLong</span> <span class="operator">=</span> (<span class="type">int</span>) longValue; <span class="comment">// 显式类型转换，long 转换为 int (可能导致数据溢出)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">intChar</span> <span class="operator">=</span> <span class="number">65</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">charValue</span> <span class="operator">=</span> (<span class="type">char</span>) intChar; <span class="comment">// 显式类型转换，int 转换为 char (65 对应 ASCII 码的 &#x27;A&#x27;)</span></span><br><span class="line"></span><br><span class="line">System.out.println(doubleValue);   <span class="comment">// 输出 123.456</span></span><br><span class="line">System.out.println(intValue);      <span class="comment">// 输出 123 (小数部分被截断)</span></span><br><span class="line">System.out.println(longValue);      <span class="comment">// 输出 2147483648</span></span><br><span class="line">System.out.println(intFromLong);    <span class="comment">// 输出 -2147483648 (数据溢出)</span></span><br><span class="line">System.out.println(charValue);      <span class="comment">// 输出 A</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>类型转换的规则总结：</strong></p>
<table>
<thead>
<tr>
<th align="left">原始类型</th>
<th align="left">目标类型</th>
<th align="left">是否需要显式转换</th>
<th align="left">可能的风险</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>byte</code></td>
<td align="left"><code>short</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>byte</code></td>
<td align="left"><code>int</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>byte</code></td>
<td align="left"><code>long</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>byte</code></td>
<td align="left"><code>float</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>byte</code></td>
<td align="left"><code>double</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>byte</code></td>
<td align="left"><code>char</code></td>
<td align="left">是</td>
<td align="left">数据截断</td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="left"><code>int</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="left"><code>long</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="left"><code>float</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="left"><code>double</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="left"><code>char</code></td>
<td align="left">是</td>
<td align="left">数据截断</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>long</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>float</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>double</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>char</code></td>
<td align="left">是</td>
<td align="left">数据截断</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left"><code>float</code></td>
<td align="left">否</td>
<td align="left">可能精度丢失</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left"><code>double</code></td>
<td align="left">否</td>
<td align="left">可能精度丢失</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left"><code>int</code></td>
<td align="left">是</td>
<td align="left">数据截断&#x2F;溢出</td>
</tr>
<tr>
<td align="left"><code>float</code></td>
<td align="left"><code>double</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>float</code></td>
<td align="left"><code>long</code></td>
<td align="left">是</td>
<td align="left">数据截断</td>
</tr>
<tr>
<td align="left"><code>float</code></td>
<td align="left"><code>int</code></td>
<td align="left">是</td>
<td align="left">数据截断</td>
</tr>
<tr>
<td align="left"><code>double</code></td>
<td align="left"><code>long</code></td>
<td align="left">是</td>
<td align="left">数据截断</td>
</tr>
<tr>
<td align="left"><code>double</code></td>
<td align="left"><code>int</code></td>
<td align="left">是</td>
<td align="left">数据截断</td>
</tr>
<tr>
<td align="left"><code>char</code></td>
<td align="left"><code>int</code></td>
<td align="left">否</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>char</code></td>
<td align="left"><code>short</code></td>
<td align="left">是</td>
<td align="left">数据截断</td>
</tr>
<tr>
<td align="left"><code>char</code></td>
<td align="left"><code>byte</code></td>
<td align="left">是</td>
<td align="left">数据截断</td>
</tr>
</tbody></table>
<p><strong>类型转换的注意事项：</strong></p>
<ul>
<li><strong>数据溢出：</strong> 当将一个超出目标类型范围的值进行强制类型转换时，可能会发生数据溢出，导致结果不正确。</li>
<li><strong>精度丢失：</strong> 当将一个浮点数转换为整数时，小数部分会被截断，导致精度丢失。</li>
<li><strong>类型不兼容：</strong> 某些类型之间无法进行类型转换，例如 <code>boolean</code> 类型不能转换为其他任何类型，反之亦然。</li>
<li><strong>对象类型转换：</strong> 对象类型转换涉及到继承关系，可以将一个子类对象转换为其父类类型（向上转型），也可以将一个父类对象转换为其子类类型（向下转型），但向下转型需要使用 <code>instanceof</code> 运算符进行类型检查，以避免 <code>ClassCastException</code> 异常。</li>
</ul>
<p><strong>示例：对象类型转换</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Generic animal sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fetch</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is fetching the ball&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CastingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 向上转型 (Upcasting)</span></span><br><span class="line"></span><br><span class="line">        animal1.makeSound(); <span class="comment">// 输出 &quot;Generic animal sound&quot;</span></span><br><span class="line">        animal2.makeSound(); <span class="comment">// 输出 &quot;Woof!&quot; (多态)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下转型 (Downcasting)</span></span><br><span class="line">        <span class="keyword">if</span> (animal2 <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal2;</span><br><span class="line">            dog.fetch(); <span class="comment">// 输出 &quot;Dog is fetching the ball&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 错误的向下转型，会导致 ClassCastException</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        <span class="keyword">if</span> (animal3 <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal3; <span class="comment">// ClassCastException: Animal cannot be cast to Dog</span></span><br><span class="line">            dog.fetch();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;animal3 is not a Dog&quot;</span>); <span class="comment">// 输出 &quot;animal3 is not a Dog&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<p>类型转换是 Java 中一种常见的操作，用于将一个数据类型的值转换为另一个数据类型的值。  理解隐式类型转换和显式类型转换的区别，以及类型转换可能带来的风险，对于编写正确的 Java 代码至关重要。  在进行类型转换时，务必注意数据溢出、精度丢失和类型兼容性等问题。<br><strong>api文档</strong><br><a href="https://www.oracle.com/java/technologies/javase-jdk21-doc-downloads.html">https://www.oracle.com/java/technologies/javase-jdk21-doc-downloads.html</a></p>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>好的，以下是关于 Java 输入输出 (I&#x2F;O) 的完整内容：</p>
<p><strong>什么是输入输出 (I&#x2F;O)?</strong></p>
<p>输入输出 (I&#x2F;O) 是指计算机系统与外部世界（例如用户、文件、网络等）之间进行数据交换的过程。 在 Java 中，I&#x2F;O 操作是通过各种类和接口来实现的，这些类和接口位于 <code>java.io</code> 包中。</p>
<p><strong>Java I&#x2F;O 的分类：</strong></p>
<p>Java I&#x2F;O 可以分为以下几类：</p>
<ol>
<li><p><strong>按数据流方向：</strong></p>
<ul>
<li><strong>输入流（Input Stream）：</strong> 从外部源（例如文件、网络连接）读取数据到程序中。</li>
<li><strong>输出流（Output Stream）：</strong> 将数据从程序写入到外部目标（例如文件、网络连接）。</li>
</ul>
</li>
<li><p><strong>按数据类型：</strong></p>
<ul>
<li><strong>字节流（Byte Stream）：</strong> 以字节为单位处理数据，适用于处理二进制数据（例如图像、音频、视频）或任何类型的数据。<ul>
<li><code>InputStream</code>：所有字节输入流的基类。</li>
<li><code>OutputStream</code>：所有字节输出流的基类。</li>
</ul>
</li>
<li><strong>字符流（Character Stream）：</strong> 以字符为单位处理数据，适用于处理文本数据。 字符流会自动处理字符编码的转换。<ul>
<li><code>Reader</code>：所有字符输入流的基类。</li>
<li><code>Writer</code>：所有字符输出流的基类。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>按功能：</strong></p>
<ul>
<li><strong>节点流（Node Stream）：</strong> 直接与数据源或目标连接的流，例如 <code>FileInputStream</code>、<code>FileOutputStream</code>、<code>FileReader</code>、<code>FileWriter</code>。</li>
<li><strong>处理流（Processing Stream）：</strong> 包装在节点流之上，提供额外的功能，例如缓冲、数据转换等，例如 <code>BufferedInputStream</code>、<code>BufferedOutputStream</code>、<code>BufferedReader</code>、<code>BufferedWriter</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java</span><br><span class="line">import java.io.*;</span><br><span class="line">public class NodeStreamExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 从文件读取数据</span><br><span class="line">            FileInputStream fis = new FileInputStream(&quot;input.txt&quot;);</span><br><span class="line">            int data;</span><br><span class="line">            while ((data = fis.read()) != -1) &#123;</span><br><span class="line">                System.out.print((char) data); // 将字节转换为字符并打印</span><br><span class="line">            &#125;</span><br><span class="line">            fis.close();</span><br><span class="line"></span><br><span class="line">            // 向文件写入数据</span><br><span class="line">            FileOutputStream fos = new FileOutputStream(&quot;output.txt&quot;);</span><br><span class="line">            String message = &quot;Hello, Node Stream!&quot;;</span><br><span class="line">            byte[] bytes = message.getBytes();</span><br><span class="line">            fos.write(bytes);</span><br><span class="line">            fos.close();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">         catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p><strong>常用的 Java I&#x2F;O 类：</strong></p>
<p><strong>1. 字节流：</strong></p>
<ul>
<li><strong>InputStream：</strong><ul>
<li><code>FileInputStream</code>：从文件中读取字节。</li>
<li><code>ByteArrayInputStream</code>：从字节数组中读取字节。</li>
<li><code>ObjectInputStream</code>：从输入流中读取对象。</li>
<li><code>BufferedInputStream</code>：提供缓冲功能的输入流，提高读取效率。</li>
</ul>
</li>
<li><strong>OutputStream：</strong><ul>
<li><code>FileOutputStream</code>：将字节写入到文件中。</li>
<li><code>ByteArrayOutputStream</code>：将字节写入到字节数组中。</li>
<li><code>ObjectOutputStream</code>：将对象写入到输出流中。</li>
<li><code>BufferedOutputStream</code>：提供缓冲功能的输出流，提高写入效率。</li>
</ul>
</li>
</ul>
<p><strong>2. 字符流：</strong></p>
<ul>
<li><strong>Reader：</strong><ul>
<li><code>FileReader</code>：从文件中读取字符。</li>
<li><code>CharArrayReader</code>：从字符数组中读取字符。</li>
<li><code>BufferedReader</code>：提供缓冲功能的字符输入流，提高读取效率，并提供 <code>readLine()</code> 方法用于读取一行文本。</li>
<li><code>InputStreamReader</code>：将字节输入流转换为字符输入流，可以指定字符编码。</li>
</ul>
</li>
<li><strong>Writer：</strong><ul>
<li><code>FileWriter</code>：将字符写入到文件中。</li>
<li><code>CharArrayWriter</code>：将字符写入到字符数组中。</li>
<li><code>BufferedWriter</code>：提供缓冲功能的字符输出流，提高写入效率，并提供 <code>newLine()</code> 方法用于写入一个换行符。</li>
<li><code>OutputStreamWriter</code>：将字符输出流转换为字节输出流，可以指定字符编码。</li>
</ul>
</li>
</ul>
<p><strong>3. 控制台 I&#x2F;O：</strong></p>
<ul>
<li><code>System.in</code>：标准输入流，通常连接到键盘。</li>
<li><code>System.out</code>：标准输出流，通常连接到控制台。</li>
<li><code>System.err</code>：标准错误流，通常连接到控制台。</li>
</ul>
<p><strong>Java I&#x2F;O 的使用步骤：</strong></p>
<ol>
<li><strong>创建流对象：</strong> 根据需要选择合适的流类，并创建流对象。</li>
<li><strong>打开流：</strong> 对于文件流，需要指定文件路径，打开与文件的连接。</li>
<li><strong>进行 I&#x2F;O 操作：</strong> 使用流对象的方法读取或写入数据。</li>
<li><strong>关闭流：</strong> 完成 I&#x2F;O 操作后，必须关闭流，释放资源。</li>
</ol>
<p><strong>示例：从文件中读取文本：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">```java</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader; <span class="comment">// 导入 BufferedReader 类，用于高效读取文本文件</span></span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;   <span class="comment">// 导入 FileReader 类，用于读取文件</span></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;  <span class="comment">// 导入 IOException 类，用于处理输入输出异常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadFileExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明 BufferedReader 对象，初始化为 null，用于读取文件内容</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 尝试打开文件并读取内容</span></span><br><span class="line">            reader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;example.txt&quot;</span>)); <span class="comment">// 创建 BufferedReader 对象，关联到文件 &quot;example.txt&quot;</span></span><br><span class="line">            String line; <span class="comment">// 声明字符串变量 line，用于存储读取的每一行内容</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环读取文件的每一行，直到文件末尾</span></span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">// 使用 readLine() 方法读取一行内容，如果读取到文件末尾，则返回 null</span></span><br><span class="line">                System.out.println(line); <span class="comment">// 将读取到的每一行内容输出到控制台</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获 IOException 异常，例如文件不存在、权限不足等</span></span><br><span class="line">            e.printStackTrace(); <span class="comment">// 打印异常堆栈信息，方便调试</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// finally 块中的代码无论是否发生异常都会执行，用于关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 尝试关闭 BufferedReader 对象</span></span><br><span class="line">                <span class="keyword">if</span> (reader != <span class="literal">null</span>) &#123; <span class="comment">// 确保 reader 对象不为 null，避免空指针异常</span></span><br><span class="line">                    reader.close(); <span class="comment">// 关闭 BufferedReader 对象，释放资源</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// 捕获关闭 BufferedReader 对象时可能发生的 IOException 异常</span></span><br><span class="line">                e.printStackTrace(); <span class="comment">// 打印异常堆栈信息，方便调试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**示例：将文本写入到文件中：**</span><br><span class="line">```java</span><br><span class="line">```java</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteFileExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明一个 BufferedWriter 对象，用于写入文件</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建 BufferedWriter 对象，并关联到文件 &quot;output.txt&quot;</span></span><br><span class="line">            <span class="comment">// FileWriter 用于将字符写入文件</span></span><br><span class="line">            <span class="comment">// BufferedWriter 提供了缓冲功能，可以提高写入效率</span></span><br><span class="line">            writer = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将字符串 &quot;Hello, World!&quot; 写入文件</span></span><br><span class="line">            writer.write(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写入一个换行符，确保下一行内容另起一行</span></span><br><span class="line">            writer.newLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将字符串 &quot;This is a new line.&quot; 写入文件</span></span><br><span class="line">            writer.write(<span class="string">&quot;This is a new line.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获可能发生的 IOException 异常，例如文件不存在、权限不足等</span></span><br><span class="line">            <span class="comment">// 打印异常堆栈信息，方便调试</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// finally 块中的代码无论是否发生异常都会执行</span></span><br><span class="line">            <span class="comment">// 用于确保资源被正确释放，例如关闭文件流</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 检查 writer 对象是否为空，避免空指针异常</span></span><br><span class="line">                <span class="keyword">if</span> (writer != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 关闭 BufferedWriter 对象，释放资源</span></span><br><span class="line">                    <span class="comment">// 关闭流之前，缓冲区中的数据会被刷新到文件中</span></span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// 捕获关闭流时可能发生的 IOException 异常</span></span><br><span class="line">                <span class="comment">// 打印异常堆栈信息，方便调试</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**示例：使用控制台 I/O：**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class ConsoleIOExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;Enter your name: &quot;);</span><br><span class="line">        String name = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">        System.out.print(&quot;Enter your age: &quot;);</span><br><span class="line">        int age = scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Hello, &quot; + name + &quot;! You are &quot; + age + &quot; years old.&quot;);</span><br><span class="line"></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java I&#x2F;O 的注意事项：</strong></p>
<ol>
<li><p><strong>必须关闭流：</strong> 在完成 I&#x2F;O 操作后，必须关闭流，释放资源。 可以使用 <code>try-finally</code> 块或 <code>try-with-resources</code> 语句来确保流被正确关闭。</p>
</li>
<li><p><strong>处理 IOException 异常：</strong> I&#x2F;O 操作可能会抛出 <code>IOException</code> 异常，必须进行处理。</p>
</li>
<li><p><strong>选择合适的流：</strong> 根据需要选择合适的流类，例如字节流或字符流，节点流或处理流。</p>
</li>
<li><p><strong>使用缓冲流：</strong> 使用缓冲流可以提高 I&#x2F;O 效率。</p>
</li>
<li><p><strong>指定字符编码：</strong> 在处理文本数据时，应该指定字符编码，以避免乱码问题。</p>
</li>
<li><p><strong>使用 <code>try-with-resources</code> 语句：</strong>  <code>try-with-resources</code> 语句可以自动关闭流，简化代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;example.txt&quot;</span>))) &#123;</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>总结：</strong></p>
<p>Java I&#x2F;O 是 Java 编程中不可或缺的一部分，用于实现程序与外部世界的数据交换。 掌握 Java I&#x2F;O 的基本概念、常用类和使用步骤，对于编写高效、可靠的 Java 程序至关重要。 在进行 I&#x2F;O 操作时，务必注意资源管理、异常处理和字符编码等问题。</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Java 中的运算符用于执行各种操作，例如算术运算、比较、逻辑运算、赋值等。  以下是 Java 中常见的运算符类型：</p>
<p><strong>1. 算术运算符：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
<td><code>a + b</code></td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td><code>a - b</code></td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td><code>a * b</code></td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除法</td>
<td><code>a / b</code></td>
</tr>
<tr>
<td>%</td>
<td>取模（求余数）</td>
<td><code>a % b</code></td>
</tr>
<tr>
<td>++</td>
<td>自增（前缀&#x2F;后缀）</td>
<td><code>++a</code> &#x2F; <code>a++</code></td>
</tr>
<tr>
<td>–</td>
<td>自减（前缀&#x2F;后缀）</td>
<td><code>--a</code> &#x2F; <code>a--</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>注意：</strong><ul>
<li>整数除法会舍去小数部分。  例如，<code>5 / 2</code> 的结果是 <code>2</code>。</li>
<li>取模运算符 <code>%</code> 用于计算除法的余数。  例如，<code>5 % 2</code> 的结果是 <code>1</code>。</li>
<li>自增和自减运算符可以放在变量前面（前缀）或后面（后缀）。  前缀形式会先改变变量的值，然后返回改变后的值。  后缀形式会先返回变量的值，然后改变变量的值。</li>
</ul>
</li>
</ul>
<p><strong>2. 关系运算符：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>等于</td>
<td><code>a == b</code></td>
<td><code>true</code> 或 <code>false</code></td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等于</td>
<td><code>a != b</code></td>
<td><code>true</code> 或 <code>false</code></td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td><code>a &gt; b</code></td>
<td><code>true</code> 或 <code>false</code></td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td><code>a &lt; b</code></td>
<td><code>true</code> 或 <code>false</code></td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
<td><code>a &gt;= b</code></td>
<td><code>true</code> 或 <code>false</code></td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
<td><code>a &lt;= b</code></td>
<td><code>true</code> 或 <code>false</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>注意：</strong><ul>
<li>关系运算符用于比较两个值之间的关系。</li>
<li>关系运算符的返回值是布尔类型 (<code>true</code> 或 <code>false</code>)。</li>
</ul>
</li>
</ul>
<p><strong>3. 逻辑运算符：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td><code>a &amp;&amp; b</code></td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
<td><code>a || b</code></td>
</tr>
<tr>
<td>!</td>
<td>逻辑非</td>
<td><code>!a</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>注意：</strong><ul>
<li>逻辑运算符用于组合或修改布尔表达式。</li>
<li>逻辑与 <code>&amp;&amp;</code>：当且仅当两个操作数都为 <code>true</code> 时，结果才为 <code>true</code>。</li>
<li>逻辑或 <code>||</code>：当且仅当两个操作数都为 <code>false</code> 时，结果才为 <code>false</code>。</li>
<li>逻辑非 <code>!</code>：用于反转操作数的布尔值。</li>
</ul>
</li>
</ul>
<p><strong>4. 位运算符：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与</td>
<td><code>a &amp; b</code></td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td><code>a | b</code></td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td><code>a ^ b</code></td>
</tr>
<tr>
<td>~</td>
<td>按位取反</td>
<td><code>~a</code></td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td><code>a &lt;&lt; b</code></td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td><code>a &gt;&gt; b</code></td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>无符号右移</td>
<td><code>a &gt;&gt;&gt; b</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>注意：</strong><ul>
<li>位运算符用于对整数类型的二进制位进行操作。</li>
<li>左移 <code>&lt;&lt;</code>：将操作数的二进制位向左移动指定的位数，右边空出的位用 0 填充。</li>
<li>右移 <code>&gt;&gt;</code>：将操作数的二进制位向右移动指定的位数，左边空出的位用符号位填充（如果操作数是正数，则用 0 填充；如果操作数是负数，则用 1 填充）。</li>
<li>无符号右移 <code>&gt;&gt;&gt;</code>：将操作数的二进制位向右移动指定的位数，左边空出的位用 0 填充。</li>
</ul>
</li>
</ul>
<p><strong>5. 赋值运算符：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>赋值</td>
<td><code>a = b</code></td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加法赋值</td>
<td><code>a += b</code></td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减法赋值</td>
<td><code>a -= b</code></td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘法赋值</td>
<td><code>a *= b</code></td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除法赋值</td>
<td><code>a /= b</code></td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>取模赋值</td>
<td><code>a %= b</code></td>
</tr>
<tr>
<td>&amp;&#x3D;</td>
<td>按位与赋值</td>
<td><code>a &amp;= b</code></td>
</tr>
<tr>
<td>|&#x3D;</td>
<td>按位或赋值</td>
<td><code>a |= b</code></td>
</tr>
<tr>
<td>^&#x3D;</td>
<td>按位异或赋值</td>
<td><code>a ^= b</code></td>
</tr>
<tr>
<td>&lt;&lt;&#x3D;</td>
<td>左移赋值</td>
<td><code>a &lt;&lt;= b</code></td>
</tr>
<tr>
<td>&gt;&gt;&#x3D;</td>
<td>右移赋值</td>
<td><code>a &gt;&gt;= b</code></td>
</tr>
<tr>
<td>&gt;&gt;&gt;&#x3D;</td>
<td>无符号右移赋值</td>
<td><code>a &gt;&gt;&gt;= b</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>注意：</strong><ul>
<li>赋值运算符用于将一个值赋给一个变量。</li>
<li>复合赋值运算符 (例如 <code>+=</code>, <code>-=</code>, <code>*=</code>) 是一种简写形式，例如 <code>a += b</code> 等价于 <code>a = a + b</code>。</li>
</ul>
</li>
</ul>
<p><strong>6. 三元运算符：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>?:</td>
<td>三元条件运算符</td>
<td><code>condition ? value1 : value2</code></td>
</tr>
</tbody></table>
<ul>
<li><strong>注意：</strong><ul>
<li>三元运算符是一种简洁的条件表达式。</li>
<li>如果 <code>condition</code> 为 <code>true</code>，则返回 <code>value1</code>；否则，返回 <code>value2</code>。</li>
</ul>
</li>
</ul>
<p><strong>7. 其他运算符：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>成员访问运算符</td>
<td><code>object.member</code></td>
</tr>
<tr>
<td>[]</td>
<td>数组索引运算符</td>
<td><code>array[index]</code></td>
</tr>
<tr>
<td>()</td>
<td>方法调用运算符</td>
<td><code>method()</code></td>
</tr>
<tr>
<td>new</td>
<td>对象创建运算符</td>
<td><code>new Class()</code></td>
</tr>
<tr>
<td>instanceof</td>
<td>类型检查运算符</td>
<td><code>object instanceof Class</code></td>
</tr>
</tbody></table>
<p><strong>运算符优先级：</strong></p>
<p>运算符优先级决定了表达式中运算符的执行顺序。  可以使用括号 <code>()</code> 来改变运算符的优先级。  以下是 Java 中运算符的优先级（从高到低）：</p>
<ol>
<li><code>()</code></li>
<li><code>++</code>, <code>--</code> (后缀)</li>
<li><code>!</code>, <code>+</code>, <code>-</code>, <code>~</code>, <code>++</code>, <code>--</code> (前缀)</li>
<li><code>*</code>, <code>/</code>, <code>%</code></li>
<li><code>+</code>, <code>-</code></li>
<li><code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code></li>
<li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>instanceof</code></li>
<li><code>==</code>, <code>!=</code></li>
<li><code>&amp;</code></li>
<li><code>^</code></li>
<li><code>|</code></li>
<li><code>&amp;&amp;</code></li>
<li><code>||</code></li>
<li><code>?:</code></li>
<li><code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&gt;&gt;&gt;=</code></li>
</ol>
<p>希望以上信息能够帮助你理解 Java 中的运算符。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章：Numpy的使用</title>
    <url>/2025/05/12/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9ANumpy%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="numpy简介"><a href="#numpy简介" class="headerlink" title="numpy简介"></a>numpy简介</h2><p>NumPy（Numerical Python的简称）是 Python 中用于科学计算的一个基础库。它提供了一个强大的 N维数组对象 <code>ndarray</code>，以及用于处理这些数组的各种函数。</p>
<p>以下是 NumPy 的一些关键特性和功能：</p>
<ul>
<li><strong>ndarray (N-dimensional Array Object):</strong> NumPy 的核心是 <code>ndarray</code> 对象，它是一个多维数组，其中的所有元素都具有相同的数据类型。这使得 NumPy 能够高效地存储和操作大量数据。</li>
<li><strong>矢量化操作：</strong> NumPy 允许你对整个数组执行操作，而无需编写显式的循环。这被称为矢量化，它可以显著提高代码的执行速度。</li>
<li><strong>广播 (Broadcasting):</strong> NumPy 具有广播功能，允许你在不同形状的数组之间执行操作。例如，你可以将一个标量值加到一个数组的所有元素上。</li>
<li><strong>数学函数：</strong> NumPy 提供了大量的数学函数，包括三角函数、指数函数、对数函数等，可以用于数组的元素级运算。</li>
<li><strong>线性代数：</strong> NumPy 包含用于线性代数运算的模块，例如矩阵乘法、求逆、特征值分解等。</li>
<li><strong>随机数生成：</strong> NumPy 提供了生成各种随机数的函数，可以用于模拟、统计分析等领域。</li>
<li><strong>傅里叶变换：</strong> NumPy 包含用于执行傅里叶变换的模块，这在信号处理和其他科学领域中非常有用。</li>
<li><strong>易于与其他语言集成：</strong> NumPy 可以很容易地与用 C、C++ 或 Fortran 编写的代码集成，这使得它成为构建高性能科学计算工具的理想选择。</li>
</ul>
<p>总的来说，NumPy 是 Python 中进行数值计算、科学计算和数据分析的重要工具。它的高效数组操作、丰富的数学函数和与其他语言的集成能力，使得它成为许多科学计算库（如 SciPy、Pandas 和 Scikit-learn）的基础。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入numpy库，用于后续创建和操作数组  </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建一个numpy数组t1，包含1到5的整数  </span></span><br><span class="line">t1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 输出数组t1的内容  </span></span><br><span class="line"><span class="built_in">print</span>(t1)  </span><br><span class="line"><span class="comment"># 输出数组t1的数据类型  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(t1))  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建一个numpy数组t2，包含0到9的整数  </span></span><br><span class="line">t2 = np.array(<span class="built_in">range</span>(<span class="number">10</span>))  </span><br><span class="line"><span class="built_in">print</span>(t2)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用arange函数创建一个numpy数组t3，包含0到9的整数  </span></span><br><span class="line">t3 = np.arange(<span class="number">10</span>)  </span><br><span class="line"><span class="built_in">print</span>(t3)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用arange函数创建一个numpy数组t4，包含1到9的奇数  </span></span><br><span class="line">t4 = np.arange(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(t4)  </span><br><span class="line"><span class="comment"># 输出数组t4的数据类型  </span></span><br><span class="line"><span class="built_in">print</span>(t4.dtype)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用arange函数创建一个numpy数组t5，包含1到9的奇数，数据类型指定为float32  </span></span><br><span class="line">t5 = np.arange(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>, dtype=np.float32)  </span><br><span class="line"><span class="built_in">print</span>(t5)  </span><br><span class="line"><span class="built_in">print</span>(t5.dtype)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">t7=t4.astype(<span class="string">&quot;int8&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(t7)  </span><br><span class="line"><span class="built_in">print</span>(t7.dtype)  </span><br><span class="line">  </span><br><span class="line">t8=np.<span class="built_in">round</span>(t5,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(t8)  </span><br><span class="line"><span class="built_in">print</span>(t8.dtype)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/264LbWv.png"></p>
<h2 id="numpy创建数组-矩阵"><a href="#numpy创建数组-矩阵" class="headerlink" title="numpy创建数组(矩阵)"></a>numpy创建数组(矩阵)</h2><h3 id="numpy重常见的数据类型"><a href="#numpy重常见的数据类型" class="headerlink" title="numpy重常见的数据类型"></a>numpy重常见的数据类型</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型</strong></td>
<td><strong>类型代码</strong></td>
<td><strong>说明</strong></td>
</tr>
<tr>
<td>int8, uint8</td>
<td>i1, u1</td>
<td>有符号和无符号的8位 (1个字节) 整型</td>
</tr>
<tr>
<td>int16, uint16</td>
<td>i2, u2</td>
<td>有符号和无符号的16位 (2个字节) 整型</td>
</tr>
<tr>
<td>int32, uint32</td>
<td>i4, u4</td>
<td>有符号和无符号的32位 (4个字节) 整型</td>
</tr>
<tr>
<td>int64, uint64</td>
<td>i8, u8</td>
<td>有符号和无符号的64位 (8个字节) 整型</td>
</tr>
<tr>
<td>float16</td>
<td>f2</td>
<td>半精度浮点数</td>
</tr>
<tr>
<td>float32</td>
<td>f4或f</td>
<td>标准的单精度浮点数。1与C的float兼容</td>
</tr>
<tr>
<td>float64</td>
<td>f8或d</td>
<td>标准的双精度浮点数。与C的double和Python的float对象兼容</td>
</tr>
<tr>
<td>float128</td>
<td>f16或g</td>
<td>扩展精度浮点数</td>
</tr>
<tr>
<td>complex64, complex128, complex256</td>
<td>c8, c16, c32</td>
<td>分别用两个32位2、64位或128位浮点数表示的复数</td>
</tr>
<tr>
<td>bool</td>
<td>?</td>
<td>存储True和Fa3lse值的布尔类型</td>
</tr>
</tbody></table>
<h3 id="广播原则"><a href="#广播原则" class="headerlink" title="广播原则"></a>广播原则</h3><p>NumPy 的广播 (broadcasting) 是一种强大的机制，允许 NumPy 在执行算术运算时处理不同形状的数组。广播解决了在数组形状不完全匹配时如何进行元素级运算的问题。</p>
<p>以下是 NumPy 广播需要遵循的规则：</p>
<ol>
<li><strong>维度对齐：</strong> NumPy 会比较两个数组的形状。从 trailing dimension（即最后一个轴）开始比较，并向后进行。</li>
<li><strong>兼容性检查：</strong> 对于两个数组的每个维度，它们必须满足以下条件之一才能兼容：<ul>
<li>维度大小相等。</li>
<li>其中一个维度的大小为 1。</li>
</ul>
</li>
<li><strong>广播执行：</strong> 如果满足上述兼容性条件，NumPy 会“广播”维度大小为 1 的数组，使其与另一个数组的对应维度大小相匹配。这个过程不会复制数据，而是在逻辑上扩展数组，使其具有相同的形状。</li>
<li><strong>输出形状：</strong> 最终输出数组的形状是输入数组形状的元素级最大值。也就是说，输出数组的每个维度的大小是输入数组在该维度上的最大大小。</li>
</ol>
<p>如果这些规则不满足，NumPy 将抛出一个 <code>ValueError</code>，表明数组的形状不兼容。</p>
<p><strong>举例说明：</strong></p>
<p>假设有两个数组 <code>A</code> 和 <code>B</code>：</p>
<ul>
<li><code>A</code> 的形状是 <code>(4, 3)</code></li>
<li><code>B</code> 的形状是 <code>(3,)</code></li>
</ul>
<p>在这种情况下，NumPy 会将 <code>B</code> 广播到形状 <code>(4, 3)</code>，然后执行元素级加法。<code>B</code> 实际上并没有被复制 4 次，而是在计算过程中被逻辑地扩展。</p>
<p>另一个例子：</p>
<ul>
<li><code>A</code> 的形状是 <code>(4, 1)</code></li>
<li><code>B</code> 的形状是 <code>(1, 3)</code></li>
</ul>
<p>NumPy 可以将 <code>A</code> 广播到形状 <code>(4, 3)</code>，并将 <code>B</code> 也广播到形状 <code>(4, 3)</code>，然后执行运算。</p>
<p><strong>总结：</strong></p>
<p>广播允许 NumPy 在形状不完全匹配的数组之间执行有意义的运算，而无需显式地重塑数组。这使得代码更简洁、更易读，并且通常更高效。理解广播规则对于有效地使用 NumPy 至关重要。</p>
<p><img src="https://i.imgur.com/zkvBblG.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入numpy库，用于后续的数组操作  </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建一个一维数组t1，包含0到11的整数  </span></span><br><span class="line">t1 = np.arange(<span class="number">12</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印t1数组的形状，此处为一维数组  </span></span><br><span class="line"><span class="built_in">print</span>(t1.shape)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印t1数组的内容  </span></span><br><span class="line"><span class="built_in">print</span>(t1)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 对t1数组进行形状重塑，转换为3行4列的二维数组，但此处未将重塑后的数组赋值给t1，因此t1的形状不会改变  </span></span><br><span class="line">t2=t1.reshape(<span class="number">3</span>, <span class="number">4</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印重塑后的数组，展示3行4列的二维数组形式  </span></span><br><span class="line"><span class="built_in">print</span>(t1.reshape(<span class="number">3</span>, <span class="number">4</span>))  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建并打印一个三维数组t5，包含24个元素，形状为2x3x4  </span></span><br><span class="line">t5 = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  </span><br><span class="line"><span class="built_in">print</span>(t5)  </span><br><span class="line"><span class="built_in">print</span>(t5+<span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建并打印一个形状为24x1的二维数组t6，包含0到23的整数  </span></span><br><span class="line">t6=np.arange(<span class="number">24</span>).reshape(<span class="number">24</span>,<span class="number">1</span>)  </span><br><span class="line"><span class="built_in">print</span>(t6)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将t2数组重塑为一维数组，展示如何通过计算动态确定数组形状  </span></span><br><span class="line">t7=t2.reshape((t2.shape[<span class="number">0</span>]*t2.shape[<span class="number">1</span>],))  </span><br><span class="line"><span class="built_in">print</span>(t7)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印t2数组的平铺版本，每个元素增加2，展示数组的flatten方法和元素级运算  </span></span><br><span class="line"><span class="built_in">print</span>(t2.flatten()+<span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建并打印数组t8，形状为3x4，包含64到75的整数，展示如何创建指定范围和形状的数组  </span></span><br><span class="line">t8=np.arange(<span class="number">64</span>,<span class="number">76</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印t2和t8数组的元素级乘积，展示数组间的元素级运算  </span></span><br><span class="line"><span class="built_in">print</span>(t2*t8)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建并打印一个包含0到3的整数的一维数组t9  </span></span><br><span class="line">t9=np.arange(<span class="number">4</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将t9数组重塑为4x1的二维数组，展示如何改变数组的形状  </span></span><br><span class="line">t10=t9.reshape(<span class="number">4</span>,<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印t2和t9数组的元素级乘积，由于t9是一维数组，展示广播机制  </span></span><br><span class="line"><span class="built_in">print</span>(t2*t9)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印t2和t10数组的元素级乘积，由于t10是二维数组，避免了广播  </span></span><br><span class="line"><span class="built_in">print</span>(t2*t10)</span><br></pre></td></tr></table></figure>

<h2 id="numpy的轴"><a href="#numpy的轴" class="headerlink" title="numpy的轴"></a>numpy的轴</h2><p>在 NumPy 中，“轴”（axis）是多维数组（<code>ndarray</code>）的一个重要概念，它用于描述数组的维度。理解轴的概念对于正确地操作和处理 NumPy 数组至关重要。</p>
<p><strong>基本概念：</strong></p>
<ul>
<li><strong>维度 (Dimension):</strong> 数组的维度是指数组拥有的轴的数量。例如，一个二维数组有两个维度（行和列），一个三维数组有三个维度，以此类推。</li>
<li><strong>轴 (Axis):</strong> 每个维度对应一个轴。轴的编号从 0 开始。对于一个二维数组，轴 0 通常代表行，轴 1 代表列。对于更高维度的数组，轴的编号依次递增。</li>
<li><strong>形状 (Shape):</strong> 数组的形状是一个元组，其中包含每个轴的长度（即该轴上的元素数量）。例如，一个形状为 <code>(3, 4)</code> 的二维数组有 3 行和 4 列。</li>
</ul>
<p><strong>轴的含义：</strong></p>
<p>轴的概念主要用于描述 NumPy 中各种操作的方向。例如，在对数组进行求和、平均值、排序等操作时，可以指定沿着哪个轴进行操作。</p>
<ul>
<li><strong>二维数组：</strong><ul>
<li><code>axis=0</code>：沿着行的方向进行操作（即对每一列进行操作）。</li>
<li><code>axis=1</code>：沿着列的方向进行操作（即对每一行进行操作）。</li>
</ul>
</li>
<li><strong>三维数组：</strong><ul>
<li><code>axis=0</code>：沿着第一个维度的方向进行操作。</li>
<li><code>axis=1</code>：沿着第二个维度的方向进行操作。</li>
<li><code>axis=2</code>：沿着第三个维度的方向进行操作。</li>
</ul>
</li>
</ul>
<p><strong>举例说明：</strong></p>
<p>假设有一个二维数组 <code>arr</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>arr.sum(axis=0)</code>：沿着轴 0（行）求和，结果是 <code>[5, 7, 9]</code> (1+4, 2+5, 3+6)。</li>
<li><code>arr.sum(axis=1)</code>：沿着轴 1（列）求和，结果是 <code>[6, 15]</code> (1+2+3, 4+5+6)。</li>
</ul>
<p><strong>总结：</strong></p>
<p>理解 NumPy 中轴的概念是进行有效数组操作的关键。通过指定轴，你可以控制 NumPy 函数在哪个维度上执行操作，从而实现各种复杂的计算和数据处理任务。记住，轴的编号从 0 开始，并且轴的方向决定了操作的执行方式。</p>
<h2 id="numpy的索引和切片"><a href="#numpy的索引和切片" class="headerlink" title="numpy的索引和切片"></a>numpy的索引和切片</h2><p><strong>核心概念：</strong> NumPy 数组的索引和切片操作与 Python 列表的操作非常相似，但更加强大和灵活，尤其是在处理多维数组时。</p>
<p><strong>基本索引 (获取单个元素)：</strong></p>
<ul>
<li><code>a[行索引, 列索引]</code>：用于获取二维 NumPy 数组中的单个元素。<ul>
<li>例如，对于数组 <code>a = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]</code>：<ul>
<li><code>a[1]</code>：获取索引为 1 的<strong>行</strong>，结果是 <code>[4, 5, 6, 7]</code>。</li>
<li><code>a[0, 2]</code>：获取索引为 0 的<strong>行</strong>和索引为 2 的<strong>列</strong>的元素，结果是 <code>2</code>。</li>
<li><code>a[2, 0]</code>：获取索引为 2 的<strong>行</strong>和索引为 0 的<strong>列</strong>的元素，结果是 <code>8</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>基本切片 (获取子数组)：</strong></p>
<ul>
<li><code>a[start_row:end_row, start_col:end_col]</code>：用于获取二维 NumPy 数组的子数组。<ul>
<li><code>start</code>：起始索引（包含）。</li>
<li><code>end</code>：结束索引（不包含）。</li>
<li>省略 <code>start</code> 表示从头开始，省略 <code>end</code> 表示到末尾。</li>
<li>冒号 <code>:</code> 表示选择整个维度。</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li><p><strong>获取一行：</strong></p>
<ul>
<li><code>a[1]</code> 或 <code>a[1, :]</code>：获取索引为 1 的<strong>一行</strong>，结果是 <code>[4, 5, 6, 7]</code>。</li>
<li><code>a[:, 2]</code>：获取所有行的索引为 2 的<strong>一列</strong>，结果是 <code>[2, 6, 10]</code>。</li>
</ul>
</li>
<li><p><strong>获取多行：</strong></p>
<ul>
<li><code>a[1:3]</code> 或 <code>a[1:3, :]</code>：获取索引从 1 到 2 的<strong>多行</strong>，结果是 <code>[[4, 5, 6, 7], [8, 9, 10, 11]]</code>。</li>
</ul>
</li>
<li><p><strong>获取多列：</strong></p>
<ul>
<li><code>a[:, 2:4]</code>：获取所有行的索引从 2 到 3 的<strong>多列</strong>，结果是 <code>[[2, 3], [6, 7], [10, 11]]</code>。</li>
</ul>
</li>
<li><p><strong>同时获取多行和多列：</strong></p>
<ul>
<li><code>a[1:3, 2:4]</code>：获取索引从 1 到 2 的<strong>行</strong>和索引从 2 到 3 的<strong>列</strong>的子数组，结果是 <code>[[6, 7], [10, 11]]</code>。</li>
</ul>
</li>
</ul>
<p><strong>步长 (stride) 切片：</strong></p>
<ul>
<li><code>a[start:end:step]</code>：可以在切片中指定步长。<ul>
<li><code>step</code>：步长，表示每隔多少个元素选择一个。</li>
</ul>
</li>
</ul>
<p><strong>示例 (根据图片中的问题)：</strong></p>
<ul>
<li><p><code>a[[1, 3], :]</code>：<strong>（注意：图片中是 <code>a[[1, 3], :]</code>，这实际上是使用花式索引选择行索引为 1 和 3 的行。假设数组 <code>a</code> 至少有 4 行）</strong> 表示选择索引为 1 和 3 的<strong>行</strong>的所有列。</p>
</li>
<li><p><code>a[:, 2:4]</code>：表示选择所有<strong>行</strong>的索引从 2 到 3 的<strong>列</strong>。</p>
</li>
</ul>
<p><strong>总结：</strong></p>
<p>NumPy 的索引和切片功能非常强大，能够灵活地访问和操作数组中的元素和子数组。理解基本的索引和切片语法，以及如何应用于多维数组，是使用 NumPy 进行数据分析的关键。步长切片和花式索引提供了更高级的元素选择方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建一个包含24个元素的数组，并将其重塑为6行4列的二维数组  </span></span><br><span class="line">t1=np.arange(<span class="number">24</span>).reshape(<span class="number">6</span>,<span class="number">4</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印第二行的全部元素  </span></span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">1</span>])  </span><br><span class="line"><span class="comment"># 打印第二行的全部元素，效果与上一行相同  </span></span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">1</span>,:])  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印前两行的所有元素  </span></span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">0</span>:<span class="number">2</span>,:])  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印所有行的前两列元素  </span></span><br><span class="line"><span class="built_in">print</span>(t1[:,<span class="number">0</span>:<span class="number">2</span>])  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印整个数组  </span></span><br><span class="line"><span class="built_in">print</span>(t1)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印第3行到第4行和第2列到第3列的子数组  </span></span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">2</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">3</span>])  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印第2行和第4行的所有元素  </span></span><br><span class="line"><span class="built_in">print</span>(t1[[<span class="number">1</span>,<span class="number">3</span>],:])</span><br></pre></td></tr></table></figure>

<p>其他操作</p>
<h3 id="numpy的布尔索引"><a href="#numpy的布尔索引" class="headerlink" title="numpy的布尔索引"></a>numpy的布尔索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印t1数组中索引为1和3的行以及所有列  </span></span><br><span class="line"><span class="built_in">print</span>(t1[[<span class="number">1</span>,<span class="number">3</span>],:])  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印一个布尔数组，显示t1数组中每个元素是否小于10  </span></span><br><span class="line"><span class="built_in">print</span>(t1&lt;<span class="number">10</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将t1数组中所有小于10的元素设置为3  </span></span><br><span class="line">t1[t1&lt;<span class="number">10</span>]=<span class="number">3</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印更新后的t1数组  </span></span><br><span class="line"><span class="built_in">print</span>(t1)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/ATrZ5PC.png"></p>
<h3 id="numpy的三元运算符"><a href="#numpy的三元运算符" class="headerlink" title="numpy的三元运算符"></a>numpy的三元运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印t1数组中元素是否小于10的结果：如果元素小于10，则对应位置输出3；否则输出20</span></span><br><span class="line"><span class="built_in">print</span>(np.where(t1&lt;<span class="number">10</span>,<span class="number">3</span>,<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新t1数组，条件同上</span></span><br><span class="line">t1=np.where(t1&lt;<span class="number">10</span>,<span class="number">3</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印更新后的t1数组</span></span><br><span class="line"><span class="built_in">print</span>(t1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/foBtTfx.png"></p>
<h2 id="numpy中的nan和inf"><a href="#numpy中的nan和inf" class="headerlink" title="numpy中的nan和inf"></a>numpy中的nan和inf</h2><h3 id="nan（NAN、Nan）"><a href="#nan（NAN、Nan）" class="headerlink" title="nan（NAN、Nan）"></a><code>nan</code>（<code>NAN</code>、<code>Nan</code>）</h3><ul>
<li><code>not a number</code>，表示不是一个数字。</li>
<li><strong>在<code>numpy</code>中出现<code>nan</code>的情况</strong>：<ul>
<li>读取本地文件为<code>float</code>类型时，若存在缺失值，会出现<code>nan</code>。</li>
<li>进行不合适的计算时，比如无穷大（<code>inf</code>）减去无穷大。</li>
</ul>
</li>
</ul>
<h3 id="inf（-inf、inf）"><a href="#inf（-inf、inf）" class="headerlink" title="inf（-inf、inf）"></a><code>inf</code>（<code>-inf</code>、<code>inf</code>）</h3><ul>
<li><code>infinity</code>，<code>inf</code>表示正无穷，<code>-inf</code>表示负无穷。</li>
<li><strong>在<code>numpy</code>中出现<code>inf</code>（包括<code>-inf</code>，<code>+inf</code> ）的情况</strong>：<br>  例如一个数字除以 0 ，在<code>python</code>中直接报错，在<code>numpy</code>中会得到一个<code>inf</code>或者<code>-inf</code>。</li>
</ul>
<h4 id="指定nan或inf及类型"><a href="#指定nan或inf及类型" class="headerlink" title="指定nan或inf及类型"></a>指定<code>nan</code>或<code>inf</code>及类型</h4><ul>
<li><strong>指定方法</strong>：在<code>numpy</code>中可使用<code>np.inf</code>指定无穷大，使用<code>np.nan</code>指定非数字。</li>
<li><strong>类型</strong>：<ul>
<li><code>In [71]: a = np.inf</code></li>
<li><code>In [73]: type(a)</code></li>
<li><code>Out[73]: float</code></li>
<li><code>In [74]: a = np.nan</code></li>
<li><code>In [75]: type(a)</code></li>
<li><code>Out[75]: float</code></li>
</ul>
</li>
</ul>
<h4 id="nan-的特性及相关操作"><a href="#nan-的特性及相关操作" class="headerlink" title="nan 的特性及相关操作"></a><code>nan</code> 的特性及相关操作</h4><ol>
<li><strong><code>nan</code> 的不等性</strong><ul>
<li>两个 <code>nan</code> 是不相等的。示例：<ul>
<li><code>In [76]: np.nan==np.nan</code></li>
<li><code>Out[76]: False</code></li>
</ul>
</li>
<li><code>np.nan!=np.nan</code> 结果为 <code>True</code> 。示例：<ul>
<li><code>In [81]: np.nan!=np.nan</code></li>
<li><code>Out[81]: True</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>判断数组中 <code>nan</code> 的个数</strong><br> 利用 <code>nan</code> 不等于自身的特性，使用 <code>np.count_nonzero()</code> 函数。示例：<ul>
<li><code>In [86]: t</code></li>
<li><code>Out[86]: array([ 1., 2., nan])</code></li>
<li><code>In [87]: np.count_nonzero(t!=t)</code></li>
<li><code>Out[87]: 1</code></li>
</ul>
</li>
<li><strong>判断单个数字是否为 <code>nan</code></strong><br> 通过 <code>np.isnan(a)</code> 来判断，返回 <code>bool</code> 类型。若要将数组中的 <code>nan</code> 替换为 <code>0</code> ，示例如下：<ul>
<li><code>In [89]: t</code></li>
<li><code>Out[89]: array([ 1., 2., nan])</code></li>
<li><code>In [90]: t[np.isnan(t)]=0</code></li>
<li><code>In [91]: t</code></li>
<li><code>Out[91]: array([ 1., 2., 0.])</code></li>
</ul>
</li>
<li><strong><code>nan</code> 的计算特性</strong><br> <code>nan</code> 和任何值计算结果都为 <code>nan</code> 。</li>
</ol>
<h2 id="numpy中的常见统计方法"><a href="#numpy中的常见统计方法" class="headerlink" title="numpy中的常见统计方法"></a>numpy中的常见统计方法</h2><ol>
<li><strong>求和</strong>：<code>t.sum(axis=None)</code></li>
<li><strong>均值</strong>：<code>t.mean(axis=None)</code> ，受离群点影响较大。</li>
<li><strong>中值</strong>：<code>np.median(t,axis=None)</code></li>
<li><strong>最大值</strong>：<code>t.max(axis=None)</code></li>
<li><strong>最小值</strong>：<code>t.min(axis=None)</code></li>
<li><strong>极值</strong>：<code>np.ptp(t,axis=None)</code> ，即最大值和最小值只差。</li>
<li><strong>标准差</strong>：<code>t.std(axis=None)</code> ，公式为 $σ &#x3D; \sqrt{\frac{1}{N}\sum_{i&#x3D;1}^{N}(x_i - μ)^2}$ ，是一组数据平均值分散程度的一种度量。较大标准差代表大部分数值与其平均值差异大；较小标准差代表数值较接近平均值，反映数据波动稳定情况，越大表示波动越大、越不稳定。</li>
</ol>
<h3 id="nan（NAN、Nan）-1"><a href="#nan（NAN、Nan）-1" class="headerlink" title="nan（NAN、Nan）"></a>nan（NAN、Nan）</h3><ul>
<li><strong>含义</strong>：not a number，表示不是一个数字</li>
<li><strong>在 numpy 中出现的情况</strong>：<ul>
<li>读取本地文件为 float 时，若有缺失值，会出现 nan</li>
<li>进行不合适的计算时，如无穷大（inf）减去无穷大</li>
</ul>
</li>
</ul>
<h3 id="inf（-inf、inf）-1"><a href="#inf（-inf、inf）-1" class="headerlink" title="inf（-inf、inf）"></a>inf（-inf、inf）</h3><ul>
<li><strong>含义</strong>：infinity，inf 表示正无穷，-inf 表示负无穷</li>
<li><strong>在 numpy 中出现的情况</strong>：例如一个数字除以 0 （在 python 中直接报错，在 numpy 中得到 inf 或 -inf ）</li>
</ul>
<h3 id="指定方法及类型"><a href="#指定方法及类型" class="headerlink" title="指定方法及类型"></a>指定方法及类型</h3><ul>
<li><strong>指定方法</strong>：<ul>
<li>使用<code>np.inf</code>指定无穷大（正无穷）</li>
<li>使用<code>np.nan</code>指定非数字</li>
</ul>
</li>
<li><strong>类型</strong>：<ul>
<li><code>type(np.inf)</code> 结果为 float</li>
<li><code>type(np.nan)</code> 结果为 float</li>
</ul>
</li>
</ul>
<h3 id="关于-numpy-中-nan-处理的要点总结"><a href="#关于-numpy-中-nan-处理的要点总结" class="headerlink" title="关于 numpy 中 nan 处理的要点总结"></a>关于 numpy 中 nan 处理的要点总结</h3><ul>
<li><strong>单纯替换为 0 的影响</strong>：在一组数据中单纯把 nan 替换为 0 不合适。若原始数据均值大于 0 ，全部替换为 0 后均值会变小 ，改变数据的统计特征。</li>
<li><strong>更优处理方式</strong>：<ul>
<li><strong>填充法</strong>：用均值或中值替换缺失数值。均值是数据总和除以数据个数；中值是将数据排序后，位于中间位置的数值（数据个数为奇数时）或中间两个数的平均值（数据个数为偶数时） 。</li>
<li><strong>删除法</strong>：直接删除有缺失值的行（列），在 pandas 中可进行相关操作。</li>
</ul>
</li>
</ul>
<h2 id="数组的拼接"><a href="#数组的拼接" class="headerlink" title="数组的拼接"></a>数组的拼接</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">180</span>]: t = np.arange (<span class="number">12</span>,<span class="number">24</span>).reshape (<span class="number">3</span>,<span class="number">4</span>)  </span><br><span class="line">In [<span class="number">181</span>]: t  </span><br><span class="line">Out [<span class="number">181</span>]:  </span><br><span class="line">array ([[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],  </span><br><span class="line">[<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],  </span><br><span class="line">[<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]])  </span><br><span class="line">In [<span class="number">182</span>]: t [[<span class="number">1</span>,<span class="number">2</span>],:] = t [[<span class="number">2</span>,<span class="number">1</span>],:] <span class="comment">#行交换  </span></span><br><span class="line">In [<span class="number">183</span>]: t  </span><br><span class="line">Out [<span class="number">183</span>]:  </span><br><span class="line">array ([[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],  </span><br><span class="line">[<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],  </span><br><span class="line">[<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]])  </span><br><span class="line">In [<span class="number">184</span>]: t [:,[<span class="number">0</span>,<span class="number">2</span>]] = t [:,[<span class="number">2</span>,<span class="number">0</span>]] <span class="comment">#列交换  </span></span><br><span class="line">In [<span class="number">185</span>]: t  </span><br><span class="line">Out [<span class="number">185</span>]:  </span><br><span class="line">array ([[<span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">15</span>],  </span><br><span class="line">[<span class="number">22</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">23</span>],  </span><br><span class="line">[<span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">19</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/TheisTrue/DataAnalysis%E8%B5%84%E6%96%99">https://github.com/TheisTrue/DataAnalysis资料</a></p>
<p>实例<br><img src="https://i.imgur.com/gFhPptd.png"><br><img src="https://i.imgur.com/zABRVU1.png"></p>
<h3 id="numpy-生成随机数"><a href="#numpy-生成随机数" class="headerlink" title="numpy 生成随机数"></a>numpy 生成随机数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>.rand(d0,d1,...dn)</code></td>
<td>创建 d0 - dn 维度的均匀分布随机数组，元素为浮点数，范围 0 - 1</td>
</tr>
<tr>
<td><code>.randn(d0,d1,...dn)</code></td>
<td>创建 d0 - dn 维度的标准正态分布随机数，元素为浮点数，平均数 0，标准差 1</td>
</tr>
<tr>
<td><code>.randint(low,high,(shape))</code></td>
<td>从给定上下限范围（low - high）选取随机整数，数组形状由 shape 指定</td>
</tr>
<tr>
<td><code>.uniform(low,high,(size))</code></td>
<td>产生具有均匀分布的数组，low 为起始值，high 为结束值，size 指定形状</td>
</tr>
<tr>
<td><code>.normal(loc,scale,(size))</code></td>
<td>从指定正态分布中随机抽取样本，分布中心为 loc（均值），标准差为 scale，size 指定形状</td>
</tr>
<tr>
<td><code>.seed(s)</code></td>
<td>随机数种子，s 为给定种子值。计算机生成伪随机数，设定相同种子可每次生成相同随机数</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">```python</span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义美国youtube视频数据文件路径</span></span><br><span class="line">us_file_path = <span class="string">&quot;./youtube_video_data/US_video_data_numbers.csv&quot;</span></span><br><span class="line"><span class="comment"># 定义英国youtube视频数据文件路径</span></span><br><span class="line">uk_file_path = <span class="string">&quot;./youtube_video_data/GB_video_data_numbers.csv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用loadtxt读取美国youtube视频数据，delimiter指定分隔符为逗号，dtype指定数据类型为整数</span></span><br><span class="line"><span class="comment"># unpack=True会将数据进行转置，这里注释掉了，所以不转置</span></span><br><span class="line"><span class="comment"># t1 = np.loadtxt(us_file_path,delimiter=&quot;,&quot;,dtype=&quot;int&quot;,unpack=True)</span></span><br><span class="line">t2 = np.loadtxt(us_file_path,delimiter=<span class="string">&quot;,&quot;</span>,dtype=<span class="string">&quot;int&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印t1，这里注释掉了</span></span><br><span class="line"><span class="comment"># print(t1)</span></span><br><span class="line"><span class="comment"># 打印t2，t2是读取的美国youtube视频数据</span></span><br><span class="line"><span class="built_in">print</span>(t2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取行</span></span><br><span class="line"><span class="comment"># 打印t2的第3行（索引为2）</span></span><br><span class="line"><span class="comment"># print(t2[2])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取连续的多行</span></span><br><span class="line"><span class="comment"># 打印t2的第3行到最后一行（索引为2到结尾）</span></span><br><span class="line"><span class="comment"># print(t2[2:])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取不连续的多行</span></span><br><span class="line"><span class="comment"># 打印t2的第3行、第9行和第11行（索引为2, 8, 10）</span></span><br><span class="line"><span class="comment"># print(t2[[2,8,10]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印t2的第2行（索引为1）的所有列</span></span><br><span class="line"><span class="comment"># print(t2[1,:])</span></span><br><span class="line"><span class="comment"># 打印t2的第3行到最后一行（索引为2到结尾）的所有列</span></span><br><span class="line"><span class="comment"># print(t2[2:,:])</span></span><br><span class="line"><span class="comment"># 打印t2的第3行、第11行和第4行（索引为2, 10, 3）的所有列</span></span><br><span class="line"><span class="comment"># print(t2[[2,10,3],:])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取列</span></span><br><span class="line"><span class="comment"># 打印t2的第一列（索引为0）的所有行</span></span><br><span class="line"><span class="comment"># print(t2[:,0])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取连续的多列</span></span><br><span class="line"><span class="comment"># 打印t2的第3列到最后一列（索引为2到结尾）的所有行</span></span><br><span class="line"><span class="comment"># print(t2[:,2:])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取不连续的多列</span></span><br><span class="line"><span class="comment"># 打印t2的第一列和第三列（索引为0, 2）的所有行</span></span><br><span class="line"><span class="comment"># print(t2[:,[0,2]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去行和列，取第3行，第四列的值</span></span><br><span class="line"><span class="comment"># a = t2[2,3]</span></span><br><span class="line"><span class="comment"># print(a)</span></span><br><span class="line"><span class="comment"># print(type(a))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取多行和多列，取第3行到第五行，第2列到第4列的结果</span></span><br><span class="line"><span class="comment"># 去的是行和列交叉点的位置</span></span><br><span class="line">b = t2[<span class="number">2</span>:<span class="number">5</span>,<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line"><span class="comment"># print(b)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取多个不相邻的点</span></span><br><span class="line"><span class="comment"># 选出来的结果是（0，0） （2，1） （2，3）</span></span><br><span class="line">c = t2[[<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding for</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line">  </span><br><span class="line">us_file_path = <span class="string">&quot;./youtube_video_data/US_video_data_numbers.csv&quot;</span>  </span><br><span class="line">uk_file_path = <span class="string">&quot;./youtube_video_data/GB_video_data_numbers.csv&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># t1 = np.loadtxt(us_file_path,delimiter=&quot;,&quot;,dtype=&quot;int&quot;,unpack=True)</span></span><br><span class="line"><span class="comment"># 使用 numpy 加载美国 youtube 视频数据，数据类型为 int</span></span><br><span class="line">t_us = np.loadtxt(us_file_path,delimiter=<span class="string">&quot;,&quot;</span>,dtype=<span class="string">&quot;int&quot;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 从加载的数据中提取评论数（最后一列）</span></span><br><span class="line">t_us_comments= t_us[:,-<span class="number">1</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 过滤评论数，只保留小于等于 5000 的数据，去除异常值</span></span><br><span class="line">t_us_comments = t_us_comments[t_us_comments&lt;=<span class="number">5000</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 打印过滤后的评论数的最大值和最小值</span></span><br><span class="line"><span class="built_in">print</span>(t_us_comments.<span class="built_in">max</span>(),t_us_comments.<span class="built_in">min</span>())  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 定义组距为 250</span></span><br><span class="line">d=<span class="number">250</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 计算组数，用最大值减去最小值，然后除以组距</span></span><br><span class="line">bin_nums =(t_us_comments.<span class="built_in">max</span>()-t_us_comments.<span class="built_in">min</span>())//d  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建一个图形，设置大小和分辨率</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">8</span>),dpi=<span class="number">80</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 绘制直方图，使用过滤后的评论数数据和计算出的组数</span></span><br><span class="line">plt.hist(t_us_comments,bin_nums)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/XZ5nUf0.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding for  </span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义美国视频数据文件的路径</span></span><br><span class="line">us_file_path = <span class="string">&quot;./youtube_video_data/US_video_data_numbers.csv&quot;</span></span><br><span class="line"><span class="comment"># 定义英国视频数据文件的路径</span></span><br><span class="line">uk_file_path = <span class="string">&quot;./youtube_video_data/GB_video_data_numbers.csv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 numpy 的 loadtxt 函数加载英国视频数据，指定分隔符为逗号，数据类型为整数</span></span><br><span class="line"><span class="comment"># t_uk 是一个 numpy 数组，每一行代表一个视频的数据</span></span><br><span class="line">t_uk = np.loadtxt(uk_file_path, delimiter=<span class="string">&quot;,&quot;</span>, dtype=<span class="string">&quot;int&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤数据：只保留点赞数小于等于 500000 的视频数据</span></span><br><span class="line"><span class="comment"># t_uk[:, 1] 表示 t_uk 数组的所有行的第二列（点赞数）</span></span><br><span class="line"><span class="comment"># t_uk[t_uk[:, 1] &lt;= 500000] 表示选取 t_uk 数组中第二列小于等于 500000 的所有行</span></span><br><span class="line">t_uk = t_uk[t_uk[:, <span class="number">1</span>] &lt;= <span class="number">500000</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从过滤后的数据中提取评论数和点赞数</span></span><br><span class="line"><span class="comment"># t_uk[:, -1] 表示 t_uk 数组的所有行的最后一列（评论数）</span></span><br><span class="line">t_uk_comments = t_uk[:, -<span class="number">1</span>]</span><br><span class="line"><span class="comment"># t_uk[:, 1] 表示 t_uk 数组的所有行的第二列（点赞数）</span></span><br><span class="line">t_uk_like = t_uk[:, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个图形，并设置大小和分辨率</span></span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>, <span class="number">8</span>), dpi=<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建散点图，x 轴为点赞数，y 轴为评论数</span></span><br><span class="line">plt.scatter(t_uk_like, t_uk_comments)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://i.imgur.com/1uGzzex.png"></p>
]]></content>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章：数组</title>
    <url>/2025/05/12/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>好的，我们来详细讲解一下数组 (Array)。</p>
<p><strong>什么是数组？</strong></p>
<p>数组是一种数据结构，用于存储<strong>相同类型</strong>的元素的<strong>固定大小</strong>的顺序集合。 数组中的每个元素都可以通过其索引来访问。</p>
<p><strong>数组的特点</strong></p>
<ul>
<li><strong>相同类型</strong>：数组中的所有元素必须是相同的数据类型（例如，整数、浮点数、字符串等）。</li>
<li><strong>固定大小</strong>：数组在创建时必须指定大小，并且大小在创建后不能更改。</li>
<li><strong>顺序集合</strong>：数组中的元素按照一定的顺序排列，每个元素都有一个唯一的索引。</li>
<li><strong>索引访问</strong>：可以通过索引来访问数组中的任何元素。 索引通常从 0 开始。</li>
</ul>
<p><strong>数组的优点</strong></p>
<ul>
<li><strong>高效访问</strong>：可以通过索引快速访问数组中的任何元素，时间复杂度为 O(1)。</li>
<li><strong>简单易用</strong>：数组是一种简单的数据结构，易于理解和使用。</li>
</ul>
<p><strong>数组的缺点</strong></p>
<ul>
<li><strong>固定大小</strong>：数组的大小在创建后不能更改，这可能会导致空间浪费或溢出。</li>
<li><strong>插入和删除效率低</strong>：在数组中插入或删除元素需要移动其他元素，时间复杂度为 O(n)。</li>
<li><strong>只能存储相同类型的元素</strong>：数组只能存储相同类型的元素，这限制了其灵活性。</li>
</ul>
<p><strong>数组的声明和初始化</strong></p>
<p>在 Java 中，数组的声明和初始化有多种方式：</p>
<ol>
<li><p><strong>先声明，后初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个整数数组，名为 numbers，大小为 5</span></span><br><span class="line"><span class="type">int</span>[] numbers;</span><br><span class="line">numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个字符串数组，名为 names，大小为 3</span></span><br><span class="line">String[] names;</span><br><span class="line">names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>声明并初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化一个整数数组，名为 numbers，大小为 5</span></span><br><span class="line"><span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并初始化一个字符串数组，名为 names，大小为 3</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>声明并直接赋值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化一个整数数组，名为 numbers，并直接赋值</span></span><br><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并初始化一个字符串数组，名为 names，并直接赋值</span></span><br><span class="line">String[] names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>数组元素的访问</strong></p>
<p>可以通过索引来访问数组中的元素。 索引从 0 开始，到 <code>数组长度 - 1</code> 结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问数组中的第一个元素（索引为 0）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">firstElement</span> <span class="operator">=</span> numbers[<span class="number">0</span>]; <span class="comment">// firstElement 的值为 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问数组中的第三个元素（索引为 2）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">thirdElement</span> <span class="operator">=</span> numbers[<span class="number">2</span>]; <span class="comment">// thirdElement 的值为 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改数组中的第四个元素（索引为 3）</span></span><br><span class="line">numbers[<span class="number">3</span>] = <span class="number">45</span>; <span class="comment">// numbers 数组变为 &#123;10, 20, 30, 45, 50&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>数组的长度</strong></p>
<p>可以使用 <code>数组名.length</code> 来获取数组的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> numbers.length; <span class="comment">// length 的值为 5</span></span><br></pre></td></tr></table></figure>

<p><strong>数组的遍历</strong></p>
<p>可以使用循环来遍历数组中的所有元素。</p>
<ol>
<li><p><strong>使用 <code>for</code> 循环</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Element at index &quot;</span> + i + <span class="string">&quot;: &quot;</span> + numbers[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用增强型 <code>for</code> 循环 (foreach 循环)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>多维数组</strong></p>
<p>Java 支持多维数组，例如二维数组、三维数组等。 多维数组可以看作是数组的数组。</p>
<ol>
<li><p><strong>二维数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明并初始化一个二维整数数组，3 行 4 列</span></span><br><span class="line"><span class="type">int</span>[][] matrix = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问二维数组中的元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> matrix[<span class="number">1</span>][<span class="number">2</span>]; <span class="comment">// element 的值为 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">        System.out.print(matrix[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>数组的常用操作</strong></p>
<ul>
<li><strong>排序</strong>：可以使用 <code>Arrays.sort()</code> 方法对数组进行排序。</li>
<li><strong>查找</strong>：可以使用循环或二分查找算法在数组中查找指定元素。</li>
<li><strong>复制</strong>：可以使用 <code>Arrays.copyOf()</code> 方法复制数组。</li>
<li><strong>填充</strong>：可以使用 <code>Arrays.fill()</code> 方法用指定值填充数组。</li>
<li><strong>比较</strong>：可以使用 <code>Arrays.equals()</code> 方法比较两个数组是否相等。</li>
</ul>
<p><strong>数组的替代方案</strong></p>
<p>由于数组的大小固定，插入和删除效率低，因此在某些情况下，可以使用其他数据结构来替代数组，例如：</p>
<ul>
<li><strong><code>ArrayList</code></strong>: 可变大小的数组，可以动态添加和删除元素。</li>
<li><strong><code>LinkedList</code></strong>: 链表，插入和删除效率高，但访问效率较低。</li>
<li><strong><code>HashMap</code></strong>: 键值对存储，可以根据键快速查找值。</li>
</ul>
<p><strong>总结</strong></p>
<p>数组是一种基本的数据结构，用于存储相同类型的元素的固定大小的顺序集合。 了解数组的特点、声明、初始化、访问、遍历和常用操作对于编写 Java 程序至关重要。 在选择数据结构时，需要根据实际需求权衡数组的优缺点，选择最合适的数据结构。</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><img src="https://i.imgur.com/0yPEAGb.png"></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：二叉树</title>
    <url>/2024/09/11/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="二叉树总结笔记"><a href="#二叉树总结笔记" class="headerlink" title="二叉树总结笔记"></a>二叉树总结笔记</h3><hr>
<h4 id="二叉树的类别"><a href="#二叉树的类别" class="headerlink" title="二叉树的类别"></a><strong>二叉树的类别</strong></h4><ol>
<li><p><strong>满二叉树</strong>  </p>
<ul>
<li>一个深度为 <code>k</code>，且包含 <code>2^k - 1</code> 个节点的二叉树。</li>
<li>每一层的节点数都是最大值。</li>
</ul>
</li>
<li><p><strong>完全二叉树</strong>  </p>
<ul>
<li>除最后一层外，所有层的节点都充满，且最后一层的节点从左到右排列。</li>
</ul>
</li>
<li><p><strong>二叉搜索树（BST, Binary Search Tree）</strong>  </p>
<ul>
<li>对于每个节点，左子树上的所有节点值都小于该节点值，右子树上的所有节点值都大于该节点值。</li>
<li>具有高效的查找、插入和删除操作，时间复杂度为 <code>O(log n)</code>（在平衡情况下）。</li>
</ul>
</li>
<li><p><strong>平衡二叉树</strong>  </p>
<ul>
<li>保证任何节点的左、右子树的高度差不超过 1。</li>
<li>常见类型有 AVL 树和红黑树。</li>
</ul>
</li>
<li><p><strong>完全二叉树</strong>  </p>
<ul>
<li>所有叶子节点都集中在最后两层，且最后一层的节点集中在最左侧。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a><strong>二叉树的概念</strong></h4><ul>
<li><p><strong>根节点 (Root)</strong><br>树的最顶层节点，没有父节点。</p>
</li>
<li><p><strong>节点 (Node)</strong><br>每个节点包含三个部分：值、左子节点、右子节点。</p>
</li>
<li><p><strong>子树 (Subtree)</strong><br>任何节点和其所有后代构成的树。</p>
</li>
<li><p><strong>父节点 (Parent)</strong><br>具有子节点的节点。</p>
</li>
<li><p><strong>叶子节点 (Leaf)</strong><br>没有子节点的节点。</p>
</li>
<li><p><strong>深度 (Depth)</strong><br>节点到根节点的距离。</p>
</li>
<li><p><strong>高度 (Height)</strong><br>节点到叶子节点的最长路径。</p>
</li>
</ul>
<hr>
<h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a><strong>二叉树的遍历方式</strong></h4><ol>
<li><p><strong>前序遍历 (Pre-order Traversal)</strong></p>
<ul>
<li>顺序：根节点 -&gt; 左子树 -&gt; 右子树</li>
<li>过程：访问当前节点，递归前序遍历左子树，再递归前序遍历右子树。</li>
<li>应用：可以用来复制树结构。</li>
</ul>
</li>
<li><p><strong>中序遍历 (In-order Traversal)</strong></p>
<ul>
<li>顺序：左子树 -&gt; 根节点 -&gt; 右子树</li>
<li>过程：递归中序遍历左子树，访问当前节点，再递归中序遍历右子树。</li>
<li>应用：可以用于输出有序的节点值（如果是二叉搜索树）。</li>
</ul>
</li>
<li><p><strong>后序遍历 (Post-order Traversal)</strong></p>
<ul>
<li>顺序：左子树 -&gt; 右子树 -&gt; 根节点</li>
<li>过程：递归后序遍历左子树，递归后序遍历右子树，最后访问当前节点。</li>
<li>应用：适合用于删除树或释放资源。</li>
</ul>
</li>
<li><p><strong>层次遍历 (Level-order Traversal)</strong></p>
<ul>
<li>顺序：从上到下、从左到右逐层访问。</li>
<li>应用：适合用于按层操作节点。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a><strong>平衡树</strong></h4><ul>
<li><p><strong>平衡二叉树 (Balanced Binary Tree)</strong></p>
<ul>
<li>定义：保证任何节点的左右子树高度差不超过1，以避免极端情况如链表状树（退化为线性结构）。</li>
<li>优点：查找、插入和删除操作能始终保持 <code>O(log n)</code> 的时间复杂度。</li>
</ul>
</li>
<li><p><strong>常见平衡树类型：</strong></p>
<ol>
<li><p><strong>AVL树</strong></p>
<ul>
<li>定义：一种严格平衡的二叉搜索树，确保每个节点的左右子树高度差至多为1。</li>
<li>调整：通过旋转操作（左旋、右旋、左右旋、右左旋）来保持平衡。</li>
<li>应用：适用于读操作远多于写操作的场景。</li>
</ul>
</li>
<li><p><strong>红黑树 (Red-Black Tree)</strong></p>
<ul>
<li>定义：一种自平衡二叉搜索树，确保树在最坏情况下也是接近平衡的。</li>
<li>性质：<ul>
<li>每个节点要么是红色，要么是黑色。</li>
<li>根节点是黑色，所有叶节点（空节点）都是黑色。</li>
<li>如果一个节点是红色，它的子节点必须是黑色（不能有连续的红色节点）。</li>
<li>从根到叶子节点的每条路径上必须包含相同数量的黑色节点。</li>
</ul>
</li>
<li>应用：广泛用于许多系统中的平衡二叉树，如 Java 中的 <code>TreeMap</code> 和 C++ 中的 <code>map</code>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="深度优先搜索（DFS-Depth-First-Search）"><a href="#深度优先搜索（DFS-Depth-First-Search）" class="headerlink" title="深度优先搜索（DFS, Depth-First Search）"></a>深度优先搜索（DFS, Depth-First Search）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>深度优先搜索是一种遍历或搜索图和树的算法，它尽可能深入每一个分支，直到无法继续为止，再回溯到最近的未探索节点继续搜索。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul>
<li><strong>递归性</strong>：DFS通常使用递归的方式实现，沿着某个路径深入到最深处，再逐步回溯。</li>
<li><strong>栈结构</strong>：如果使用迭代方式实现，DFS依赖栈结构来记录节点的路径。</li>
<li><strong>遍历顺序</strong>：优先探索每个节点的所有子节点，只有在无法深入时才回溯。</li>
</ul>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul>
<li>适合用于<strong>找路径</strong>或<strong>找到树或图的连通性</strong>。</li>
<li>解决问题如<strong>迷宫问题</strong>，<strong>拓扑排序</strong>，<strong>岛屿数量</strong>等。</li>
</ul>
<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a><strong>实现方法</strong></h4><ol>
<li><p>递归实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 处理当前节点</span></span><br><span class="line">    <span class="built_in">visit</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> child : node-&gt;children) &#123;</span><br><span class="line">        <span class="built_in">DFS</span>(child);  <span class="comment">// 递归处理子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代实现（使用栈）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    stack&lt;Node*&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* current = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">visit</span>(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child : current-&gt;children) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(child);  <span class="comment">// 将子节点压入栈中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul>
<li>对于树和图的分支，能够深入到最深处。</li>
<li>在有解的情况下，如果目标节点比较深，DFS通常能较早找到解。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul>
<li>可能会陷入<strong>无限深度</strong>的递归，尤其是当存在环的图中，DFS可能需要额外的机制避免重复访问。</li>
<li>不适合用于寻找最短路径。</li>
</ul>
<hr>
<h3 id="广度优先搜索（BFS-Breadth-First-Search）"><a href="#广度优先搜索（BFS-Breadth-First-Search）" class="headerlink" title="广度优先搜索（BFS, Breadth-First Search）"></a>广度优先搜索（BFS, Breadth-First Search）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><strong>概念</strong></h4><p>广度优先搜索是一种遍历图和树的算法，逐层展开，先访问与起点距离最近的节点，然后逐层向外扩展。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul>
<li><strong>队列结构</strong>：BFS依赖队列（FIFO）来保证节点按层次顺序被访问。</li>
<li><strong>层次遍历</strong>：先访问当前节点的所有邻居节点，再继续访问这些邻居节点的子节点。</li>
<li><strong>找到最短路径</strong>：在无权图中，BFS保证找到起点到任意节点的最短路径。</li>
</ul>
<h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul>
<li>适合用于寻找<strong>最短路径</strong>。</li>
<li>解决问题如<strong>最短路径问题</strong>，<strong>图的遍历</strong>，<strong>广度优先迷宫</strong>，<strong>连通性检测</strong>等。</li>
</ul>
<h4 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a><strong>实现方法</strong></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* current = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">visit</span>(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> child : current-&gt;children) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(child);  <span class="comment">// 将子节点加入队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul>
<li>在无权图中，能够找到起点到目标节点的<strong>最短路径</strong>。</li>
<li>对于树的广度遍历非常直观，能够完整遍历所有节点。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul>
<li>由于广度优先扩展，BFS的空间复杂度可能会较高，尤其是当图的广度非常大时。</li>
</ul>
<hr>
<h3 id="对比-DFS-和-BFS"><a href="#对比-DFS-和-BFS" class="headerlink" title="对比 DFS 和 BFS"></a><strong>对比 DFS 和 BFS</strong></h3><ul>
<li><p><strong>DFS 深度优先搜索</strong>：  </p>
<ul>
<li>优先探索尽可能深的路径，适合用于找路径、连通性检测。</li>
<li>空间复杂度通常较低，但在深度很大时可能引发栈溢出（递归方式）。</li>
</ul>
</li>
<li><p><strong>BFS 广度优先搜索</strong>：  </p>
<ul>
<li>按层次遍历，保证找到最短路径，适合用于无权图的最短路径问题。</li>
<li>空间复杂度较高，尤其是图的广度较大时。</li>
</ul>
</li>
</ul>
<p>在实际使用中，根据问题的具体需求选择合适的算法。例如，在寻找迷宫最短路径问题中，BFS较为适合；在连通性检测或路径问题中，DFS可能更为高效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章：面向对象编程</title>
    <url>/2025/05/12/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>好的，我们用 Java 语言来详细说明面向对象编程 (OOP) 的概念、原则和实践。</p>
<h2 id="1-类-Class-和对象-Object"><a href="#1-类-Class-和对象-Object" class="headerlink" title="1. 类 (Class) 和对象 (Object)"></a><strong>1. 类 (Class) 和对象 (Object)</strong></h2><p>在 Java 中，类是创建对象的蓝图。 它定义了对象的属性（数据）和方法（行为）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 Dog 的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="comment">// 属性（成员变量）</span></span><br><span class="line">    String name;</span><br><span class="line">    String breed;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法（成员函数）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Breed: &quot;</span> + breed);</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Dog 类的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个名为 myDog 的 Dog 对象</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 myDog 对象的属性</span></span><br><span class="line">        myDog.name = <span class="string">&quot;Buddy&quot;</span>;</span><br><span class="line">        myDog.breed = <span class="string">&quot;Golden Retriever&quot;</span>;</span><br><span class="line">        myDog.age = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 myDog 对象的方法</span></span><br><span class="line">        myDog.bark(); <span class="comment">// 输出：Woof!</span></span><br><span class="line">        myDog.displayInfo();</span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// Name: Buddy</span></span><br><span class="line">        <span class="comment">// Breed: Golden Retriever</span></span><br><span class="line">        <span class="comment">// Age: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建另一个 Dog 对象</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">anotherDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        anotherDog.name = <span class="string">&quot;Lucy&quot;</span>;</span><br><span class="line">        anotherDog.breed = <span class="string">&quot;Poodle&quot;</span>;</span><br><span class="line">        anotherDog.age = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        anotherDog.displayInfo();</span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// Name: Lucy</span></span><br><span class="line">        <span class="comment">// Breed: Poodle</span></span><br><span class="line">        <span class="comment">// Age: 5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Dog</code> 类定义了狗的通用属性（<code>name</code>、<code>breed</code>、<code>age</code>）和行为（<code>bark</code>、<code>displayInfo</code>）。</li>
<li><code>myDog</code> 和 <code>anotherDog</code> 是 <code>Dog</code> 类的两个不同的对象，它们拥有各自的属性值。</li>
</ul>
<h2 id="2-封装-Encapsulation"><a href="#2-封装-Encapsulation" class="headerlink" title="2. 封装 (Encapsulation)"></a><strong>2. 封装 (Encapsulation)</strong></h2><p>在 Java 中，封装通过将属性声明为 <code>private</code>，并提供 <code>public</code> 的 getter 和 setter 方法来实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String breed;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBreed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> breed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setter 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBreed</span><span class="params">(String breed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.breed = breed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Age cannot be negative.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Breed: &quot;</span> + breed);</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 setter 方法设置属性</span></span><br><span class="line">        myDog.setName(<span class="string">&quot;Buddy&quot;</span>);</span><br><span class="line">        myDog.setBreed(<span class="string">&quot;Golden Retriever&quot;</span>);</span><br><span class="line">        myDog.setAge(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 getter 方法获取属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + myDog.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Breed: &quot;</span> + myDog.getBreed());</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + myDog.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>name</code>、<code>breed</code> 和 <code>age</code> 属性被声明为 <code>private</code>，这意味着它们只能在 <code>Dog</code> 类内部访问。</li>
<li><code>getName</code>、<code>getBreed</code>、<code>getAge</code> 方法是 getter 方法，用于获取属性的值。</li>
<li><code>setName</code>、<code>setBreed</code>、<code>setAge</code> 方法是 setter 方法，用于设置属性的值。</li>
<li>setter 方法可以包含逻辑，例如，验证输入值的有效性（如 <code>setAge</code> 方法中的年龄验证）。</li>
</ul>
<h2 id="3-继承-Inheritance"><a href="#3-继承-Inheritance" class="headerlink" title="3. 继承 (Inheritance)"></a><strong>3. 继承 (Inheritance)</strong></h2><p>在 Java 中，使用 <code>extends</code> 关键字来实现继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个 Animal 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 Dog 类，继承自 Animal 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String breed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, String breed)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>.breed = breed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写父类的 eat 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + myDog.name); <span class="comment">// 访问父类的属性</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Breed: &quot;</span> + myDog.breed); <span class="comment">// 访问子类的属性</span></span><br><span class="line">        myDog.eat(); <span class="comment">// 调用重写后的方法</span></span><br><span class="line">        myDog.bark(); <span class="comment">// 调用子类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Dog</code> 类继承了 <code>Animal</code> 类的 <code>name</code> 属性和 <code>eat</code> 方法。</li>
<li><code>Dog</code> 类添加了自己的属性 <code>breed</code> 和方法 <code>bark</code>。</li>
<li><code>Dog</code> 类重写了 <code>eat</code> 方法，提供了自己的实现。</li>
<li><code>super(name)</code> 用于调用父类的构造方法，初始化父类的属性。</li>
<li><code>@Override</code> 注解用于表示该方法是重写父类的方法。</li>
</ul>
<h2 id="4-多态-Polymorphism"><a href="#4-多态-Polymorphism" class="headerlink" title="4. 多态 (Polymorphism)"></a><strong>4. 多态 (Polymorphism)</strong></h2><p>在 Java 中，多态可以通过方法重写 (method overriding) 和接口 (interface) 来实现。</p>
<h3 id="1-方法重写-Method-Overriding"><a href="#1-方法重写-Method-Overriding" class="headerlink" title="1.  方法重写 (Method Overriding)"></a>1.  <strong>方法重写 (Method Overriding)</strong></h3><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Generic animal sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Meow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        animal1.makeSound(); <span class="comment">// 输出：Generic animal sound</span></span><br><span class="line">        animal2.makeSound(); <span class="comment">// 输出：Woof!</span></span><br><span class="line">        animal3.makeSound(); <span class="comment">// 输出：Meow!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

*   `Animal` 类有一个 `makeSound` 方法。
*   `Dog` 和 `Cat` 类都继承了 `Animal` 类，并重写了 `makeSound` 方法。
*   在 `main` 方法中，使用 `Animal` 类型的引用来引用 `Dog` 和 `Cat` 对象，调用 `makeSound` 方法时，会根据对象的实际类型来执行不同的方法。
</code></pre>
<h3 id="2-接口-Interface"><a href="#2-接口-Interface" class="headerlink" title="2.  接口 (Interface)"></a>2.  <strong>接口 (Interface)</strong></h3><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Meow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        animal1.makeSound(); <span class="comment">// 输出：Woof!</span></span><br><span class="line">        animal2.makeSound(); <span class="comment">// 输出：Meow!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

*   `Animal` 接口定义了一个 `makeSound` 方法。
*   `Dog` 和 `Cat` 类都实现了 `Animal` 接口，并提供了 `makeSound` 方法的实现。
*   在 `main` 方法中，使用 `Animal` 类型的引用来引用 `Dog` 和 `Cat` 对象，调用 `makeSound` 方法时，会根据对象的实际类型来执行不同的方法。
</code></pre>
<h2 id="5-抽象-Abstraction"><a href="#5-抽象-Abstraction" class="headerlink" title="5. 抽象 (Abstraction)"></a><strong>5. 抽象 (Abstraction)</strong></h2><p>在 Java 中，可以使用抽象类 (abstract class) 和接口 (interface) 来实现抽象。</p>
<h3 id="1-抽象类-Abstract-Class"><a href="#1-抽象类-Abstract-Class" class="headerlink" title="1.  抽象类 (Abstract Class)"></a>1.  <strong>抽象类 (Abstract Class)</strong></h3><pre><code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法，没有具体实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 无法创建抽象类的对象</span></span><br><span class="line">        <span class="comment">// Animal animal = new Animal(&quot;Generic Animal&quot;); // 错误</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>);</span><br><span class="line">        myDog.makeSound(); <span class="comment">// 输出：Woof!</span></span><br><span class="line">        myDog.eat(); <span class="comment">// 输出：Animal is eating.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

*   抽象类使用 `abstract` 关键字声明。
*   抽象类可以包含抽象方法（没有具体实现的方法）和普通方法。
*   抽象类不能被实例化（不能创建对象）。
*   子类必须实现抽象类中的所有抽象方法，除非子类也是抽象类。
</code></pre>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p><strong>1. 接口的定义和声明</strong></p>
<p>接口使用 <code>interface</code> 关键字来声明。接口是一种完全抽象的类型，它定义了一组方法签名，但不提供方法的具体实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="comment">// 接口的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 接口的成员</strong></p>
<ul>
<li><strong>抽象方法：</strong> 接口中的方法默认是 <code>public abstract</code>，可以省略 <code>public abstract</code> 关键字。这些方法没有方法体，必须由实现该接口的类来提供具体实现。</li>
<li><strong>常量：</strong> 接口可以包含常量，这些常量默认是 <code>public static final</code>。</li>
<li><strong>默认方法（Java 8+）：</strong> 接口可以包含默认方法，使用 <code>default</code> 关键字声明。默认方法提供了方法的默认实现，实现类可以选择性地覆盖这些方法。</li>
<li><strong>静态方法（Java 8+）：</strong> 接口可以包含静态方法，使用 <code>static</code> 关键字声明。静态方法属于接口本身，可以通过接口名直接调用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MY_CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">myDefaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Default implementation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 实现接口</strong></p>
<p>一个类使用 <code>implements</code> 关键字来实现一个或多个接口。实现接口的类必须提供接口中所有抽象方法的具体实现，除非该类是抽象类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My method implementation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 接口的特性</strong></p>
<ul>
<li><strong>多重继承：</strong> 一个类可以实现多个接口，从而实现多重继承的效果。这是 Java 中解决多重继承问题的一种方式。</li>
<li><strong>类型声明：</strong> 接口可以作为一种类型来声明变量，从而实现多态。</li>
<li><strong>解耦合：</strong> 接口可以降低类之间的耦合度，提高代码的灵活性和可维护性。</li>
</ul>
<p><strong>5. 接口的用途</strong></p>
<ul>
<li><strong>定义规范：</strong> 接口可以定义一组规范，要求所有实现类都遵循这些规范。</li>
<li><strong>实现回调：</strong> 接口可以用于实现回调机制，即当某个事件发生时，通过接口调用实现类中的方法。</li>
<li><strong>实现插件化：</strong> 接口可以用于实现插件化架构，即通过接口定义插件的接口，然后由不同的类来实现这些插件。</li>
</ul>
<p><strong>6. 接口 vs 抽象类</strong></p>
<p>接口和抽象类都是用于实现抽象的机制，但它们之间有一些关键区别：</p>
<ul>
<li><strong>成员变量：</strong> 接口通常只有常量（<code>static final</code>），而抽象类可以有成员变量。</li>
<li><strong>方法实现：</strong> 接口在 Java 8 之前只能有抽象方法，而抽象类可以有已经实现的方法。Java 8 之后，接口可以有默认方法和静态方法。</li>
<li><strong>继承：</strong> 一个类只能继承一个抽象类，但可以实现多个接口。</li>
<li><strong>设计理念：</strong> 抽象类通常用于表示 “is-a” 关系，即子类是父类的一种特殊类型。接口通常用于表示 “can-do” 关系，即类可以实现接口中的行为。</li>
</ul>
<p><strong>7. 示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>; <span class="comment">// 接口中的方法默认是 public abstract</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Meow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        myDog.makeSound(); <span class="comment">// 输出：Woof!</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">myCat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        myCat.makeSound(); <span class="comment">// 输出：Meow!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Animal</code> 是一个接口，它定义了一个 <code>makeSound</code> 抽象方法。<code>Dog</code> 和 <code>Cat</code> 类实现了 <code>Animal</code> 接口，并提供了 <code>makeSound</code> 方法的具体实现。</p>
<h2 id="什么是构造器？"><a href="#什么是构造器？" class="headerlink" title="什么是构造器？"></a><strong>什么是构造器？</strong></h2><p>构造器是一种特殊的方法，用于创建和初始化类的对象。 构造器的名称必须与类名相同，并且没有返回类型（即使是 <code>void</code> 也不行）。</p>
<h3 id="构造器的作用"><a href="#构造器的作用" class="headerlink" title="构造器的作用"></a><strong>构造器的作用</strong></h3><ul>
<li><strong>创建对象</strong>：使用 <code>new</code> 关键字调用构造器来创建类的对象。</li>
<li><strong>初始化对象</strong>：构造器可以初始化对象的属性，设置对象的初始状态。</li>
</ul>
<h3 id="构造器的特点"><a href="#构造器的特点" class="headerlink" title="构造器的特点"></a><strong>构造器的特点</strong></h3><ul>
<li><strong>名称与类名相同</strong>：构造器的名称必须与类名完全相同（包括大小写）。</li>
<li><strong>没有返回类型</strong>：构造器没有返回类型，即使是 <code>void</code> 也不行。</li>
<li><strong>可以重载</strong>：一个类可以有多个构造器，只要它们的参数列表不同（参数类型、参数个数或参数顺序不同）。</li>
<li><strong>默认构造器</strong>：如果一个类没有显式地定义任何构造器，Java 编译器会自动为该类生成一个默认构造器。 默认构造器没有参数，并且不执行任何操作。</li>
<li><strong>构造器不能被继承</strong>：子类不能继承父类的构造器。</li>
<li><strong>构造器可以调用其他构造器</strong>：在一个构造器中可以使用 <code>this()</code> 调用同一个类的其他构造器。</li>
</ul>
<h3 id="构造器的声明"><a href="#构造器的声明" class="headerlink" title="构造器的声明"></a><strong>构造器的声明</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构造器的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造器的使用示例"><a href="#构造器的使用示例" class="headerlink" title="构造器的使用示例"></a><strong>构造器的使用示例</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String breed;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">        name = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        breed = <span class="string">&quot;Unknown&quot;</span>;</span><br><span class="line">        age = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, String breed, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.breed = breed;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一个带参数的构造器，调用上面的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, String breed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name, breed, <span class="number">0</span>); <span class="comment">// 调用 Dog(String name, String breed, int age) 构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Breed: &quot;</span> + breed);</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用默认构造器创建对象</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog1.displayInfo();</span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// Name: Unknown</span></span><br><span class="line">        <span class="comment">// Breed: Unknown</span></span><br><span class="line">        <span class="comment">// Age: 0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用带参数的构造器创建对象</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        dog2.displayInfo();</span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// Name: Buddy</span></span><br><span class="line">        <span class="comment">// Breed: Golden Retriever</span></span><br><span class="line">        <span class="comment">// Age: 3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用另一个带参数的构造器创建对象</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Lucy&quot;</span>, <span class="string">&quot;Poodle&quot;</span>);</span><br><span class="line">        dog3.displayInfo();</span><br><span class="line">        <span class="comment">// 输出：</span></span><br><span class="line">        <span class="comment">// Name: Lucy</span></span><br><span class="line">        <span class="comment">// Breed: Poodle</span></span><br><span class="line">        <span class="comment">// Age: 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Dog</code> 类定义了三个构造器：一个默认构造器和两个带参数的构造器。</li>
<li>默认构造器将 <code>name</code>、<code>breed</code> 和 <code>age</code> 属性设置为默认值。</li>
<li>带参数的构造器使用传入的参数来初始化对象的属性。</li>
<li><code>this(name, breed, 0)</code> 用于调用同一个类的其他构造器。</li>
<li>在 <code>main</code> 方法中，使用不同的构造器来创建 <code>Dog</code> 对象，并调用 <code>displayInfo</code> 方法显示对象的信息。</li>
</ul>
<h3 id="构造器的作用-1"><a href="#构造器的作用-1" class="headerlink" title="构造器的作用"></a><strong>构造器的作用</strong></h3><ol>
<li><strong>初始化对象的状态</strong>：构造器可以设置对象的初始状态，确保对象在创建后处于一个有效的状态。</li>
<li><strong>强制执行初始化逻辑</strong>：构造器可以强制执行一些初始化逻辑，例如，验证输入参数的有效性，或者加载配置文件。</li>
<li><strong>简化对象创建</strong>：通过提供不同的构造器，可以方便地创建具有不同初始状态的对象。</li>
</ol>
<h3 id="构造器的注意事项"><a href="#构造器的注意事项" class="headerlink" title="构造器的注意事项"></a><strong>构造器的注意事项</strong></h3><ul>
<li>如果一个类没有显式地定义任何构造器，Java 编译器会自动为该类生成一个默认构造器。</li>
<li>如果一个类显式地定义了构造器，Java 编译器就不会再自动生成默认构造器。</li>
<li>子类不能继承父类的构造器，但可以使用 <code>super()</code> 关键字调用父类的构造器。</li>
<li>构造器应该尽量简单，避免在构造器中执行复杂的逻辑。</li>
</ul>
<h2 id="静态变量-Static-Variable"><a href="#静态变量-Static-Variable" class="headerlink" title="静态变量 (Static Variable)"></a><strong>静态变量 (Static Variable)</strong></h2><p>静态变量也称为类变量 (Class Variable)，它属于类，而不是属于类的任何特定对象。 这意味着无论创建多少个类的对象，静态变量在内存中只有一份拷贝。</p>
<h3 id="静态变量的特点"><a href="#静态变量的特点" class="headerlink" title="静态变量的特点"></a><strong>静态变量的特点</strong></h3><ul>
<li><strong>属于类</strong>：静态变量属于类，而不是属于类的任何特定对象。</li>
<li><strong>共享</strong>：所有类的对象共享同一个静态变量。</li>
<li><strong>内存中只有一份拷贝</strong>：无论创建多少个类的对象，静态变量在内存中只有一份拷贝。</li>
<li><strong>可以通过类名直接访问</strong>：可以使用 <code>类名.静态变量名</code> 的方式直接访问静态变量，而不需要创建类的对象。</li>
<li><strong>在类加载时初始化</strong>：静态变量在类加载时被初始化，并且只初始化一次。</li>
<li><strong>生命周期与类相同</strong>：静态变量的生命周期与类相同，当类被卸载时，静态变量才会被销毁。</li>
</ul>
<h3 id="静态变量的声明"><a href="#静态变量的声明" class="headerlink" title="静态变量的声明"></a><strong>静态变量的声明</strong></h3><p>使用 <code>static</code> 关键字来声明一个静态变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态变量的使用示例"><a href="#静态变量的使用示例" class="headerlink" title="静态变量的使用示例"></a><strong>静态变量的使用示例</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Counter</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 每次创建对象，count 加 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Number of objects created: &quot;</span> + Counter.count); <span class="comment">// 输出：Number of objects created: 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>count</code> 是一个静态变量，用于记录创建了多少个 <code>Counter</code> 对象。</li>
<li>每次创建 <code>Counter</code> 对象时，<code>count</code> 的值都会加 1。</li>
<li>可以使用 <code>Counter.count</code> 的方式直接访问静态变量，而不需要创建 <code>Counter</code> 对象。</li>
</ul>
<h3 id="静态方法-Static-Method"><a href="#静态方法-Static-Method" class="headerlink" title="静态方法 (Static Method)"></a><strong>静态方法 (Static Method)</strong></h3><p>静态方法也称为类方法 (Class Method)，它属于类，而不是属于类的任何特定对象。 静态方法只能访问静态变量和调用其他静态方法，不能访问非静态变量和调用非静态方法。</p>
<h3 id="静态方法的特点"><a href="#静态方法的特点" class="headerlink" title="静态方法的特点"></a><strong>静态方法的特点</strong></h3><ul>
<li><strong>属于类</strong>：静态方法属于类，而不是属于类的任何特定对象。</li>
<li><strong>可以通过类名直接调用</strong>：可以使用 <code>类名.静态方法名()</code> 的方式直接调用静态方法，而不需要创建类的对象。</li>
<li><strong>只能访问静态成员</strong>：静态方法只能访问静态变量和调用其他静态方法，不能访问非静态变量和调用非静态方法。</li>
<li><strong>不能使用 <code>this</code> 关键字</strong>：静态方法不能使用 <code>this</code> 关键字，因为 <code>this</code> 关键字指向当前对象，而静态方法不属于任何对象。</li>
</ul>
<h3 id="静态方法的声明"><a href="#静态方法的声明" class="headerlink" title="静态方法的声明"></a><strong>静态方法的声明</strong></h3><p>使用 <code>static</code> 关键字来声明一个静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myStaticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态方法的使用示例"><a href="#静态方法的使用示例" class="headerlink" title="静态方法的使用示例"></a><strong>静态方法的使用示例</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>; <span class="comment">// 静态常量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法，计算圆的面积</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">calculateCircleArea</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">5.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> MathUtils.calculateCircleArea(radius); <span class="comment">// 调用静态方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Area of circle with radius &quot;</span> + radius + <span class="string">&quot; is: &quot;</span> + area); <span class="comment">// 输出：Area of circle with radius 5.0 is: 78.53975</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>calculateCircleArea</code> 是一个静态方法，用于计算圆的面积。</li>
<li>可以使用 <code>MathUtils.calculateCircleArea(radius)</code> 的方式直接调用静态方法，而不需要创建 <code>MathUtils</code> 对象。</li>
<li>静态方法可以访问静态常量 <code>PI</code>。</li>
</ul>
<h3 id="静态变量和静态方法的用途"><a href="#静态变量和静态方法的用途" class="headerlink" title="静态变量和静态方法的用途"></a><strong>静态变量和静态方法的用途</strong></h3><ul>
<li><strong>存储类级别的状态</strong>：静态变量可以用于存储类级别的状态，例如，记录创建了多少个对象，或者存储一些配置信息。</li>
<li><strong>提供工具方法</strong>：静态方法可以用于提供一些工具方法，例如，数学计算、字符串处理等。</li>
<li><strong>实现单例模式</strong>：静态变量和静态方法可以用于实现单例模式，确保一个类只有一个实例。</li>
</ul>
<h3 id="静态变量和静态方法的注意事项"><a href="#静态变量和静态方法的注意事项" class="headerlink" title="静态变量和静态方法的注意事项"></a><strong>静态变量和静态方法的注意事项</strong></h3><ul>
<li>静态变量在类加载时被初始化，并且只初始化一次。</li>
<li>静态方法只能访问静态变量和调用其他静态方法，不能访问非静态变量和调用非静态方法。</li>
<li>静态方法不能使用 <code>this</code> 关键字。</li>
<li>过度使用静态变量和静态方法可能会导致代码的耦合度增加，降低代码的可测试性和可维护性。</li>
</ul>
<h2 id="1-final-变量"><a href="#1-final-变量" class="headerlink" title="1.  final 变量:"></a>1.  <strong>final 变量</strong>:</h2><pre><code>*   表示常量，一旦被赋值后，其值不能被修改。
*   `final` 变量必须在声明时或在类的构造器中初始化。
*   对于基本类型，`final` 使数值不变；对于引用类型，`final` 使引用不可变，即不能指向其他对象，但对象自身的内容是可以改变的。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// x 的值不能被修改</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// person 不能指向其他 Person 对象</span></span><br><span class="line">person.setName(<span class="string">&quot;Bob&quot;</span>); <span class="comment">// 但是可以修改 person 对象的内容</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="final-方法"><a href="#final-方法" class="headerlink" title="final 方法:"></a><strong>final 方法</strong>:</h3><pre><code>*   表示该方法不能被子类重写 (override)。
*   使用 `final` 方法可以防止子类修改父类的行为，保证程序的安全性。
*   `private` 方法默认是 `final` 的，因为它们不能在子类中被访问，所以也不能被重写。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a final method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="comment">// 无法重写 display 方法</span></span><br><span class="line">    <span class="comment">// void display() &#123;&#125; // 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="final-类"><a href="#final-类" class="headerlink" title="final 类:"></a><strong>final 类</strong>:</h3><pre><code>*   表示该类不能被继承。
*   `final` 类通常用于创建不可变的类，例如 `String` 类。
*   `final` 类中的所有方法都隐式地是 `final` 的。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ImmutableClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImmutableClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法继承 ImmutableClass</span></span><br><span class="line"><span class="comment">// class SubClass extends ImmutableClass &#123;&#125; // 编译错误</span></span><br></pre></td></tr></table></figure>
</code></pre>
<p>总结：</p>
<ul>
<li><code>final</code> 变量：保证变量引用的对象不变。</li>
<li><code>final</code> 方法：保证方法不被子类重写。</li>
<li><code>final</code> 类：保证类不被继承。</li>
</ul>
<p>使用 <code>final</code> 关键字可以提高代码的健壮性和安全性，但也可能降低代码的灵活性。</p>
<h2 id="单例类"><a href="#单例类" class="headerlink" title="单例类"></a>单例类</h2><h3 id="1-饿汉式（Eager-Initialization）"><a href="#1-饿汉式（Eager-Initialization）" class="headerlink" title="1. 饿汉式（Eager Initialization）"></a><strong>1. 饿汉式（Eager Initialization）</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个静态的、final 的实例。</span></span><br><span class="line">    <span class="comment">//    - static 保证该实例在类加载时就被创建，且只有一个。</span></span><br><span class="line">    <span class="comment">//    - final 保证该实例创建后不可被修改。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 私有化构造函数。</span></span><br><span class="line">    <span class="comment">//    - private 关键字确保外部类无法直接通过 new 关键字创建 Singleton 类的实例。</span></span><br><span class="line">    <span class="comment">//    - 这是实现单例模式的关键步骤，防止外部随意创建对象。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提供一个公共的静态方法来获取单例实例。</span></span><br><span class="line">    <span class="comment">//    - static 关键字允许直接通过类名调用该方法，无需创建对象。</span></span><br><span class="line">    <span class="comment">//    - 该方法返回上面创建的唯一实例。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点：</strong> 实现简单，线程安全（因为实例在类加载时创建）。</li>
<li><strong>缺点：</strong> 无论是否使用，实例都会在类加载时创建，可能造成资源浪费。</li>
</ul>
<h3 id="2-懒汉式（Lazy-Initialization）"><a href="#2-懒汉式（Lazy-Initialization）" class="headerlink" title="2. 懒汉式（Lazy Initialization）"></a><strong>2. 懒汉式（Lazy Initialization）</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 静态私有成员变量，用于存储单例实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部类通过 new 关键字创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 可以在这里添加一些初始化逻辑</span></span><br><span class="line">        <span class="comment">// 例如：初始化一些配置信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态公共方法，用于获取单例实例</span></span><br><span class="line">    <span class="comment">// 使用 synchronized 关键字保证线程安全，防止多线程环境下创建多个实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果实例为空，则创建实例</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回单例实例</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点：</strong> 延迟加载，只有在第一次调用 <code>getInstance()</code> 方法时才会创建实例。</li>
<li><strong>缺点：</strong> 线程安全问题。在多线程环境下，可能会创建多个实例。使用 <code>synchronized</code> 关键字可以解决线程安全问题，但会降低性能。</li>
</ul>
<h3 id="3-双重检查锁（Double-Checked-Locking）"><a href="#3-双重检查锁（Double-Checked-Locking）" class="headerlink" title="3. 双重检查锁（Double-Checked Locking）"></a><strong>3. 双重检查锁（Double-Checked Locking）</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 volatile 关键字确保多线程环境下的可见性</span></span><br><span class="line">    <span class="comment">// 当 instance 被初始化后，所有线程都能立即看到最新的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里可以添加一些初始化逻辑，例如读取配置文件等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个全局访问点，获取 Singleton 实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查，如果 instance 已经创建，则直接返回，避免进入同步块</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用 synchronized 关键字对 Singleton.class 进行同步</span></span><br><span class="line">            <span class="comment">// 保证只有一个线程可以进入该代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查，防止多个线程同时进入同步块后重复创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建 Singleton 实例</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                    <span class="comment">// 这行代码实际上做了三件事：</span></span><br><span class="line">                    <span class="comment">// 1. 分配内存空间</span></span><br><span class="line">                    <span class="comment">// 2. 初始化 Singleton 对象</span></span><br><span class="line">                    <span class="comment">// 3. 将 instance 指向分配的内存地址</span></span><br><span class="line">                    <span class="comment">// 由于指令重排序的存在，可能会导致 1-&gt;3-&gt;2 的执行顺序</span></span><br><span class="line">                    <span class="comment">// 这就是为什么需要 volatile 关键字的原因</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回 Singleton 实例</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点：</strong> 延迟加载，线程安全，性能相对较高。</li>
<li><strong>缺点：</strong> 实现较为复杂。需要使用 <code>volatile</code> 关键字来防止指令重排序。</li>
</ul>
<h3 id="4-静态内部类（Static-Inner-Class）"><a href="#4-静态内部类（Static-Inner-Class）" class="headerlink" title="4. 静态内部类（Static Inner Class）"></a><strong>4. 静态内部类（Static Inner Class）</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造函数，防止外部类直接实例化该类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 可以添加一些初始化逻辑，如果需要的话</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类，用于延迟加载 Singleton 实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="comment">// 在类加载时就创建 Singleton 实例，保证线程安全</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有的静态方法，用于获取 Singleton 实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回内部类持有的唯一实例</span></span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点：</strong> 延迟加载，线程安全，实现简单。</li>
<li><strong>缺点：</strong> 无。这是推荐的单例模式实现方式。</li>
</ul>
<h3 id="5-枚举（Enum）"><a href="#5-枚举（Enum）" class="headerlink" title="5. 枚举（Enum）"></a><strong>5. 枚举（Enum）</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优点：</strong> 简洁，线程安全，防止反射攻击和序列化问题。</li>
<li><strong>缺点：</strong> 不能延迟加载，不适用于需要传递参数给构造函数的情况。</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>如果不需要延迟加载，推荐使用<strong>饿汉式</strong>或<strong>枚举</strong>。</li>
<li>如果需要延迟加载，推荐使用<strong>静态内部类</strong>。</li>
<li><strong>双重检查锁</strong>实现较为复杂，需要注意 <code>volatile</code> 关键字的使用。</li>
<li><strong>懒汉式</strong>在多线程环境下存在线程安全问题，不推荐使用。</li>
</ul>
<h2 id="Java-抽象类。"><a href="#Java-抽象类。" class="headerlink" title="Java 抽象类。"></a>Java 抽象类。</h2><h3 id="1-抽象类的定义和声明"><a href="#1-抽象类的定义和声明" class="headerlink" title="1. 抽象类的定义和声明"></a><strong>1. 抽象类的定义和声明</strong></h3><p>抽象类使用 <code>abstract</code> 关键字来声明。一个类被声明为抽象类，意味着它可能包含抽象方法，也可能不包含。关键在于，抽象类不能被直接实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">// 类的成员变量和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-抽象方法"><a href="#2-抽象方法" class="headerlink" title="2. 抽象方法"></a><strong>2. 抽象方法</strong></h3><p>抽象方法是没有方法体的方法，只有方法签名。它也使用 <code>abstract</code> 关键字声明。抽象方法必须存在于抽象类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，没有具体实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-抽象类与普通类的区别"><a href="#3-抽象类与普通类的区别" class="headerlink" title="3. 抽象类与普通类的区别"></a><strong>3. 抽象类与普通类的区别</strong></h3><ul>
<li><strong>实例化：</strong> 抽象类不能被实例化，而普通类可以。</li>
<li><strong>抽象方法：</strong> 抽象类可以包含抽象方法，而普通类不能。如果一个类包含抽象方法，那么这个类必须声明为抽象类。</li>
<li><strong>实现：</strong> 抽象类可以包含已经实现的方法（即非抽象方法），而普通类只能包含已经实现的方法。</li>
</ul>
<h3 id="4-继承抽象类"><a href="#4-继承抽象类" class="headerlink" title="4. 继承抽象类"></a><strong>4. 继承抽象类</strong></h3><p>当一个类继承抽象类时，它需要遵循以下规则：</p>
<ul>
<li><strong>实现所有抽象方法：</strong> 如果子类不是抽象类，那么它必须实现父类中的所有抽象方法。</li>
<li><strong>声明为抽象类：</strong> 如果子类不想实现父类中的所有抽象方法，那么子类必须声明为抽象类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类 Shape</span></span><br><span class="line"><span class="comment">// 抽象类不能被实例化，只能被继承</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法 getArea()</span></span><br><span class="line">    <span class="comment">// 抽象方法没有具体实现，必须由子类实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非抽象方法 display()</span></span><br><span class="line">    <span class="comment">// 非抽象方法有具体实现，子类可以选择重写或直接继承</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is a shape.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 Circle 继承自 Shape</span></span><br><span class="line"><span class="comment">// Circle 是一个具体的类，可以被实例化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">// 私有成员变量 radius，表示圆的半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法，用于初始化 Circle 对象的 radius</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写父类的抽象方法 getArea()</span></span><br><span class="line">    <span class="comment">// 实现计算圆的面积的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象子类 Polygon 继承自 Shape</span></span><br><span class="line"><span class="comment">// Polygon 是一个抽象类，不能被实例化</span></span><br><span class="line"><span class="comment">// Polygon 继承了 Shape 的抽象方法 getArea()，但没有实现它，所以 Polygon 仍然是抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Polygon</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法 getNumberOfSides()</span></span><br><span class="line">    <span class="comment">// 抽象方法没有具体实现，必须由子类实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getNumberOfSides</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-构造器"><a href="#5-构造器" class="headerlink" title="5. 构造器"></a><strong>5. 构造器</strong></h3><p>抽象类可以有构造器。虽然不能直接实例化抽象类，但是当创建子类实例时，抽象类的构造器会被调用。构造器通常用于初始化抽象类的成员变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 动物的名字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动物类的构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 动物的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// 初始化动物的名字</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Animal constructor called.&quot;</span>); <span class="comment">// 打印构造器被调用的信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取动物的名字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 动物的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name; <span class="comment">// 返回动物的名字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法，用于定义动物发出声音的行为。</span></span><br><span class="line"><span class="comment">     * 具体的实现由子类完成。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dog 类，继承自 Animal 类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dog 类的构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 狗的名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类（Animal）的构造器，初始化狗的名字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写父类的 makeSound 方法，实现狗发出声音的行为</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Woof!&quot;</span>); <span class="comment">// 打印狗叫的声音</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主类，包含 main 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主方法，程序的入口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 命令行参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>); <span class="comment">// 创建一个 Dog 对象，名字是 &quot;Buddy&quot;，会调用 Animal 的构造器，输出 &quot;Animal constructor called.&quot;</span></span><br><span class="line">        dog.makeSound(); <span class="comment">// 调用 Dog 对象的 makeSound 方法，输出 &quot;Woof!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-抽象类的用途"><a href="#6-抽象类的用途" class="headerlink" title="6. 抽象类的用途"></a><strong>6. 抽象类的用途</strong></h3><ul>
<li><strong>定义通用接口：</strong> 抽象类可以定义一组方法，要求所有子类都实现这些方法，从而确保子类具有相同的接口。</li>
<li><strong>代码复用：</strong> 抽象类可以提供一些通用的实现，子类可以直接继承和使用，避免重复编写代码。</li>
<li><strong>实现多态：</strong> 通过抽象类，可以实现多态，即使用父类类型的引用来引用子类对象，从而实现灵活的设计。</li>
</ul>
<h3 id="7-抽象类-vs-接口"><a href="#7-抽象类-vs-接口" class="headerlink" title="7. 抽象类 vs 接口"></a><strong>7. 抽象类 vs 接口</strong></h3><p>抽象类和接口都是用于实现抽象的机制，但它们之间有一些关键区别：</p>
<ul>
<li><strong>成员变量：</strong> 抽象类可以有成员变量，而接口通常只有常量（<code>static final</code>）。</li>
<li><strong>方法实现：</strong> 抽象类可以有已经实现的方法，而接口在 Java 8 之前只能有抽象方法。Java 8 之后，接口可以有默认方法和静态方法。</li>
<li><strong>继承：</strong> 一个类只能继承一个抽象类，但可以实现多个接口。</li>
<li><strong>设计理念：</strong> 抽象类通常用于表示 “is-a” 关系，即子类是父类的一种特殊类型。接口通常用于表示 “can-do” 关系，即类可以实现接口中的行为。</li>
</ul>
<h2 id="Java-代码块"><a href="#Java-代码块" class="headerlink" title="**Java 代码块"></a>**Java 代码块</h2><p>Java 代码块的类型</p>
<p>Java 中主要有四种类型的代码块：</p>
<ol>
<li><strong>普通代码块 (Local Block)</strong></li>
<li><strong>构造代码块 (Instance Initializer Block)</strong></li>
<li><strong>静态代码块 (Static Initializer Block)</strong></li>
<li><strong>同步代码块 (Synchronized Block)</strong></li>
</ol>
<p>接下来，我们逐一介绍这些代码块。</p>
<h3 id="1-普通代码块-Local-Block"><a href="#1-普通代码块-Local-Block" class="headerlink" title="1. 普通代码块 (Local Block)"></a><strong>1. 普通代码块 (Local Block)</strong></h3><ul>
<li><strong>定义：</strong> 位于方法或语句中的代码块，用花括号 <code>&#123;&#125;</code> 包围。</li>
<li><strong>作用：</strong><ul>
<li>限制变量的作用域：在代码块中声明的变量只能在该代码块内部访问。</li>
<li>提高代码的可读性：将相关的代码组织在一起。</li>
</ul>
</li>
<li><strong>执行时机：</strong> 当程序执行到该代码块时，代码块中的代码会被执行。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        &#123; <span class="comment">// 普通代码块</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;x = &quot;</span> + x); <span class="comment">// 输出: x = 10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;x = &quot; + x); // 编译错误：x 在这里不可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-构造代码块-Instance-Initializer-Block"><a href="#2-构造代码块-Instance-Initializer-Block" class="headerlink" title="2. 构造代码块 (Instance Initializer Block)"></a><strong>2. 构造代码块 (Instance Initializer Block)</strong></h3><ul>
<li><strong>定义：</strong> 位于类中，没有 <code>static</code> 关键字的代码块，用花括号 <code>&#123;&#125;</code> 包围。</li>
<li><strong>作用：</strong><ul>
<li>在每次创建对象时执行，且在构造方法之前执行。</li>
<li>可以用来初始化实例变量，或者执行一些需要在每次创建对象时都执行的代码。</li>
</ul>
</li>
<li><strong>执行时机：</strong> 在每次创建对象时，构造方法之前执行。如果类中有多个构造代码块，它们会按照在类中出现的顺序依次执行。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// 构造代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;构造代码块执行&quot;</span>);</span><br><span class="line">        name = <span class="string">&quot;Unknown&quot;</span>; <span class="comment">// 初始化 name 变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 输出:</span></span><br><span class="line">        <span class="comment">// 构造代码块执行</span></span><br><span class="line">        <span class="comment">// 构造方法执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-静态代码块-Static-Initializer-Block"><a href="#3-静态代码块-Static-Initializer-Block" class="headerlink" title="3. 静态代码块 (Static Initializer Block)"></a><strong>3. 静态代码块 (Static Initializer Block)</strong></h3><ul>
<li><strong>定义：</strong> 位于类中，使用 <code>static</code> 关键字修饰的代码块，用花括号 <code>&#123;&#125;</code> 包围。</li>
<li><strong>作用：</strong><ul>
<li>在类加载时执行，且只执行一次。</li>
<li>可以用来初始化静态变量，或者执行一些只需要在类加载时执行一次的代码。</li>
</ul>
</li>
<li><strong>执行时机：</strong> 在类加载时执行，且只执行一次。如果类中有多个静态代码块，它们会按照在类中出现的顺序依次执行。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123; <span class="comment">// 静态代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行&quot;</span>);</span><br><span class="line">        count = <span class="number">0</span>; <span class="comment">// 初始化静态变量 count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象被创建，count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 输出: 对象被创建，count = 1</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 输出: 对象被创建，count = 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出:</span></span><br><span class="line">    <span class="comment">// 静态代码块执行 (只执行一次)</span></span><br><span class="line">    <span class="comment">// 对象被创建，count = 1</span></span><br><span class="line">    <span class="comment">// 对象被创建，count = 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-同步代码块-Synchronized-Block"><a href="#4-同步代码块-Synchronized-Block" class="headerlink" title="4. 同步代码块 (Synchronized Block)"></a><strong>4. 同步代码块 (Synchronized Block)</strong></h3><ul>
<li><strong>定义：</strong> 使用 <code>synchronized</code> 关键字修饰的代码块。</li>
<li><strong>作用：</strong><ul>
<li>用于控制多线程对共享资源的并发访问，保证线程安全。</li>
<li><code>synchronized</code> 关键字可以修饰方法或代码块。修饰代码块时，需要指定一个锁对象。</li>
</ul>
</li>
<li><strong>执行时机：</strong> 当线程尝试进入同步代码块时，会尝试获取锁。如果锁被其他线程占用，则该线程会被阻塞，直到获取到锁。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 锁对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 同步代码块</span></span><br><span class="line">            count++;</span><br><span class="line">            System.out.println(<span class="string">&quot;Count = &quot;</span> + count + <span class="string">&quot;, Thread = &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                counter.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;Thread-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Final Count = &quot;</span> + counter.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li><strong>普通代码块：</strong> 限制变量作用域，提高代码可读性。</li>
<li><strong>构造代码块：</strong> 在每次创建对象时执行，用于初始化实例变量。</li>
<li><strong>静态代码块：</strong> 在类加载时执行，用于初始化静态变量。</li>
<li><strong>同步代码块：</strong> 用于控制多线程对共享资源的并发访问，保证线程安全。</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><hr>
<h3 id="一、什么是内部类？"><a href="#一、什么是内部类？" class="headerlink" title="一、什么是内部类？"></a>一、什么是内部类？</h3><p><strong>内部类</strong>是指：<strong>定义在另一个类内部的类</strong>。<br>也就是说，一个类中可以再写一个类，这个“内部的类”就是内部类。</p>
<p>举个简单例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello from Inner!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二、Java-中的四种内部类类型"><a href="#二、Java-中的四种内部类类型" class="headerlink" title="二、Java 中的四种内部类类型"></a>二、Java 中的四种内部类类型</h3><p>Java 内部类有四种类型，每种都有自己的特点和使用场景：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>定义位置</th>
<th>是否能访问外部类成员</th>
<th>是否需要外部类对象</th>
<th>修饰符支持情况</th>
</tr>
</thead>
<tbody><tr>
<td>成员内部类</td>
<td>类的成员位置</td>
<td>✅ 可以</td>
<td>✅ 需要</td>
<td>public&#x2F;private 等</td>
</tr>
<tr>
<td>局部内部类</td>
<td>方法内部</td>
<td>✅ 可以（有限制）</td>
<td>✅ 需要</td>
<td>不允许使用 public 等</td>
</tr>
<tr>
<td>匿名内部类</td>
<td>没有名字，直接在 new 之后</td>
<td>✅ 可以</td>
<td>✅ 需要</td>
<td>不能有构造函数</td>
</tr>
<tr>
<td>静态内部类（嵌套类）</td>
<td>类的成员位置，使用 static</td>
<td>❌ 不能直接访问</td>
<td>❌ 不需要</td>
<td>可以是 public&#x2F;private 等</td>
</tr>
</tbody></table>
<hr>
<h3 id="三、逐个类型详细讲解"><a href="#三、逐个类型详细讲解" class="headerlink" title="三、逐个类型详细讲解"></a>三、逐个类型详细讲解</h3><hr>
<h4 id="1️⃣-成员内部类"><a href="#1️⃣-成员内部类" class="headerlink" title="1️⃣ 成员内部类"></a>1️⃣ 成员内部类</h4><p>就是定义在另一个类的 <strong>成员位置</strong> 的类（与字段&#x2F;方法平级）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Outer msg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner sees: &quot;</span> + msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🧠 <strong>注意</strong>：</p>
<ul>
<li><p>成员内部类 <strong>可以访问外部类的私有成员</strong>。</p>
</li>
<li><p>创建方式：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.show();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2️⃣-局部内部类（方法中定义类）"><a href="#2️⃣-局部内部类（方法中定义类）" class="headerlink" title="2️⃣ 局部内部类（方法中定义类）"></a>2️⃣ 局部内部类（方法中定义类）</h4><p>定义在方法、代码块、构造器中的类，作用域只在这个块内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;局部内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        i.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✨ <strong>特点</strong>：</p>
<ul>
<li><p>类似于局部变量，出了方法就不能访问。</p>
</li>
<li><p>如果访问外部方法的局部变量，<strong>这个变量必须是 final 或 effectively final</strong>。</p>
</li>
</ul>
<hr>
<h4 id="3️⃣-匿名内部类"><a href="#3️⃣-匿名内部类" class="headerlink" title="3️⃣ 匿名内部类"></a>3️⃣ 匿名内部类</h4><p>🌟 这是最常见的一种形式，通常用来“临时实现一个接口或类”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;匿名内部类实现的线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br></pre></td></tr></table></figure>

<p>🔍 特点：</p>
<ul>
<li><p><strong>没有类名！</strong>（所以叫“匿名”）</p>
</li>
<li><p>直接 new 接口或抽象类。</p>
</li>
<li><p>常用于回调、事件处理等场景。</p>
</li>
<li><p><strong>不能有构造函数</strong>。</p>
</li>
</ul>
<hr>
<h4 id="4️⃣-静态内部类（静态嵌套类）"><a href="#4️⃣-静态内部类（静态嵌套类）" class="headerlink" title="4️⃣ 静态内部类（静态嵌套类）"></a>4️⃣ 静态内部类（静态嵌套类）</h4><p>使用 <code>static</code> 修饰的内部类，<strong>它不依赖外部类对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;静态内部类，不需要外部类对象&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 使用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.<span class="type">StaticInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br><span class="line">inner.say();</span><br></pre></td></tr></table></figure>

<p>⚠️ 它不能访问外部类的非静态成员！</p>
<hr>
<h3 id="四、使用场景举例"><a href="#四、使用场景举例" class="headerlink" title="四、使用场景举例"></a>四、使用场景举例</h3><ul>
<li><p>成员内部类：当内部类需要频繁访问外部类的实例变量或方法时。</p>
</li>
<li><p>局部内部类：当一个类只在某个方法中用一次（封装临时逻辑）。</p>
</li>
<li><p>匿名内部类：在需要临时实现接口或抽象类时（如事件监听器、Runnable）。</p>
</li>
<li><p>静态内部类：用于实现工具类、构建器模式（Builder）、数据封装等。</p>
</li>
</ul>
<hr>
<h3 id="总结一句话："><a href="#总结一句话：" class="headerlink" title="总结一句话："></a>总结一句话：</h3><blockquote>
<p>内部类让你可以“把逻辑上相关的类放在一起”，并且可以方便地访问外部类的数据，让代码结构更紧凑，更清晰。</p>
</blockquote>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p><strong>什么是 Lambda 表达式？</strong></p>
<p>Lambda 表达式是 Java 8 引入的一个重要特性，它本质上是一个匿名函数，可以作为参数传递给方法或存储在变量中。 Lambda 表达式提供了一种简洁而灵活的方式来表示函数式接口（Functional Interface）的实例。</p>
<p><strong>Lambda 表达式的语法：</strong></p>
<p>Lambda 表达式的基本语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(parameters) -&gt; &#123; statements; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>parameters：</strong> 参数列表，可以为空，也可以包含一个或多个参数。参数类型可以显式声明，也可以由编译器推断。</li>
<li><strong>-&gt;：</strong> Lambda 操作符，用于分隔参数列表和 Lambda 体。</li>
<li><strong>expression：</strong> 表达式，Lambda 体可以是单个表达式，也可以是代码块。</li>
<li><strong>statements：</strong> 代码块，如果 Lambda 体包含多个语句，需要用花括号 <code>&#123;&#125;</code> 包围。</li>
</ul>
<p><strong>Lambda 表达式的特点：</strong></p>
<ol>
<li><strong>匿名性：</strong> Lambda 表达式没有名称，它是一个匿名函数。</li>
<li><strong>函数式接口：</strong> Lambda 表达式只能用于实现函数式接口。</li>
<li><strong>类型推断：</strong> 编译器可以根据上下文推断 Lambda 表达式的参数类型。</li>
<li><strong>简洁性：</strong> Lambda 表达式可以用更少的代码来实现相同的功能。</li>
</ol>
<p><strong>函数式接口（Functional Interface）：</strong></p>
<p>函数式接口是指只包含一个抽象方法的接口。 Java 8 引入了 <code>@FunctionalInterface</code> 注解，用于显式声明一个接口为函数式接口。 如果一个接口被 <code>@FunctionalInterface</code> 注解标记，但实际上包含多个抽象方法，编译器会报错。</p>
<p><strong>常见的函数式接口：</strong></p>
<p>Java 8 提供了一些常用的函数式接口，位于 <code>java.util.function</code> 包中，例如：</p>
<ul>
<li><code>Predicate&lt;T&gt;</code>：接受一个参数 <code>T</code>，返回一个布尔值。</li>
<li><code>Consumer&lt;T&gt;</code>：接受一个参数 <code>T</code>，不返回任何值（<code>void</code>）。</li>
<li><code>Function&lt;T, R&gt;</code>：接受一个参数 <code>T</code>，返回一个结果 <code>R</code>。</li>
<li><code>Supplier&lt;T&gt;</code>：不接受任何参数，返回一个结果 <code>T</code>。</li>
<li><code>UnaryOperator&lt;T&gt;</code>：接受一个参数 <code>T</code>，返回一个类型为 <code>T</code> 的结果。</li>
<li><code>BinaryOperator&lt;T&gt;</code>：接受两个类型为 <code>T</code> 的参数，返回一个类型为 <code>T</code> 的结果。</li>
</ul>
<p><strong>Lambda 表达式的示例：</strong></p>
<ol>
<li><strong>无参数的 Lambda 表达式：</strong></li>
</ol>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个名为 doSomething 的抽象方法。</span></span><br><span class="line"><span class="comment">     * 任何实现 MyInterface 的类或 Lambda 表达式都需要提供此方法的具体实现。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式实现 MyInterface 接口。</span></span><br><span class="line">        <span class="comment">// Lambda 表达式 () -&gt; System.out.println(&quot;Hello, Lambda!&quot;)  实现了 MyInterface 的 doSomething 方法。</span></span><br><span class="line">        <span class="comment">// () 表示没有参数， -&gt; 分隔参数列表和方法体， System.out.println(&quot;Hello, Lambda!&quot;) 是方法体，打印 &quot;Hello, Lambda!&quot; 到控制台。</span></span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">myInterface</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello, Lambda!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 myInterface 对象的 doSomething 方法。</span></span><br><span class="line">        <span class="comment">// 这将执行 Lambda 表达式中定义的代码，即打印 &quot;Hello, Lambda!&quot; 到控制台。</span></span><br><span class="line">        myInterface.doSomething(); <span class="comment">// 输出 Hello, Lambda!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>带一个参数的 Lambda 表达式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式实现 MyInterface</span></span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">myInterface</span> <span class="operator">=</span> (message) -&gt; System.out.println(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        myInterface.doSomething(<span class="string">&quot;Lambda is awesome!&quot;</span>); <span class="comment">// 输出 Message: Lambda is awesome!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>带多个参数的 Lambda 表达式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式实现 MyInterface</span></span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">myInterface</span> <span class="operator">=</span> (a, b) -&gt; a + b;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> myInterface.add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result); <span class="comment">// 输出 Result: 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用代码块的 Lambda 表达式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式实现 MyInterface</span></span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">myInterface</span> <span class="operator">=</span> (message) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Processing message...&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">        &#125;;</span><br><span class="line">        myInterface.doSomething(<span class="string">&quot;Lambda is powerful!&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="comment">// Processing message...</span></span><br><span class="line">        <span class="comment">// Message: Lambda is powerful!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>java.util.function</code> 包中的函数式接口：</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个整数列表</span></span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个 Predicate，用于判断一个整数是否为偶数</span></span><br><span class="line">        <span class="comment">// Predicate 是一个函数式接口，接受一个参数并返回一个布尔值</span></span><br><span class="line">        Predicate&lt;Integer&gt; isEven = (number) -&gt; number % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Stream API 过滤列表中的偶数并打印</span></span><br><span class="line">        numbers.stream() <span class="comment">// 将列表转换为 Stream</span></span><br><span class="line">                .filter(isEven) <span class="comment">// 使用 Predicate 过滤 Stream 中的元素，只保留偶数</span></span><br><span class="line">                .forEach(number -&gt; System.out.println(number)); <span class="comment">// 遍历过滤后的 Stream，并打印每个元素</span></span><br><span class="line">                <span class="comment">// 输出 2 4 6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda 表达式的优点：</strong></p>
<ul>
<li><strong>代码简洁：</strong> 可以用更少的代码来实现相同的功能。</li>
<li><strong>可读性强：</strong> Lambda 表达式使代码更易于理解。</li>
<li><strong>灵活性高：</strong> 可以将 Lambda 表达式作为参数传递给方法，实现更灵活的编程。</li>
<li><strong>支持函数式编程：</strong> Lambda 表达式是 Java 支持函数式编程的基础。</li>
</ul>
<p><strong>Lambda 表达式的注意事项：</strong></p>
<ul>
<li><strong>只能用于函数式接口：</strong> Lambda 表达式只能用于实现函数式接口。</li>
<li><strong>变量捕获：</strong> Lambda 表达式可以访问外部的 <code>final</code> 或 effectively final 的局部变量。</li>
<li><strong><code>this</code> 关键字：</strong> 在 Lambda 表达式中，<code>this</code> 关键字指向的是外部类的实例，而不是 Lambda 表达式本身。</li>
</ul>
<h2 id="java的方法引用"><a href="#java的方法引用" class="headerlink" title="java的方法引用"></a>java的方法引用</h2><p>方法引用是 Java 8 引入的一个重要特性，它允许你直接引用已经存在的方法或构造器，并将其作为函数式接口的实例来使用。  这使得代码更加简洁易读，也更符合函数式编程的风格。</p>
<h3 id="基础原理"><a href="#基础原理" class="headerlink" title="基础原理"></a><strong>基础原理</strong></h3><p>方法引用本质上是 Lambda 表达式的一种简化形式。  Lambda 表达式允许你定义匿名函数，而方法引用则允许你直接引用已有的方法，避免编写冗余的 Lambda 表达式。</p>
<p>Java 中有四种方法引用：</p>
<ol>
<li><strong>静态方法引用：</strong>  <code>类名::静态方法名</code></li>
<li><strong>实例方法引用（特定对象）：</strong>  <code>对象::实例方法名</code></li>
<li><strong>实例方法引用（类型）：</strong>  <code>类名::实例方法名</code></li>
<li><strong>构造器引用：</strong>  <code>类名::new</code></li>
</ol>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a><strong>函数式接口</strong></h3><p>方法引用必须与函数式接口兼容。  函数式接口是只包含一个抽象方法的接口。  Java 8 引入了 <code>@FunctionalInterface</code> 注解，用于显式声明一个接口为函数式接口。  常见的函数式接口包括 <code>Predicate</code>, <code>Consumer</code>, <code>Function</code>, <code>Supplier</code> 等。</p>
<p><strong>代码示例：静态方法引用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethodReference</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串转换为大写。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 要转换的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转换后的大写字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toUpperCase</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个包含小写名字的列表</span></span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>, <span class="string">&quot;charlie&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式将列表中的每个名字转换为大写</span></span><br><span class="line">        <span class="comment">// .map(s -&gt; toUpperCase(s))：对流中的每个元素应用 Lambda 表达式，将每个字符串 s 转换为 toUpperCase(s) 的结果。</span></span><br><span class="line">        <span class="comment">// .collect(Collectors.toList())：将流中的元素收集到一个新的列表中。</span></span><br><span class="line">        List&lt;String&gt; upperCaseNamesLambda = names.stream()</span><br><span class="line">                .map(s -&gt; toUpperCase(s))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda: &quot;</span> + upperCaseNamesLambda);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用静态方法引用将列表中的每个名字转换为大写</span></span><br><span class="line">        <span class="comment">// StaticMethodReference::toUpperCase：这是一个静态方法引用，它引用了 StaticMethodReference 类的 toUpperCase 方法。</span></span><br><span class="line">        <span class="comment">//  它等价于 Lambda 表达式 s -&gt; StaticMethodReference.toUpperCase(s)。</span></span><br><span class="line">        List&lt;String&gt; upperCaseNamesMethodReference = names.stream()</span><br><span class="line">                .map(StaticMethodReference::toUpperCase)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;Method Reference: &quot;</span> + upperCaseNamesMethodReference);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>StaticMethodReference::toUpperCase</code>  引用了 <code>StaticMethodReference</code> 类的静态方法 <code>toUpperCase</code>。  <code>map</code> 方法接受一个 <code>Function</code> 函数式接口，该接口的 <code>apply</code> 方法接受一个 <code>String</code> 参数并返回一个 <code>String</code> 结果，这与 <code>toUpperCase</code> 方法的签名相匹配。</p>
<p><strong>代码示例：实例方法引用（特定对象）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceMethodReferenceObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toUpperCase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toString().toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InstanceMethodReferenceObject</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstanceMethodReferenceObject</span>();</span><br><span class="line">        List&lt;InstanceMethodReferenceObject&gt; instances = Arrays.asList(<span class="keyword">new</span> <span class="title class_">InstanceMethodReferenceObject</span>(), <span class="keyword">new</span> <span class="title class_">InstanceMethodReferenceObject</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">        List&lt;String&gt; upperCaseNamesLambda = instances.stream()</span><br><span class="line">                .map(i -&gt; instance.toUpperCase())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda: &quot;</span> + upperCaseNamesLambda);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用实例方法引用 (特定对象)</span></span><br><span class="line">        List&lt;String&gt; upperCaseNamesMethodReference = instances.stream()</span><br><span class="line">                .map(instance::toUpperCase)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;Method Reference: &quot;</span> + upperCaseNamesMethodReference);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，<code>instance::toUpperCase</code>  引用了 <code>instance</code> 对象的 <code>toUpperCase</code> 实例方法。  <code>map</code> 方法仍然接受一个 <code>Function</code>，但这次 <code>apply</code> 方法的实现是调用 <code>instance</code> 对象的 <code>toUpperCase</code> 方法。</p>
<p><strong>代码示例：实例方法引用（类型）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceMethodReferenceType</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toUpperCase</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toString().toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;InstanceMethodReferenceType&gt; instances = Arrays.asList(<span class="keyword">new</span> <span class="title class_">InstanceMethodReferenceType</span>(), <span class="keyword">new</span> <span class="title class_">InstanceMethodReferenceType</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">        List&lt;String&gt; upperCaseNamesLambda = instances.stream()</span><br><span class="line">                .map(i -&gt; i.toUpperCase())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda: &quot;</span> + upperCaseNamesLambda);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用实例方法引用 (类型)</span></span><br><span class="line">        List&lt;String&gt; upperCaseNamesMethodReference = instances.stream()</span><br><span class="line">                .map(InstanceMethodReferenceType::toUpperCase)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;Method Reference: &quot;</span> + upperCaseNamesMethodReference);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>InstanceMethodReferenceType::toUpperCase</code>  引用了 <code>InstanceMethodReferenceType</code> 类的 <code>toUpperCase</code> 实例方法。  <code>map</code> 方法接受一个 <code>Function</code>，该接口的 <code>apply</code> 方法接受一个 <code>InstanceMethodReferenceType</code> 对象作为参数，并调用该对象的 <code>toUpperCase</code> 方法。  这种方法引用适用于当你需要对流中的每个对象调用相同的方法时。</p>
<p><strong>代码示例：构造器引用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstructorReference</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorReference</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;Default Name&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConstructorReference</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 name 属性的方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式创建 ConstructorReference 对象 (无参构造器)</span></span><br><span class="line">        Supplier&lt;ConstructorReference&gt; constructorLambda = () -&gt; <span class="keyword">new</span> <span class="title class_">ConstructorReference</span>();</span><br><span class="line">        <span class="type">ConstructorReference</span> <span class="variable">instanceLambda</span> <span class="operator">=</span> constructorLambda.get(); <span class="comment">// 调用 get() 方法创建对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda: &quot;</span> + instanceLambda.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用构造器引用创建 ConstructorReference 对象 (无参构造器)</span></span><br><span class="line">        <span class="comment">// ConstructorReference::new 等价于 () -&gt; new ConstructorReference()</span></span><br><span class="line">        Supplier&lt;ConstructorReference&gt; constructorReference = ConstructorReference::<span class="keyword">new</span>;</span><br><span class="line">        <span class="type">ConstructorReference</span> <span class="variable">instanceReference</span> <span class="operator">=</span> constructorReference.get(); <span class="comment">// 调用 get() 方法创建对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Method Reference (no args): &quot;</span> + instanceReference.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式创建 ConstructorReference 对象列表 (带参数的构造器)</span></span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">        List&lt;ConstructorReference&gt; instancesLambda = names.stream()</span><br><span class="line">                .map(name -&gt; <span class="keyword">new</span> <span class="title class_">ConstructorReference</span>(name)) <span class="comment">// 对每个 name 创建一个 ConstructorReference 对象</span></span><br><span class="line">                .collect(Collectors.toList()); <span class="comment">// 将创建的对象收集到 List 中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Lambda (with args): &quot;</span> + instancesLambda.stream().map(ConstructorReference::getName).collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用构造器引用创建 ConstructorReference 对象列表 (带参数的构造器)</span></span><br><span class="line">        <span class="comment">// ConstructorReference::new 等价于 name -&gt; new ConstructorReference(name)</span></span><br><span class="line">        List&lt;ConstructorReference&gt; instancesReference = names.stream()</span><br><span class="line">                .map(ConstructorReference::<span class="keyword">new</span>) <span class="comment">// 对每个 name 创建一个 ConstructorReference 对象</span></span><br><span class="line">                .collect(Collectors.toList()); <span class="comment">// 将创建的对象收集到 List 中</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Method Reference (with args): &quot;</span> + instancesReference.stream().map(ConstructorReference::getName).collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConstructorReference::new</code>  引用了 <code>ConstructorReference</code> 类的构造器。  <code>Supplier&lt;ConstructorReference&gt;</code> 函数式接口的 <code>get</code> 方法返回一个新的 <code>ConstructorReference</code> 对象。  如果构造器有参数，<code>map</code> 方法会根据参数类型选择合适的构造器。</p>
<p><strong>进阶知识</strong></p>
<ul>
<li><p><strong>方法引用与泛型：</strong>  方法引用可以与泛型一起使用，以创建更灵活的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericMethodReference</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; String <span class="title function_">convertToString</span><span class="params">(T obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用泛型方法引用</span></span><br><span class="line">        List&lt;String&gt; stringNumbers = numbers.stream()</span><br><span class="line">                .map(GenericMethodReference::&lt;Integer&gt;convertToString) <span class="comment">// 显式指定类型参数</span></span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(stringNumbers); <span class="comment">// 输出: [1, 2, 3]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法引用与继承：</strong>  方法引用可以引用父类的方法，只要该方法对子类可见。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Generic animal sound&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InheritanceMethodReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Dog&gt; dogs = Arrays.asList(<span class="keyword">new</span> <span class="title class_">Dog</span>(), <span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用父类方法 (如果子类没有重写)</span></span><br><span class="line">        List&lt;String&gt; sounds = dogs.stream()</span><br><span class="line">                .map(Animal::makeSound) <span class="comment">// 即使是Dog对象，也可以通过Animal引用</span></span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        System.out.println(sounds); <span class="comment">// 输出: [Woof!, Woof!]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法引用与接口：</strong>  方法引用可以引用接口的默认方法和静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> String <span class="title function_">getDefaultMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Default message from interface&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">getStaticMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Static message from interface&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="comment">// 可以选择性地重写接口的默认方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfaceMethodReference</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用接口的默认方法</span></span><br><span class="line">        Supplier&lt;String&gt; defaultMessageSupplier = myObject::getDefaultMessage;</span><br><span class="line">        System.out.println(defaultMessageSupplier.get()); <span class="comment">// 输出: Default message from interface</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 引用接口的静态方法</span></span><br><span class="line">        Supplier&lt;String&gt; staticMessageSupplier = MyInterface::getStaticMessage;</span><br><span class="line">        System.out.println(staticMessageSupplier.get()); <span class="comment">// 输出: Static message from interface</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>实际案例</strong></p>
<ol>
<li><p><strong>排序：</strong>  可以使用方法引用来简化集合的排序操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; people = Arrays.asList(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">35</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式排序</span></span><br><span class="line">        people.sort((p1, p2) -&gt; p1.getName().compareTo(p2.getName()));</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted by name (Lambda): &quot;</span> + people);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用方法引用排序</span></span><br><span class="line">        people.sort(Comparator.comparing(Person::getName));</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted by name (Method Reference): &quot;</span> + people);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用方法引用和 reversed() 排序</span></span><br><span class="line">        people.sort(Comparator.comparing(Person::getAge).reversed());</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted by age (Method Reference, reversed): &quot;</span> + people);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事件处理：</strong>  在 GUI 编程中，可以使用方法引用来简化事件处理器的注册。  (虽然现在GUI开发更多使用框架，但原理相同)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设有一个按钮类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ClickHandler clickHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClickHandler</span><span class="params">(ClickHandler clickHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.clickHandler = clickHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">click</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (clickHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">            clickHandler.onClick();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数式接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ClickHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventHandlingExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleButtonClick</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Button clicked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>();</span><br><span class="line">        <span class="type">EventHandlingExample</span> <span class="variable">eventHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventHandlingExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">        button.setClickHandler(() -&gt; eventHandler.handleButtonClick());</span><br><span class="line">        button.click();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用方法引用</span></span><br><span class="line">        button.setClickHandler(eventHandler::handleButtonClick);</span><br><span class="line">        button.click();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>日志记录：</strong>  可以使用方法引用来简化日志记录器的使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(LoggingExample.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        logger.info(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LoggingExample</span> <span class="variable">loggingExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingExample</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">logTaskLambda</span> <span class="operator">=</span> () -&gt; loggingExample.logMessage(<span class="string">&quot;This is a log message (Lambda).&quot;</span>);</span><br><span class="line">        logTaskLambda.run();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用方法引用</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">logTaskReference</span> <span class="operator">=</span> loggingExample::logMessage;</span><br><span class="line">        logTaskReference.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据验证：</strong>  可以使用方法引用来简化数据验证逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidationExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPositive</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">        List&lt;Integer&gt; positiveNumbersLambda = numbers.stream()</span><br><span class="line">                .filter(n -&gt; isPositive(n))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;Positive numbers (Lambda): &quot;</span> + positiveNumbersLambda);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用方法引用</span></span><br><span class="line">        List&lt;Integer&gt; positiveNumbersReference = numbers.stream()</span><br><span class="line">                .filter(ValidationExample::isPositive)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;Positive numbers (Method Reference): &quot;</span> + positiveNumbersReference);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Java常用API"><a href="#Java常用API" class="headerlink" title="Java常用API"></a>Java常用API</h2><h3 id="一、基础原理：API的概念与作用"><a href="#一、基础原理：API的概念与作用" class="headerlink" title="一、基础原理：API的概念与作用"></a><strong>一、基础原理：API的概念与作用</strong></h3><p>API (Application Programming Interface)，即应用程序编程接口，是一组预定义的函数、类、协议和工具，允许软件应用程序之间进行交互。在Java中，API通常以类库的形式提供，开发者可以通过调用这些类库中的方法，来实现各种功能，而无需从头编写代码。</p>
<p>API的作用：</p>
<ul>
<li><strong>代码重用：</strong> 避免重复编写相同功能的代码，提高开发效率。</li>
<li><strong>简化开发：</strong> 封装复杂的操作，提供简单易用的接口。</li>
<li><strong>标准化：</strong> 提供统一的接口，方便不同应用程序之间的集成。</li>
<li><strong>抽象：</strong> 隐藏底层实现细节，使开发者专注于业务逻辑。</li>
</ul>
<h3 id="二、常用API分类与详解"><a href="#二、常用API分类与详解" class="headerlink" title="二、常用API分类与详解"></a><strong>二、常用API分类与详解</strong></h3><p>Java API非常庞大，涵盖了各种领域。以下是一些常用的API分类及其详解：</p>
<h4 id="1-Java核心类库-java-lang-java-util-java-io-java-net-java-text-java-math"><a href="#1-Java核心类库-java-lang-java-util-java-io-java-net-java-text-java-math" class="headerlink" title="1.  Java核心类库 (java.lang, java.util, java.io, java.net, java.text, java.math)"></a>1.  <strong>Java核心类库 (java.lang, java.util, java.io, java.net, java.text, java.math)</strong></h4><pre><code>*   **java.lang:**  Java语言的基础类库，包含Object、String、Math、Thread等核心类。
</code></pre>
<p>使用””创建字符串对象，放在常量池中<br><img src="https://i.imgur.com/tAyOA6B.png"><br>使用字符串创建对象，或者其他的放在常量池中。</p>
<h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a><strong>基本操作</strong></h5><ul>
<li><p><strong><code>length()</code></strong>: 返回字符串的长度（字符数）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length(); <span class="comment">// len = 5</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>charAt(int index)</code></strong>: 返回指定索引位置的字符。索引从 0 开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>); <span class="comment">// ch = &#x27;H&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>substring(int beginIndex)</code></strong>: 返回从指定索引开始到字符串末尾的子字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> str.substring(<span class="number">2</span>); <span class="comment">// sub = &quot;llo&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>substring(int beginIndex, int endIndex)</code></strong>: 返回从 <code>beginIndex</code>（包含）到 <code>endIndex</code>（不包含）的子字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> str.substring(<span class="number">1</span>, <span class="number">4</span>); <span class="comment">// sub = &quot;ell&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>比较</strong></p>
<ul>
<li><p><strong><code>equals(Object obj)</code></strong>: 比较字符串的内容是否相等（区分大小写）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> str1.equals(str2); <span class="comment">// isEqual = false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>equalsIgnoreCase(String anotherString)</code></strong>: 比较字符串的内容是否相等（忽略大小写）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEqual</span> <span class="operator">=</span> str1.equalsIgnoreCase(str2); <span class="comment">// isEqual = true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>compareTo(String anotherString)</code></strong>: 按照字典顺序比较字符串。返回一个整数，如果小于 0，则表示当前字符串小于 <code>anotherString</code>；如果等于 0，则表示相等；如果大于 0，则表示大于 <code>anotherString</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;banana&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> str1.compareTo(str2); <span class="comment">// result &lt; 0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>查找</strong></p>
<ul>
<li><p><strong><code>indexOf(int ch)</code></strong>: 返回指定字符在字符串中第一次出现的索引。如果未找到，则返回 -1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.indexOf(<span class="string">&#x27;l&#x27;</span>); <span class="comment">// index = 2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>indexOf(String str)</code></strong>: 返回指定子字符串在字符串中第一次出现的索引。如果未找到，则返回 -1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.indexOf(<span class="string">&quot;world&quot;</span>); <span class="comment">// index = 6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>lastIndexOf(int ch)</code></strong>: 返回指定字符在字符串中最后一次出现的索引。如果未找到，则返回 -1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.lastIndexOf(<span class="string">&#x27;l&#x27;</span>); <span class="comment">// index = 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>lastIndexOf(String str)</code></strong>: 返回指定子字符串在字符串中最后一次出现的索引。如果未找到，则返回 -1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello world world&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.lastIndexOf(<span class="string">&quot;world&quot;</span>); <span class="comment">// index = 12</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>转换</strong></p>
<ul>
<li><p><strong><code>toLowerCase()</code></strong>: 将字符串转换为小写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">lower</span> <span class="operator">=</span> str.toLowerCase(); <span class="comment">// lower = &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>toUpperCase()</code></strong>: 将字符串转换为大写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">upper</span> <span class="operator">=</span> str.toUpperCase(); <span class="comment">// upper = &quot;HELLO&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>trim()</code></strong>: 去除字符串开头和结尾的空格。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;  Hello  &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">trimmed</span> <span class="operator">=</span> str.trim(); <span class="comment">// trimmed = &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>replace(char oldChar, char newChar)</code></strong>: 将字符串中所有出现的 <code>oldChar</code> 替换为 <code>newChar</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">replaced</span> <span class="operator">=</span> str.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;p&#x27;</span>); <span class="comment">// replaced = &quot;Heppo&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>replace(CharSequence target, CharSequence replacement)</code></strong>: 将字符串中所有出现的 <code>target</code> 替换为 <code>replacement</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">replaced</span> <span class="operator">=</span> str.replace(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;Java&quot;</span>); <span class="comment">// replaced = &quot;Hello Java&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>split(String regex)</code></strong>: 根据给定的正则表达式将字符串分割成字符串数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;apple,banana,orange&quot;</span>;</span><br><span class="line">String[] parts = str.split(<span class="string">&quot;,&quot;</span>); <span class="comment">// parts = &#123;&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>toCharArray()</code></strong>: 将字符串转换为字符数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] chars = str.toCharArray(); <span class="comment">// chars = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><p><strong><code>startsWith(String prefix)</code></strong>: 检查字符串是否以指定的前缀开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">startsWithHello</span> <span class="operator">=</span> str.startsWith(<span class="string">&quot;Hel&quot;</span>); <span class="comment">// startsWithHello = true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>endsWith(String suffix)</code></strong>: 检查字符串是否以指定的后缀结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">endsWithHello</span> <span class="operator">=</span> str.endsWith(<span class="string">&quot;llo&quot;</span>); <span class="comment">// endsWithHello = true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>contains(CharSequence s)</code></strong>: 检查字符串是否包含指定的字符序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">containsWorld</span> <span class="operator">=</span> str.contains(<span class="string">&quot;world&quot;</span>); <span class="comment">// containsWorld = true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>isEmpty()</code></strong>: 检查字符串是否为空（长度为 0）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> str.isEmpty(); <span class="comment">// isEmpty = true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>valueOf(各种类型)</code></strong>:  这是一个静态方法，可以将各种数据类型转换为字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(num); <span class="comment">// str = &quot;123&quot;</span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>Object:</strong> 所有类的父类，提供equals()、hashCode()、toString()等通用方法。<ul>
<li><strong>String:</strong> 字符串类，提供字符串操作方法，如substring()、indexOf()、replace()等。</li>
<li><strong>Math:</strong> 数学类，提供数学运算方法，如abs()、sqrt()、sin()、cos()等。</li>
<li><strong>Thread:</strong> 线程类，用于创建和管理线程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// String示例</span><br><span class="line">String str = &quot;Hello World&quot;;</span><br><span class="line">System.out.println(str.substring(0, 5)); // 输出 Hello</span><br><span class="line">System.out.println(str.indexOf(&quot;World&quot;)); // 输出 6</span><br><span class="line"></span><br><span class="line">// Math示例</span><br><span class="line">System.out.println(Math.abs(-10)); // 输出 10</span><br><span class="line">System.out.println(Math.sqrt(9));  // 输出 3.0</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>java.util:</strong>  包含集合框架、日期时间、随机数等工具类。</p>
</li>
<li><p><strong>List, Set, Map:</strong> 集合框架接口，提供存储和操作数据的容器。<br>*   <strong>ArrayList, LinkedList, HashSet, HashMap:</strong> 集合框架的常用实现类。<br>*   <strong>Date, Calendar:</strong> 日期时间类，用于处理日期和时间。<br>*   <strong>Random:</strong> 随机数生成器。<br>[[集合]]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList示例</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">System.out.println(list.get(<span class="number">0</span>)); <span class="comment">// 输出 Apple</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap示例</span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;Apple&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;Banana&quot;</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(map.get(<span class="string">&quot;Apple&quot;</span>)); <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Date示例</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(now);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>java.io:</strong>  输入输出类库，用于读写文件、网络数据等。</p>
<ul>
<li><strong>InputStream, OutputStream:</strong> 字节输入输出流的抽象类。<ul>
<li><strong>Reader, Writer:</strong> 字符输入输出流的抽象类。</li>
<li><strong>FileInputStream, FileOutputStream:</strong> 文件字节输入输出流。</li>
<li><strong>FileReader, FileWriter:</strong> 文件字符输入输出流。</li>
<li><strong>BufferedReader, BufferedWriter:</strong> 带缓冲的字符输入输出流。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```java</span><br><span class="line"> // 文件读取示例</span><br><span class="line"> try (BufferedReader reader = new BufferedReader(new FileReader(&quot;test.txt&quot;))) &#123;</span><br><span class="line">     String line;</span><br><span class="line">     while ((line = reader.readLine()) != null) &#123;</span><br><span class="line">         System.out.println(line);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; catch (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 文件写入示例</span><br><span class="line"> try (BufferedWriter writer = new BufferedWriter(new FileWriter(&quot;output.txt&quot;))) &#123;</span><br><span class="line">     writer.write(&quot;Hello, World!&quot;);</span><br><span class="line"> &#125; catch (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*   **java.net:**  网络编程类库，用于创建网络连接、发送数据等。</span><br><span class="line"></span><br><span class="line">        *   **Socket:** 套接字类，用于建立客户端连接。</span><br><span class="line">        *   **ServerSocket:** 服务器套接字类，用于监听客户端连接。</span><br><span class="line">        *   **URL:** 统一资源定位符类，用于表示网络资源。</span><br><span class="line"></span><br><span class="line">        ```java</span><br><span class="line">        // 客户端示例</span><br><span class="line">        try (Socket socket = new Socket(&quot;localhost&quot;, 8080);</span><br><span class="line">             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);</span><br><span class="line">             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))) &#123;</span><br><span class="line"></span><br><span class="line">            out.println(&quot;Hello Server!&quot;);</span><br><span class="line">            String response = in.readLine();</span><br><span class="line">            System.out.println(&quot;Server response: &quot; + response);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //服务端示例</span><br><span class="line">        try (ServerSocket serverSocket = new ServerSocket(8080);</span><br><span class="line">             Socket clientSocket = serverSocket.accept();</span><br><span class="line">             PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);</span><br><span class="line">             BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))) &#123;</span><br><span class="line"></span><br><span class="line">            String inputLine;</span><br><span class="line">            while ((inputLine = in.readLine()) != null) &#123;</span><br><span class="line">                System.out.println(&quot;Client says: &quot; + inputLine);</span><br><span class="line">                out.println(&quot;Echo: &quot; + inputLine);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<pre><code>*   **java.text:**  文本处理类库，用于格式化日期、数字等。

    *   **DateFormat, SimpleDateFormat:** 日期格式化类。
    *   **NumberFormat:** 数字格式化类。

    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 日期格式化示例</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDate</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">System.out.println(formattedDate); <span class="comment">// 输出类似 2023-10-27 10:00:00</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 数字格式化示例</span></span><br><span class="line"><span class="type">NumberFormat</span> <span class="variable">nf</span> <span class="operator">=</span> NumberFormat.getNumberInstance();</span><br><span class="line">nf.setMaximumFractionDigits(<span class="number">2</span>); <span class="comment">// 设置小数位数</span></span><br><span class="line"><span class="type">String</span> <span class="variable">formattedNumber</span> <span class="operator">=</span> nf.format(<span class="number">1234.567</span>);</span><br><span class="line">System.out.println(formattedNumber); <span class="comment">// 输出 1,234.57 (根据本地化设置)</span></span><br></pre></td></tr></table></figure>

*   **java.math:**  数学计算类库，提供高精度计算。

    *   **BigDecimal:** 高精度浮点数类。
    *   **BigInteger:** 高精度整数类。

    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BigDecimal示例</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">result</span> <span class="operator">=</span> num1.subtract(num2);</span><br><span class="line">System.out.println(result); <span class="comment">// 输出 0.1</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// BigInteger示例</span></span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">factorial</span> <span class="operator">=</span> BigInteger.ONE;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">    factorial = factorial.multiply(BigInteger.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(factorial); <span class="comment">// 输出 2432902008176640000</span></span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="2">
<li><p><strong>Java Swing&#x2F;JavaFX (javax.swing, javafx.*):</strong>  图形用户界面 (GUI) 类库。</p>
<ul>
<li><strong>JFrame, JPanel, JButton, JLabel, JTextField:</strong> Swing的常用组件。</li>
<li><strong>Scene, Stage, Button, Label, TextField:</strong> JavaFX的常用组件。</li>
</ul>
<p>(GUI编程较为复杂，此处仅作简单提及，不提供详细代码示例)</p>
</li>
<li><p><strong>Java Database Connectivity (JDBC) (java.sql):</strong>  数据库连接类库。</p>
<ul>
<li><strong>DriverManager:</strong> 驱动管理器，用于加载数据库驱动。</li>
<li><strong>Connection:</strong> 数据库连接接口。</li>
<li><strong>Statement, PreparedStatement:</strong> SQL语句执行接口。</li>
<li><strong>ResultSet:</strong> 查询结果集接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDBC示例 (需要数据库驱动)</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 加载驱动</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>); <span class="comment">// MySQL驱动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取连接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;username&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;password&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建Statement</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 执行查询</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users&quot;</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 处理结果</span></span><br><span class="line">    <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">        System.out.println(resultSet.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 关闭连接</span></span><br><span class="line">    resultSet.close();</span><br><span class="line">    statement.close();</span><br><span class="line">    connection.close();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Java XML Processing (javax.xml.*):</strong>  XML处理类库。</p>
<ul>
<li><strong>DocumentBuilder, DocumentBuilderFactory:</strong> 用于解析XML文档。</li>
<li><strong>XPath:</strong> 用于查询XML文档。</li>
</ul>
<p>(XML处理较为复杂，此处仅作简单提及，不提供详细代码示例)</p>
</li>
<li><p><strong>Java Collections Framework (java.util.collections):</strong> 集合框架的工具类，提供排序、查找等算法。</p>
<ul>
<li><strong>Collections.sort():</strong> 对List进行排序。</li>
<li><strong>Collections.binarySearch():</strong> 在List中进行二分查找。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collections示例</span></span><br><span class="line">List&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">numbers.add(<span class="number">5</span>);</span><br><span class="line">numbers.add(<span class="number">2</span>);</span><br><span class="line">numbers.add(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(numbers); <span class="comment">// 排序</span></span><br><span class="line">System.out.println(numbers); <span class="comment">// 输出 [2, 5, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Collections.binarySearch(numbers, <span class="number">5</span>); <span class="comment">// 二分查找</span></span><br><span class="line">System.out.println(index); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>三、进阶知识：API设计原则与最佳实践</strong></p>
<ol>
<li><strong>单一职责原则 (SRP):</strong>  每个类或接口应该只有一个明确的职责。</li>
<li><strong>开闭原则 (OCP):</strong>  软件实体应该对扩展开放，对修改关闭。</li>
<li><strong>里氏替换原则 (LSP):</strong>  子类应该能够替换其父类，而不会导致程序出错。</li>
<li><strong>接口隔离原则 (ISP):</strong>  客户端不应该被迫依赖于它不需要的接口。</li>
<li><strong>依赖倒置原则 (DIP):</strong>  高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</li>
</ol>
<p><strong>API设计最佳实践：</strong></p>
<ul>
<li><strong>清晰的命名：</strong> 使用有意义的名称，避免歧义。</li>
<li><strong>简洁的接口：</strong> 接口应该尽可能简单，避免过度设计。</li>
<li><strong>良好的文档：</strong> 提供清晰、完整的文档，方便开发者使用。</li>
<li><strong>版本控制：</strong> 使用版本号管理API，方便维护和升级。</li>
<li><strong>异常处理：</strong> 合理处理异常，提供友好的错误信息。</li>
<li><strong>线程安全：</strong> 考虑多线程环境下的安全性。</li>
</ul>
<p><strong>四、实际案例：使用API构建简单应用</strong></p>
<p><strong>案例：构建一个简单的命令行计算器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Simple Calculator&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;Enter first number: &quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">num1</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter operator (+, -, *, /): &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">operator</span> <span class="operator">=</span> scanner.next();</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Enter second number: &quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">num2</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (operator) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = num1 - num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> (num2 == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Error: Division by zero!&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                result = num1 / num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Error: Invalid operator!&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li><strong>Scanner:</strong>  <code>java.util.Scanner</code> 用于从控制台读取用户输入。</li>
<li><strong>System.out.println&#x2F;print:</strong>  <code>java.lang.System</code> 用于向控制台输出信息。</li>
<li><strong>String:</strong>  <code>java.lang.String</code> 用于处理用户输入的运算符。</li>
<li><strong>double:</strong>  Java的基本数据类型，用于存储数字。</li>
</ul>
<p>这个简单的例子展示了如何使用Java API来构建一个简单的命令行应用程序。  通过学习和掌握更多的Java API，可以构建更复杂、功能更强大的应用程序。</p>
<h2 id="Java-GUI页面编程"><a href="#Java-GUI页面编程" class="headerlink" title="Java GUI页面编程"></a>Java GUI页面编程</h2><p>Java GUI页面编程涉及使用Java提供的图形用户界面（GUI）工具包来创建交互式的桌面应用程序。主要涉及AWT、Swing和JavaFX这三个技术栈，其中Swing和JavaFX是更常用的选择。</p>
<h3 id="基础原理：组件、容器和布局管理器"><a href="#基础原理：组件、容器和布局管理器" class="headerlink" title="基础原理：组件、容器和布局管理器"></a><strong>基础原理：组件、容器和布局管理器</strong></h3><p>GUI编程的核心在于组件（Component）、容器（Container）和布局管理器（Layout Manager）。</p>
<ul>
<li><p><strong>组件（Component）：</strong> GUI的基本构建块，例如按钮（Button）、标签（Label）、文本框（TextField）等。它们是用户可以直接交互的元素。</p>
</li>
<li><p><strong>容器（Container）：</strong> 用于容纳和组织组件的特殊组件。例如，窗口（JFrame）、面板（JPanel）等。容器可以嵌套，形成复杂的界面结构。</p>
</li>
<li><p><strong>布局管理器（Layout Manager）：</strong> 负责控制容器中组件的排列方式。不同的布局管理器提供不同的排列策略，例如流式布局（FlowLayout）、边界布局（BorderLayout）、网格布局（GridLayout）等。</p>
</li>
</ul>
<p><strong>示例代码（Swing）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleGUI</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleGUI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设置窗口标题</span></span><br><span class="line">        setTitle(<span class="string">&quot;Simple GUI Example&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置窗口大小</span></span><br><span class="line">        setSize(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置窗口关闭时的默认操作</span></span><br><span class="line">        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个面板</span></span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">panel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个标签</span></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">label</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个按钮</span></span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Click Me!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加事件监听器到按钮</span></span><br><span class="line">        button.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">                label.setText(<span class="string">&quot;Button Clicked!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将组件添加到面板</span></span><br><span class="line">        panel.add(label);</span><br><span class="line">        panel.add(button);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将面板添加到窗口的内容面板</span></span><br><span class="line">        add(panel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置窗口可见</span></span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimpleGUI</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码创建了一个简单的窗口，其中包含一个标签和一个按钮。点击按钮会改变标签的文本。</p>
<h3 id="进阶知识：事件处理、线程和数据绑定"><a href="#进阶知识：事件处理、线程和数据绑定" class="headerlink" title="进阶知识：事件处理、线程和数据绑定"></a><strong>进阶知识：事件处理、线程和数据绑定</strong></h3><ul>
<li><p><strong>事件处理：</strong> GUI程序的核心是响应用户的交互。事件处理机制允许程序监听用户的操作（例如点击按钮、输入文本等），并执行相应的代码。Java使用事件监听器（EventListener）接口来实现事件处理。</p>
</li>
<li><p><strong>线程：</strong> GUI程序通常需要执行耗时的操作（例如网络请求、文件读写等）。为了避免阻塞GUI线程，影响用户体验，应该将这些操作放在单独的线程中执行。SwingUtilities.invokeLater() 和 JavaFX的Platform.runLater() 用于在GUI线程中更新UI。</p>
</li>
<li><p><strong>数据绑定：</strong> 数据绑定是一种将GUI组件与数据模型关联起来的技术。当数据模型发生变化时，GUI组件会自动更新；反之，当用户在GUI组件中修改数据时，数据模型也会自动更新。JavaFX提供了内置的数据绑定机制。</p>
</li>
</ul>
<p><strong>示例代码（JavaFX）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javafx.application.Application;</span><br><span class="line"><span class="keyword">import</span> javafx.application.Platform;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Button;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Label;</span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.StackPane;</span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaFXExample</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> &#123;</span><br><span class="line">        <span class="type">Label</span> <span class="variable">label</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Hello, JavaFX!&quot;</span>);</span><br><span class="line">        <span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Click Me!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        button.setOnAction(event -&gt; &#123;</span><br><span class="line">            Platform.runLater(() -&gt; &#123;</span><br><span class="line">                label.setText(<span class="string">&quot;Button Clicked!&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">StackPane</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackPane</span>();</span><br><span class="line">        root.getChildren().addAll(label, button);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(root, <span class="number">300</span>, <span class="number">250</span>);</span><br><span class="line"></span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;JavaFX Example&quot;</span>);</span><br><span class="line">        primaryStage.setScene(scene);</span><br><span class="line">        primaryStage.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        launch(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个JavaFX示例与Swing示例类似，但使用了JavaFX的API。<code>Platform.runLater()</code>确保UI更新在JavaFX应用程序线程上执行。</p>
<h3 id="实际案例：开发一个简单的计算器"><a href="#实际案例：开发一个简单的计算器" class="headerlink" title="实际案例：开发一个简单的计算器"></a><strong>实际案例：开发一个简单的计算器</strong></h3><p>下面是一个使用Swing开发的简单计算器的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示计算结果的文本框</span></span><br><span class="line">    <span class="keyword">private</span> JTextField display;</span><br><span class="line">    <span class="comment">// 存放按钮的面板</span></span><br><span class="line">    <span class="keyword">private</span> JPanel buttonPanel;</span><br><span class="line">    <span class="comment">// 当前输入的数字字符串</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">currentInput</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 计算结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 上一次执行的运算符，默认为 &quot;=&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">lastOperation</span> <span class="operator">=</span> <span class="string">&quot;=&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Calculator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设置窗口标题</span></span><br><span class="line">        setTitle(<span class="string">&quot;Simple Calculator&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置窗口大小</span></span><br><span class="line">        setSize(<span class="number">300</span>, <span class="number">400</span>);</span><br><span class="line">        <span class="comment">// 设置关闭窗口时的默认操作（退出程序）</span></span><br><span class="line">        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="comment">// 设置布局管理器为 BorderLayout</span></span><br><span class="line">        setLayout(<span class="keyword">new</span> <span class="title class_">BorderLayout</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化显示文本框</span></span><br><span class="line">        display = <span class="keyword">new</span> <span class="title class_">JTextField</span>();</span><br><span class="line">        <span class="comment">// 设置文本框内容右对齐</span></span><br><span class="line">        display.setHorizontalAlignment(JTextField.RIGHT);</span><br><span class="line">        <span class="comment">// 设置文本框不可编辑</span></span><br><span class="line">        display.setEditable(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 将文本框添加到窗口的北部</span></span><br><span class="line">        add(display, BorderLayout.NORTH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化按钮面板</span></span><br><span class="line">        buttonPanel = <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">        <span class="comment">// 设置按钮面板的布局管理器为 GridLayout (4行4列)</span></span><br><span class="line">        buttonPanel.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">4</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义按钮上的文本标签</span></span><br><span class="line">        String[] buttonLabels = &#123;</span><br><span class="line">                <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>, <span class="string">&quot;/&quot;</span>,</span><br><span class="line">                <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;*&quot;</span>,</span><br><span class="line">                <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;-&quot;</span>,</span><br><span class="line">                <span class="string">&quot;0&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;=&quot;</span>, <span class="string">&quot;+&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环创建按钮并添加到面板</span></span><br><span class="line">        <span class="keyword">for</span> (String label : buttonLabels) &#123;</span><br><span class="line">            <span class="comment">// 创建按钮</span></span><br><span class="line">            <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(label);</span><br><span class="line">            <span class="comment">// 为按钮添加 ActionListener (当前类)</span></span><br><span class="line">            button.addActionListener(<span class="built_in">this</span>);</span><br><span class="line">            <span class="comment">// 将按钮添加到面板</span></span><br><span class="line">            buttonPanel.add(button);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将按钮面板添加到窗口的中心</span></span><br><span class="line">        add(buttonPanel, BorderLayout.CENTER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置窗口可见</span></span><br><span class="line">        setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ActionListener 接口的实现方法，用于处理按钮点击事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取触发事件的按钮上的文本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> e.getActionCommand();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果点击的是数字或小数点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;0123456789.&quot;</span>.contains(command)) &#123;</span><br><span class="line">            <span class="comment">// 将点击的数字或小数点添加到当前输入字符串</span></span><br><span class="line">            currentInput += command;</span><br><span class="line">            <span class="comment">// 更新显示文本框的内容</span></span><br><span class="line">            display.setText(currentInput);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果点击的是运算符</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;+-*/=&quot;</span>.contains(command)) &#123;</span><br><span class="line">            <span class="comment">// 进行计算</span></span><br><span class="line">            calculate(Double.parseDouble(currentInput));</span><br><span class="line">            <span class="comment">// 更新上一次执行的运算符</span></span><br><span class="line">            lastOperation = command;</span><br><span class="line">            <span class="comment">// 清空当前输入字符串</span></span><br><span class="line">            currentInput = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="comment">// 更新显示文本框的内容为计算结果</span></span><br><span class="line">            display.setText(String.valueOf(result));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calculate</span><span class="params">(<span class="type">double</span> number)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据上一次执行的运算符进行计算</span></span><br><span class="line">        <span class="keyword">switch</span> (lastOperation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result += number;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result -= number;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result *= number;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                <span class="comment">// 除法需要判断除数是否为0</span></span><br><span class="line">                <span class="keyword">if</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                    result /= number;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果除数为0，则显示错误信息</span></span><br><span class="line">                    display.setText(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">                    <span class="comment">// 重置计算结果</span></span><br><span class="line">                    result = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;=&quot;</span>:</span><br><span class="line">                <span class="comment">// 如果上一次执行的是 &quot;=&quot;, 则将当前数字赋值给计算结果</span></span><br><span class="line">                result = number;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建计算器对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个计算器示例展示了如何使用Swing组件、布局管理器和事件处理来创建一个简单的交互式应用程序。它接收用户的输入，执行基本的算术运算，并将结果显示在文本框中。</p>
<h3 id="事件的三种常见写法"><a href="#事件的三种常见写法" class="headerlink" title="事件的三种常见写法"></a>事件的三种常见写法</h3><p>事件，本质上是一种通知机制，用于在程序中传递状态变化或用户行为。常见的三种写法，分别对应着不同的编程范式和应用场景。</p>
<h4 id="1-回调函数-Callback-Functions"><a href="#1-回调函数-Callback-Functions" class="headerlink" title="1. 回调函数 (Callback Functions)"></a><strong>1. 回调函数 (Callback Functions)</strong></h4><ul>
<li><p><strong>基础原理:</strong>  回调函数是最基础的事件处理方式。它将一个函数（回调函数）作为参数传递给另一个函数。当特定事件发生时，被调用的函数会执行这个回调函数。</p>
</li>
<li><p><strong>进阶知识:</strong>  回调函数容易形成“回调地狱”（Callback Hell），即嵌套过深的回调函数，导致代码难以阅读和维护。  Promise 和 async&#x2F;await 解决了这个问题，但回调函数仍然是理解事件机制的基础。</p>
</li>
<li><p><strong>实际案例 (JavaScript):</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">downloadFile</span>(<span class="params">url, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`开始下载: <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">// 模拟下载过程</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fileData = <span class="string">`文件内容来自: <span class="subst">$&#123;url&#125;</span>`</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`下载完成: <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">    <span class="title function_">callback</span>(fileData); <span class="comment">// 下载完成后调用回调函数</span></span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processFile</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`开始处理文件: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">  <span class="comment">// 模拟处理文件</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`文件处理完成: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">downloadFile</span>(<span class="string">&quot;https://example.com/data.txt&quot;</span>, processFile);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>downloadFile</code> 函数接受一个 URL 和一个回调函数 <code>processFile</code>。  <code>downloadFile</code> 模拟下载文件，下载完成后，它会调用 <code>processFile</code> 函数，并将下载的数据作为参数传递给它。</p>
</li>
</ul>
<p><strong>2. 发布&#x2F;订阅模式 (Publish&#x2F;Subscribe Pattern)</strong></p>
<ul>
<li><p><strong>基础原理:</strong>  发布&#x2F;订阅模式是一种消息传递模式，其中发布者（Publisher）发布消息，订阅者（Subscriber）订阅感兴趣的消息。  发布者不需要知道订阅者是谁，订阅者也不知道发布者是谁。  消息通过一个中央消息代理（Message Broker）进行传递。</p>
</li>
<li><p><strong>进阶知识:</strong>  发布&#x2F;订阅模式实现了松耦合，允许组件独立地发布和订阅事件。  它常用于构建事件驱动的架构，例如消息队列、GUI 事件处理等。  常见的实现方式包括使用事件总线（Event Bus）或消息队列（Message Queue）。</p>
</li>
<li><p><strong>实际案例 (JavaScript - 简易事件总线):</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventBus</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="params">event, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">events</span>[event]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[event] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">push</span>(callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">publish</span>(<span class="params">event, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">events</span>[event]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">events</span>[event].<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="title function_">callback</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> <span class="title class_">EventBus</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅 &quot;user.created&quot; 事件</span></span><br><span class="line">eventBus.<span class="title function_">subscribe</span>(<span class="string">&quot;user.created&quot;</span>, <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`新用户创建: <span class="subst">$&#123;user.name&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">subscribe</span>(<span class="string">&quot;user.created&quot;</span>, <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`发送欢迎邮件给: <span class="subst">$&#123;user.email&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布 &quot;user.created&quot; 事件</span></span><br><span class="line">eventBus.<span class="title function_">publish</span>(<span class="string">&quot;user.created&quot;</span>, &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">email</span>: <span class="string">&quot;alice@example.com&quot;</span> &#125;);</span><br><span class="line">eventBus.<span class="title function_">publish</span>(<span class="string">&quot;user.created&quot;</span>, &#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>, <span class="attr">email</span>: <span class="string">&quot;bob@example.com&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>EventBus</code> 类充当消息代理。  <code>subscribe</code> 方法用于订阅事件，<code>publish</code> 方法用于发布事件。  当 “user.created” 事件被发布时，所有订阅该事件的回调函数都会被执行。</p>
</li>
</ul>
<p><strong>3. 观察者模式 (Observer Pattern)</strong></p>
<ul>
<li><p><strong>基础原理:</strong>  观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。  当主题对象的状态发生改变时，所有依赖它的观察者都会收到通知并自动更新。</p>
</li>
<li><p><strong>进阶知识:</strong>  观察者模式与发布&#x2F;订阅模式类似，但观察者模式通常是针对特定对象的，观察者直接与主题对象关联。  发布&#x2F;订阅模式则更加通用，发布者和订阅者之间通过消息代理进行解耦。  观察者模式常用于 GUI 框架中的事件处理，例如按钮点击事件。</p>
</li>
<li><p><strong>实际案例 (JavaScript):</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">subscribe</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">push</span>(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unsubscribe</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span> = <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">obs</span> =&gt;</span> obs !== observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setState</span>(<span class="params">newState</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = newState;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">notifyObservers</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notifyObservers</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">observers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">observer</span> =&gt;</span> observer.<span class="title function_">update</span>(<span class="variable language_">this</span>.<span class="property">state</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> 收到通知，状态更新为: <span class="subst">$&#123;state&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer1 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&quot;Observer 1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> observer2 = <span class="keyword">new</span> <span class="title class_">Observer</span>(<span class="string">&quot;Observer 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">subject.<span class="title function_">subscribe</span>(observer1);</span><br><span class="line">subject.<span class="title function_">subscribe</span>(observer2);</span><br><span class="line"></span><br><span class="line">subject.<span class="title function_">setState</span>(<span class="number">1</span>);</span><br><span class="line">subject.<span class="title function_">setState</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">subject.<span class="title function_">unsubscribe</span>(observer1);</span><br><span class="line"></span><br><span class="line">subject.<span class="title function_">setState</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>Subject</code> 类是主题对象，<code>Observer</code> 类是观察者对象。  <code>Subject</code> 维护一个观察者列表，并在状态改变时通知所有观察者。  <code>Observer</code> 的 <code>update</code> 方法用于响应状态变化。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eleteItem.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">selectedRow</span> <span class="operator">=</span> employeeTable.getSelectedRow();  </span><br><span class="line">        <span class="keyword">if</span> (selectedRow != -<span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="comment">// 实现删除逻辑  </span></span><br><span class="line">            tableModel.removeRow(selectedRow);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：二分法</title>
    <url>/2022/10/06/%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><h2 id="二分法易错点"><a href="#二分法易错点" class="headerlink" title="二分法易错点"></a>二分法易错点</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h3><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><ul>
<li>居间的边界问题</li>
</ul>
<h2 id="循环不变量"><a href="#循环不变量" class="headerlink" title="循环不变量"></a>循环不变量</h2><p>$$<br>[left,right]\<br>[left,right)\<br>(left,right]\<br>$$</p>
<p>二分查找基本方法：可以看到就是在二分查找中，用到了双指针的方法。这里的指针就是左指针，右指针就是这样子的一个左右指针。这两个指针它们对应数组的一个索引之和的一半就是我们一个中间指针的位置。</p>
<p>我们在进行循环的时候循环调节，就是左指针的索引，小于等于右指针的索引。现在就是比较目标值和中间值的大小，如果目标值比中间值小，它的位置更新到中间位置的左边，一位就是mid-1，同理，如果中间指针所指的值比目标值小，我们就需要将左指针它的位置更新到中间指针的右一位，mid+1。</p>
<p>就这样一直循环，当这个中间值和目标值相同的时候，就可以返回这个，中间指针所指的那个数的值，但如果嗯左右值呢，指向相同的时候，还是没找到它的值，就返回一个-1。</p>
<h2 id="左闭右闭写法"><a href="#左闭右闭写法" class="headerlink" title="左闭右闭写法"></a>左闭右闭写法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int left=0,right=nums.size()-1;</span><br><span class="line">    while(left&lt;=right)</span><br><span class="line">    //合法区间</span><br><span class="line">    &#123;</span><br><span class="line">    int mid=(left+right)/2;</span><br><span class="line">    //考虑两数相加发生数组越界的情况</span><br><span class="line">    if(nums[mid]&gt;target)&#123;right=mid-1;&#125;</span><br><span class="line">    else if(nums[mid]&lt;target)&#123;left=mid+1;&#125;</span><br><span class="line">    else return mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">    //找不到可以跳出循环，return-1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="左闭右开写法"><a href="#左闭右开写法" class="headerlink" title="左闭右开写法"></a>左闭右开写法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int left=0,right=nums.size()-1;</span><br><span class="line">    while(left&lt;right)</span><br><span class="line">    //如果相等了就不是合法区间</span><br><span class="line">    &#123;</span><br><span class="line">    int mid=(left+right)/2;</span><br><span class="line">    //考虑两数相加发生数组越界的情况</span><br><span class="line">    if(nums[mid]&gt;target)&#123;right=mid-1;&#125;</span><br><span class="line">    //搜索的时候，条件已经否定了mid的值，调整l，r位置的时候，要剔除数据</span><br><span class="line">    else if(nums[mid]&lt;target)&#123;left=mid+1;&#125;</span><br><span class="line">    else return mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">    //找不到可以跳出循环，return-1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">    int left=0,right=nums.size()-1;</span><br><span class="line">    while(left&lt;=right)</span><br><span class="line">    //合法区间,</span><br><span class="line">    &#123;</span><br><span class="line">    int mid=(left+right)/2;</span><br><span class="line">    //考虑两数相加发生数组越界的情况</span><br><span class="line">    if(nums[mid]&gt;target)&#123;right=mid-1;&#125;</span><br><span class="line">    else if(nums[mid]&lt;target)&#123;left=mid+1;&#125;</span><br><span class="line">    else return mid;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">    //找不到可以跳出循环，return-1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：动态规划</title>
    <url>/2022/10/24/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划（Dynamic-Programing）"><a href="#动态规划（Dynamic-Programing）" class="headerlink" title="动态规划（Dynamic Programing）"></a>动态规划（Dynamic Programing）</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems.</p>
<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">斐波那契数列可以看作一个简易的DP问题</span><br><span class="line">F(n)=F(n-1)+F(n-2);(n&gt;=3)</span><br><span class="line">F(10)=F(9)+F(8);</span><br><span class="line">F(9)=F(8)+F(7);</span><br><span class="line">……</span><br><span class="line">F(3)=F(2)+F(1);</span><br></pre></td></tr></table></figure>

<p>如果是使用递归思路，那么程序需要将每一次需要的元素都重新算一次，会导致重复的运算，如果是在DP算法里面，每一次算过的数都用一个数组或者哈希表存储起来，之后就可以复用了，这样能减少运算量。</p>
<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><h4 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h4><p>F(n-1)和F(n-2)称为F(n)的最优子结构</p>
<h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><p>F(n)&#x3D;F(n-1)+F(n-2)就称为状态转移方程</p>
<h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h4><p>F(1) &#x3D; 1, F(2) &#x3D; 2 就是边界啦</p>
<h4 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h4><p>比如F(10)&#x3D; F(9)+F(8),F(9) &#x3D; F(8) + F(7) ,f(8)就是重叠子问题</p>
<h2 id="适用例题"><a href="#适用例题" class="headerlink" title="适用例题"></a>适用例题</h2><blockquote>
<p>如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划。</p>
</blockquote>
<p>比如一些求最值的场景，如<strong>最长递增子序列、最小编辑距离、背包问题、凑零钱问题</strong>等等，都是动态规划的经典应用场景。</p>
<p>动态规划的核心思想就是<strong>拆分子问题，记住过往，减少重复计算。</strong> 并且动态规划一般都是自底向上的，因此到这里，基于<strong>青蛙跳阶</strong>问题，我总结了一下我做动态规划的思路：</p>
<h4 id="穷举分析"><a href="#穷举分析" class="headerlink" title="穷举分析"></a>穷举分析</h4><h4 id="确定边界"><a href="#确定边界" class="headerlink" title="确定边界"></a>确定边界</h4><h4 id="找出规律，确定最优子结构"><a href="#找出规律，确定最优子结构" class="headerlink" title="找出规律，确定最优子结构"></a>找出规律，确定最优子结构</h4><h4 id="写出状态转移方程"><a href="#写出状态转移方程" class="headerlink" title="写出状态转移方程"></a>写出状态转移方程</h4><h4 id="leetcode案例分析"><a href="#leetcode案例分析" class="headerlink" title="leetcode案例分析"></a>leetcode案例分析</h4><blockquote>
<p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>

<ol>
<li><p>穷举分析</p>
<p>因为动态规划，核心思想包括<strong>拆分子问题，记住过往，减少重复计算。</strong> 所以我们在思考原问题：<strong>数组num[i]的最长递增子序列长度时</strong>，可以思考下<strong>相关子问题</strong>，比如原问题是否跟<strong>子问题</strong>num[i-1]的最长递增子序列长度有关呢？</p>
</li>
<li><p>在穷举分析的时候，可以将元素写成两个数组的形式，这样便于找寻规律。</p>
</li>
<li><p>现在让我们分析一下</p>
<table>
<thead>
<tr>
<th>nums的元素数量</th>
<th>最大子序列长度</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>{10} 1</td>
</tr>
<tr>
<td>2</td>
<td>{10}||{9} 1</td>
</tr>
<tr>
<td>3</td>
<td>{10}||{9}||{2} 1</td>
</tr>
<tr>
<td>4</td>
<td>{2，5} 2</td>
</tr>
<tr>
<td>5</td>
<td>{2，3}||{2，5} 2</td>
</tr>
<tr>
<td>6</td>
<td>{2，3，7}||{2，5，7} 3</td>
</tr>
<tr>
<td>7</td>
<td>{2，3，7，101}||{2，5，7，101} 4</td>
</tr>
<tr>
<td>8</td>
<td>{2，3，7，18}||{2，5，7，18} 4</td>
</tr>
</tbody></table>
<p>可以得到，最大子序列长度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dp[i]=max&#123;Dp[j]&#125;+1;</span><br><span class="line">j&gt;=0&amp;&amp;j&lt;=i-1;</span><br><span class="line">nums[i]&gt;nums[j];</span><br></pre></td></tr></table></figure>

<p>符合这样的状态转移方程</p>
<p>最优子结构：max{Dp[j]}+1.</p>
<p>状态转移方程：Dp[i]&#x3D;max{Dp[j]}+1.</p>
<p>边界：Dp[0]&#x3D;1.</p>
<p>出现了重叠子问题.</p>
<p>所以给出本题的题解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">    if(nums.size()==0)</span><br><span class="line">    &#123;return 0;&#125;</span><br><span class="line">    //保证程序的健壮性</span><br><span class="line">    int Dp[nums.size()];</span><br><span class="line">    Dp[0]=1;</span><br><span class="line">    //声明一个数组，用来存储目标值</span><br><span class="line">    for(int i=0;i&lt;nums.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">    for(int j=0;j&lt;i-1;j++)</span><br><span class="line">    &#123;</span><br><span class="line">    if(nums[i]&gt;nums[j])</span><br><span class="line">    &#123;</span><br><span class="line">    Dp[i]=max(Dp[j])+1;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;Dp[i]=max(Dp[j]);&#125;</span><br><span class="line">    //分类：满足飞升条件的+1，不满足的占位</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //利用双重循环遍历所列举的情况，将最终值算出来</span><br><span class="line">    return Dp[nums.size()-1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="几种不同的解决思路"><a href="#几种不同的解决思路" class="headerlink" title="几种不同的解决思路"></a>几种不同的解决思路</h1><p>下面是过河卒的集中不同思路。</p>
<h1 id="数组下标平移变换的技巧"><a href="#数组下标平移变换的技巧" class="headerlink" title="数组下标平移变换的技巧"></a>数组下标平移变换的技巧</h1>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：反转链表</title>
    <url>/2022/11/01/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>通常我们会在大厂里的第一道比较简单的面试题里面见到反转链表这样的题目，这是对链表这一数据结构的一个基本操作，这是需要我们找掌握的。</p>
<p>众所周知列表中一个基础结构叫做节点，节点之中有数据域和指针域这两个部分。一个链表由一个头结点，决定总体地址信息，可以通过头结点遍历这个链表中所有的元素，而我们想要把链表反转就是让首尾的数据域进行交换，这个过程中，指针域名是不变的。</p>
<h2 id="题目206-反转链表"><a href="#题目206-反转链表" class="headerlink" title="题目206. 反转链表"></a>题目<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>​	首先我们要明确一个事实，就是链表的基础结构是一个线性表，上面包含对应的节点，而节点之间，在单链表之中，每个节点有一个数据域名，一个指针域。指针是指向下一个节点的，所以说就是在单链表的单个结点上的指针是单向的，最后一个节点的指针指向一个空指针。</p>
<p>​	我们用双指针的方法解决问题反转列表的问题的话，其实很简单。我们只需要想办法把这个节点之间的指针的指向反转，就行了，数据是不用变的，只需要变指针。要实现这样的操作就需要从最开始着手，最开始是给了一个currPtr指针和prevPtr指针，我们给currPtr赋予head指针的地址，prevPtr指针的话是一个在空指针位置上的。</p>
<p>​	实现反转指针方向操作的话，我们需要先建立一个临时指针temPtr，它的主要功能是占位，我们是需要用那个新的指针去占currPtr指针下一个指针的位置，因为它肯定是往前走的，需要遍历完整个链表。那我们现在可以看到就是currPtr指针的前面结点，已经用刚才生成的指针标记了，下一个的位置然后需要让prevPtr指针向前走，占据currPtr指针刚才的位置。</p>
<p>​	这样操作完后，最后currPtr指针指向空指针时，就是这个链表的指针全变了一次方向，指针的指向也变成了currPtr指针指向prevPtr指针，最后我们需要遍历整个链表，所以需要给出现在新的这个链表的一个头结点，很明显新的头结点就是prevPtr指针，因为最后currPtr指针指向的是一个空指针，它不在结点内，不能作为一个链表的地址信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* currPtr=head;</span><br><span class="line">        ListNode* prevPtr=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(currPtr!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode*temPtr=currPtr-&gt;next;</span><br><span class="line">            currPtr-&gt;next=prevPtr;</span><br><span class="line">            prevPtr=currPtr;</span><br><span class="line">            currPtr=temPtr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prevPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://p.sda1.dev/18/8e3e86cce8f5a98723d7e12d62c4dc84/7c7c28743b79030cd76517d3dd0deafc.png"></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：哈希表</title>
    <url>/2024/08/06/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<p>哈希表的具体内容参照以下内容</p>
<h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h3><p>给定两个字符串 <code>*s*</code> 和 <code>*t*</code> ，编写一个函数来判断 <code>*t*</code> 是否是 <code>*s*</code> 的字母异位词。</p>
<p><strong>注意：</strong>若 <code>*s*</code> 和 <code>*t*</code> 中每个字符出现的次数都相同，则称 <code>*s*</code> 和 <code>*t*</code> 互为字母异位词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li>
<li><code>s</code> 和 <code>t</code> 仅包含小写字母</li>
</ul>
<p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<p>数据结构：哈希表的语法和例题</p>
<p>简易的哈希表，这里建立一个字母表的统计数组，分别扫描两个字符串，s串中出现某个字母，对应统计数组的计数就增加一个，t串和这个相反，最后遍历整个统计数组，如果两个字符串符合预期，则最后统计数组中的每一个数都是零。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            record[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            record[t[i]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(record[i]!=<span class="number">0</span>)&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h3><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的</em> 交集 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 1000</code></li>
</ul>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result_set;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">nums_set</span><span class="params">(nums1.begin(),nums1.end())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_set.<span class="built_in">find</span>(num)!=nums_set.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                result_set.<span class="built_in">insert</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result_set.<span class="built_in">begin</span>(), result_set.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h3><p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>提示</p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>
<h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map1;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map1.<span class="built_in">count</span>(target - nums[i]))</span><br><span class="line">                <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;i, map1[target - nums[i]]&#125;;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map1[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="排序加双指针"><a href="#排序加双指针" class="headerlink" title="排序加双指针"></a>排序加双指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        temp=nums;</span><br><span class="line">        <span class="type">int</span> n=temp.<span class="built_in">size</span>();</span><br><span class="line">       <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">       <span class="type">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;j)&#123;  </span><br><span class="line">           <span class="keyword">if</span>(temp[i]+temp[j]&gt;target)j--;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(temp[i]+temp[j]&lt;target)i++;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">break</span>; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(i&lt;n&amp;&amp;nums[k]==temp[i])&#123;</span><br><span class="line">              ans.<span class="built_in">push_back</span>(k);</span><br><span class="line">              i=n;</span><br><span class="line">          &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(j&lt;n&amp;&amp;nums[k]==temp[j])&#123;</span><br><span class="line">              ans.<span class="built_in">push_back</span>(k);</span><br><span class="line">              j=n;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(i==n&amp;&amp;j==n)<span class="keyword">return</span> ans;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a></h3><p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p> <strong>提示：</strong></p>
<ul>
<li><code>n == nums1.length</code></li>
<li><code>n == nums2.length</code></li>
<li><code>n == nums3.length</code></li>
<li><code>n == nums4.length</code></li>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>-228 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 228</code></li>
</ul>
<h4 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h4><p>使用哈希表进行解答时的关键，首先四个数的和是0，这个式子具有四个自由度，而要解决这个问题，就需要四次方的时间复杂度，这个过不了时间限制，因此需要对其进行降次处理，我们直到，计算机里是可以出现多个变量的，我们不像解决数学问题一样，要解锁为单自由度才能解决问题，一次维度的遍历就可以消除一个变量。</p>
<p>这里由这个四数之和的问题，发现时间复杂度的变化有以下规律，高次向低次数转化的方式可以是，将次方转化为加法，在这边，我们嫌弃四个变量太多了，可以选择冻结两个，就是将两个变量的和视为常数，这样就可以实现降低次数的目的。<br>$$<br>a+b+c+d&#x3D;0;\\<br>c+d&#x3D;k(constant);<br>$$<br>这里我们只需要用一次二重循环就可以把c+d的组合找出来，回到题目本身可以知道，我们最后需要得出的只有这样的四个数字到底有多少组，不难知道，后续在循环过程中，对于单次的操作，每次操作对于次数的贡献都需要乘以a+b的结果的数量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B, vector&lt;<span class="type">int</span>&gt;&amp; C, vector&lt;<span class="type">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; umap; <span class="comment">//key:a+b的数值，value:a+b数值出现的次数</span></span><br><span class="line">        <span class="comment">// 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b : B) &#123;</span><br><span class="line">                umap[a + b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计a+b+c+d = 0 出现的次数</span></span><br><span class="line">        <span class="comment">// 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : C) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d : D) &#123;</span><br><span class="line">                <span class="keyword">if</span> (umap.<span class="built_in">find</span>(<span class="number">0</span> - (c + d)) != umap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    count += umap[<span class="number">0</span> - (c + d)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里用到了范围内循环的语法知识，这里的循环遍历通常用于一个集合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a:sum)</span><br></pre></td></tr></table></figure>

<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="哈希法"><a href="#哈希法" class="headerlink" title="哈希法"></a>哈希法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h3><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<h4 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝处理</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            	<span class="keyword">break</span>; <span class="comment">// 这里使用break，统一通过最后的return返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对nums[k]去重</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="comment">// 2级剪枝处理</span></span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对nums[i]去重</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：双指针</title>
    <url>/2024/08/15/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>数组其实是一个连续的内存空间，删除元素的基本原理是</p>
<ul>
<li>空间不变</li>
<li>计数方法会进行包装</li>
</ul>
<h3 id="erase函数"><a href="#erase函数" class="headerlink" title="erase函数"></a>erase函数</h3><p>在vector这个模板里面，就算使用了erase函数，原本申请的数组所占有的内存也是不发生变化的。</p>
<table>
<thead>
<tr>
<th>a[0]</th>
<th>a[1]</th>
<th>a[2]</th>
<th>a[3]</th>
<th>a[4]</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>5</td>
</tr>
</tbody></table>
<blockquote>
<p>删除4元素的原理，就是删除将下一位的元素那进来补位，然后通过某些手段，屏蔽接下来的元素，这样就可以形成一个新的数组</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void erase(&amp;a,int b)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]==b)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[j-1]=a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">复杂度O(i+(n-i))=O(n)</span><br></pre></td></tr></table></figure>

<h3 id="库函数的使用"><a href="#库函数的使用" class="headerlink" title="库函数的使用"></a>库函数的使用</h3><p>过于简单的题目（能用库函数一次解决的），就不要用库函数</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><blockquote>
<p>其实就是牺牲空间，获取时间，原理是这样的，我们采用额外的空间，比如再声明一个数组，这样一个数组有了之后，我们就可以采用快慢指针的方法，快指针的作用很简单，就是用于遍历数组中的所有元素，而慢指针的作用在于标度待删除元素的存在，确认数组在最后拥有的数组大小。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete element(&amp;a,int b)</span><br><span class="line">&#123;</span><br><span class="line">int slow=0;</span><br><span class="line">vector&lt;int&gt;a_1;</span><br><span class="line">for(int fast=0;fast&lt;a.size();fast++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[fast]!=b) slow++;</span><br><span class="line">&#125;</span><br><span class="line">return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么是快慢指针"><a href="#什么是快慢指针" class="headerlink" title="什么是快慢指针"></a>什么是快慢指针</h4><p>快慢指针是双指针算法中的一种。不同于左右对撞指针，快慢指针中的两个指针是从同一侧但以不同的策略移动的指针。因此，两个指针中会有一个移动较快的快指针（fast）和一个较慢的慢指针（slow）。当快指针移动到数组的顶端时，停止遍历或进行新一轮遍历。</p>
<h4 id="为什么要用快慢指针"><a href="#为什么要用快慢指针" class="headerlink" title="为什么要用快慢指针"></a>为什么要用快慢指针</h4><p>使用双指针最实在的好处在于，我们的快指针相当于一个探路侠，它每走一步就会给予慢指针一个信息，让慢指针完成它的一部分工作，这样尽量让两个指针分工操作。</p>
<p>快指针的工作在前面进行，而快指针完成工作之后，对于它本身信息的传递，其实是不消耗空间，也不消耗时间的。我们可以利用信息的充分化利用，使得两个指针能干更多有意义的事情。</p>
<h4 id="快慢指针是怎么用的"><a href="#快慢指针是怎么用的" class="headerlink" title="快慢指针是怎么用的"></a>快慢指针是怎么用的</h4><ul>
<li>链表：在链表中，链表往往是单向链表，这个时候使用快慢指针，让它们朝着同一个方向进行迭代。</li>
<li>数组：数组利用的是索引的只是，在return值里面使用索引，便可以返回对应长度数组的值。</li>
</ul>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p>
<p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p>
<ul>
<li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li>
<li>返回 <code>k</code>。</li>
</ul>
<p><strong>用户评测：</strong></p>
<p>评测机将使用以下代码测试您的解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int val = ...; // 要移除的值</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的预期答案。</span><br><span class="line">                            // 它以不等于 val 的值排序。</span><br><span class="line"></span><br><span class="line">int k = removeElement(nums, val); // 调用你的实现</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">sort(nums, 0, k); // 排序 nums 的前 k 个元素</span><br><span class="line">for (int i = 0; i &lt; actualLength; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果所有的断言都通过，你的解决方案将会 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2,_,_]</span><br><span class="line">解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。</span><br><span class="line">注意这五个元素可以任意顺序返回。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<h3 id="题解（双指针）"><a href="#题解（双指针）" class="headerlink" title="题解（双指针）"></a>题解（双指针）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">0</span>; fast &lt; nums.<span class="built_in">size</span>(); fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val)</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以联想为两排数组，快指针的那排数组具有元素，当快指针找到不是val的值的时候，就把这个值丢给慢指针，反之则不丢，最后慢指针在的那个数组中，去除了所有的目标元素。</p>
<p><img src="https://p.sda1.dev/18/496fb1149023399a4fb0163b1520cb4b/B7EC9CA94D6DF2BEB4E92654E268692E.png"></p>
<h4 id="硬解"><a href="#硬解" class="headerlink" title="硬解"></a>硬解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 相向双指针⽅法，基于元素顺序可以改变的题⽬描述改变了元素相对位置，确保了移动最少元素</span></span><br><span class="line"><span class="comment">* 时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">* 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> leftIndex = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> rightIndex = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (leftIndex &lt;= rightIndex) &#123;</span><br><span class="line"><span class="comment">// 找左边等于val的元素</span></span><br><span class="line"><span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[leftIndex] != val)&#123;</span><br><span class="line">++leftIndex;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 找右边不等于val的元素</span></span><br><span class="line"><span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[rightIndex] == val) &#123;</span><br><span class="line">-- rightIndex;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 将右边不等于val的元素覆盖左边等于val的元素</span></span><br><span class="line"><span class="keyword">if</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">nums[leftIndex++] = nums[rightIndex--];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="keyword">return</span> leftIndex; <span class="comment">// leftIndex⼀定指向了最终数组末尾的下⼀个元素</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p>
<p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p>
<ul>
<li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li>
<li>返回 <code>k</code> 。</li>
</ul>
<p><strong>判题标准:</strong></p>
<p>系统会用下面的代码来测试你的题解:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2,_]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li>
</ul>
<p>​	我们来分析删除元素这个算法的原理，首先我们给定的一个数组它是严格递增的，在这里我们需要把重复的元素都删掉，然后返回整个数组的长度，可以看到我们这边是使用了一个快慢指针的方法，一个慢指针，一个快指针。</p>
<p>​	这里基本的思路是，如果说就是快指针和慢指针所指的两个数它相同的话。那么就只有快指针向前走一步，慢指针不动。在这里我们可以举一个例子，假如说嗯，这时候有三个相同的元素卖指针已经指向了第1个元素，而会计证指向的是第2个元素，这时候进行一步操作。因为这两个指针指向的元素的值是相同的，所以说慢指针不动，然后快指针向前走一步。</p>
<p>​	接下来继续操作，这个时候慢指针指向了第1个元素，然后快指针指向了第3个元素。因为这个时候会计证和慢指针的值还是相同的，所以说慢指针不动，快指针继续前进。这个时候快指针已经指向了和慢指针不同的元素。这个时候循环继续，因为快指针和慢指针它指向的元素已经不同了，所以说慢指针和快指针都向前走一步。而我们的操作中，当慢指针和快指针它们的值不同的时候，我们会将快指针的值赋给慢指针。</p>
<p>​	所以说慢指针，它最后会走的步数是。数组中不同元素的个数，而慢指针它本身的一个值是索引，所以说我们在计算数组长度的时候需要返回就是慢指针它的值，加上一个1。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fast = <span class="number">1</span>; fast &lt; nums.<span class="built_in">size</span>(); fast = fast + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] != nums[fast])</span><br><span class="line">                nums[++slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://p.sda1.dev/18/0310a04d7db7eb8d955b8c89eca22e95/0DEE598ED87C4D5522F12F9FD0F44B2C.png"></p>
<ul>
<li><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s[i]</code> 都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li>
</ul>
<h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[l],s[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="双指针底层"><a href="#双指针底层" class="headerlink" title="双指针底层"></a>双指针底层</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=s[l];</span><br><span class="line">            s[l]=s[r];</span><br><span class="line">            s[r]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="LCR-122-路径加密"><a href="#LCR-122-路径加密" class="headerlink" title="LCR 122. 路径加密"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">LCR 122. 路径加密</a></h3><p>假定一段路径记作字符串 <code>path</code>，其中以 “<code>.</code>“ 作为分隔符。现需将路径加密，加密方法为将 <code>path</code> 中的分隔符替换为空格 “<code> </code>“，请返回加密后的字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：path = &quot;a.aef.qerf.bb&quot;</span><br><span class="line"></span><br><span class="line">输出：&quot;a aef qerf bb&quot;</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt;= path.length &lt;= 10000</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">pathEncryption</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fast=<span class="number">0</span>,slow=<span class="number">0</span>;fast&lt;path.<span class="built_in">size</span>();fast++,slow++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(path[fast]==<span class="string">&#x27;.&#x27;</span>) path[slow]=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原地修改</p>
<h3 id="剑指Offer-05-替换空格"><a href="#剑指Offer-05-替换空格" class="headerlink" title="剑指Offer 05.替换空格"></a>剑指Offer 05.替换空格</h3><p>请实现⼀个函数，把字符串 s 中的每个空格替换成”%20”。 </p>
<p>示例 1： </p>
<p>输⼊：s &#x3D; “We are happy.” </p>
<p>输出：”We**%20<strong>are</strong>%20**happy.” </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计空格的个数</span></span><br><span class="line"><span class="type">int</span> sOldSize = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 扩充字符串s的⼤⼩，也就是每个空格替换成&quot;%20&quot;之后的⼤⼩</span></span><br><span class="line">s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> sNewSize = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 从后先前将空格替换为&quot;%20&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = sNewSize - <span class="number">1</span>, j = sOldSize - <span class="number">1</span>; j &lt; i; i--, j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">s[i] = s[j];</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">s[i - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">s[i - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">i -= <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="拓展：字符串和数组的区别"><a href="#拓展：字符串和数组的区别" class="headerlink" title="拓展：字符串和数组的区别"></a>拓展：字符串和数组的区别</h3><p>C&#x2F;C++中的字符串以’\0’作为结束的标志</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">5</span>] = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; a[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++中，string类中会给我们提供size接口，这可以用来判断string类字符串是否结束，可以避免’\0’的使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string a = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vector<char>和vector<string>的区别是string类中重载了一些运算符，在处理字符串的时候会显得更加方便。</string></char></p>
<h2 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h2><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>
<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li>
<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>
</ul>
<p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p>
<h4 id="自己的思路"><a href="#自己的思路" class="headerlink" title="自己的思路"></a>自己的思路</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; s1;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        a.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//左边隔板的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;a.<span class="built_in">push_back</span>(i);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录中间隔板的位置</span></span><br><span class="line">        a.<span class="built_in">push_back</span>(s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">//右边界隔板的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!a.<span class="built_in">size</span>()) <span class="keyword">return</span> s;</span><br><span class="line">            <span class="comment">//单个单词直接返回</span></span><br><span class="line">            s1.<span class="built_in">push_back</span>(s.<span class="built_in">begin</span>()+a[i]+<span class="number">1</span>,s.<span class="built_in">begin</span>()+a[i+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//左隔板前移动一位，右隔板后移一位，切出一个单词</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s1.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;r;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s1[l],s1[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        string s2=s1[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//左右指针将单词反转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s1.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s2+=<span class="string">&#x27; &#x27;</span>+s1[i];</span><br><span class="line">        &#125;<span class="comment">//利用占头部的方式消除前置零</span></span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123; <span class="comment">//翻转，区间写法：左闭又闭 []</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;<span class="comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;   <span class="comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//遇到非空格就处理，即删除所有空格。</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//补上该单词，遇到空格说明单词结束。</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow); <span class="comment">//slow的大小即为去除多余空格后的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s); <span class="comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i - <span class="number">1</span>); <span class="comment">//翻转，注意是左闭右闭 []的翻转。</span></span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">//更新下一个单词的开始下标start</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Split库-分隔单词"><a href="#Split库-分隔单词" class="headerlink" title="Split库+分隔单词"></a>Split库+分隔单词</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">istringstream <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">        string str;</span><br><span class="line">        stack&lt;string&gt; zhan;</span><br><span class="line">        <span class="keyword">while</span>(is&gt;&gt;str)&#123;</span><br><span class="line">            zhan.<span class="built_in">push</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用输入流，将单词分别输入</span></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!zhan.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res += zhan.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(zhan.<span class="built_in">size</span>() != <span class="number">1</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            zhan.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//利用栈原理，逆向接受单词空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="栈原理"><a href="#栈原理" class="headerlink" title="栈原理"></a>栈原理</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">// self solution! yeah!!</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack &lt;string&gt; stk;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;<span class="comment">//先遍历字符串，提前单词，word入栈</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                word += s[i];</span><br><span class="line">                <span class="keyword">if</span> (i ==  n<span class="number">-1</span> || s[i+<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//关键判断条件：什么时候入栈，当字母后有空格或已是最后一个则判断为word，入栈</span></span><br><span class="line">                    stk.<span class="built_in">push</span>(word);</span><br><span class="line">                    word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>())&#123;<span class="comment">//释放栈中元素，加入空格组成反转后结果</span></span><br><span class="line">            ans += stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>())  ans += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<p>通常我们会在大厂里的第一道比较简单的面试题里面，见到反转链表这样的题目，这是对单链表数据结构的基本操作，是需要掌握的知识点。</p>
<p>众所周知，链表中一个基础结构叫做节点，节点之中有<strong>数据域和指针域</strong>两个部分，一个链表由<strong>头节点决定链表整体的地址信息</strong>，头接点可以遍历整个链表，而要把链表反转，就是让每个节点的<strong>指针域进行反向操作</strong>，这是比较高级的做法，下面从最开始接触到反转链表的问题的想法。</p>
<p>最容易想到的是，利用双指针的方法，进一步说明就是利用左右指针的算法，从链表两侧往中间遍历。对于整个链表，基本操作方式就是，左指针从链表的左侧一直往右侧移动，右测的指针往左测移动，当左右指针都能移动一步过后，我们把这两个指针所在的节点的数据域进行交换。但是，这里交换数据域出现问题，我们不能直接像数组一样，利用索引就调出某个元素的值，这边我们要调用单列表的某个元素是，只能从头节点开始遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;target;i++)</span><br><span class="line">&#123;</span><br><span class="line">    currPtr=currPtr-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果像这样去调用每个对象的数据域，会出现currPtr的指向一直在变化，我们要调用两个镜像的节点的数据域需要考虑预设中间节点，但是我们没有回退的指针运算，不管如何，都得从头节点出发。如果是能够从中间开始，这里就需要考虑元素的奇偶性，必然会导致“数数”的过程，增加运算的步骤，出现这样的情况。</p>
<blockquote>
<p>注意：如果出现奇偶的情况，最先考虑二者最后的执行情况是否能一致。</p>
</blockquote>
<p>很显然，反转链表是一道简单题，如果是选择数据域进行操作，可以计算一下操作的自由度：这里存在链表给予的空间自由度，还有链表本身的一维遍历自由度.</p>
<p>单链表有一个特点:每一个节点之间以一个next指针连接,要遍历整个链表只需找头接点,头接点规定为链表的末尾节点,接着将所有的指针域反转,就可以实现链表反转的目标.</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
<th>空</th>
</tr>
</thead>
<tbody><tr>
<td>head</td>
<td>head-&gt;next</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td>nullptr</td>
</tr>
<tr>
<td>currPtr</td>
<td>currPtr-&gt;next</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>prevPtr</td>
</tr>
<tr>
<td></td>
<td>temPtr</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://pic.leetcode-cn.com/1631933586-mEtOBg-008eGmZEly1gnrf1oboupg30gy0c44qp.gif" alt="img"></p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
<th>空</th>
</tr>
</thead>
<tbody><tr>
<td>head</td>
<td>head-&gt;next</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td>nullptr</td>
</tr>
<tr>
<td>currPtr</td>
<td>currPtr-&gt;next</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>prevPtr</td>
</tr>
<tr>
<td></td>
<td>temPtr</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>存c下一位,转向切换</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* currPtr=head;</span><br><span class="line">        ListNode* prevPtr=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(currPtr!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode*temPtr=currPtr-&gt;next;</span><br><span class="line">            <span class="comment">//①</span></span><br><span class="line">            currPtr-&gt;next=prevPtr;</span><br><span class="line">            <span class="comment">//其实是调转方向的指令②</span></span><br><span class="line">            prevPtr=currPtr;</span><br><span class="line">            <span class="comment">//③</span></span><br><span class="line">            currPtr=temPtr;</span><br><span class="line">            <span class="comment">//④</span></span><br><span class="line">            <span class="comment">//①④是完成操作后,使c前进一位</span></span><br><span class="line">            <span class="comment">//③是完成调转方向后,使p前进一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prevPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>链表的操作可以微元化单个步骤的重复.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(currPtr!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode*temPtr=currPtr-&gt;next;</span><br><span class="line">            <span class="comment">//①</span></span><br><span class="line">            currPtr-&gt;next=prevPtr;</span><br><span class="line">            <span class="comment">//其实是调转方向的指令②</span></span><br><span class="line">            prevPtr=currPtr;</span><br><span class="line">            <span class="comment">//③</span></span><br><span class="line">            currPtr=temPtr;</span><br><span class="line">            <span class="comment">//④</span></span><br><span class="line">            <span class="comment">//①④是完成操作后,使c前进一位</span></span><br><span class="line">            <span class="comment">//③是完成调转方向后,使p前进一位</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre,ListNode* cur)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">ListNode* temp = cur-&gt;next;</span><br><span class="line">cur-&gt;next = pre;</span><br><span class="line"><span class="comment">// 可以和双指针法的代码进⾏对⽐，如下递归的写法，其实就是做了这两步</span></span><br><span class="line"><span class="comment">// pre = cur;</span></span><br><span class="line"><span class="comment">// cur = temp;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse</span>(cur,temp);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 和双指针法初始化是⼀样的逻辑</span></span><br><span class="line"><span class="comment">// ListNode* cur = head;</span></span><br><span class="line"><span class="comment">// ListNode* pre = NULL;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">NULL</span>, head);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<ul>
<li><h4 id="虚拟头结点"><a href="#虚拟头结点" class="headerlink" title="虚拟头结点"></a>虚拟头结点</h4></li>
</ul>
<p>我们在处理链表问题时,通常会用到虚拟头结点这个工具,虚拟头结点本身不储存任何数据,它的存在只是为了更方便我们去对链表中的元素进行操作.</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
<th>g</th>
</tr>
</thead>
<tbody><tr>
<td>dummyhead</td>
<td>head</td>
<td>head-&gt;next</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>如果我们要删除头结点,那么就只需要将dummyhead的指针指向head-&gt;next所在的节点,清理掉头结点的内存,然后head节点指向dummyhead.</p>
<p>这里我们要删除链表的倒数第二个元素，首先我们要知道链表，我们是<strong>无法直接指定他到某个索引找出它的节点</strong>，我们需要用到一些方法就是<strong>快慢指针</strong>的那一种方式。</p>
<p>快慢指针的方式：快指针先走n步，慢指针后走，这样能在两个指针之间形成n个节点的间隔，当快指针走到空指针的位置的时候，慢指针刚好在倒数第n个节点的前一个节点的位置，之后对倒数第n个元素进行删除就好了，这里我们还需要使用到虚拟头接点的方式，有了虚拟头节点我们就方便地进行链表节点的删除。</p>
<p>关于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyhead= <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next=head;</span><br><span class="line">        ListNode* fast=dummyhead;</span><br><span class="line">        ListNode* slow=dummyhead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next=slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.postimg.cc/WzGdvtRY/A0-A70-DA070-ECE89284-F06-FC7-C8-FBC855.png" alt="删除链表的倒数第n个元素"></p>
<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>自定义评测：</strong></p>
<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>
<ul>
<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>
<li><code>listA</code> - 第一个链表</li>
<li><code>listB</code> - 第二个链表</li>
<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>
<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li><code>1 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>
</ul>
<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<h4 id="逻辑环-双指针"><a href="#逻辑环-双指针" class="headerlink" title="逻辑环+双指针"></a>逻辑环+双指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *A=headA,*B=headB;</span><br><span class="line">        <span class="keyword">while</span>(A!=B)</span><br><span class="line">        &#123;</span><br><span class="line">            A=A!=<span class="literal">nullptr</span>?A-&gt;next:headB;</span><br><span class="line">            B=B!=<span class="literal">nullptr</span>?B-&gt;next:headA;</span><br><span class="line">            <span class="comment">//相当于将两个链表结成一个环，当两个指针完全一致的时候，就返回对应的指针</span></span><br><span class="line">            <span class="comment">//这里的环只是逻辑上的环，实际上并没有改变链表的任何数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="复杂双指针"><a href="#复杂双指针" class="headerlink" title="复杂双指针"></a>复杂双指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表A的长度</span></span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表B的长度</span></span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">// 让curA为最长链表的头，lenA为其长度</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求长度差</span></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">        <span class="comment">// 让curA和curB在同一起点上（末尾位置对齐）</span></span><br><span class="line">        <span class="keyword">while</span> (gap--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历curA 和 curB，遇到相同则直接返回</span></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>层次分析</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//外层为具体条件,while语句对链表进行扫描</span></span><br><span class="line"><span class="comment">//slow一次移动一个节点,fast则移动两个</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(slow==fast)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode*index1=fast;</span><br><span class="line">    ListNode*index2=head;</span><br><span class="line">    <span class="comment">//用index1和index2标记头结点和fast节点</span></span><br><span class="line">    <span class="comment">//标记slow也可以</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(index1!=index2)</span><br><span class="line">            &#123;</span><br><span class="line">                index1=index1-&gt;next;</span><br><span class="line">                index2=index2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> index2;</span><br><span class="line"><span class="comment">//用快指针定位,已知x=(n-1)(y+z)+z</span></span><br><span class="line"><span class="comment">//就是当index1(fast)指针到达相交点后,index2(head)指针也在这里</span></span><br></pre></td></tr></table></figure>

<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="哈希法"><a href="#哈希法" class="headerlink" title="哈希法"></a>哈希法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="双指针法-2"><a href="#双指针法-2" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重a方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    <span class="comment">//如果不进行收缩,那么一会儿还会重复计算一次算过的数据</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h3><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<h4 id="双指针法-3"><a href="#双指针法-3" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; nums.<span class="built_in">size</span>(); k++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝处理</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            	<span class="keyword">break</span>; <span class="comment">// 这里使用break，统一通过最后的return返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对nums[k]去重</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = k + <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                <span class="comment">// 2级剪枝处理</span></span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对nums[i]去重</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：字符串</title>
    <url>/2024/08/10/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s[i]</code> 都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li>
</ul>
<h4 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[l],s[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="双指针底层"><a href="#双指针底层" class="headerlink" title="双指针底层"></a>双指针底层</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;s.<span class="built_in">size</span>()/<span class="number">2</span>;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=s[l];</span><br><span class="line">            s[l]=s[r];</span><br><span class="line">            s[r]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a></h4><p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p>
<ul>
<li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>
<li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, k = 2</span><br><span class="line">输出：&quot;bacd&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由小写英文组成</li>
<li><code>1 &lt;= k &lt;= 104</code></li>
</ul>
<h4 id="分类讨论-库函数"><a href="#分类讨论-库函数" class="headerlink" title="分类讨论+库函数"></a>分类讨论+库函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i=i+<span class="number">2</span>*k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+k&lt;=s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">2</span>*k<span class="number">-1</span>;l&lt;k;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=s[l];</span><br><span class="line">            s[l]=s[r];</span><br><span class="line">            s[r]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=i+k,r=s.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;(s.<span class="built_in">size</span>()+i+k)/<span class="number">2</span>;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=s[l];</span><br><span class="line">            s[l]=s[r];</span><br><span class="line">            s[r]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="分类讨论"><a href="#分类讨论" class="headerlink" title="分类讨论"></a>分类讨论</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp;s,<span class="type">int</span> start,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=start,r=end;l&lt;r;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            temp=s[l];</span><br><span class="line">            s[l]=s[r];</span><br><span class="line">            s[r]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i = i + <span class="number">2</span> * k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + k &lt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s,i,i+k<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverse</span>(s,i,s.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151. 反转字符串中的单词"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a></h4><p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>
<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li>
<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>
</ul>
<p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p>
<h4 id="自己的思路"><a href="#自己的思路" class="headerlink" title="自己的思路"></a>自己的思路</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; s1;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">        a.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//左边隔板的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>)&#123;a.<span class="built_in">push_back</span>(i);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录中间隔板的位置</span></span><br><span class="line">        a.<span class="built_in">push_back</span>(s.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">//右边界隔板的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!a.<span class="built_in">size</span>()) <span class="keyword">return</span> s;</span><br><span class="line">            <span class="comment">//单个单词直接返回</span></span><br><span class="line">            s1.<span class="built_in">push_back</span>(s.<span class="built_in">begin</span>()+a[i]+<span class="number">1</span>,s.<span class="built_in">begin</span>()+a[i+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">            <span class="comment">//左隔板前移动一位，右隔板后移一位，切出一个单词</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>,r=s1.<span class="built_in">size</span>()<span class="number">-1</span>;l&lt;r;l++,r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s1[l],s1[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        string s2=s1[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//左右指针将单词反转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s1.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s2+=<span class="string">&#x27; &#x27;</span>+s1[i];</span><br><span class="line">        &#125;<span class="comment">//利用占头部的方式消除前置零</span></span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Split库-分隔单词"><a href="#Split库-分隔单词" class="headerlink" title="Split库+分隔单词"></a>Split库+分隔单词</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">istringstream <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">        string str;</span><br><span class="line">        stack&lt;string&gt; zhan;</span><br><span class="line">        <span class="keyword">while</span>(is&gt;&gt;str)&#123;</span><br><span class="line">            zhan.<span class="built_in">push</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用输入流，将单词分别输入</span></span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span>(!zhan.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res += zhan.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(zhan.<span class="built_in">size</span>() != <span class="number">1</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            zhan.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//利用栈原理，逆向接受单词空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="栈原理"><a href="#栈原理" class="headerlink" title="栈原理"></a>栈原理</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">// self solution! yeah!!</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack &lt;string&gt; stk;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;<span class="comment">//先遍历字符串，提前单词，word入栈</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                word += s[i];</span><br><span class="line">                <span class="keyword">if</span> (i ==  n<span class="number">-1</span> || s[i+<span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//关键判断条件：什么时候入栈，当字母后有空格或已是最后一个则判断为word，入栈</span></span><br><span class="line">                    stk.<span class="built_in">push</span>(word);</span><br><span class="line">                    word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>())&#123;<span class="comment">//释放栈中元素，加入空格组成反转后结果</span></span><br><span class="line">            ans += stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>())  ans += <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(string&amp; s, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123; <span class="comment">//翻转，区间写法：左闭又闭 []</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string&amp; s)</span> </span>&#123;<span class="comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;   <span class="comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123; <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//遇到非空格就处理，即删除所有空格。</span></span><br><span class="line">                <span class="keyword">if</span> (slow != <span class="number">0</span>) s[slow++] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//补上该单词，遇到空格说明单词结束。</span></span><br><span class="line">                    s[slow++] = s[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow); <span class="comment">//slow的大小即为去除多余空格后的大小。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s); <span class="comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class="line">        <span class="built_in">reverse</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>; <span class="comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>() || s[i] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class="line">                <span class="built_in">reverse</span>(s, start, i - <span class="number">1</span>); <span class="comment">//翻转，注意是左闭右闭 []的翻转。</span></span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">//更新下一个单词的开始下标start</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>文本串 （m）<br>$$<br>aabaabaaf<br>$$<br>模式串（n）<br>$$<br>aabaaf<br>$$<br>暴力算法的时间复杂度O（m*n）</p>
<h4 id="前缀表"><a href="#前缀表" class="headerlink" title="前缀表"></a>前缀表</h4><p>前缀：</p>
<p>必须包含第一个字母但不包含最后一个字母的连续子串</p>
<p>后缀：</p>
<p>必须包含最后一个字母但不包含第一个字母的连续子串</p>
<p>前缀表：</p>
<p>最长相等前后缀（即这个字符串的前缀和后缀相等，还是最长的那个）</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cebda048620efc235b1cdd19de36b6fa.png" alt="前缀表"></p>
<p>设置一个next数组，来记录前缀表的值。</p>
<h4 id="前缀函数的实现"><a href="#前缀函数的实现" class="headerlink" title="前缀函数的实现"></a>前缀函数的实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prefix_function</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n = (<span class="type">int</span>)s.<span class="built_in">length</span>();</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">      <span class="keyword">if</span> (s.<span class="built_in">substr</span>(<span class="number">0</span>, j) == s.<span class="built_in">substr</span>(i - j + <span class="number">1</span>, j)) &#123;</span><br><span class="line">        pi[i] = j;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">return</span> pi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/08/10/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240814132219332.png" alt="image-20240814132219332"></p>
<h4 id="KMP算法的示例"><a href="#KMP算法的示例" class="headerlink" title="KMP算法的示例"></a>KMP算法的示例</h4><p>为了展示这个算法的细节，以及这个算法的运行，给出两个字符串：<br>$$<br>W&#x3D;”ABCDABD” andS&#x3D;”ABC ABCDAB ABCDABCDABDE”<br>$$<br>在某个特定的时间点，这个处于被两个整数类型的变量决定的状态</p>
<ul>
<li>m，显示W串在S串中的起始位置</li>
<li>i，显示当前被考虑的字符在W串中的索引</li>
</ul>
<p>在算法的每一步中。都将比较S[m+i]与W[i]，如果这两者相等，就递增变量i。</p>
<p>下面是对过程的呈现，在运行的最开始。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">             <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W: ABCDABD</span><br><span class="line">i: <span class="number">0123456</span></span><br></pre></td></tr></table></figure>

<p>这个算法比较W中的连续字符串与S中的平行字符串，如果两者的字符能够匹配，i发生递增，将从现在的字符移动到另一个字符。然而在第四步中，S[3]&#x3D;’ ‘与W[3]&#x3D;’D’不匹配。我们不会从S[1]重新开始搜索，我们注意到在S串的位置1到位置2中，’A’都没有出现，因此，在预先检查过S串中对饮的所有字符之后（以及已知它们能够匹配上W串中对应的字符），得知从S串的最开始去寻找没有机会达成目标，因此，根据算法，设置m&#x3D;3以及i&#x3D;0.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">             <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:    ABCDABD</span><br><span class="line">i:    <span class="number">0123456</span></span><br></pre></td></tr></table></figure>

<p>这次匹配在初始字符处失败了，因此根据算法，设置m&#x3D;4以及i&#x3D;0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">             <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:     ABCDABD</span><br><span class="line">i:     <span class="number">0123456</span></span><br></pre></td></tr></table></figure>

<p>此处，i随着一次几乎完全的匹配递增，直到i&#x3D;6的时候，在W[6]和S[10]出现了一次不匹配。然而就在这次部分匹配之前，存在子串”AB”，它可以作为新一次匹配的起始，所以根据算法必须考虑这一点。因为能够匹配两个字符的这个字串处于当前位置之前，这些字符没有被再次核验的必要；根据算法，设置m&#x3D;9（初始化词头的起始点）以及i&#x3D;2（表示有两个字符匹配），然后继续匹配。因此根据算法不仅省略了提前匹配S串的字符（’AB’），而且提前匹配了W串的字符（词头”AB”）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">      <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:         ABCDABD</span><br><span class="line">i:         <span class="number">0123456</span></span><br></pre></td></tr></table></figure>

<p>在新位置的搜索立刻由于W[2]和S[10]不匹配而失败。由于在首次尝试，根据算法，不匹配使得运算退回W串的起始点，以及从S串的不匹配字符位置（m&#x3D;10）开始匹配，设置i&#x3D;0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">             <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:           ABCDABD</span><br><span class="line">i:           <span class="number">0123456</span></span><br></pre></td></tr></table></figure>

<p>在m&#x3D;10处的匹配立即失败，因此根据算法，开始尝试m&#x3D;11和i&#x3D;0.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">             <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:            ABCDABD</span><br><span class="line">i:            <span class="number">0123456</span></span><br></pre></td></tr></table></figure>

<p>再一次，根据算法，能够匹配”ABCDAB“字符，但是其下一个字符‘C’不能匹配W串的最后一个字符‘D’。和之前同样的原因，根据算法，设置m&#x3D;15，从双字符字符串”AB“开始，连接到当前位置，设置i&#x3D;2，然后继续从当前位置开始匹配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">             <span class="number">1</span>         <span class="number">2</span>  </span><br><span class="line">m: <span class="number">01234567890123456789012</span></span><br><span class="line">S: ABC ABCDAB ABCDABCDABDE</span><br><span class="line">W:                ABCDABD</span><br><span class="line">i:                <span class="number">0123456</span></span><br></pre></td></tr></table></figure>

<p>此时匹配已经完成，W串的第一个字符是从S[15]开始匹配的。</p>
<h4 id="KMP搜索算法的伪代码描述"><a href="#KMP搜索算法的伪代码描述" class="headerlink" title="KMP搜索算法的伪代码描述"></a>KMP搜索算法的伪代码描述</h4><p>以上的样例包含了KMP搜索算法的所有要素。此时，我们假定”部分匹配“表T的存在，描述如下，其表示当一次不匹配被发现时，我们需要从哪里开始我们新一次的匹配。创建T的目录是为了当我们以S[m]为匹配起始点，比较S[m+i]到W[i]失败时，下一个可能的匹配起始点可以为S串索引为m+i-T[i]的位置（T[i]是在发生一次不匹配后我们需要回溯的数量）。这具有两个影响：首先，T[0]&#x3D;-1，表明W[0]会发生一次不匹配，我们不能回溯还必须简单检查下面一个字符；以及第二个，尽管接下来可能的匹配会从索引m+i-T[i]开始，因为以上的例子，我们没有必要镇店确定T[i]之后的任何字符，因此我们继续从W[T[i]]开始搜索。下面是KMP搜索算法的一个简单伪代码执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">algorithm kmp_search:</span><br><span class="line">    input:</span><br><span class="line">        an array of characters, <span class="built_in">S</span> (the text to be searched)</span><br><span class="line">        an array of characters, <span class="built_in">W</span> (the word sought)</span><br><span class="line">    output:</span><br><span class="line">        an array of integers, <span class="built_in">P</span> (positions in S at which W is found)</span><br><span class="line">        an integer, <span class="built_in">nP</span> (number of positions)</span><br><span class="line"></span><br><span class="line">    define variables:</span><br><span class="line">        an integer, j ← <span class="number">0</span> (the position of the current character in S)</span><br><span class="line">        an integer, k ← <span class="number">0</span> (the position of the current character in W)</span><br><span class="line">        an array of integers, <span class="built_in">T</span> (the table, computed elsewhere)</span><br><span class="line"></span><br><span class="line">    let nP ← <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> j &lt; <span class="built_in">length</span>(S) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> W[k] = S[j] then</span><br><span class="line">            let j ← j + <span class="number">1</span></span><br><span class="line">            let k ← k + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k = <span class="built_in">length</span>(W) <span class="built_in">then</span></span><br><span class="line">                (occurrence found, <span class="keyword">if</span> only first occurrence is needed, m ← j - k  may be returned here)</span><br><span class="line">                let P[nP] ← j - k, nP ← nP + <span class="number">1</span></span><br><span class="line">                let k ← T[k] (T[<span class="built_in">length</span>(W)] can<span class="number">&#x27;</span>t be <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            let k ← T[k]</span><br><span class="line">            <span class="keyword">if</span> k &lt; <span class="number">0</span> then</span><br><span class="line">                let j ← j + <span class="number">1</span></span><br><span class="line">                let k ← k + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">j++;</span><br><span class="line"> &#125;</span><br><span class="line">next[i] = j; <span class="comment">// 将j（前缀的⻓度）赋给next[i]</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = j;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i从1开始</span></span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; s[i] != s[j + <span class="number">1</span>]) &#123; <span class="comment">// 前后缀不相同了</span></span><br><span class="line">j = next[j]; <span class="comment">// 向前回退</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span> (s[i] == s[j + <span class="number">1</span>]) &#123; <span class="comment">// 找到相同的前后缀</span></span><br><span class="line">j++;</span><br><span class="line"> &#125;</span><br><span class="line">next[i] = j; <span class="comment">// 将j（前缀的⻓度）赋给next[i]</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (needle.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">int</span> next[needle.<span class="built_in">size</span>()];</span><br><span class="line"><span class="built_in">getNext</span>(next, needle);</span><br><span class="line"><span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">// // 因为next数组⾥记录的起始位置为-1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; haystack.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 注意i就从0开始</span></span><br><span class="line"><span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">j = next[j]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span> (haystack[i] == needle[j + <span class="number">1</span>]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">j++; <span class="comment">// i的增加在for循环⾥</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">if</span> (j == (needle.<span class="built_in">size</span>() - <span class="number">1</span>) ) &#123; <span class="comment">// ⽂本串s⾥出现了模式串t</span></span><br><span class="line"><span class="keyword">return</span> (i - needle.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：数学</title>
    <url>/2024/08/20/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="1-1矩阵"><a href="#1-1矩阵" class="headerlink" title="1.1矩阵"></a>1.1矩阵</h1><h2 id="1-1-1矩阵类"><a href="#1-1-1矩阵类" class="headerlink" title="1.1.1矩阵类"></a>1.1.1矩阵类</h2><ul>
<li>任务：</li>
</ul>
<p>实现矩阵的基本变换</p>
<ul>
<li>接口</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">结构体：Matrix</span><br><span class="line">成员变量：</span><br><span class="line"><span class="type">int</span> n,m 矩阵大小</span><br><span class="line"><span class="type">int</span> a[][] 矩阵内容</span><br><span class="line">重载运算符：+、-、x</span><br><span class="line">成员函数：</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> 清空矩阵</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM=<span class="number">1010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="type">int</span> a[MAXN][MAXM];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n=m=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    &#125; </span><br><span class="line">    Matrix <span class="keyword">operator</span>+(<span class="type">const</span> Matrix&amp;b) <span class="type">const</span>&#123;</span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n;</span><br><span class="line">        tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.a[i][j]=a[i][j]+b.a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>-(<span class="type">const</span> Matrix&amp;b) <span class="type">const</span>&#123;</span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n;</span><br><span class="line">        tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.a[i][j]=a[i][j]-b.a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix&amp;b) <span class="type">const</span>&#123;</span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n;</span><br><span class="line">        tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.a[i][j]+=a[i][k]*b.a[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="矩阵乘法分析，在线性代数里面，矩阵的乘法规则如下："><a href="#矩阵乘法分析，在线性代数里面，矩阵的乘法规则如下：" class="headerlink" title="矩阵乘法分析，在线性代数里面，矩阵的乘法规则如下："></a>矩阵乘法分析，在线性代数里面，矩阵的乘法规则如下：</h4></li>
</ul>
<p>矩阵中某行（n）某列（m）确定的元素的值，等于前一个矩阵的该行向量（n，k）与后一个矩阵的该列向量（k，m）的乘积，k代表行向量和列向量中的第几个值。</p>
<ul>
<li><h4 id="重载运算符的规则"><a href="#重载运算符的规则" class="headerlink" title="重载运算符的规则"></a>重载运算符的规则</h4></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix&amp;b) <span class="type">const</span>&#123;</span><br><span class="line">    <span class="comment">//本质是一个函数，传入的参数是常引用，函数本身是常函数，不可更改</span></span><br><span class="line">        Matrix tmp;</span><br><span class="line">        tmp.n=n;</span><br><span class="line">        tmp.m=m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;b.m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;m;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.a[i][j]+=a[i][k]*b.a[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-1-2Gauss消元"><a href="#1-1-2Gauss消元" class="headerlink" title="1.1.2Gauss消元"></a>1.1.2Gauss消元</h2><ul>
<li>任务：</li>
</ul>
<p>给一个n元一次方程组，求它们的解集</p>
<ul>
<li>说明</li>
</ul>
<p>将方程组做成矩阵形式，再利用三种初等矩阵变换，得到上三角矩阵，最后回代得到解集。</p>
<ul>
<li>接口</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">double</span> a[][MAXN],<span class="type">bool</span> l[],<span class="type">double</span> ans[],<span class="type">const</span> <span class="type">int</span>&amp;n)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>复杂度</li>
</ul>
<p>$$<br>O(n^3)<br>$$</p>
<ul>
<li>输入</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a 方程组对应的矩阵</span><br><span class="line">n 未知数个数</span><br><span class="line">l，ans 存储解，l[]表示是否为自由元</span><br></pre></td></tr></table></figure>

<ul>
<li>输出</li>
</ul>
<p>解空间的维数</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：有序数组的平方</title>
    <url>/2022/10/09/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    <content><![CDATA[<h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977. 有序数组的平方"></a><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>请你设计时间复杂度为 <code>O(n)</code> 的算法解决本问题</li>
</ul>
<p>​	有序数组平方和用到的方法是左右指针。可以想象现在面前有两个数组。他们的数组大小一样，但前面一个数组它是严格递增的数组，后面那个数组它是一个空数组。</p>
<p>​	现在我们将前面那个数组的每一个数都进行一个平方操作，可以很容易的知道，如果要从大到小依次挑出最大值的话，一定是从第1个数组的左右两侧往中间开始选。</p>
<p>那么方法就很明确了，循环的条件是左指针小于等于右指针，现在进行比较，这里用到了if-else语句， 就这样一直循环，当这个中间值和目标值相同的时候，我们就可以返回中间值对应的数，中间指针所指的那个数的值，但如果左右指针指向相同的时候，我们还是没找到它的值，我们就返回一个-1。</p>
<h3 id="题解1（暴力运算，平方加排序）"><a href="#题解1（暴力运算，平方加排序）" class="headerlink" title="题解1（暴力运算，平方加排序）"></a>题解1（暴力运算，平方加排序）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            nums[i++] = nums[i] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="题解2（开新数组-左右指针）"><a href="#题解2（开新数组-左右指针）" class="headerlink" title="题解2（开新数组+左右指针）"></a>题解2（开新数组+左右指针）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> b=a.<span class="built_in">size</span>()<span class="number">-1</span>,r=a.<span class="built_in">size</span>(),l=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(a.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[l])&lt;<span class="built_in">fabs</span>(a[r]))</span><br><span class="line">            &#123;</span><br><span class="line">                c[b]=a[r]*a[r];</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                c[b--]=a[l]*a[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic.leetcode-cn.com/1631932242-BViXlX-977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="977.有序数组的平方.gif"></p>
<p>这个算法的思路是，新开一个数组用来记录信息，首位两个指针互相交换信息，有一个特点，其实就是，生成的新数组的值，其实应该从小到大，依次是从中间，左右之一取得的。</p>
<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：每日一题</title>
    <url>/2024/10/23/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
    <content><![CDATA[<p><strong>2024年10月23日</strong></p>
<p><img src="https://i.postimg.cc/DzNRDmP7/d939241e073b3bf46017619e08f5e9a1.png" alt="img"></p>
<p>今天这个题目就是两数之和的应用，使用的方法是哈希表法。</p>
<p><strong>语法回顾</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map.<span class="built_in">count</span>(x);<span class="comment">//获得map中同种元素的个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> hour:hours);<span class="comment">//顺序遍历hours中的所有元素，每次遍历都用hour指代对应元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> &amp;pair:map);<span class="comment">//顺序遍历map中的所有元素</span></span><br><span class="line">pair.first;<span class="comment">//key</span></span><br><span class="line">pair.second;<span class="comment">//value</span></span><br></pre></td></tr></table></figure>

<p>逻辑：</p>
<p>​	取余数的过程相当于剥壳，取完余数之后，某些本来不相关的元素就同质化了。然后hours里面的一批人每个人拥有一把钥匙（可能相同），开完锁之后放一个东西在里面，后面通过特定的方式，给这些人重新分配一把钥匙，统计打开门之后，这些人能回收的物品个数。</p>
<p>2024年10月24日</p>
<p><a href="https://leetcode.cn/problems/find-the-first-player-to-win-k-games-in-a-row/">3175. 找到连续赢 K 场比赛的第一位玩家</a></p>
<p><img src="https://i.postimg.cc/Hkdm4JBK/image-20241024133340965.png" alt="image-20241024133340965"></p>
<p>今天这个题目是双指针问题，遍历加上辅助指针解决问题，问题的简化就是：遍历指针的元素与辅助指针的元素进行大小的比较，需要辅助指针的元素胜利k次，然后就能顺利返回，不然就只能移动辅助指针，重新计数。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：滑动窗口</title>
    <url>/2022/10/10/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="滑动窗口是什么"><a href="#滑动窗口是什么" class="headerlink" title="滑动窗口是什么"></a>滑动窗口是什么</h3><p>滑动窗口可以用来解决数组&#x2F;字符串的子元素问题，它可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度。</p>
<h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p>给定一个整数数组，计算长度为 ‘k’ 的连续子数组的最大总和。</p>
<p>输入：arr [] &#x3D; {100,200,300,400}</p>
<p>​			k &#x3D; 2</p>
<p>输出：700</p>
<p>解释：300 + 400 &#x3D; 700</p>
<h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><p>争对这个问题，我可以采用信息利用率最低的一种方式，就是将所有元素遍历一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(&amp;arr,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>()-k+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cut=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">            &#123;</span><br><span class="line">             cut=cut+arr[i+j];   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> maxsum=<span class="built_in">max</span>(cut,mansum);</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如代码里所写的那样，这里的解题思路很简单，就是用i指针进行引导，j在i指针后，k区间内进行滑动，这里滑动完之后，会留下一个信息，怎么记录这一个信息呢？因为这道题让我输出的是单信息，不用考虑信息丢失，我们就有两种方法来解决它，第一个方法是开多余的空间来记录他，就是说启动一个动态数组来存储产生的k区间和值信息，第二个方式就是采用迭代更新的方式，因为我们需要的单数据只需要占用一个位置，我们只要每次把这个位置更新了就好了，要做到这一点其实也不难，只需要我们使用两个值来记录，一个是current值，一个是max值，max值在current值和之前的max值之间进行更新。</p>
<h5 id="滑动窗口解法"><a href="#滑动窗口解法" class="headerlink" title="滑动窗口解法"></a>滑动窗口解法</h5><p>滑动窗口法只用了很小的一点变化就让窗口得到累加，我们可以寻找到不同窗口之间的关系，我们可以发现，其实窗口之间的信息差距只有1,数据的相似性高达$\frac{k-1}{k}\times100%$，这样我们其实在没算出一次的窗口时，都为下一次做了k-1次的运算，如果我们每次都把这个k-1次运算利用上，那我们的时间复杂度可以大大降低，下面时时间复杂度优化的计算过程。<br>$$<br>原本的时间复杂度（暴力法）：\\<br>窗口的个数:n&#x3D;arr.size()-k\\<br>而我们每个窗口都要进行k次运算，实际上我们运算的次数就是\\<br>n_1&#x3D;n\times\ k&#x3D;(arr.size()-k)\times k\\<br>而当我们采用滑动窗口的解法，每个窗口的运算变化是，减去一个无效数字，增加一个有效数字，所以运算的次数变为\\<br>n_2&#x3D;n\times 2&#x3D;(arr.size()-k)\times 2\\<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:<span class="built_in">fun</span>(&amp;arr,<span class="type">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cut=<span class="number">0</span>,max_1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            max_1+=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cut =max_1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cut+=arr[i]-arr[i-k];</span><br><span class="line">            max_1=<span class="built_in">max</span>(max_1,cut);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="为什么要用滑动窗口"><a href="#为什么要用滑动窗口" class="headerlink" title="为什么要用滑动窗口"></a>为什么要用滑动窗口</h3><p>使用滑动窗口可以帮助我们公用已有的计算量，减少计算机运算的次数，提高程序运行效率。</p>
<h3 id="怎么使用滑动窗口"><a href="#怎么使用滑动窗口" class="headerlink" title="怎么使用滑动窗口"></a>怎么使用滑动窗口</h3><ul>
<li>判断是否存在大区间里套小区间</li>
<li>小区间之间是否具有共有的运算量</li>
</ul>
<p>需要注意的部分在于</p>
<ol>
<li>k区间在滑动窗口下的更新方法</li>
<li>算数列首项的思想。</li>
</ol>
<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h2><p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 </p>
<p><strong>子数组</strong></p>
<p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
<blockquote>
<p>注意：子数组意思是直接从数组里面取一个序列的元素，不是单个取值。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 109</code></li>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>
</ul>
<h3 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxsum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> flag=nums.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cut=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i+j&lt;nums.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    cut+=nums[i+j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(cut&gt;=target)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag=<span class="built_in">min</span>(j+<span class="number">1</span>,flag);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==nums.<span class="built_in">size</span>()+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口-1"><a href="#滑动窗口-1" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxsum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> flag=nums.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cut=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cut+=nums[j];</span><br><span class="line">                <span class="keyword">while</span>(cut&gt;=target)</span><br><span class="line">                &#123;</span><br><span class="line">                    cut-=nums[i++];</span><br><span class="line">                    flag=<span class="built_in">min</span>(j-i+<span class="number">2</span>,flag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==nums.<span class="built_in">size</span>()+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里用到的滑动窗口其实就是不断调整子序列的起始位置和终止位置，从而得到我们想要的结果。</p>
<p><img src="https://pic.leetcode-cn.com/1659059220-jxMpDA-209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="209.长度最小的子数组.gif"></p>
<p>滑动窗口的精髓在于移动k区间的起始位置，关键代码在于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(cut&gt;=target)</span><br><span class="line">&#123;</span><br><span class="line">    cut-=nums[i++];</span><br><span class="line">    flag=<span class="built_in">min</span>(flag,j+<span class="number">2</span>-i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以分析得知，要知道一个事实，能够取到目标值的k区间，其终点带来的效果不是超出这个target值，就是刚刚好。如果是超出这个值的话，我们只需要在前面减去多余的数字就可以了。</p>
<p>在这个更新起始位置的代码中，我们用到的更新手段是，调节起始位置的索引，从而改变我们字串的索引值。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：栈与队列</title>
    <url>/2024/08/20/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>1212</p>
<h2 id="栈与队列理论基础"><a href="#栈与队列理论基础" class="headerlink" title="栈与队列理论基础"></a>栈与队列理论基础</h2><h3 id="栈（stack）："><a href="#栈（stack）：" class="headerlink" title="栈（stack）："></a>栈（stack）：</h3><p>先进后出，属于STL中的数据结构，提供push、pop等外部接口，栈不提供走访功能，以及迭代器（iterator）。</p>
<h4 id="初始化语句"><a href="#初始化语句" class="headerlink" title="初始化语句"></a>初始化语句</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt; &gt; third;  <span class="comment">// 使用vector为底层容器的栈</span></span><br></pre></td></tr></table></figure>

<h3 id="队列（queue）："><a href="#队列（queue）：" class="headerlink" title="队列（queue）："></a>队列（queue）：</h3><p>先进先出，属于STL中的数据结构，如果是双向队列，简写就是deque。</p>
<h4 id="初始化语句-1"><a href="#初始化语句-1" class="headerlink" title="初始化语句"></a>初始化语句</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>, std::list&lt;<span class="type">int</span>&gt;&gt; third; <span class="comment">// 定义以list为底层容器的队列</span></span><br></pre></td></tr></table></figure>

<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235346563.png" alt="栈与队列理论1"></p>
<blockquote>
<p>在STL中，栈和队列两种数据结构都不被归类为容器，而被归类为container adapter（容器适配器）</p>
</blockquote>
<h2 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初等构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接复用栈的push函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="comment">//pop的逻辑是退出一个元素，如果还有元素，那就不用再从s1中push元素。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将s1的所有元素都push到s2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> a=s2.<span class="built_in">top</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> a;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        s2.<span class="built_in">push</span>(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>()&amp;&amp;s2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>例如用双栈实现队列的以下功能</p>
<ul>
<li>pop</li>
<li>peek</li>
<li>empty</li>
<li>push</li>
</ul>
<p>实现功能的前提是熟知这个功能的具体内容是什么。</p>
<h5 id="pop函数的功能："><a href="#pop函数的功能：" class="headerlink" title="pop函数的功能："></a>pop函数的功能：</h5><p>将最先进入队列的元素推出队列，并返回它的值。我们将功能依次翻译为代码，最先进入队列的元素：使用双栈，用out栈反向接受in栈的元素（我们只有栈作为工具，栈的特点是后进后出，我们的操作是为了让最先进队列的元素变成最先进栈的元素）、使用一个值记录要推出的元素的值，再对栈使用pop函数，将该元素退出。</p>
<h5 id="peek函数的功能："><a href="#peek函数的功能：" class="headerlink" title="peek函数的功能："></a>peek函数的功能：</h5><p>要返回最后进入队列的元素，搭载队列的底层数据结构是栈，直接将队列当栈使用，调用栈的top函数。</p>
<h5 id="empty函数的功能："><a href="#empty函数的功能：" class="headerlink" title="empty函数的功能："></a>empty函数的功能：</h5><p>当in栈和out栈都为空时，队列才为空，我们只需要返回一个判定两者是否同时为空的布尔变量。</p>
<h5 id="push函数的功能："><a href="#push函数的功能：" class="headerlink" title="push函数的功能："></a>push函数的功能：</h5><p>要返回最后进入队列的元素，搭载队列的底层数据结构是栈，直接将队列当栈使用，调用栈的push函数。</p>
<blockquote>
<p>整体的程序设计其实有部分问题，在使用过队列的pop函数过后，in栈的元素全都逆向进入了out栈，此时再用栈的push函数，新元素进入in栈，这个时候问题就出现了，in栈和out栈的元素失去了原先的顺序特征。因此，在pop函数达到目标功能过后，最好把out栈的元素归位。</p>
<p>注意：上方的注释忽略了一个事实，pop函数在执行的时候是有前提的，out栈为空，这样函数整体的逻辑就像从要从顶部将竹子分为竹节，我们为了便利（等竹子生长），从竹子的根部以上将其砍开，先分解上部的竹节，而下面竹子的生长能够继续，当我们分解完上部的竹节之后，再将下面的竹节砍下，继续分解，这样既不会耽误我们分解竹子，也不会耽误竹子生长。</p>
</blockquote>
<h2 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p>
<p>实现 <code>MyStack</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 压入栈顶。</li>
<li><code>int pop()</code> 移除并返回栈顶元素。</li>
<li><code>int top()</code> 返回栈顶元素。</li>
<li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>你只能使用队列的标准操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // 返回 2</span><br><span class="line">myStack.pop(); // 返回 2</span><br><span class="line">myStack.empty(); // 返回 False</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li>
<li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li>
</ul>
<p><strong>进阶：</strong>你能否仅用一个队列来实现栈。</p>
<p>利用队列实现栈</p>
<blockquote>
<p>这部分的程序设计可以抽象出队列元素的特点，就像用栈实现队列的时候一样，是从顶上开始分解竹子的逻辑。这边将优先级放到了顶部的竹节上，类似地，可以将这个属性进行迁移。就像重要度不同的一系列人请你帮忙，假设队列的逻辑是从最重要的人开始处理，那栈的逻辑就是从最不重要的人开始处理，要用队列的逻辑实现栈的逻辑，就得将最重要的人转变为最不重要的人，这里选择的方式是将重要的人（具有优先处理权）直接转移到另一个队列里，然后将最不重要的人视为最重要的人处理。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que2; <span class="comment">// 辅助队列，用来备份</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que1.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123; <span class="comment">// 将que1 导入que2，但要留下最后一个元素</span></span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = que1.<span class="built_in">front</span>(); <span class="comment">// 留下的最后一个元素就是要返回的值</span></span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line">        que1 = que2;            <span class="comment">// 再将que2赋值给que1</span></span><br><span class="line">        <span class="keyword">while</span> (!que2.<span class="built_in">empty</span>()) &#123; <span class="comment">// 清空que2</span></span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element.</span></span><br><span class="line"><span class="comment">     ** Can not use back() direactly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que1.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--)&#123;</span><br><span class="line">            <span class="comment">// 将que1 导入que2，但要留下最后一个元素</span></span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = que1.<span class="built_in">front</span>(); <span class="comment">// 留下的最后一个元素就是要回返的值</span></span><br><span class="line">        que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());   <span class="comment">// 获取值后将最后一个元素也加入que2中，保持原本的结构不变</span></span><br><span class="line">        que1.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        que1 = que2; <span class="comment">// 再将que2赋值给que1</span></span><br><span class="line">        <span class="keyword">while</span> (!que2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">// 清空que2</span></span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>整体的程序设计其实有部分问题，在使用过队列的pop函数过后，in栈的元素全都逆向进入了out栈，此时再用栈的push函数，新元素进入in栈，这个时候问题就出现了，in栈和out栈的元素失去了原先的顺序特征。因此，在pop函数达到目标功能过后，最好把out栈的元素归位。</p>
</blockquote>
<p>我在用栈实现队列的时候，提到了这个细节，现在它能在队列实现栈时派上用场。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>在使用单个队列进行模拟的时候发现，将最不重要的元素化为最重要的元素就可以了，然而在实现的过程中，需要新开队列空间，将需要移除的元素暂存，等处理完目标元素之后，再将它们放回来，实际上并不需要这样操作。要做的事情就只有将元素移除，再添加进当前队列，直接让最加入的元素变成最先加入的元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--) &#123; <span class="comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span></span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = que.<span class="built_in">front</span>(); <span class="comment">// 此时弹出的元素顺序就是栈的顺序了</span></span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element.</span></span><br><span class="line"><span class="comment">     ** Can not use back() direactly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span> (size--)&#123;</span><br><span class="line">            <span class="comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span></span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = que.<span class="built_in">front</span>(); <span class="comment">// 此时获得的元素就是栈顶的元素了</span></span><br><span class="line">        que.<span class="built_in">push</span>(que.<span class="built_in">front</span>());    <span class="comment">// 将获取完的元素也重新添加到队列尾部，保证数据结构没有变化</span></span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/20.%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.gif" alt="20.有效括号"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果s的长度为奇数，一定不符合要求</span></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span></span><br><span class="line">            <span class="comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>(); <span class="comment">// st.top() 与 s[i]相等，栈弹出元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1047-删除字符串中的所有相邻重复项"><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h2><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= S.length &lt;= 20000</code></li>
<li><code>S</code> 仅由小写英文字母组成。</li>
</ol>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif" alt="1047.删除字符串中的所有相邻重复项"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> s : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || s != st.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// s 与 st.top()相等的情况</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123; <span class="comment">// 将栈中元素放到result字符串汇总</span></span><br><span class="line">            result += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span> (result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 此时字符串需要反转一下</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h2><p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>
<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>
<li>表达式中不含除零运算。</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>
<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= tokens.length &lt;= 104</code></li>
<li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li>
</ul>
<p><strong>逆波兰表达式：</strong></p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<ul>
<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>
<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>
</ul>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li>
</ul>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif" alt="150.逆波兰表达式求值"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 力扣修改了后台测试数据，需要用longlong</span></span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; st; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tokens.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;+&quot;</span>) st.<span class="built_in">push</span>(num2 + num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;-&quot;</span>) st.<span class="built_in">push</span>(num2 - num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;*&quot;</span>) st.<span class="built_in">push</span>(num2 * num1);</span><br><span class="line">                <span class="keyword">if</span> (tokens[i] == <span class="string">&quot;/&quot;</span>) st.<span class="built_in">push</span>(num2 / num1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoll</span>(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>(); <span class="comment">// 把栈里最后一个元素弹出（其实不弹出也没事）</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<p>在解决滑动窗口最大值的问题的时候，我们注意到P：小窗口向右移动、Q：窗口右端达到数组的右端，在P中，小窗口的元素进出规律如下：小窗口最多容纳k个元素，小窗口每次向右移动一格，会push一个新元素，而窗口内部，最先进来的那个元素被pop出去，这就是队列的先进先出的思想。而整个题目还给我们留下了一个R：输出滑动窗口的最大值。</p>
<p>最后我们解决这个题目要做到的就是<br>$$<br>P\cap Q\cap R<br>$$<br>实现思路就是建立一个单向队列充当小窗口，然后我们每次从滑动窗口里面取k个元素，总体的进程是让窗口向滑动窗口的右端移动。</p>
<p>队列的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="built_in">empty</span>()&amp;&amp;val==que.<span class="built_in">front</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(val&gt;que.<span class="built_in">back</span>()&amp;&amp;!que.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对此处代码的理解，现在回忆代码内容，能注意到正确的逻辑如下：push函数的意义是，当val大于back处的值时，将back处的值pop掉，一直这样操作，直到val大于back处的值，将val作为back处的值，一直这样操作，让整个队列处于递增的情况。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">queue</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="built_in">empty</span>()&amp;&amp;val==que.<span class="built_in">front</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()&amp;&amp;val&gt;que.<span class="built_in">back</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i-k]);</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(que.<span class="built_in">front</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>
<li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li>
</ul>
<p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p>
<p>要解决这个题目，我们首先需要了解堆是什么。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：移除元素</title>
    <url>/2022/10/09/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>数组其实是一个连续的内存空间，删除元素的基本原理是</p>
<ul>
<li>空间不变</li>
<li>计数方法会进行包装</li>
</ul>
<h3 id="erase函数"><a href="#erase函数" class="headerlink" title="erase函数"></a>erase函数</h3><p>在vector这个模板里面，就算使用了erase函数，原本申请的数组所占有的内存也是不发生变化的。</p>
<table>
<thead>
<tr>
<th>a[0]</th>
<th>a[1]</th>
<th>a[2]</th>
<th>a[3]</th>
<th>a[4]</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>5</td>
</tr>
</tbody></table>
<blockquote>
<p>删除4元素的原理，就是删除将下一位的元素那进来补位，然后通过某些手段，屏蔽接下来的元素，这样就可以形成一个新的数组</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void erase(&amp;a,int b)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i]==b)</span><br><span class="line">&#123;</span><br><span class="line">for(int j=i;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[j-1]=a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">复杂度O(i+(n-i))=O(n)</span><br></pre></td></tr></table></figure>

<h3 id="库函数的使用"><a href="#库函数的使用" class="headerlink" title="库函数的使用"></a>库函数的使用</h3><p>过于简单的题目（能用库函数一次解决的），就不要用库函数</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><blockquote>
<p>其实就是牺牲空间，获取时间，原理是这样的，我们采用额外的空间，比如再声明一个数组，这样一个数组有了之后，我们就可以采用快慢指针的方法，快指针的作用很简单，就是用于遍历数组中的所有元素，而慢指针的作用在于标度待删除元素的存在，确认数组在最后拥有的数组大小。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete element(&amp;a,int b)</span><br><span class="line">&#123;</span><br><span class="line">int slow=0;</span><br><span class="line">vector&lt;int&gt;a_1;</span><br><span class="line">for(int fast=0;fast&lt;a.size();fast++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[fast]!=b) slow++;</span><br><span class="line">&#125;</span><br><span class="line">return slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么是快慢指针"><a href="#什么是快慢指针" class="headerlink" title="什么是快慢指针"></a>什么是快慢指针</h4><p>快慢指针是双指针算法中的一种。不同于左右对撞指针，快慢指针中的两个指针是从同一侧但以不同的策略移动的指针。因此，两个指针中会有一个移动较快的快指针（fast）和一个较慢的慢指针（slow）。当快指针移动到数组的顶端时，停止遍历或进行新一轮遍历。</p>
<h4 id="为什么要用快慢指针"><a href="#为什么要用快慢指针" class="headerlink" title="为什么要用快慢指针"></a>为什么要用快慢指针</h4><p>使用双指针最实在的好处在于，我们的快指针相当于一个探路侠，它每走一步就会给予慢指针一个信息，让慢指针完成它的一部分工作，这样尽量让两个指针分工操作。</p>
<p>快指针的工作在前面进行，而快指针完成工作之后，对于它本身信息的传递，其实是不消耗空间，也不消耗时间的。我们可以利用信息的充分化利用，使得两个指针能干更多有意义的事情。</p>
<h4 id="快慢指针是怎么用的"><a href="#快慢指针是怎么用的" class="headerlink" title="快慢指针是怎么用的"></a>快慢指针是怎么用的</h4><ul>
<li>链表：在链表中，链表往往是单向链表，这个时候使用快慢指针，让它们朝着同一个方向进行迭代。</li>
<li>数组：数组利用的是索引的只是，在return值里面使用索引，便可以返回对应长度数组的值。</li>
</ul>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p>
<p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p>
<ul>
<li>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</li>
<li>返回 <code>k</code>。</li>
</ul>
<p><strong>用户评测：</strong></p>
<p>评测机将使用以下代码测试您的解决方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int val = ...; // 要移除的值</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的预期答案。</span><br><span class="line">                            // 它以不等于 val 的值排序。</span><br><span class="line"></span><br><span class="line">int k = removeElement(nums, val); // 调用你的实现</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">sort(nums, 0, k); // 排序 nums 的前 k 个元素</span><br><span class="line">for (int i = 0; i &lt; actualLength; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果所有的断言都通过，你的解决方案将会 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2,_,_]</span><br><span class="line">解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。</span><br><span class="line">注意这五个元素可以任意顺序返回。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        for (int fast = 0; fast &lt; nums.size(); fast++) &#123;</span><br><span class="line">            if (nums[fast] != val)</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以联想为两排数组，快指针的那排数组具有元素，当快指针找到不是val的值的时候，就把这个值丢给慢指针，反之则不丢，最后慢指针在的那个数组中，去除了所有的目标元素。</p>
<p><img src="https://p.sda1.dev/18/496fb1149023399a4fb0163b1520cb4b/B7EC9CA94D6DF2BEB4E92654E268692E.png"></p>
<h2 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p>
<p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p>
<ul>
<li>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。</li>
<li>返回 <code>k</code> 。</li>
</ul>
<p><strong>判题标准:</strong></p>
<p>系统会用下面的代码来测试你的题解:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[] nums = [...]; // 输入数组</span><br><span class="line">int[] expectedNums = [...]; // 长度正确的期望答案</span><br><span class="line"></span><br><span class="line">int k = removeDuplicates(nums); // 调用</span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line">for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果所有断言都通过，那么您的题解将被 <strong>通过</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2,_]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li>
</ul>
<p>​	我们来分析删除元素这个算法的原理，首先我们给定的一个数组它是严格递增的，在这里我们需要把重复的元素都删掉，然后返回整个数组的长度，可以看到我们这边是使用了一个快慢指针的方法，一个慢指针，一个快指针。</p>
<p>​	这里基本的思路是，如果说就是快指针和慢指针所指的两个数它相同的话。那么就只有快指针向前走一步，慢指针不动。在这里我们可以举一个例子，假如说嗯，这时候有三个相同的元素卖指针已经指向了第1个元素，而会计证指向的是第2个元素，这时候进行一步操作。因为这两个指针指向的元素的值是相同的，所以说慢指针不动，然后快指针向前走一步。</p>
<p>​	接下来继续操作，这个时候慢指针指向了第1个元素，然后快指针指向了第3个元素。因为这个时候会计证和慢指针的值还是相同的，所以说慢指针不动，快指针继续前进。这个时候快指针已经指向了和慢指针不同的元素。这个时候循环继续，因为快指针和慢指针它指向的元素已经不同了，所以说慢指针和快指针都向前走一步。而我们的操作中，当慢指针和快指针它们的值不同的时候，我们会将快指针的值赋给慢指针。</p>
<p>​	所以说慢指针，它最后会走的步数是。数组中不同元素的个数，而慢指针它本身的一个值是索引，所以说我们在计算数组长度的时候需要返回就是慢指针它的值，加上一个1。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        for (int fast = 1; fast &lt; nums.size(); fast = fast + 1) &#123;</span><br><span class="line">            if (nums[slow] != nums[fast])</span><br><span class="line">                nums[++slow] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        return slow + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://p.sda1.dev/18/0310a04d7db7eb8d955b8c89eca22e95/0DEE598ED87C4D5522F12F9FD0F44B2C.png"></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：程序自由度</title>
    <url>/2024/08/19/%E7%AE%97%E6%B3%95%EF%BC%9A%E7%A8%8B%E5%BA%8F%E8%87%AA%E7%94%B1%E5%BA%A6/</url>
    <content><![CDATA[<p>在研究算法的时间复杂度和空间复杂度的时候，总是会遇到，在写出一个完整的算法程序之前，无法预判这个算法的时间复杂度和空间复杂度的情况，从而出现思路混乱，每一步都依靠灵感思考的问题。在这篇文章，我将着重于时间复杂度和空间复杂度背后的底层逻辑，在写出算法前，预判其两种复杂度。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>在反转链表的算法练习中，我们着重于分析链表反转的基本自由度，在一开始的陌生化思考过程中，我们提到了一种类似于数组反转的算法，即直接对链表中的元素做一个镜像对称，但是在思考过后，我们发现这种算法并不可取，为什么呢？问题就出在程序的自由度上，由于这是我自己的算法笔记，我就在这里规定一些我个人定义的概念：</p>
<ul>
<li><strong>空间自由度：</strong></li>
</ul>
<p>是指元素受数据结构的影响，必须按照某种规则进行操作的受限程度。比如在链表这个数据结构中，对元素的表示不能使用索引，必须遍历到某个特定的节点之上才能调用节点的成员，对数据结构的限制的抵抗体现为这个遍历的过程。很明显，链表的遍历是一维遍历，而这里的由于链表的数据结构，在数组中属于单元操作的步骤，变成了一维操作。</p>
<ul>
<li><strong>遍历自由度</strong></li>
</ul>
<p>就是指必须完成的运算步骤（遍历过程）需要运算的规模。比如链表，我们对其的遍历自由度是一维，然而矩阵则是二维.</p>
<ul>
<li><strong>基元程序</strong></li>
</ul>
<p>基本算法就是执行同一个步骤的程序.例如反转链表之中,就只需要存元素、反向、移动元素、移动元素这个循环。</p>
<ul>
<li><h5 id="距离格数"><a href="#距离格数" class="headerlink" title="距离格数"></a>距离格数</h5></li>
</ul>
<p>在处理双指针问题的时候，通常会遇到不知道怎么处理循环次数的问题,这里提出一种从距离视角出发，解决循环次数问题的方法。</p>
<p>总所周知,如果有n棵树，那么就会有n-1个间隔，在数组的数据结构的背景下，索引会比实际的元素序数少1位。在进行一个基元操作之后,实际上是跨越了一个距离，可以在观测元素未知的时候，从三个角度出发：其一是序数，其二是索引，其三是跨度。</p>
<ul>
<li>序数</li>
</ul>
<p>序数对应实际考虑问题时，分析的对象。</p>
<ul>
<li>索引</li>
</ul>
<p>索引是在写代码时，需要序数转化为的对象。</p>
<ul>
<li>跨度</li>
</ul>
<p>跨度是某个维度遍历，在空间上呈现的变化。</p>
<p>在考虑第n个元素时，可以知道它的索引应该是n-1，而跨度也是n-1。如果考虑镜像对称的元素，能发现对称元素的序数和恒定为n+1，索引恒定为n-1，跨度之和为n-1（对称之后处于同一位置）。</p>
<h4 id="while语句与for语句的对比"><a href="#while语句与for语句的对比" class="headerlink" title="while语句与for语句的对比"></a>while语句与for语句的对比</h4><p>在使用两个循环语句的时候，while语句更适合条件循环，而for语句则更适合扫描循环，这使得while在更复杂的条件下，使用起来更加方便，可以用抽象条件来控制循环。</p>
<h4 id="逻辑语句的快速判断"><a href="#逻辑语句的快速判断" class="headerlink" title="逻辑语句的快速判断"></a>逻辑语句的快速判断</h4><p>现在观察到的逻辑运算符号中，比较容易弄混的有：！&#x3D;、while语句判断条件、a？b：c运算。</p>
<ul>
<li>a！+while（for）：a不成立时运行。</li>
</ul>
<h4 id="高精度循环"><a href="#高精度循环" class="headerlink" title="高精度循环"></a>高精度循环</h4><p>在复杂的算法问题中，我们经常用到非二维遍历的双重循环。在用到这样的循环时，应该考虑些什么问题呢？</p>
<ul>
<li>筛选型</li>
</ul>
<p>这类高精度循环，外层通常套了抽象条件的循环，而内层存在if语句，作为目标条件的筛选，到达外部抽象条件后，内部循环处理的是题目要求的内容。</p>
<ul>
<li>去重型</li>
</ul>
<p>在三数之和的问题中，用到了while语句进行去重，算是一个条件指令。</p>
<h4 id="仿射变换实现"><a href="#仿射变换实现" class="headerlink" title="仿射变换实现"></a>仿射变换实现</h4><h4 id="功能性程序"><a href="#功能性程序" class="headerlink" title="功能性程序"></a>功能性程序</h4><p>例如用双栈实现队列的以下功能</p>
<ul>
<li>pop</li>
<li>peek</li>
<li>empty</li>
<li>push</li>
</ul>
<p>实现功能的前提是熟知这个功能的具体内容是什么。</p>
<h5 id="pop函数的功能："><a href="#pop函数的功能：" class="headerlink" title="pop函数的功能："></a>pop函数的功能：</h5><p>将最先进入队列的元素推出队列，并返回它的值。我们将功能依次翻译为代码，最先进入队列的元素：使用双栈，用out栈反向接受in栈的元素（我们只有栈作为工具，栈的特点是后进后出，我们的操作是为了让最先进队列的元素变成最先进栈的元素）、使用一个值记录要推出的元素的值，再对栈使用pop函数，将该元素退出。</p>
<h5 id="peek函数的功能："><a href="#peek函数的功能：" class="headerlink" title="peek函数的功能："></a>peek函数的功能：</h5><p>要返回最后进入队列的元素，搭载队列的底层数据结构是栈，直接将队列当栈使用，调用栈的top函数。</p>
<h5 id="empty函数的功能："><a href="#empty函数的功能：" class="headerlink" title="empty函数的功能："></a>empty函数的功能：</h5><p>当in栈和out栈都为空时，队列才为空，我们只需要返回一个判定两者是否同时为空的布尔变量。</p>
<h5 id="push函数的功能："><a href="#push函数的功能：" class="headerlink" title="push函数的功能："></a>push函数的功能：</h5><p>要返回最后进入队列的元素，搭载队列的底层数据结构是栈，直接将队列当栈使用，调用栈的push函数。</p>
<blockquote>
<p>整体的程序设计其实有部分问题，在使用过队列的pop函数过后，in栈的元素全都逆向进入了out栈，此时再用栈的push函数，新元素进入in栈，这个时候问题就出现了，in栈和out栈的元素失去了原先的顺序特征。因此，在pop函数达到目标功能过后，最好把out栈的元素归位。</p>
<p>注意：上方的注释忽略了一个事实，pop函数在执行的时候是有前提的，out栈为空，这样函数整体的逻辑就像从要从顶部将竹子分为竹节，我们为了便利（等竹子生长），从竹子的根部以上将其砍开，先分解上部的竹节，而下面竹子的生长能够继续，当我们分解完上部的竹节之后，再将下面的竹节砍下，继续分解，这样既不会耽误我们分解竹子，也不会耽误竹子生长。</p>
</blockquote>
<p>利用队列实现栈</p>
<p>这部分的程序设计可以抽象出队列元素的特点，就像用栈实现队列的时候一样，是从顶上开始分解竹子的逻辑。这边将优先级放到了顶部的竹节上，类似地，可以将这个属性进行迁移。就像重要度不同的一系列人请你帮忙，假设队列的逻辑是从最重要的人开始处理，那栈的逻辑就是从最不重要的人开始处理，要用队列的逻辑实现栈的逻辑，就得将最重要的人转变为最不重要的人，这里选择的方式是将重要的人（具有优先处理权）直接转移到另一个队列里，然后将最不重要的人视为最重要的人处理。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：螺旋矩阵</title>
    <url>/2022/10/11/%E7%AE%97%E6%B3%95%EF%BC%9A%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="什么是螺旋矩阵"><a href="#什么是螺旋矩阵" class="headerlink" title="什么是螺旋矩阵"></a>什么是螺旋矩阵</h2><p>螺旋矩阵就是从四周向中心遍历矩阵的所有元素，没有实质上的算法内容，更多的是做一个模拟，所以螺旋矩阵可以归类为模拟题。</p>
<h2 id="螺旋矩阵的难点在哪里"><a href="#螺旋矩阵的难点在哪里" class="headerlink" title="螺旋矩阵的难点在哪里"></a>螺旋矩阵的难点在哪里</h2><p>螺旋矩阵作为一个模拟题，具有相当多的边界条件，在编写代码的时候，要把握好所有的边界，同时需要特判输入样例中的特殊情况。</p>
<p>在模拟螺旋居正的过程中，我们的一个基本思路是：</p>
<ol>
<li>输出矩阵的基本信息：rows&amp;cols</li>
<li>向右遍历</li>
<li>向下遍历</li>
<li>直到遍历完所有的元素</li>
</ol>
<p><img src="https://p.sda1.dev/18/5f73561576743bdf724935475bb82a49/QQ%E6%88%AA%E5%9B%BE20240611225505.png" alt="https://p.sda1.dev/18/5f73561576743bdf724935475bb82a49/QQ截图20240611225505.png"></p>
<h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h2><p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
</ul>
<p><img src="https://pic.leetcode-cn.com/1ad0fe88d15dc87643435eb7a17b368191725a44da4596722977e5798ace5b62-Picture2.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/193444cbca5529fcd1bafec33ef576fe1309690be2c0110de05868f4415a8723-Picture3.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/bca38a428306cb2aacc00513821e74150947ba241d9b7199bcad6c7e843a0105-Picture4.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/e5de1e07957417f13d9fae22e6fb18dd5331b50258f0297f00ba57d25651df4a-Picture5.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/2fde8dcd1481e390532995c02d3575ec9675a27390513c1540f40431dad7997a-Picture6.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1950d4c8ab6b09b62b7d5900ece4d8d4be882abebd2417a3030d172aedbc304e-Picture7.png" alt="img"></p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rows = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cols = <span class="number">0</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter the size of your matrix&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; rows &gt;&gt; cols;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix_1</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cols)); <span class="comment">// Init with size</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; matrix_2; <span class="comment">// This should be a 1D vector</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter your matrix&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            cin &gt;&gt; matrix_1[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (matrix_1.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = rows - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c = cols - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d; i &lt;= c; ++i) matrix_2.<span class="built_in">push_back</span>(matrix_1[a][i]);</span><br><span class="line">        <span class="keyword">if</span> (++a &gt; b) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = a; i &lt;= b; ++i) matrix_2.<span class="built_in">push_back</span>(matrix_1[i][c]);</span><br><span class="line">        <span class="keyword">if</span> (--c &lt; d) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &gt;= d; --i) matrix_2.<span class="built_in">push_back</span>(matrix_1[b][i]);</span><br><span class="line">        <span class="keyword">if</span> (--b &lt; a) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = b; i &gt;= a; --i) matrix_2.<span class="built_in">push_back</span>(matrix_1[i][d]);</span><br><span class="line">        <span class="keyword">if</span> (++d &gt; c) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; matrix_2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; matrix_2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) res.<span class="built_in">push_back</span>(matrix[t][i]); <span class="comment">// left to right</span></span><br><span class="line">            <span class="keyword">if</span> (++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = t; i &lt;= b; i++) res.<span class="built_in">push_back</span>(matrix[i][r]); <span class="comment">// top to bottom</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = r; i &gt;= l; i--) res.<span class="built_in">push_back</span>(matrix[b][i]); <span class="comment">// right to left</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = b; i &gt;= t; i--) res.<span class="built_in">push_back</span>(matrix[i][l]); <span class="comment">// bottom to top</span></span><br><span class="line">            <span class="keyword">if</span> (++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：模板</title>
    <url>/2024/08/10/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">n≤<span class="number">30</span> dfs+剪枝,状态压缩dp</span><br><span class="line">n≤<span class="number">100</span>， floyd,dp,高斯消元</span><br><span class="line">n≤<span class="number">1000</span> dp,二分,朴素版Dijkstra、朴素版Prim、Bellman-Ford</span><br><span class="line">n≤<span class="number">10</span>^<span class="number">4</span> 块状链表、分块、莫队</span><br><span class="line">n≤<span class="number">10</span>^<span class="number">5</span> 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、prim+heap、</span><br><span class="line">spfa、求凸包、求半平面交、二分、 CDQ分治、整体二分</span><br><span class="line">n≤<span class="number">10</span>^<span class="number">6</span> 单调队列、 hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 <span class="built_in">O</span>(nlogn)<span class="built_in">O</span>(nlogn)</span><br><span class="line">的做法：sort、树状数组、heap、dijkstra、spfa</span><br><span class="line">n≤<span class="number">10</span>^<span class="number">7</span> 双指针扫描、kmp、AC自动机、线性筛素数</span><br><span class="line">n≤<span class="number">10</span>^<span class="number">9</span> 判断质数</span><br><span class="line">n≤<span class="number">10</span>^<span class="number">18</span> 最大公约数，快速幂</span><br></pre></td></tr></table></figure>

<h2 id="1-排序"><a href="#1-排序" class="headerlink" title="1 排序"></a><strong>1</strong> <strong>排序</strong></h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l ,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[(l + r) &gt;&gt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line"><span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line"><span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line"><span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line"><span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"><span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid; <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例题-acwing-789</p>
<h2 id="2-高精度-前缀和-差分"><a href="#2-高精度-前缀和-差分" class="headerlink" title="2 高精度 前缀和 差分"></a><strong>2</strong> <strong>高精度 前缀和 差分</strong></h2><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="comment">// A, B 为倒序</span></span><br><span class="line"><span class="comment">// 计算A + B (1234 + 5678) 输入应该为 A [4, 3, 2, 1], B[8， 7， 6， 5]</span></span><br><span class="line"><span class="comment">// 得到的 C 也为倒序</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">&#123;</span><br><span class="line">t += A[i];</span><br><span class="line"><span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t); <span class="comment">// 最高位进位</span></span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="comment">// 同加法, 输入为逆序</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">&#123;</span><br><span class="line">t = A[i] - t;</span><br><span class="line"><span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 去掉先导 0</span></span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">t /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">// 去掉先导 0</span></span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">&#123;</span><br><span class="line">r = r * <span class="number">10</span> + A[i];</span><br><span class="line">C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">r %= b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">一维前缀和</span><br><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br><span class="line">二维前缀和</span><br><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">一维差分</span><br><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br><span class="line">二维差分</span><br><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] +=c</span><br></pre></td></tr></table></figure>

<p>一维差分-练习题</p>
<p>二维差分-练习题</p>
<h2 id="3-离散化-区间和并"><a href="#3-离散化-区间和并" class="headerlink" title="3 离散化 区间和并"></a><strong>3</strong> <strong>离散化 区间和并</strong></h2><h3 id="离散化-值域很大，但数据稀疏"><a href="#离散化-值域很大，但数据稀疏" class="headerlink" title="离散化 (值域很大，但数据稀疏)"></a>离散化 (值域很大，但数据稀疏)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>()); <span class="comment">// 去掉重复元素</span></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间和–-离散化-前缀和"><a href="#区间和–-离散化-前缀和" class="headerlink" title="区间和–(离散化 + 前缀和)"></a>区间和–(离散化 + 前缀和)</h3><h3 id="区间和并"><a href="#区间和并" class="headerlink" title="区间和并"></a>区间和并</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;PII&gt; res;</span><br><span class="line"><span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line"><span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">st = seg.first, ed = seg.second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"><span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>区间和并</p>
<h2 id="4-数组链表-单调栈-KMP"><a href="#4-数组链表-单调栈-KMP" class="headerlink" title="4 数组链表 单调栈 KMP"></a><strong>4</strong> <strong>数组链表 单调栈</strong> <strong>KMP</strong></h2><h3 id="数组实现静态链表，提高效率"><a href="#数组实现静态链表，提高效率" class="headerlink" title="数组实现静态链表，提高效率"></a>数组实现静态链表，提高效率</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">head = <span class="number">-1</span>;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单调栈习题</p>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ; <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>滑动窗口</p>
<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">cin &gt;&gt; m &gt;&gt; p + <span class="number">1</span> &gt;&gt; n &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 求 next 数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line"><span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>( j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line"><span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line"><span class="keyword">if</span> (j == m) &#123; <span class="comment">// 匹配成功</span></span><br><span class="line">j = ne[j];</span><br><span class="line"><span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KMP 字符串</p>
<h2 id="5-Tire树-并查集"><a href="#5-Tire树-并查集" class="headerlink" title="5 Tire树 并查集"></a><strong>5 Tire树 并查集</strong></h2><h3 id="Tire树"><a href="#Tire树" class="headerlink" title="Tire树"></a>Tire树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 这里 26 是表示所有小写字母(若有大写字母，则可修改为 52)</span></span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">p = son[p][u];</span><br><span class="line">&#125;</span><br><span class="line">cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">p = son[p][u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tire 字符串统计</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)朴素并查集：</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点,根节点满足 p[x] = x</span></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">(<span class="number">2</span>)维护size的并查集：</span><br><span class="line"><span class="type">int</span> p[N], size[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的</span></span><br><span class="line">数量</span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">p[i] = i;</span><br><span class="line">size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合, 必须先修改size, 再修改父节点。</span></span><br><span class="line">size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)]; <span class="comment">// 这行必须在前</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">(<span class="number">3</span>)维护到祖宗节点距离的并查集：</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x) &#123;</span><br><span class="line"><span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">d[x] += d[p[x]];</span><br><span class="line">p[x] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">p[i] = i;</span><br><span class="line">d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure>

<p>合并集合</p>
<p>连通块中点的数量</p>
<h3 id="手写堆"><a href="#手写堆" class="headerlink" title="手写堆"></a>手写堆</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line"><span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line"><span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> t = u;</span><br><span class="line"><span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">// 用 h[t]</span></span><br><span class="line">比较，取三者最小值</span><br><span class="line"><span class="keyword">if</span> (u != t) &#123;</span><br><span class="line"><span class="built_in">heap_swap</span>(u, t);</span><br><span class="line"><span class="built_in">down</span>(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>]) &#123;</span><br><span class="line"><span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure>

<p>堆排序</p>
<p>模拟堆</p>
<h2 id="6-字符串哈希-STL常用函数"><a href="#6-字符串哈希-STL常用函数" class="headerlink" title="6 字符串哈希 STL常用函数"></a><strong>6</strong> <strong>字符串哈希</strong> <strong>STL常用函数</strong></h2><h3 id="一般哈希"><a href="#一般哈希" class="headerlink" title="一般哈希"></a>一般哈希</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) 拉链法</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">e[idx] = x;</span><br><span class="line">ne[idx] = h[k];</span><br><span class="line">h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (e[i] == x)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">2</span>) 开放寻址法</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line"><span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">&#123;</span><br><span class="line">t ++ ;</span><br><span class="line"><span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串哈希</p>
<h3 id="C-STL常用函数"><a href="#C-STL常用函数" class="headerlink" title="C++ STL常用函数"></a>C++ STL常用函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line"><span class="built_in">size</span>() 返回元素个数</span><br><span class="line"><span class="built_in">empty</span>() 返回是否为空</span><br><span class="line"><span class="built_in">clear</span>() 清空</span><br><span class="line"><span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line"><span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line"><span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">[]</span><br><span class="line">支持比较运算，按字典序</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">first, 第一个元素</span><br><span class="line">second, 第二个元素</span><br><span class="line">支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line">string，字符串</span><br><span class="line"><span class="built_in">size</span>()/<span class="built_in">length</span>() 返回字符串长度</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">substr</span>(起始下标，(子串长度)) 返回子串</span><br><span class="line"><span class="built_in">c_str</span>() 返回字符串所在字符数组的起始地址</span><br><span class="line">queue, 队列</span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>() 向队尾插入一个元素</span><br><span class="line"><span class="built_in">front</span>() 返回队头元素</span><br><span class="line"><span class="built_in">back</span>() 返回队尾元素</span><br><span class="line"><span class="built_in">pop</span>() 弹出队头元素</span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>() 插入一个元素</span><br><span class="line"><span class="built_in">top</span>() 返回堆顶元素</span><br><span class="line"><span class="built_in">pop</span>() 弹出堆顶元素</span><br><span class="line">定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">stack, 栈</span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">push</span>() 向栈顶插入一个元素</span><br><span class="line"><span class="built_in">top</span>() 返回栈顶元素</span><br><span class="line"><span class="built_in">pop</span>() 弹出栈顶元素</span><br><span class="line">deque, 双端队列</span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line"><span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line"><span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line"><span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">[]</span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line"><span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">empty</span>()</span><br><span class="line"><span class="built_in">clear</span>()</span><br><span class="line"><span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line">set/<span class="function">multiset</span></span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">()</span> 插入一个数</span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">()</span> 查找一个数</span></span><br><span class="line"><span class="function"><span class="title">count</span><span class="params">()</span> 返回某一个数的个数</span></span><br><span class="line"><span class="function"><span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="number">1</span>)</span> 输入是一个数x，删除所有x <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function"><span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">lower_bound</span><span class="params">(x)</span> 返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function"><span class="title">upper_bound</span><span class="params">(x)</span> 返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">map/multimap</span></span><br><span class="line"><span class="function"><span class="title">insert</span><span class="params">()</span> 插入的数是一个pair</span></span><br><span class="line"><span class="function"><span class="title">erase</span><span class="params">()</span> 输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">[] 注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function"><span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br><span class="line"><span class="function">bitset, 圧位</span></span><br><span class="line"><span class="function">bitset&lt;10000&gt; s</span>;</span><br><span class="line">~, &amp;, |, ^</span><br><span class="line">&gt;&gt;, &lt;&lt;</span><br><span class="line">==, !=</span><br><span class="line">[]</span><br><span class="line"><span class="built_in">count</span>() 返回有多少个<span class="number">1</span></span><br><span class="line"><span class="built_in">any</span>() 判断是否至少有一个<span class="number">1</span></span><br><span class="line"><span class="built_in">none</span>() 判断是否全为<span class="number">0</span></span><br><span class="line"><span class="built_in">set</span>() 把所有位置成<span class="number">1</span></span><br><span class="line"><span class="built_in">set</span>(k, v) 将第k位变成v</span><br><span class="line"><span class="built_in">reset</span>() 把所有位变成<span class="number">0</span></span><br><span class="line"><span class="built_in">flip</span>() 等价于~</span><br><span class="line"><span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure>

<h2 id="7-DFS-BFS-拓扑排序"><a href="#7-DFS-BFS-拓扑排序" class="headerlink" title="7 DFS BFS 拓扑排序"></a><strong>7 DFS BFS</strong> <strong>拓扑排序</strong></h2><h3 id="树与图的存储-邻接表"><a href="#树与图的存储-邻接表" class="headerlink" title="树与图的存储(邻接表)"></a>树与图的存储(邻接表)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure>

<h3 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) 深度优先</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">2</span>) 宽度优先</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (!st[j])</span><br><span class="line">&#123;</span><br><span class="line">st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树的重心</p>
<p>图中点的层次</p>
<h3 id="拓扑排序-O-n-m"><a href="#拓扑排序-O-n-m" class="headerlink" title="拓扑排序 O(n + m)"></a>拓扑排序 O(n + m)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30010</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> q[N], d[N];</span><br><span class="line">bitset&lt;N&gt; f[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (!d[i])</span><br><span class="line">q[ ++ tt] = i;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">q[ ++ tt] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="built_in">add</span>(x, y);</span><br><span class="line">d[y] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">topsort</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line"><span class="type">int</span> j = q[i];</span><br><span class="line">f[j][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = h[j]; ~k; k = ne[k])</span><br><span class="line">f[j] |= f[e[k]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cout &lt;&lt; f[i].<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有向图的拓扑排序</p>
<h3 id="最大最小搜索"><a href="#最大最小搜索" class="headerlink" title="最大最小搜索"></a><strong>最大最小搜索</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Alice 和 Bob 正在玩井字棋游戏。</span><br><span class="line">井字棋游戏的规则很简单：两人轮流往 <span class="number">3</span>×<span class="number">3</span> 的棋盘中放棋子，Alice 放的是 X，Bob 放的是 O，Alice执</span><br><span class="line">先。</span><br><span class="line">当同一种棋子占据一行、一列或一条对角线的三个格子时，游戏结束，该种棋子的持有者获胜。</span><br><span class="line">当棋盘被填满的时候，游戏结束，双方平手。</span><br><span class="line">Alice 设计了一种对棋局评分的方法：</span><br><span class="line">对于 Alice 已经获胜的局面，评估得分为(棋盘上的空格子数+<span class="number">1</span>)；</span><br><span class="line">对于 Bob 已经获胜的局面，评估得分为 -(棋盘上的空格子数+<span class="number">1</span>)；</span><br><span class="line">对于平局的局面，评估得分为 <span class="number">0</span>；</span><br><span class="line">输入格式</span><br><span class="line">输入的第一行包含一个正整数 T，表示数据的组数。</span><br><span class="line">每组数据输入有 <span class="number">3</span> 行，每行有 <span class="number">3</span> 个整数，用空格分隔，分别表示棋盘每个格子的状态。<span class="number">0</span> 表示格子为</span><br><span class="line">空，<span class="number">1</span> 表示格子中为X，<span class="number">2</span> 表示格子中为 O。保证不会出现其他状态。</span><br><span class="line">保证输入的局面合法。(即保证输入的局面可以通过行棋到达，且保证没有双方同时获胜的情况).保证输</span><br><span class="line">入的局面轮到 Alice 行棋。</span><br><span class="line">输出格式</span><br><span class="line">对于每组数据，输出一行一个整数，表示当前局面的得分</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line"><span class="keyword">if</span> (g[i][j] == x)</span><br><span class="line">s ++ ;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line"><span class="keyword">if</span> (g[j][i] == x)</span><br><span class="line">s ++ ;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (g[<span class="number">0</span>][<span class="number">0</span>] == x &amp;&amp; g[<span class="number">1</span>][<span class="number">1</span>] == x &amp;&amp; g[<span class="number">2</span>][<span class="number">2</span>] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (g[<span class="number">2</span>][<span class="number">0</span>] == x &amp;&amp; g[<span class="number">1</span>][<span class="number">1</span>] == x &amp;&amp; g[<span class="number">0</span>][<span class="number">2</span>] == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">evaluate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!g[i][j])</span><br><span class="line">s ++ ;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(<span class="number">1</span>)) <span class="keyword">return</span> s + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(<span class="number">2</span>)) <span class="keyword">return</span> -(s + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">evaluate</span>();</span><br><span class="line"><span class="keyword">if</span> (t != INF) <span class="keyword">return</span> t;</span><br><span class="line"><span class="keyword">if</span> (!u) <span class="comment">// Alice</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!g[i][j])</span><br><span class="line">&#123;</span><br><span class="line">g[i][j] = <span class="number">1</span>;</span><br><span class="line">res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(<span class="number">1</span>));</span><br><span class="line">g[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// Bob</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> res = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!g[i][j])</span><br><span class="line">&#123;</span><br><span class="line">g[i][j] = <span class="number">2</span>;</span><br><span class="line">res = <span class="built_in">min</span>(res, <span class="built_in">dfs</span>(<span class="number">0</span>));</span><br><span class="line">g[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line">cin &gt;&gt; T;</span><br><span class="line"><span class="keyword">while</span> (T -- )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j ++ )</span><br><span class="line">cin &gt;&gt; g[i][j];</span><br><span class="line">cout &lt;&lt; <span class="built_in">dfs</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-最短路算法"><a href="#8-最短路算法" class="headerlink" title="8 最短路算法"></a><strong>8</strong> <strong>最短路算法</strong></h2><h3 id="朴素dijkstra-算法"><a href="#朴素dijkstra-算法" class="headerlink" title="朴素dijkstra*算法"></a><strong>朴素dijkstra*算法</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>; <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">t = j;</span><br><span class="line"><span class="comment">// 用t更新其他点的距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">st[t] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="comment">// 求最短路，初始化距离为极大</span></span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">g[x][y] = <span class="built_in">min</span>(g[x][y], z);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dijkstra 求最短路</p>
<h3 id="堆优化版dijkstra"><a href="#堆优化版dijkstra" class="headerlink" title="堆优化版dijkstra"></a><strong>堆优化版dijkstra</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(nm), n表示点数，m表示边数</span></span><br><span class="line"><span class="comment">// 注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"><span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"><span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">st[ver] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">&#123;</span><br><span class="line">dist[j] = distance + w[i];</span><br><span class="line">heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dijkstra 求最短路II</p>
<h3 id="拆点"><a href="#拆点" class="headerlink" title="拆点"></a><strong>拆点</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">小明和小芳出去乡村玩，小明负责开车，小芳来导航。</span><br><span class="line">小芳将可能的道路分为大道和小道。</span><br><span class="line">大道比较好走，每走 <span class="number">1</span> 公里小明会增加 <span class="number">1</span> 的疲劳度。</span><br><span class="line">小道不好走，如果连续走小道，小明的疲劳值会快速增加，连续走 s 公里小明会增加 s2 的疲劳度。</span><br><span class="line">现在小芳拿到了地图，请帮助她规划一个开车的路线，使得按这个路线开车小明的疲劳度最小。</span><br><span class="line">输入格式</span><br><span class="line">输入的第一行包含两个整数 n,m，分别表示路口的数量和道路的数量。路口由 <span class="number">1</span> 至 n 编号，小明需要</span><br><span class="line">开车从 <span class="number">1</span> 号路口到 n 号路口。</span><br><span class="line">接下来 m 行描述道路，每行包含四个整数 t,a,b,c，表示一条类型为 t，连接 a 与 b 两个路口，</span><br><span class="line">长度为 c 公里的双向道路。其中 t 为 <span class="number">0</span> 表示大道，t 为 <span class="number">1</span> 表示小道。</span><br><span class="line">保证 <span class="number">1</span> 号路口和 n 号路口是连通的。</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最优路线下小明的疲劳度。</span><br><span class="line">数据范围</span><br><span class="line">对于 <span class="number">30</span>% 的评测用例，<span class="number">1</span>≤n≤<span class="number">8</span>，<span class="number">1</span>≤m≤<span class="number">10</span>；</span><br><span class="line">对于另外 <span class="number">20</span>% 的评测用例，不存在小道；</span><br><span class="line">对于另外 <span class="number">20</span>% 的评测用例，所有的小道不相交；</span><br><span class="line">对于所有评测用例，<span class="number">1</span>≤n≤<span class="number">500</span>，<span class="number">1</span>≤m≤<span class="number">10</span>^<span class="number">5</span>，<span class="number">1</span>≤a,b≤n，t 是 <span class="number">0</span> 或 <span class="number">1</span>，c≤<span class="number">10</span>^<span class="number">5</span>。</span><br><span class="line">保证答案不超过 <span class="number">10</span>^<span class="number">6</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 答案不超过 10^6, 因此小路最大连续距离不超过 1000, 考虑拆点</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">200010</span>, INF = <span class="number">1e6</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N][<span class="number">1010</span>];</span><br><span class="line"><span class="type">bool</span> st[N][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y, v;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Node&amp; t) <span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> v &gt; t.v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, f[idx] = t, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">priority_queue&lt;Node&gt; heap;</span><br><span class="line">heap.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (heap.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">heap.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span> (st[t.x][t.y]) <span class="keyword">continue</span>;</span><br><span class="line">st[t.x][t.y] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t.x]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> x = e[i], y = t.y;</span><br><span class="line"><span class="keyword">if</span> (f[i]) &#123;</span><br><span class="line">y += w[i];</span><br><span class="line"><span class="keyword">if</span> (y &lt;= <span class="number">1000</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (dist[x][y] &gt; t.v - t.y * t.y + y * y) &#123;</span><br><span class="line">dist[x][y] = t.v - t.y * t.y + y * y;</span><br><span class="line"><span class="keyword">if</span> (dist[x][y] &lt;= INF)</span><br><span class="line">heap.<span class="built_in">push</span>(&#123;x, y, dist[x][y]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dist[x][<span class="number">0</span>] &gt; t.v + w[i]) &#123;</span><br><span class="line">dist[x][<span class="number">0</span>] = t.v + w[i];</span><br><span class="line"><span class="keyword">if</span> (dist[x][<span class="number">0</span>] &lt;= INF)</span><br><span class="line">heap.<span class="built_in">push</span>(&#123;x, <span class="number">0</span>, dist[x][<span class="number">0</span>]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t, a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;t, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(t, a, b, c), <span class="built_in">add</span>(t, b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dijkstra</span>();</span><br><span class="line"><span class="type">int</span> res = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i ++ ) res = <span class="built_in">min</span>(res, dist[n][i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a><strong>Bellman-Ford</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> last[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ ) &#123; <span class="comment">// 循环 K 次, 从1号点到n号点的最多经过k条边的最短距离</span></span><br><span class="line"><span class="built_in">memcpy</span>(last, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ ) &#123;</span><br><span class="line"><span class="keyword">auto</span> e = edges[j];</span><br><span class="line">dist[e.b] = <span class="built_in">min</span>(dist[e.b], last[e.a] + e.c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">edges[i] = &#123;a, b, c&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bellman_ford</span>();</span><br><span class="line"><span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dist[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a><strong>spfa</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">G 国国王来中国参观后，被中国的高速铁路深深的震撼，决定为自己的国家也建设一个高速铁路系统。建设高</span><br><span class="line">速铁路投入非常大，为了节约建设成本，G 国国王决定不新建铁路，而是将已有的铁路改造成高速铁路。</span><br><span class="line">现在，请你为 G 国国王提供一个方案，将现有的一部分铁路改造成高速铁路，使得任何两个城市间都可以通</span><br><span class="line">过高速铁路到达，而且从所有城市乘坐高速铁路到首都的最短路程和原来一样长。</span><br><span class="line">请你告诉 G 国国王在这些条件下最少要改造多长的铁路。</span><br><span class="line">输入格式</span><br><span class="line">输入的第一行包含两个整数 n,m，分别表示 G 国城市的数量和城市间铁路的数量。所有的城市由 <span class="number">1</span> 到</span><br><span class="line">n 编号，首都为 <span class="number">1</span> 号。</span><br><span class="line">接下来 m 行，每行三个整数 a,b,c，表示城市 a 和城市 b 之间有一条长度为 c 的双向铁路。这条</span><br><span class="line">铁路不会经过 a 和 b 以外的城市。</span><br><span class="line">输出格式</span><br><span class="line">输出一行，表示在满足条件的情况下最少要改造的铁路长度</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dist[N], q[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 做完spfa之后, dist数组表示各个点到 源点 的最短路径距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (hh != tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line">st[t] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i]) &#123;</span><br><span class="line">dist[j] = dist[t] + w[i];</span><br><span class="line"><span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">q[tt ++ ] = j;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line">st[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">spfa</span>();</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 反推哪些边被选中, 很关键</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">2</span>; a &lt;= n; a ++ ) &#123;</span><br><span class="line"><span class="type">int</span> minw = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = h[a]; ~j; j = ne[j]) &#123;</span><br><span class="line"><span class="type">int</span> b = e[j];</span><br><span class="line"><span class="keyword">if</span> (dist[a] == dist[b] + w[j])</span><br><span class="line">minw = <span class="built_in">min</span>(minw, w[j]);</span><br><span class="line">&#125;</span><br><span class="line">res += minw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a><strong>Floyd</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, Q;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="comment">// 初始化：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line"><span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理结果时(查询 a b)</span></span><br><span class="line"><span class="keyword">if</span> (d[a][b] &gt; INF / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>); <span class="comment">// 可能存在 INF -&gt;(-2) INF 的情况</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, d[a][b]);</span><br></pre></td></tr></table></figure>

<p>Floyd求最短路</p>
<h3 id="Floyd-传递闭包"><a href="#Floyd-传递闭包" class="headerlink" title="Floyd 传递闭包"></a><strong>Floyd</strong> <strong>传递闭包</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">给定 n 个变量和 m 个不等式。其中 n 小于等于 <span class="number">26</span>，变量分别用前 n 的大写英文字母表示。</span><br><span class="line">不等式之间具有传递性，即若 A&gt;B 且 B&gt;C，则 A&gt;C。请从前往后遍历每对关系，每次遍历时判断：</span><br><span class="line"><span class="number">1.</span> 如果能够确定全部关系且无矛盾，则结束循环，输出确定的次序；</span><br><span class="line"><span class="number">2.</span> 如果发生矛盾，则结束循环，输出有矛盾；</span><br><span class="line"><span class="number">3.</span> 如果循环结束时没有发生上述两种情况，则输出无定解。</span><br><span class="line">输入格式</span><br><span class="line">输入包含多组测试数据。每组测试数据，第一行包含两个整数 n 和 m。接下来 m 行，每行包含一个不</span><br><span class="line">等式，不等式全部为小于关系。当输入一行 <span class="number">0</span> <span class="number">0</span> 时，表示输入终止。</span><br><span class="line">输出格式</span><br><span class="line">每组数据输出一个占一行的结果。结果可能为下列三种之一：</span><br><span class="line"><span class="number">1.</span> 如果可以确定两两之间的关系，则输出 <span class="string">&quot;Sorted sequence determined after t</span></span><br><span class="line"><span class="string">relations: yyy...y.&quot;</span>,其中<span class="string">&#x27;t&#x27;</span>指迭代次数，<span class="string">&#x27;yyy...y&#x27;</span>是指升序排列的所有变量。</span><br><span class="line"><span class="number">2.</span> 如果有矛盾，则输出： <span class="string">&quot;Inconsistency found after t relations.&quot;</span>，其中<span class="string">&#x27;t&#x27;</span>指迭代次</span><br><span class="line">数。</span><br><span class="line"><span class="number">3.</span> 如果没有矛盾，且不能确定两两之间的关系，则输出 <span class="string">&quot;Sorted sequence cannot be</span></span><br><span class="line"><span class="string">determined.&quot;</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">26</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> g[N][N], d[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memcpy</span>(d, g, <span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">d[i][j] |= d[i][k] &amp;&amp; d[k][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (d[i][i])</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!d[i][j] &amp;&amp; !d[j][i])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get_min</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!st[j] &amp;&amp; d[j][i]) &#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">st[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m) &#123;</span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="type">int</span> type = <span class="number">0</span>, t;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) &#123;</span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>];</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"><span class="type">int</span> a = str[<span class="number">0</span>] - <span class="string">&#x27;A&#x27;</span>, b = str[<span class="number">2</span>] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!type) &#123;</span><br><span class="line">g[a][b] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">floyd</span>();</span><br><span class="line">type = <span class="built_in">check</span>();</span><br><span class="line"><span class="keyword">if</span> (type) t = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!type) <span class="built_in">puts</span>(<span class="string">&quot;Sorted sequence cannot be determined.&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;Inconsistency found after %d relations.\n&quot;</span>,</span><br><span class="line">t);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Sorted sequence determined after %d relations: &quot;</span>, t);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">get_min</span>());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-最小生成树"><a href="#9-最小生成树" class="headerlink" title="9 最小生成树"></a><strong>9</strong> <strong>最小生成树</strong></h2><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a><strong>Prim</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">// 时间复杂度是 O(n^2 + m), n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">t = j;</span><br><span class="line"><span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">st[t] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 需要初始化 g[][] :</span></span><br><span class="line"><span class="comment">// g[i][i] = 0, g[i][j] = INF</span></span><br></pre></td></tr></table></figure>

<p>Prim求最小生成树</p>
<h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a><strong>Kruskal</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">// 时间复杂度是 O(mlogm), n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123; <span class="comment">// 存储边</span></span><br><span class="line"><span class="type">int</span> a, b, w;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i; <span class="comment">// 初始化并查集</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line"><span class="keyword">if</span> (a != b) &#123; <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">p[a] = b;</span><br><span class="line">res += w;</span><br><span class="line">cnt ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kruskal最小生成树</p>
<h2 id="10-二分图"><a href="#10-二分图" class="headerlink" title="10 二分图"></a><strong>10</strong> <strong>二分图</strong></h2><p>二分图的一个等价定义是：不含有 含奇数条边的环 的图</p>
<h3 id="染色法判别二分图"><a href="#染色法判别二分图" class="headerlink" title="染色法判别二分图"></a><strong>染色法判别二分图</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n; <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N]; <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">color[u] = c;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> vis[<span class="number">101</span>], color[<span class="number">101</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;graph)</span></span>&#123;</span><br><span class="line">q.<span class="built_in">push</span>(u);</span><br><span class="line">color[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> v : graph[u])&#123;</span><br><span class="line"><span class="keyword">if</span> (color[v] != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (color[v] == color[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q.<span class="built_in">push</span>(v);</span><br><span class="line">color[v] = (color[u] == <span class="number">1</span>)? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line"><span class="keyword">if</span> (!color[i] &amp;&amp; !<span class="built_in">bfs</span>(i, graph)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="匈牙利算法-二分图最大匹配算法"><a href="#匈牙利算法-二分图最大匹配算法" class="headerlink" title="匈牙利算法(二分图最大匹配算法)"></a><strong>匈牙利算法(二分图最大匹配算法)</strong></h3><p>最小点覆盖 : 无向图中选取最少的点，使得覆盖掉所有的边</p>
<p>最大独立集 : 无向图中选取最多的点，使得选出的点没有边</p>
<p>最大匹配数 &#x3D; 最小点覆盖 &#x3D; 总点数 - 最大独立集 &#x3D; 总点数 - 最小路径点覆盖</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2; <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx; <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向</span></span><br><span class="line">第二个集合的边，所以这里只用存一个方向的边</span><br><span class="line"><span class="type">int</span> match[N]; <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (!st[j])</span><br><span class="line">&#123;</span><br><span class="line">st[j] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">&#123;</span><br><span class="line">match[j] = x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分图的最大匹配</p>
<h2 id="11-背包问题"><a href="#11-背包问题" class="headerlink" title="11 背包问题"></a><strong>11</strong> <strong>背包问题</strong></h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a><strong>01背包</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"><span class="comment">// 状态转移方程 dp[i][j] = max(dp[i-1][j-w] + v, dp[i-1][j-w])</span></span><br><span class="line"><span class="comment">// 优化版本, 注意第二层循环, 思考优化的根据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; --j)</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>01背包模板题</p>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a><strong>完全背包</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[i,j] = max(f[i-1,j],f[i-1,j-v]+w,f[i-1,j-2*v]+2*w,f[i-1,j-3*v]+3*w, .....)</span></span><br><span class="line"><span class="comment">f[i,j-v]= max(f[i-1,j-v],f[i-1,j-2*v]+w,f[i-1,j-2*v]+2*w,.....)</span></span><br><span class="line"><span class="comment">由上两式，可得出如下递推关系：</span></span><br><span class="line"><span class="comment">f[i][j]=max(f[i-1][j], f[i,j-v]+w)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = v[i]; j &lt;= m; ++j) &#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完全背包模板题</p>
<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a><strong>多重背包</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">有 N 种物品和一个容量是 V 的背包。</span><br><span class="line">第 i 种物品最多有 s_i 件，每件体积是 v_i，价值是 w_i。</span><br><span class="line">求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。</span><br><span class="line">输出最大价值。</span><br><span class="line">输入格式</span><br><span class="line">第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。</span><br><span class="line">接下来有 N 行，每行三个整数 vi,wi,si，用空格隔开，分别表示第 i 种物品的体积、价值和数量。</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++ )</span><br><span class="line">f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line">cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a><strong>分组背包</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">有 N 组物品和一个容量是 V 的背包。</span><br><span class="line">每组物品有若干个，同一组内的物品最多只能选一个。</span><br><span class="line">每件物品的体积是 v_ij，价值是 w_ij，其中 i 是组号，j 是组内编号。</span><br><span class="line">求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。</span><br><span class="line">输出最大价值。</span><br><span class="line">输入格式</span><br><span class="line">第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。</span><br><span class="line">接下来有 N 组数据：</span><br><span class="line">每组数据第一行有一个整数 S_i，表示第 i 个物品组的物品数量；</span><br><span class="line">每组数据接下来有 S_i 行，每行有两个整数 v_ij,w_ij，用空格隔开，分别表示第 i 个物品组的第</span><br><span class="line">j 个物品的体积和价值；</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最大价值</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N], s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line">cin &gt;&gt; s[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; j ++ )</span><br><span class="line">cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j -- )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; s[i]; k ++ )</span><br><span class="line"><span class="keyword">if</span> (v[i][k] &lt;= j)</span><br><span class="line">f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-数学相关"><a href="#12-数学相关" class="headerlink" title="12 数学相关"></a><strong>12</strong> <strong>数学相关</strong></h2><h3 id="判定质数"><a href="#判定质数" class="headerlink" title="判定质数"></a>判定质数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line"><span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求区间内-素数个数-线性筛法"><a href="#求区间内-素数个数-线性筛法" class="headerlink" title="求区间内 素数个数 (线性筛法)"></a>求区间内 素数个数 (线性筛法)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(n)</span></span><br><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++) &#123;</span><br><span class="line">st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求 m^k mod p，时间复杂度 O(logk)。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line"><span class="keyword">while</span> (k) &#123;</span><br><span class="line"><span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * t % p;</span><br><span class="line">t = t * t % p;</span><br><span class="line">k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c[a][b] 表示从a个苹果中选b个的方案数</span></span><br><span class="line"><span class="comment">// 注意 溢出问题, 通常会在下面代码基础上取模</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++ )</span><br><span class="line"><span class="keyword">if</span> (!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展欧几里得算法, 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="comment">// 返回值为 gcd(a, b）</span></span><br><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a, LL b, LL &amp;x, LL &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) &#123;</span><br><span class="line">x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">LL d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">y -= (a / b) * x;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-线段树"><a href="#13-线段树" class="headerlink" title="13 线段树"></a><strong>13</strong> <strong>线段树</strong></h2><h3 id="朴素版"><a href="#朴素版" class="headerlink" title="朴素版"></a><strong>朴素版</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123; <span class="comment">// 根据问题具体选择存储内容</span></span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">LL sum, add;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 往上传一层</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 往下传一层</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (root.add) &#123;</span><br><span class="line">left.add += root.add, left.sum += (LL)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">right.add += root.add, right.sum += (LL)(right.r - right.l + <span class="number">1</span>) *</span><br><span class="line">root.add;</span><br><span class="line">root.add = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建线段树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="comment">// 固定写法</span></span><br><span class="line"><span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, a[r], <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tr[u] = &#123;l, r&#125;; <span class="comment">// 左右端点初始化</span></span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) &#123;</span><br><span class="line">tr[u].sum += (LL)(tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">tr[u].add += d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// 分裂</span></span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间查询</span></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">LL sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="comment">/*-----------------------------------具体看----------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r, d;</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line"><span class="keyword">if</span> (*op == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可在此测试代码</p>
<h3 id="支持加法和乘法"><a href="#支持加法和乘法" class="headerlink" title="支持加法和乘法"></a><strong>支持加法和乘法</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, p, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line"><span class="type">int</span> sum, add, mul;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">tr[u].sum = (tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(Node &amp;t, <span class="type">int</span> add, <span class="type">int</span> mul)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先乘后加</span></span><br><span class="line"><span class="comment">// 修改前 x = x * a + b</span></span><br><span class="line"><span class="comment">// 修改后希望是 x = ((x * a) + b) * c + d = x * (a * c) + b * c + d</span></span><br><span class="line">t.sum = ((LL)t.sum * mul + (LL)(t.r - t.l + <span class="number">1</span>) * add) % p;</span><br><span class="line">t.mul = (LL)t.mul * mul % p;</span><br><span class="line">t.add = ((LL)t.add * mul + add) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line"><span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, a[r], <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> add, <span class="type">int</span> mul)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="built_in">eval</span>(tr[u], add, mul);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, add, mul);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, add, mul);</span><br><span class="line"><span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"><span class="built_in">pushdown</span>(u);</span><br><span class="line"><span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line"><span class="keyword">if</span> (r &gt; mid) sum = (sum + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r)) % p;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;p);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> t, l, r, d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;t, &amp;l, &amp;r);</span><br><span class="line"><span class="keyword">if</span> (t == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, l, r, <span class="number">0</span>, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>, l, r, d, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可在此测试代码</p>
<h2 id="14-网络流"><a href="#14-网络流" class="headerlink" title="14 网络流"></a><strong>14</strong> <strong>网络流</strong></h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">对于任意一张有向图（也就是网络），其中有N个点、M条边以及源点S和汇点<span class="function">T</span></span><br><span class="line"><span class="function"><span class="title">c</span><span class="params">(x,y)</span>称为边的容量</span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(x,y)</span>称为边的流量</span></span><br><span class="line"><span class="function">流函数<span class="title">f</span><span class="params">(x,y)</span>三大性质:</span></span><br><span class="line"><span class="function">容量限制：每条边的流量总不可能大于该边的容量的（不然水管就爆了）</span></span><br><span class="line"><span class="function">斜对称：正向边的流量=</span>反向边的流量（反向边后面会具体讲）</span><br><span class="line">流量守恒：正向的所有流量和=反向的所有流量和（就是总量始终不变）</span><br><span class="line">最大流</span><br><span class="line">使得整个网络流量之和最大的流函数称为网络的最大流，此时的流量和被称为网络的最大流量</span><br><span class="line">增广路</span><br><span class="line">若一条从S到T的路径上所有边的剩余容量都大于<span class="number">0</span>，则称这样的路径为一条增广路</span><br><span class="line">反向边</span><br><span class="line">因为可能一条边可以被包含于多条增广路径，所以为了寻找所有的增广路经我们就要让这一条边有多次被</span><br><span class="line">选择的机会</span><br><span class="line">构建反向边则是这样一个机会，相当于给程序一个反悔的机会。</span><br><span class="line">残量网络</span><br><span class="line">在任意时刻，网络中所有节点以及剩余容量大于<span class="number">0</span>的边构成的子图被称为残量网络</span><br><span class="line">邻接表“成对存储”</span><br><span class="line">将正向边和反向边存在“<span class="number">2</span>和<span class="number">3</span>”、“<span class="number">4</span>和<span class="number">5</span>”、“<span class="number">6</span>和<span class="number">7</span>”。因为在更新边权的时候，我们就可以直接使用<span class="keyword">xor</span>的</span><br><span class="line">方</span><br><span class="line">式，找到对应的正向边和反向边</span><br></pre></td></tr></table></figure>

<h3 id="知识点梳理"><a href="#知识点梳理" class="headerlink" title="知识点梳理"></a><strong>知识点梳理</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 基本概念</span><br><span class="line"><span class="number">1.1</span> 流网络，不考虑反向边</span><br><span class="line"><span class="number">1.2</span> 可行流，不考虑反向边</span><br><span class="line"><span class="number">1.2</span><span class="number">.1</span> 两个条件：容量限制、流量守恒</span><br><span class="line"><span class="number">1.2</span><span class="number">.2</span> 可行流的流量指从源点流出的流量 - 流入源点的流量</span><br><span class="line"><span class="number">1.2</span><span class="number">.3</span> 最大流是指最大可行流</span><br><span class="line"><span class="number">1.3</span> 残留网络，考虑反向边，残留网络的可行流f<span class="number">&#x27;</span> + 原图的可行流f = 原题的另一个可行流</span><br><span class="line">(<span class="number">1</span>) |f<span class="number">&#x27;</span> + f| = |f<span class="number">&#x27;</span>| + |f|</span><br><span class="line">(<span class="number">2</span>) |f<span class="number">&#x27;</span>| 可能是负数</span><br><span class="line"><span class="number">1.4</span> 增广路径</span><br><span class="line"><span class="number">1.5</span> 割</span><br><span class="line"><span class="number">1.5</span><span class="number">.1</span> 割的定义</span><br><span class="line"><span class="number">1.5</span><span class="number">.2</span> 割的容量，不考虑反向边，“最小割”是指容量最小的割。</span><br><span class="line"><span class="number">1.5</span><span class="number">.3</span> 割的流量，考虑反向边，<span class="built_in">f</span>(S, T) &lt;= <span class="built_in">c</span>(S, T)</span><br><span class="line"><span class="number">1.5</span><span class="number">.4</span> 对于任意可行流f，任意割[S, T]，|f| = <span class="built_in">f</span>(S, T)</span><br><span class="line"><span class="number">1.5</span><span class="number">.5</span> 对于任意可行流f，任意割[S, T]，|f| &lt;= <span class="built_in">c</span>(S, T)</span><br><span class="line"><span class="number">1.5</span><span class="number">.6</span> 最大流最小割定理</span><br><span class="line">(<span class="number">1</span>) 可以流f是最大流</span><br><span class="line">(<span class="number">2</span>) 可行流f的残留网络中不存在增广路</span><br><span class="line">(<span class="number">3</span>) 存在某个割[S, T]，|f| = <span class="built_in">c</span>(S, T)</span><br><span class="line"><span class="number">1.6</span>. 算法<span class="number">1.6</span><span class="number">.1</span> EK <span class="built_in">O</span>(nm^<span class="number">2</span>)</span><br><span class="line"><span class="number">1.6</span><span class="number">.2</span> Dinic <span class="built_in">O</span>(n^<span class="number">2</span>m)</span><br><span class="line"><span class="number">1.7</span> 应用</span><br><span class="line"><span class="number">1.7</span><span class="number">.1</span> 二分图</span><br><span class="line">(<span class="number">1</span>) 二分图匹配</span><br><span class="line">(<span class="number">2</span>) 二分图多重匹配</span><br><span class="line"><span class="number">1.7</span><span class="number">.2</span> 上下界网络流</span><br><span class="line">(<span class="number">1</span>) 无源汇上下界可行流</span><br><span class="line">(<span class="number">2</span>) 有源汇上下界最大流</span><br><span class="line">(<span class="number">3</span>) 有源汇上下界最小流</span><br><span class="line"><span class="number">1.7</span><span class="number">.3</span> 多源汇最大流</span><br></pre></td></tr></table></figure>

<h3 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a><strong>Dinic算法</strong></h3><ol>
<li><p>在残量网络上 BFS 求出节点的层次，构造分层图</p>
</li>
<li><p>在分层图上 DFS 寻找增广路，在回溯时同时更新边权</p>
</li>
</ol>
<p><strong>代码实现 固定风格</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">200010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], ne[M], idx; <span class="comment">// f[N] 为 容量</span></span><br><span class="line"><span class="type">int</span> q[N], d[N], cur[N]; <span class="comment">// 队列 深度 当前弧</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">e[idx] = a, f[idx] = <span class="number">0</span>, ne[idx] = h[b], h[b] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (d[ver] == <span class="number">-1</span> &amp;&amp; f[i]) &#123;</span><br><span class="line">d[ver] = d[t] + <span class="number">1</span>;</span><br><span class="line">cur[ver] = h[ver];</span><br><span class="line"><span class="keyword">if</span> (ver == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[ ++ tt] = ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == T) <span class="keyword">return</span> limit;</span><br><span class="line"><span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;</span><br><span class="line">cur[u] = i; <span class="comment">// 当前弧优化</span></span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (d[ver] == d[u] + <span class="number">1</span> &amp;&amp; f[i]) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">find</span>(ver, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line"><span class="keyword">if</span> (!t) d[ver] = <span class="number">-1</span>;</span><br><span class="line">f[i] -= t, f[i ^ <span class="number">1</span>] += t, flow += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> r = <span class="number">0</span>, flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123; <span class="comment">// 存在增广路时循环继续</span></span><br><span class="line"><span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF)) r += flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">dinic</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大流模板题"><a href="#最大流模板题" class="headerlink" title="最大流模板题"></a>最大流模板题</h3><p>参考题解</p>
<p><strong>最小割</strong></p>
<p><img src="https://i.postimg.cc/jjwJm64s/1ac825e5ccc9522ec3584582b196aa00.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">这片管网由 n 行 m 列节点（红色，图中 n=<span class="number">5</span>，m=<span class="number">6</span>），横向管道（紫色）和纵向管道（橙色）构成。</span><br><span class="line">行和列分别用 <span class="number">1</span> 到 n 的整数和 <span class="number">1</span> 到 m 的整数表示。</span><br><span class="line">第 <span class="number">1</span> 行的任何一个节点均可以抽取湖水，湖水到达第 n 行的任何一个节点即算作引入了城市。</span><br><span class="line">除第一行和最后一行外，横向相邻或纵向相邻的两个节点之间一定有一段管道，每一段管道都有各自的最大的</span><br><span class="line">抽水速率，并需要根据情况选择抽水还是放水。</span><br><span class="line">对于纵向的管道（橙色），允许从上方向下方抽水或从下方向上方放水；如果从图中的上方向下方抽水，那么</span><br><span class="line">单位时间内能通过的水量不能超过管道的最大速率；如果从下方向上方放水，因为下方海拔较高，因此可以允</span><br><span class="line">许有任意大的水量。</span><br><span class="line">对于横向的管道（紫色），允许从左向右或从右向左抽水，不允许放水，两种情况下单位时间流过的水量都不</span><br><span class="line">能超过管道的最大速率。</span><br><span class="line">现在 MF 城市的水务负责人想知道，在已知每个管道单位时间容量的情况下，MF 城每单位时间最多可以引入</span><br><span class="line">多少的湖水</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大流 -&gt; 平面图最小割 -&gt; 最短路 -&gt; 分层图最短路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5050</span>;</span><br><span class="line"><span class="type">int</span> n, m, A, B, Q, X;</span><br><span class="line"><span class="type">int</span> r[N][N], c[N][N];</span><br><span class="line">LL d[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;A, &amp;B, &amp;Q, &amp;X);</span><br><span class="line"><span class="comment">// 边权</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">    c[i][j] = X = ((LL)A * X + B) % Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">1</span>; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">1</span>; j ++ )</span><br><span class="line">r[i][j] = X = ((LL)A * X + B) % Q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )</span><br><span class="line">d[i] += c[i][j];</span><br><span class="line"><span class="comment">// 只可能单向更新</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i ++ )</span><br><span class="line">d[i] = <span class="built_in">min</span>(d[i], d[i - <span class="number">1</span>] + r[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i; i -- )</span><br><span class="line">d[i] = <span class="built_in">min</span>(d[i], d[i + <span class="number">1</span>] + r[i + <span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line">LL res = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ ) res = <span class="built_in">min</span>(res, d[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无源汇上下界可行流"><a href="#无源汇上下界可行流" class="headerlink" title="无源汇上下界可行流"></a><strong>无源汇上下界可行流</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">问题描述</span><br><span class="line">给定一个包含 n 个点 m 条边的有向图，每条边都有一个流量下界和流量上界。</span><br><span class="line">求一种可行方案使得在所有点满足流量平衡条件的前提下，所有边满足流量限制。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含两个整数 n 和 m。接下来 m 行，每行包含四个整数 a,b,c,d 表示点 a 和 b 之间存在</span><br><span class="line">一条有向边，该边的流量下界为 c，流量上界为 d。点编号从 <span class="number">1</span> 到 n。</span><br><span class="line">输出格式</span><br><span class="line">如果存在可行方案，则第一行输出 YES，接下来 m 行，每行输出一个整数，其中第 i 行的整数表示输</span><br><span class="line">入的第 i 条边的流量。</span><br><span class="line">如果不存在可行方案，直接输出一行 NO。</span><br><span class="line">如果可行方案不唯一，则输出任意一种方案即可</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">211</span>, M = (<span class="number">10200</span> + N) * <span class="number">2</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], l[M], ne[M], idx; <span class="comment">// l[M] 存储容量下界</span></span><br><span class="line"><span class="type">int</span> q[N], d[N], cur[N], A[N]; <span class="comment">// A[N] 存储第 i 个点的出入度容量差</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> </span>&#123; <span class="comment">// c : 容量下界 d : 容量上界</span></span><br><span class="line">e[idx] = b, f[idx] = d - c, l[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">    e[idx] = a, f[idx] = <span class="number">0</span>, ne[idx] = h[b], h[b] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (d[ver] == <span class="number">-1</span> &amp;&amp; f[i]) &#123;</span><br><span class="line">d[ver] = d[t] + <span class="number">1</span>;</span><br><span class="line">cur[ver] = h[ver];</span><br><span class="line"><span class="keyword">if</span> (ver == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[ ++ tt] = ver;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == T) <span class="keyword">return</span> limit;</span><br><span class="line"><span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;</span><br><span class="line">cur[u] = i;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (d[ver] == d[u] + <span class="number">1</span> &amp;&amp; f[i]) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">find</span>(ver, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line"><span class="keyword">if</span> (!t) d[ver] = <span class="number">-1</span>;</span><br><span class="line">f[i] -= t, f[i ^ <span class="number">1</span>] += t, flow += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> r = <span class="number">0</span>, flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>()) <span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF)) r += flow;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">S = <span class="number">0</span>, T = n + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"><span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">A[a] -= c, A[b] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 注意流网络的处理 减去下界需要补边来保持流量守</span></span><br><span class="line">恒</span><br><span class="line"><span class="keyword">if</span> (A[i] &gt; <span class="number">0</span>) <span class="built_in">add</span>(S, i, <span class="number">0</span>, A[i]), tot += A[i];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span>) <span class="built_in">add</span>(i, T, <span class="number">0</span>, -A[i]);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dinic</span>() != tot) <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * <span class="number">2</span>; i += <span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[i ^ <span class="number">1</span>] + l[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>有源汇上下界最大流</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">问题描述</span><br><span class="line">给定一个包含 n 个点 m 条边的有向图，每条边都有一个流量下界和流量上界。</span><br><span class="line">给定源点 S 和汇点 T，求源点到汇点的最大流。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含四个整数 n,m,S,T。接下来 m 行，每行包含四个整数 a,b,c,d 表示点 a 和 b 之间存</span><br><span class="line">在一条有向边，该边的流量下界为 c，流量上界为 d。点编号从 <span class="number">1</span> 到 n。</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数表示最大流。如果无解，则输出 No Solution。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, M = (N + <span class="number">10000</span>) * <span class="number">2</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], cur[N], A[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">e[idx] = a, f[idx] = <span class="number">0</span>, ne[idx] = h[b], h[b] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, cur[S] = h[S];</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (d[ver] == <span class="number">-1</span> &amp;&amp; f[i]) &#123;</span><br><span class="line">d[ver] = d[t] + <span class="number">1</span>;</span><br><span class="line">cur[ver] = h[ver];</span><br><span class="line"><span class="keyword">if</span> (ver == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">q[ ++ tt] = ver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == T) <span class="keyword">return</span> limit;</span><br><span class="line"><span class="type">int</span> flow = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = cur[u]; ~i &amp;&amp; flow &lt; limit; i = ne[i]) &#123;</span><br><span class="line">cur[u] = i;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (d[ver] == d[u] + <span class="number">1</span> &amp;&amp; f[i]) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">find</span>(ver, <span class="built_in">min</span>(f[i], limit - flow));</span><br><span class="line"><span class="keyword">if</span> (!t) d[ver] = <span class="number">-1</span>;</span><br><span class="line">f[i] -= t, f[i ^ <span class="number">1</span>] += t, flow += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> r = <span class="number">0</span>, flow;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">bfs</span>()) <span class="keyword">while</span> (flow = <span class="built_in">find</span>(S, INF)) r += flow;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> s, t;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">S = <span class="number">0</span>, T = n + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"><span class="built_in">add</span>(a, b, d - c);</span><br><span class="line">A[a] -= c, A[b] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (A[i] &gt; <span class="number">0</span>) <span class="built_in">add</span>(S, i, A[i]), tot += A[i];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt; <span class="number">0</span>) <span class="built_in">add</span>(i, T, -A[i]);</span><br><span class="line"><span class="built_in">add</span>(t, s, INF); <span class="comment">// 先以 s, t 为源点(注意到这是最后增加的两条边, 输出结果时会用到这个地</span></span><br><span class="line">方)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dinic</span>() &lt; tot) <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> res = f[idx - <span class="number">1</span>];</span><br><span class="line">S = s, T = t;</span><br><span class="line">f[idx - <span class="number">1</span>] = f[idx - <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res + <span class="built_in">dinic</span>());</span><br><span class="line"><span class="comment">/* 有源汇上下界最小流 只需要修改这里即可</span></span><br><span class="line"><span class="comment">int res = f[idx - 1];</span></span><br><span class="line"><span class="comment">S = t, T = s;</span></span><br><span class="line"><span class="comment">f[idx - 1] = f[idx - 2] = 0;</span></span><br><span class="line"><span class="comment">printf(&quot;%d\n&quot;, res - dinic());</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a><strong>最大权闭合子图</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">场景</span><br><span class="line">若选择用户i，则ai,bi都必须选择，最大化点权和。这便是最大权闭合图的模型。</span><br><span class="line">最大权闭合图的解法</span><br><span class="line">新建源点S,向正权点连容量为点权的边；新建汇点T,负权点向T连容量为点权的相反数的边。图中原有的</span><br><span class="line">边容量改为正无穷。正权点点权和减去最小割即为答案。</span><br><span class="line">正确性证明</span><br><span class="line">选择用户i ⇒ ai,bi 必须选择，即必须割掉ai,bi连向T的边；放弃用户i ⇒ 割掉S连向i的边。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">问题描述</span><br><span class="line">在前期市场调查和站址勘测之后，公司得到了一共 N 个可以作为通讯信号中转站的地址，而由于这些地</span><br><span class="line">址的地理位置差异，在不同的地方建造通讯中转站需 要投入的成本也是不一样的，所幸在前期调查之后这些都</span><br><span class="line">是已知数据：</span><br><span class="line">建立第 i 个通讯中转站需要的成本为 <span class="built_in">Pi</span>(<span class="number">1</span>≤i≤N)。</span><br><span class="line">另外公司调查得出了所有期望中的用户群，一共 M 个。</span><br><span class="line">关于第 i 个用户群的信息概括为 Ai,Bi 和 Ci：这些用户会使用中转站 Ai 和中转站 Bi 进行通</span><br><span class="line">讯，公司可以获益 Ci。（<span class="number">1</span>≤i≤M,<span class="number">1</span>≤Ai,Bi≤N）</span><br><span class="line">THU 集团的 CS&amp;T 公司可以有选择的建立一些中转站（投入成本），为一些用户提供服务并获得收益</span><br><span class="line">（获益之和）。</span><br><span class="line">那么如何选择最终建立的中转站才能让公司的净获利最大呢？（净获利 = 获益之和 – 投入成本之和）</span><br><span class="line">输入格式</span><br><span class="line">第一行有两个正整数 N 和 M。第二行中有 N 个整数描述每一个通讯中转站的建立成本，依次为</span><br><span class="line">P1,P2,…,PN 。以下 M 行，第 (i+<span class="number">2</span>) 行的三个数 Ai,Bi 和 Ci 描述第 i 个用户群的信息。所有变量</span><br><span class="line">的含义可以参见题目描述。</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示公司可以得到的最大净获利。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板省略，同上</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">S = <span class="number">0</span>, T = n + m + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line"><span class="built_in">add</span>(m + i, T, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(S, i, c);</span><br><span class="line"><span class="built_in">add</span>(i, m + a, INF);</span><br><span class="line">    <span class="built_in">add</span>(i, m + b, INF);</span><br><span class="line">tot += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tot - <span class="built_in">dinic</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a><strong>费用流</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">问题描述</span><br><span class="line">给定一个包含 n 个点 m 条边的有向图，并给定每条边的容量和费用，边的容量非负。</span><br><span class="line">图中可能存在重边和自环，保证费用不会存在负环。</span><br><span class="line">求从 S 到 T 的最大流，以及在流量最大时的最小费用。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含四个整数 n,m,S,T。接下来 m 行，每行三个整数 u,v,c,w，表示从点 u 到点 v 存在一</span><br><span class="line">条有向边，容量为 c，费用为 <span class="built_in">w</span>(这里费用指的是单位流量的费用)。点的编号从 <span class="number">1</span> 到 n。</span><br><span class="line">输出格式</span><br><span class="line">输出点 S 到点 T 的最大流和流量最大时的最小费用。</span><br><span class="line">如果从点 S 无法到达点 T 则输出 <span class="number">0</span> <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5010</span>, M = <span class="number">100010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ; <span class="comment">//</span></span><br><span class="line">w[idx] = -d : 退流</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">spfa</span>() &#123; <span class="comment">// 找最短增广路</span></span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="keyword">sizeof</span> incf);</span><br><span class="line">q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line"><span class="keyword">while</span> (hh != tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line">st[t] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line">    <span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (f[i] &amp;&amp; d[ver] &gt; d[t] + w[i]) &#123;</span><br><span class="line">d[ver] = d[t] + w[i];</span><br><span class="line">pre[ver] = i;</span><br><span class="line">incf[ver] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line"><span class="keyword">if</span> (!st[ver]) &#123;</span><br><span class="line">q[tt ++ ] = ver;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line">st[ver] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EK</span><span class="params">(<span class="type">int</span>&amp; flow, <span class="type">int</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">flow = cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>()) &#123;</span><br><span class="line"><span class="type">int</span> t = incf[T];</span><br><span class="line">flow += t, cost += t * d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>]) &#123;</span><br><span class="line">f[pre[i]] -= t;</span><br><span class="line">f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;S, &amp;T);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"><span class="built_in">add</span>(a, b, c, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> flow, cost;</span><br><span class="line"><span class="built_in">EK</span>(flow, cost); <span class="comment">// flow 为 最大流 cost 为 最小费用流</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, flow, cost);</span><br><span class="line"><span class="comment">/* 若还要求最大费用流, 则先恢复图, 然后将费用取反再跑 EK, -cost 则为最大费用流</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; idx; i += 2) &#123;</span></span><br><span class="line"><span class="comment">f[i] += f[i ^ 1], f[i ^ 1] = 0;</span></span><br><span class="line"><span class="comment">w[i] = -w[i], w[i ^ 1] = -w[i ^ 1];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">EK(flow, cost);</span></span><br><span class="line"><span class="comment">printf(&quot;%d\n&quot;, -cost);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无源汇最小费用流"><a href="#无源汇最小费用流" class="headerlink" title="无源汇最小费用流"></a><strong>无源汇最小费用流</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">管道网络可以用 n 个节点 m 条边的有向图表示。机器人从 <span class="number">1</span> 号节点出发，清理完所有需要被清理的</span><br><span class="line">管道，最终回到 <span class="number">1</span> 号节点。</span><br><span class="line">管道一共有以下四种类型:</span><br><span class="line">A 类:管道需要被清理，而且可以重复经过；</span><br><span class="line">B 类:管道需要被清理，但是不能重复经过；</span><br><span class="line">C 类:管道不需要被清理，而且可以重复经过；</span><br><span class="line">D 类:管道不需要被清理，但是不能重复经过。</span><br><span class="line">一条需要清理的管道在 机器人经过它时，就会被它清理。因为管道是有向的，所以机器人只能从一端走</span><br><span class="line">到另一端不能反过来走。对于不能重复经过的管道，机器人最多只能经过它一次。因为管道网络的特殊性，如</span><br><span class="line">果把管道看成无向图，A 类和 B 类管道及其端点构成的子图是连通的，并且 <span class="number">1</span> 号节点一定在这个连通子图</span><br><span class="line">中。</span><br><span class="line">机器人能不能在约束条件下清理完所有应该清理的管道（A 类和 B 类)。机器人 每经过一条管道一次，</span><br><span class="line">就会消耗 E 个包子。如果网络能够被成功清理，少要消耗多少个包子。如果网络无法被成功清理，则直接输</span><br><span class="line">出 −<span class="number">1</span>。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含三个非负整数 T、S、E，表示数据的组数、测试点的编号和经过一条管道一次消耗的包子数</span><br><span class="line">量。</span><br><span class="line">接下来有 T 个部分，每个部分描述一组数据。对于评测数据，保证 T=<span class="number">10</span>。保证 E∈&#123;<span class="number">0</span>,<span class="number">1</span>&#125;，这 T 组</span><br><span class="line">数据的包子消耗速度相同。每个部分第一行包含两个正整数 n、m，表示管道网络的节点数和边数。节点用</span><br><span class="line"><span class="number">1</span>∼n 的整数编号。接下来 m 行，每行包含两个正整数 u,v 和一个大写字母 t，相邻两个元素之间用一个空</span><br><span class="line">格隔开，表示一条从节点 u 连向节点 v 的管道，其类型为 t。保证 <span class="number">1</span>≤u,v≤n，t 一定是 A、B、C、D 之</span><br><span class="line">一。</span><br><span class="line">输出格式</span><br><span class="line">输出 T 行，每行一个整数，表示每组数据的答案。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, M = <span class="number">2010</span>, INF = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> n, m, S, T;</span><br><span class="line"><span class="type">int</span> h[N], e[M], f[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> q[N], d[N], pre[N], incf[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> din[N], dout[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">e[idx] = b, f[idx] = c, w[idx] = d, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">e[idx] = a, f[idx] = <span class="number">0</span>, w[idx] = -d, ne[idx] = h[b], h[b] = idx ++ ; <span class="comment">//</span></span><br><span class="line">w[idx] = -d : 退流</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">spfa</span>() &#123; <span class="comment">// 找最短增广路</span></span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line"><span class="built_in">memset</span>(incf, <span class="number">0</span>, <span class="keyword">sizeof</span> incf);</span><br><span class="line">q[<span class="number">0</span>] = S, d[S] = <span class="number">0</span>, incf[S] = INF;</span><br><span class="line"><span class="keyword">while</span> (hh != tt) &#123;</span><br><span class="line">    <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line">st[t] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="keyword">if</span> (f[i] &amp;&amp; d[ver] &gt; d[t] + w[i]) &#123;</span><br><span class="line">d[ver] = d[t] + w[i];</span><br><span class="line">pre[ver] = i;</span><br><span class="line">incf[ver] = <span class="built_in">min</span>(f[i], incf[t]);</span><br><span class="line"><span class="keyword">if</span> (!st[ver]) &#123;</span><br><span class="line">q[tt ++ ] = ver;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line">st[ver] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> incf[T] &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EK</span><span class="params">(<span class="type">int</span>&amp; flow, <span class="type">int</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">flow = cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">spfa</span>()) &#123;</span><br><span class="line"><span class="type">int</span> t = incf[T];</span><br><span class="line">flow += t, cost += t * d[T];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = T; i != S; i = e[pre[i] ^ <span class="number">1</span>]) &#123;</span><br><span class="line">f[pre[i]] -= t;</span><br><span class="line">f[pre[i] ^ <span class="number">1</span>] += t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> Times, SS, E;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;Times, &amp;SS, &amp;E);</span><br><span class="line"><span class="keyword">while</span> (Times -- ) &#123;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(din, <span class="number">0</span>, <span class="keyword">sizeof</span> din);</span><br><span class="line"><span class="built_in">memset</span>(dout, <span class="number">0</span>, <span class="keyword">sizeof</span> dout);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">S = <span class="number">0</span>, T = n + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> down_cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %c&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="type">int</span> down, up;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span>) down = <span class="number">1</span>, up = INF, down_cost += E;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;B&#x27;</span>) down = up = <span class="number">1</span>, down_cost += E;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;C&#x27;</span>) down = <span class="number">0</span>, up = INF;</span><br><span class="line"><span class="keyword">else</span> down = <span class="number">0</span>, up = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">add</span>(a, b, up - down, E);</span><br><span class="line">din[b] += down, dout[a] += down;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// tot 用来判断是否满流</span></span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 根据入流量和出流量, 决定向源点还是汇点连边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (din[i] &gt; dout[i]) &#123;</span><br><span class="line"><span class="built_in">add</span>(S, i, din[i] - dout[i], <span class="number">0</span>);</span><br><span class="line">tot += din[i] - dout[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">add</span>(i, T, dout[i] - din[i], <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> flow, cost;</span><br><span class="line"><span class="built_in">EK</span>(flow, cost);</span><br><span class="line"><span class="keyword">if</span> (flow == tot) cost += down_cost;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cost);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-差分约束"><a href="#15-差分约束" class="headerlink" title="15 差分约束"></a><strong>15</strong> <strong>差分约束</strong></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>应用背景 1 : 求不等式的可行解</p>
<p>源点需要满足条件 : 从源点出发, 一定可以走到所有边</p>
<p>步骤(最短路)</p>
<p>先将每个不等式<br>$$<br>x_i&lt;&#x3D;x_j+c_k<br>$$</p>
<p>转化为一条从 到 的边， 边权为</p>
<p>找一个满足条件的源点</p>
<p>从源点出发求一遍最短路</p>
<p>若存在负环， 则原不等式组无解</p>
<p>否则 dist[i] 就是原不等式组的一个可行解</p>
<p>应用背景 2 : 如何求可行解的最值（变量 的最值）</p>
<p>若求最小值 , 则应该求最长路<br>$$<br>x_i&gt;&#x3D;x_j+c_k\\<br>x_i&lt;&#x3D;x_j+c_k<br>$$</p>
<p>若求最大值 , 则应该求最短路</p>
<p><strong>细节</strong></p>
<p>$$<br>转化x_i&lt;&#x3D;c_k这类不等式：建立超级源点x_0然后建立x_0到x_1长度为c_k的边<br>$$</p>
<h3 id="一道例题"><a href="#一道例题" class="headerlink" title="一道例题"></a><strong>一道例题</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">幼儿园里有 N 个小朋友，老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。</span><br><span class="line">但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果</span><br><span class="line">的时候， 老师需要满足小朋友们的 K 个要求。</span><br><span class="line">幼儿园的糖果总是有限的，老师想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并</span><br><span class="line">且满足小朋友们所有的要求。</span><br><span class="line">输入格式</span><br><span class="line">输入的第一行是两个整数 N,K。接下来 K 行，表示分配糖果时需要满足的关系，每行 <span class="number">3</span> 个数字</span><br><span class="line">X,A,B。</span><br><span class="line">如果 X=<span class="number">1</span>．表示第 A 个小朋友分到的糖果必须和第 B 个小朋友分到的糖果一样多。</span><br><span class="line">如果 X=<span class="number">2</span>，表示第 A 个小朋友分到的糖果必须少于第 B 个小朋友分到的糖果。</span><br><span class="line">如果 X=<span class="number">3</span>，表示第 A 个小朋友分到的糖果必须不少于第 B 个小朋友分到的糖果。</span><br><span class="line">如果 X=<span class="number">4</span>，表示第 A 个小朋友分到的糖果必须多于第 B 个小朋友分到的糖果。</span><br><span class="line">如果 X=<span class="number">5</span>，表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果。</span><br><span class="line">小朋友编号从 <span class="number">1</span> 到 N。</span><br><span class="line">输出格式</span><br><span class="line">输出一行，表示老师至少需要准备的糖果数，如果不能满足小朋友们的所有要求，就输出 −<span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line">LL dist[N];</span><br><span class="line"><span class="type">int</span> q[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">st[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="type">int</span> t = q.<span class="built_in">top</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">st[t] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="comment">// 最长路</span></span><br><span class="line"><span class="keyword">if</span> (dist[j] &lt; dist[t] + w[i]) &#123;</span><br><span class="line">dist[j] = dist[t] + w[i];</span><br><span class="line">cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (cnt[j] &gt;= n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">st[j] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> x, a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>) <span class="built_in">add</span>(b, a, <span class="number">0</span>), <span class="built_in">add</span>(a, b, <span class="number">0</span>); <span class="comment">// a &gt;= b &amp;&amp; b &gt;= a</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">2</span>) <span class="built_in">add</span>(a, b, <span class="number">1</span>); <span class="comment">// b &gt;= a + 1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">3</span>) <span class="built_in">add</span>(b, a, <span class="number">0</span>); <span class="comment">// a &gt;= b</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">4</span>) <span class="built_in">add</span>(b, a, <span class="number">1</span>); <span class="comment">// a &gt;= b + 1</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">add</span>(a, b, <span class="number">0</span>); <span class="comment">// b &gt;= a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建立 x0 超级源点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res += dist[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-字符串使用手册"><a href="#16-字符串使用手册" class="headerlink" title="16 字符串使用手册"></a><strong>16</strong> <strong>字符串使用手册</strong></h2><h3 id="读入加速"><a href="#读入加速" class="headerlink" title="读入加速"></a>读入加速</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(), ::tolower);</span><br><span class="line"><span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(), ::toupper);</span><br></pre></td></tr></table></figure>

<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从下标 pos 开始, 长度为 len 的子字符串被 str 替换</span></span><br><span class="line"><span class="function">basic_string&amp; <span class="title">replace</span> <span class="params">(size_type pos, size_type len, <span class="type">const</span> basic_string&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">str)</span></span>; <span class="comment">//str.replace(9,5,str2);</span></span><br><span class="line"><span class="comment">// iterator</span></span><br><span class="line"><span class="function">basic_string&amp; <span class="title">replace</span> <span class="params">(const_iterator i1, const_iterator i2, <span class="type">const</span></span></span></span><br><span class="line"><span class="params"><span class="function">basic_string&amp; str)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="新字符串-替换-所有指定子字符串-自己实现的"><a href="#新字符串-替换-所有指定子字符串-自己实现的" class="headerlink" title="新字符串 替换 所有指定子字符串 (自己实现的)"></a>新字符串 替换 所有指定子字符串 (自己实现的)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">subreplace</span><span class="params">(string resource_str, string sub_str, string new_str)</span> </span>&#123;</span><br><span class="line">string::size_type pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((pos = resource_str.<span class="built_in">find</span>(sub_str)) != string::npos) &#123;</span><br><span class="line">resource_str.<span class="built_in">replace</span>(pos, sub_str.<span class="built_in">length</span>(), new_str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resource_str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除 pos 开始 长度为 len 的子字符串</span></span><br><span class="line"><span class="function">basic_string&amp; <span class="title">erase</span> <span class="params">(size_type pos = <span class="number">0</span>, size_type len = npos)</span></span>; <span class="comment">// str.erase</span></span><br><span class="line">(<span class="number">10</span>,<span class="number">8</span>);</span><br><span class="line"><span class="comment">// iterator</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span> <span class="params">(const_iterator first, const_iterator last)</span></span>; <span class="comment">//str.erase</span></span><br><span class="line">(str.<span class="built_in">begin</span>()+<span class="number">5</span>, str.<span class="built_in">end</span>()<span class="number">-9</span>);</span><br></pre></td></tr></table></figure>

<h3 id="查找给定字符串"><a href="#查找给定字符串" class="headerlink" title="查找给定字符串"></a>查找给定字符串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到 str 第一次出现的位置 (pos 可以指定搜索起点)</span></span><br><span class="line"><span class="function">size_type <span class="title">find</span> <span class="params">(<span class="type">const</span> basic_string&amp; str, size_type pos = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">str</span> <span class="params">(<span class="string">&quot;There are two needles in this haystack with needles.&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">str2</span> <span class="params">(<span class="string">&quot;needle&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// different member versions of find in the same order as above:</span></span><br><span class="line">std::string::size_type found = str.<span class="built_in">find</span>(str2);</span><br><span class="line"><span class="keyword">if</span> (found != std::string::npos)</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;first &#x27;needle&#x27; found at: &quot;</span> &lt;&lt; found &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="取子字符串"><a href="#取子字符串" class="headerlink" title="取子字符串"></a>取子字符串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 pos 开始, 长度为 len 的子字符串</span></span><br><span class="line"><span class="function">basic_string <span class="title">substr</span> <span class="params">(size_type pos = <span class="number">0</span>, size_type len = npos)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span>(ch, start = <span class="number">0</span>) 查找并返回从 start 开始的字符 ch 的位置；<span class="built_in">rfind</span>(ch) 从末尾开始，</span><br><span class="line">查找并返回第一个找到的字符 ch 的位置（皆从 <span class="number">0</span> 开始）（如果查找不到，返回 <span class="number">-1</span>）。</span><br><span class="line"><span class="built_in">substr</span>(start, len) 可以从字符串的 start（从 <span class="number">0</span> 开始）截取一个长度为 len 的字符串（缺省</span><br><span class="line">len 时代码截取到字符串末尾）。</span><br><span class="line"><span class="built_in">append</span>(s) 将 s 添加到字符串末尾。</span><br><span class="line"><span class="built_in">append</span>(s, pos, n) 将字符串 s 中，从 pos 开始的 n 个字符连接到当前字符串结尾。</span><br><span class="line"><span class="built_in">replace</span>(pos, n, s) 删除从 pos 开始的 n 个字符，然后在 pos 处插入串 s。</span><br><span class="line"><span class="built_in">erase</span>(pos, n) 删除从 pos 开始的 n 个字符。</span><br><span class="line"><span class="built_in">insert</span>(pos, s) 在 pos 位置插入字符串 s。</span><br></pre></td></tr></table></figure>

<h2 id="17-Regex-正则"><a href="#17-Regex-正则" class="headerlink" title="17 Regex 正则"></a><strong>17 Regex</strong> <strong>正则</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">string <span class="title">s</span> <span class="params">(<span class="string">&quot;subject&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">regex <span class="title">e</span> <span class="params">(<span class="string">&quot;(sub)(.*)&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">regex_match</span> (s,e))</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;string object matched\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">regex_match</span> ( s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), e ) )</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;range matched\n&quot;</span>;</span><br><span class="line">smatch sm; <span class="comment">// same as match_results&lt;string::const_iterator&gt; sm;</span></span><br><span class="line"><span class="built_in">regex_match</span> (s,sm,e);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;string object with &quot;</span> &lt;&lt; sm.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; matches\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;the matches were: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> i=<span class="number">0</span>; i&lt;sm.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; sm[i] &lt;&lt; <span class="string">&quot;] &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">string object matched</span></span><br><span class="line"><span class="comment">range matched</span></span><br><span class="line"><span class="comment">string object with 3 matches</span></span><br><span class="line"><span class="comment">the matches were: [subject] [sub] [ject]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="18-日期处理模板"><a href="#18-日期处理模板" class="headerlink" title="18 日期处理模板"></a><strong>18</strong> <strong>日期处理模板</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> month[] = &#123;</span><br><span class="line"><span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 判断 是否为 闰年</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">is_leap</span><span class="params">(<span class="type">int</span> year)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> || year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取 m 月 天数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_month</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">2</span>) <span class="keyword">return</span> month[m] + <span class="built_in">is_leap</span>(y);</span><br><span class="line"><span class="keyword">return</span> month[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-最近公共祖先"><a href="#19-最近公共祖先" class="headerlink" title="19 最近公共祖先"></a><strong>19</strong> <strong>最近公共祖先</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">给定一棵包含 n 个节点的有根无向树，节点编号互不相同，但不一定是 <span class="number">1</span>∼n。</span><br><span class="line">有 m 个询问，每个询问给出了一对节点的编号 x 和 y，询问 x 与 y 的祖孙关系。</span><br><span class="line">输入格式</span><br><span class="line">输入第一行包括一个整数 表示节点个数；</span><br><span class="line">接下来 n 行每行一对整数 a 和 b，表示 a 和 b 之间有一条无向边。如果 b 是 −<span class="number">1</span>，那么 a 就是</span><br><span class="line">树的根；</span><br><span class="line">第 n + <span class="number">2</span> 行是一个整数 m 表示询问个数；</span><br><span class="line">接下来 m 行，每行两个不同的正整数 x 和 y，表示一个询问。</span><br><span class="line">输出格式</span><br><span class="line">对于每一个询问，若 x 是 y 的祖先则输出 <span class="number">1</span>，若 y 是 x 的祖先则输出 <span class="number">2</span>，否则输出 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<h3 id="倍增查询"><a href="#倍增查询" class="headerlink" title="倍增查询"></a><strong>倍增查询</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth);</span><br><span class="line">depth[<span class="number">0</span>] = <span class="number">0</span>, depth[root] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">q[<span class="number">0</span>] = root;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>) &#123;</span><br><span class="line">depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">q[ ++ tt] = j;</span><br><span class="line">fa[j][<span class="number">0</span>] = t;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; k ++ )</span><br><span class="line">fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (depth[a] &lt; depth[b]) <span class="built_in">swap</span>(a, b);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line"><span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b])</span><br><span class="line">a = fa[a][k];</span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )</span><br><span class="line"><span class="keyword">if</span> (fa[a][k] != fa[b][k]) &#123;</span><br><span class="line">a = fa[a][k];</span><br><span class="line">b = fa[b][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">-1</span>) root = a;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bfs</span>(root);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line"><span class="keyword">if</span> (p == a) <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p == b) <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-有向图强连通分量-Tarjan"><a href="#20-有向图强连通分量-Tarjan" class="headerlink" title="20. 有向图强连通分量(Tarjan)"></a><strong>20.</strong> <strong>有向图强连通分量(Tarjan)</strong></h2><p>在有向图G中，如果两个顶点间至少存在一条路径，称两个顶点<strong>强连通</strong>。如果有向图G的每两个顶点都强</p>
<p>连通，称G是一个<strong>强连通图</strong>。非强连通图有向图的极大强连通子图，称为<strong>强连通分量</strong></p>
<p>此题Targan算法主要是将 图 进行缩点。得到各个强连通分量，构成拓扑图。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">每一头牛的愿望就是变成一头最受欢迎的牛。</span><br><span class="line">现在有 N 头牛，编号从 <span class="number">1</span> 到 N，给你 M 对整数 (A,B)，表示牛 A 认为牛 B 受欢迎。</span><br><span class="line">这种关系是具有传递性的，如果 A 认为 B 受欢迎，B 认为 C 受欢迎，那么牛 A 也认为牛 C 受欢迎。</span><br><span class="line">你的任务是求出有多少头牛被除自己之外的所有牛认为是受欢迎的。</span><br><span class="line">输入格式</span><br><span class="line">第一行两个数 N,M；</span><br><span class="line">接下来 M 行，每行两个数 A,B，意思是 A 认为 B 是受欢迎的（给出的信息有可能重复，即有可能出</span><br><span class="line">现多个 A,B）。</span><br><span class="line">输出格式</span><br><span class="line">输出被除自己之外的所有牛认为是受欢迎的牛的数量。</span><br><span class="line">输入样例：</span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">1</span></span><br><span class="line">样例解释</span><br><span class="line">只有第三头牛被除自己之外的所有牛认为是受欢迎的。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], timestamp;</span><br><span class="line"><span class="comment">// dfn[u] : 遍历到 u 的时间戳</span></span><br><span class="line"><span class="comment">// low[u] : 从 u 出发能够遍历到的最小时间戳</span></span><br><span class="line"><span class="comment">// timestamp : 当前时间戳</span></span><br><span class="line"><span class="type">int</span> stk[N], top;</span><br><span class="line"><span class="type">bool</span> in_stk[N]; <span class="comment">// 点是否在栈中</span></span><br><span class="line"><span class="type">int</span> id[N], scc_cnt, Size[N];</span><br><span class="line"><span class="comment">// id[u] : 点u所在强连通分量编号</span></span><br><span class="line"><span class="comment">// scc_cnt : 当前强连通分量个数</span></span><br><span class="line"><span class="comment">// Size[u] : 强连通分量的大小</span></span><br><span class="line"><span class="type">int</span> dout[N]; <span class="comment">// 联通分量出度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++ timestamp;</span><br><span class="line">stk[ ++ top] = u, in_stk[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (!dfn[j]) &#123;</span><br><span class="line"><span class="built_in">tarjan</span>(j);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u], low[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (in_stk[j]) low[u] = <span class="built_in">min</span>(low[u], dfn[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">++ scc_cnt;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">y = stk[top -- ];</span><br><span class="line">in_stk[y] = <span class="literal">false</span>;</span><br><span class="line">id[y] = scc_cnt;</span><br><span class="line">Size[scc_cnt] ++ ;</span><br><span class="line">&#125; <span class="keyword">while</span> (y != u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">if</span> (!dfn[i])</span><br><span class="line"><span class="built_in">tarjan</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = h[i]; ~j; j = ne[j]) &#123;</span><br><span class="line"><span class="type">int</span> k = e[j];</span><br><span class="line"><span class="type">int</span> a = id[i], b = id[k];</span><br><span class="line"><span class="keyword">if</span> (a != b) dout[a] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> zeros = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= scc_cnt; i ++ )</span><br><span class="line"><span class="keyword">if</span> (!dout[i]) &#123;</span><br><span class="line">zeros ++ ;</span><br><span class="line">sum += Size[i];</span><br><span class="line"><span class="keyword">if</span> (zeros &gt; <span class="number">1</span>) &#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-最长公共上升子序列"><a href="#21-最长公共上升子序列" class="headerlink" title="21. 最长公共上升子序列"></a><strong>21.</strong> <strong>最长公共上升子序列</strong></h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。</span><br><span class="line">小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子</span><br><span class="line">序列了。</span><br><span class="line">小沐沐说，对于两个数列A和B，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一</span><br><span class="line">段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。</span><br><span class="line">奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。</span><br><span class="line">不过，只要告诉奶牛它的长度就可以了。</span><br><span class="line">数列A和B的长度均不超过<span class="number">3000</span>。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含一个整数N，表示数列A，B的长度。</span><br><span class="line">第二行包含N个整数，表示数列A。</span><br><span class="line">第三行包含N个整数，表示数列B。</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示最长公共上升子序列的长度。</span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">3000</span>,序列中的数字均不超过<span class="number">231</span>−<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入样例：</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">输出样例：</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a><strong>问题分析</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 状态表示</span><br><span class="line">f[i][j]代表所有a[<span class="number">1</span> ~ i]和b[<span class="number">1</span> ~ j]中以b[j]结尾的公共上升子序列的集合；</span><br><span class="line">f[i][j]的值等于该集合的子序列中长度的最大值；</span><br><span class="line"><span class="number">2.</span> 状态计算</span><br><span class="line">首先依据公共子序列中是否包含a[i]，将f[i][j]所代表的集合划分成两个不重不漏的子集：</span><br><span class="line">不包含a[i]的子集，最大值是f[i - <span class="number">1</span>][j]；</span><br><span class="line">包含a[i]的子集，将这个子集继续划分，依据是子序列的倒数第二个元素在b[]中是哪个数：</span><br><span class="line">子序列只包含b[j]一个数，长度是<span class="number">1</span>；</span><br><span class="line">子序列的倒数第二个数是b[<span class="number">1</span>]的集合，最大长度是f[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>；</span><br><span class="line">…</span><br><span class="line">子序列的倒数第二个数是b[j - <span class="number">1</span>]的集合，最大长度是f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>；</span><br></pre></td></tr></table></figure>

<h3 id="代码实现思路"><a href="#代码实现思路" class="headerlink" title="代码实现思路"></a><strong>代码实现思路</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">&#123;</span><br><span class="line">f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (a[i] == b[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> maxv = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; j; k ++ )</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; b[k])</span><br><span class="line">maxv = <span class="built_in">max</span>(maxv, f[i - <span class="number">1</span>][k] + <span class="number">1</span>);</span><br><span class="line">f[i][j] = <span class="built_in">max</span>(f[i][j], maxv);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a><strong>优化思路</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">我们发现每次循环求得的maxv是满足a[i] &gt; b[k] 的 f[i - <span class="number">1</span>][k] + <span class="number">1</span>的前缀最大值。</span><br><span class="line">因此可以直接将maxv提到第一层循环外面，减少重复计算，此时只剩下两重循环。</span><br><span class="line">最终答案枚举子序列结尾取最大值即可。</span><br></pre></td></tr></table></figure>

<h3 id="最终代码实现"><a href="#最终代码实现" class="headerlink" title="最终代码实现"></a><strong>最终代码实现</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> maxv = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">&#123;</span><br><span class="line">f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j], maxv);</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; b[j]) maxv = <span class="built_in">max</span>(maxv, f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, f[n][i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-点分治"><a href="#22-点分治" class="headerlink" title="22. 点分治"></a><strong>22.</strong> <strong>点分治</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">给定一个有 N 个点（编号 <span class="number">0</span>,<span class="number">1</span>,…,N−<span class="number">1</span>）的树，每条边都有一个权值（不超过 <span class="number">1000</span>）。</span><br><span class="line">树上两个节点 x 与 y 之间的路径长度就是路径上各条边的权值之和。</span><br><span class="line">求长度不超过 K 的路径有多少条。</span><br><span class="line">输入格式</span><br><span class="line">输入包含多组测试用例。</span><br><span class="line">每组测试用例的第一行包含两个整数 N 和 K。</span><br><span class="line">接下来 N−<span class="number">1</span> 行，每行包含三个整数 u,v,l，表示节点 u 与 v 之间存在一条边，且边的权值为 l。</span><br><span class="line">当输入用例 N=<span class="number">0</span>，K=<span class="number">0</span> 时，表示输入终止，且该用例无需处理。</span><br><span class="line">输出格式</span><br><span class="line">每个测试用例输出一个结果。</span><br><span class="line">每个结果占一行。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> p[N], q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_size</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123; <span class="comment">// 求子树大小</span></span><br><span class="line"><span class="keyword">if</span> (st[u]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 若节点 u 已经删掉则返回 0</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (e[i] != fa) <span class="comment">// 若不往回搜</span></span><br><span class="line">res += <span class="built_in">get_size</span>(e[i], u);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_wc</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> tot, <span class="type">int</span>&amp; wc)</span> </span>&#123; <span class="comment">// 求重心(满足任意连通块大小小于 n/2 即</span></span><br><span class="line">可)</span><br><span class="line"><span class="keyword">if</span> (st[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">1</span>, ms = <span class="number">0</span>; <span class="comment">// sum : 子树大小 ms : 连通块大小的最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>; <span class="comment">// 判断是否往回搜</span></span><br><span class="line"><span class="type">int</span> t = <span class="built_in">get_wc</span>(j, u, tot, wc);</span><br><span class="line">ms = <span class="built_in">max</span>(ms, t);</span><br><span class="line">sum += t;</span><br><span class="line">&#125;</span><br><span class="line">ms = <span class="built_in">max</span>(ms, tot - sum);</span><br><span class="line"><span class="keyword">if</span> (ms &lt;= tot / <span class="number">2</span>) wc = u;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_dist</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> dist, <span class="type">int</span>&amp; qt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (st[u] || dist &gt; m) <span class="keyword">return</span>; <span class="comment">// 若 u 已经删掉则直接 return</span></span><br><span class="line">q[qt ++ ] = dist;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i])</span><br><span class="line"><span class="keyword">if</span> (e[i] != fa)</span><br><span class="line"><span class="built_in">get_dist</span>(e[i], u, dist + w[i], qt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(a, a + k);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>, j = <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i -- ) &#123;</span><br><span class="line"><span class="keyword">while</span> (j + <span class="number">1</span> &lt; i &amp;&amp; a[j + <span class="number">1</span>] + a[i] &lt;= m) j ++ ;</span><br><span class="line">j = <span class="built_in">min</span>(j, i - <span class="number">1</span>);</span><br><span class="line">    res += j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (st[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_wc</span>(u, <span class="number">-1</span>, <span class="built_in">get_size</span>(u, <span class="number">-1</span>), u);</span><br><span class="line">st[u] = <span class="literal">true</span>; <span class="comment">// 删除重心</span></span><br><span class="line"><span class="comment">// 重点 ---------------------------------------------</span></span><br><span class="line"><span class="type">int</span> pt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i], qt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">get_dist</span>(j, <span class="number">-1</span>, w[i], qt);</span><br><span class="line">res -= <span class="built_in">get</span>(q, qt);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; qt; k ++ ) &#123;</span><br><span class="line"><span class="keyword">if</span> (q[k] &lt;= m) res ++ ;</span><br><span class="line">p[pt ++ ] = q[k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res += <span class="built_in">get</span>(p, pt);</span><br><span class="line"><span class="comment">// 归并部分------------------------------------------</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) res += <span class="built_in">calc</span>(e[i]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m), n || m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">calc</span>(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-状态压缩DP"><a href="#23-状态压缩DP" class="headerlink" title="23. 状态压缩DP"></a><strong>23.</strong> <strong>状态压缩DP</strong></h2><h3 id="棋盘式"><a href="#棋盘式" class="headerlink" title="棋盘式"></a><strong>棋盘式</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">在 n × n 的棋盘上放 k 个国王，国王可攻击相邻的 <span class="number">8</span> 个格子，求使它们无法互相攻击的方案总数。</span><br><span class="line">输入格式</span><br><span class="line">共一行，包含两个整数 n 和 k。</span><br><span class="line">输出格式</span><br><span class="line">共一行，表示方案总数，若不能够放置则输出<span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, K = <span class="number">110</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N][K][M];</span><br><span class="line"><span class="type">int</span> cnt[M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; states;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; head[M];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> state)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line"><span class="keyword">if</span> ((state &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; (state &gt;&gt; i + <span class="number">1</span> &amp; <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> state)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cnt += state &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; n; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(i)) &#123;</span><br><span class="line">states.<span class="built_in">push_back</span>(i);</span><br><span class="line">cnt[i] = <span class="built_in">get</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; states.<span class="built_in">size</span>(); i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; states.<span class="built_in">size</span>(); j ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a = states[i], b = states[j];</span><br><span class="line"><span class="keyword">if</span> ((a &amp; b) == <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(a | b))</span><br><span class="line">head[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; states.<span class="built_in">size</span>(); a ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> b : head[a]) &#123;</span><br><span class="line"><span class="type">int</span> c = cnt[states[a]];</span><br><span class="line"><span class="keyword">if</span> (j &gt;= c) &#123;</span><br><span class="line">f[i][j][a] += f[i - <span class="number">1</span>][j - c][b];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; f[n + <span class="number">1</span>][m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="棋盘式-矩阵乘法-快速幂"><a href="#棋盘式-矩阵乘法-快速幂" class="headerlink" title="棋盘式 + 矩阵乘法 + 快速幂"></a><strong>棋盘式</strong> <strong>+</strong> <strong>矩阵乘法</strong> <strong>+</strong> <strong>快速幂</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">给出一个 n×m 的方格图，现在要用如下 L 型的积木拼到这个图中，使得方格图正好被拼满，请问总共</span><br><span class="line">有多少种拼法。</span><br><span class="line">其中，方格图的每一个方格正好能放积木中的一块。</span><br><span class="line">积木可以任意旋转。</span><br><span class="line">输入格式</span><br><span class="line">输入的第一行包含两个整数 n,m，表示方格图的大小。</span><br><span class="line">输出格式</span><br><span class="line">输出一行，表示可以放的方案数，由于方案数可能很多，所以请输出方案数除以 <span class="number">109</span>+<span class="number">7</span> 的余数。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">130</span>, MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">LL n;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="comment">// 这里将原 n * m 方格 看为 m * n 方格, 便于理解</span></span><br><span class="line"><span class="comment">// x 为 当前列状态, y 为 下一列状态, u 为当前列枚举到的方格 index</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == m) w[x][y] ++ ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x &gt;&gt; u &amp; <span class="number">1</span>) <span class="built_in">dfs</span>(x, y, u + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 由于 列 从左往右, u(行) 从下往上 枚举, 因此共有四种转移方式</span></span><br><span class="line"><span class="keyword">if</span> (u &amp;&amp; !(y &gt;&gt; u &amp; <span class="number">1</span>) &amp;&amp; !(y &gt;&gt; u - <span class="number">1</span> &amp; <span class="number">1</span>))</span><br><span class="line">    <span class="built_in">dfs</span>(x, y + (<span class="number">1</span> &lt;&lt; u) + (<span class="number">1</span> &lt;&lt; u - <span class="number">1</span>), u + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (u + <span class="number">1</span> &lt; m &amp;&amp; !(y &gt;&gt; u &amp; <span class="number">1</span>) &amp;&amp; !(y &gt;&gt; u + <span class="number">1</span> &amp; <span class="number">1</span>))</span><br><span class="line"><span class="built_in">dfs</span>(x, y + (<span class="number">1</span> &lt;&lt; u) + (<span class="number">1</span> &lt;&lt; u + <span class="number">1</span>), u + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (u + <span class="number">1</span> &lt; m &amp;&amp; !(x &gt;&gt; u + <span class="number">1</span> &amp; <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(y &gt;&gt; u &amp; <span class="number">1</span>)) <span class="built_in">dfs</span>(x, y + (<span class="number">1</span> &lt;&lt; u), u + <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (!(y &gt;&gt; u + <span class="number">1</span> &amp; <span class="number">1</span>)) <span class="built_in">dfs</span>(x, y + (<span class="number">1</span> &lt;&lt; u + <span class="number">1</span>), u + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 矩阵乘法模板</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> c[][N], <span class="type">int</span> a[][N], <span class="type">int</span> b[][N])</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> tmp[N][N];</span><br><span class="line"><span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span> &lt;&lt; m; j ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">1</span> &lt;&lt; m; k ++ )</span><br><span class="line">tmp[i][j] = (tmp[i][j] + (LL)a[i][k] * b[k][j]) % MOD;</span><br><span class="line"><span class="built_in">memcpy</span>(c, tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="comment">// 构造转移矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; m; i ++ )</span><br><span class="line"><span class="built_in">dfs</span>(i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> res[N][N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">res[<span class="number">0</span>][(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="built_in">mul</span>(res, res, w);</span><br><span class="line"><span class="built_in">mul</span>(w, w, w);</span><br><span class="line">n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; res[<span class="number">0</span>][(<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="0-1-覆盖问题"><a href="#0-1-覆盖问题" class="headerlink" title="0 1 覆盖问题"></a><strong>0 1</strong> <strong>覆盖问题</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">T 市有 N 个酒店，这些酒店由 N−<span class="number">1</span> 条双向道路连接，所有酒店和道路构成一颗树。</span><br><span class="line">不同的道路可能有不同的长度，运输车通过该道路所需要的时间受道路的长度影响。在 T 市，一共有 K</span><br><span class="line">种主流食材。莱莱公司有 K 辆车，每辆车负责一种食材的配送，不存在多辆车配送相同的食材。</span><br><span class="line">由于不同酒店的特点不同，因此不同酒店对食材的需求情况也不同，比如可能 <span class="number">1</span> 号酒店只需要第 <span class="number">1</span>,<span class="number">5</span></span><br><span class="line">种食材， <span class="number">2</span> 号酒店需要全部的 K 种食材.莱莱公司每天给这些公司运输食材。对于运输第 i 种食材的车</span><br><span class="line">辆，这辆车可以从任意酒店出发，然后将食材运输到所有需要第 i 种食材的酒店.为了提高配送效率，这 K</span><br><span class="line">辆车可以从不同的酒店出发。但是由于 T 市对于食品安全特别重视，因此每辆车在配送之前需要进行食品安</span><br><span class="line">全检查。鉴于进行食品安全检查的人手不足，最多可以设置 M 个检查点。</span><br><span class="line">现在莱莱公司需要你制定一个运输方案：选定不超过 M 个酒店设立食品安全检查点，确定每辆运输车从</span><br><span class="line">哪个检查点出发，规划每辆运输车的路线.假设所有的食材运输车在进行了食品安全检查之后同时出发，请制定</span><br><span class="line">一个运输方案，使得所有酒店的等待时间的最大值最小。酒店的等待时间从运输车辆出发时开始计算，到该酒</span><br><span class="line">店所有需要的食材都运输完毕截至。</span><br><span class="line">如果一个酒店不需要任何食材，那么它的等待时间为 <span class="number">0</span>。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含 <span class="number">3</span> 个正整数 N,M,K，含义见题目描述。</span><br><span class="line">接下来 N 行，每行包含 K 个整数。每行输入描述对应酒店对每种食材的需求情况，<span class="number">1</span> 表示需要对应的</span><br><span class="line">食材， <span class="number">0</span> 表示不需要。</span><br><span class="line">接下来 N−<span class="number">1</span> 行，每行包含 <span class="number">3</span> 个整数 u,v,w，表示存在一条通行时间为 w 的双向道路连接 u 号酒店</span><br><span class="line">和 v 号酒店。</span><br><span class="line">保证输入数据是一颗树，酒店从 <span class="number">1</span> 编号到 N。</span><br><span class="line">输出格式</span><br><span class="line">输出一个整数，表示在你的方案中，所有酒店的等待时间的最大值。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, M = <span class="number">10</span>, S = <span class="number">1</span> &lt;&lt; M;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> need[N][M];</span><br><span class="line"><span class="type">int</span> h[N], e[N * <span class="number">2</span>], w[N * <span class="number">2</span>], ne[N * <span class="number">2</span>], idx;</span><br><span class="line"><span class="type">int</span> d[N][M];</span><br><span class="line"><span class="type">int</span> f[S], state[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PII <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="function">PII <span class="title">res</span><span class="params">(<span class="number">0</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (need[u][v]) res.y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) &#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (j == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">dfs</span>(j, u, v);</span><br><span class="line"><span class="keyword">if</span> (t.y != <span class="number">-1</span>) &#123;</span><br><span class="line">res.x += t.x + w[i] * <span class="number">2</span>;</span><br><span class="line">res.y = <span class="built_in">max</span>(res.y, t.y + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(state, <span class="number">0</span>, <span class="keyword">sizeof</span> state);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j ++ )</span><br><span class="line"><span class="keyword">if</span> (d[i][j] &lt;= mid) <span class="comment">// 构建 0 1 矩阵(共 n 行, k 列)</span></span><br><span class="line">state[i] |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span> &lt;&lt; k; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">f[i | state[j]] = <span class="built_in">min</span>(f[i | state[j]], f[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> f[(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>] &lt;= m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j ++ )</span><br><span class="line">cin &gt;&gt; need[i][j];</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以第 i 个店为起点, 到满足所有第 j 种食材的供应所需最小距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j ++ ) &#123;</span><br><span class="line"><span class="keyword">auto</span> t = <span class="built_in">dfs</span>(i, <span class="number">-1</span>, j);</span><br><span class="line"><span class="keyword">if</span> (t.y != <span class="number">-1</span>) d[i][j] = t.x - t.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">2e8</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, r);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-状态机DP"><a href="#24-状态机DP" class="headerlink" title="24. 状态机DP"></a><strong>24.</strong> <strong>状态机DP</strong></h2><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a><strong>KMP</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">你现在需要设计一个密码 S，S 需要满足：</span><br><span class="line">S 的长度是 N；</span><br><span class="line">S 只包含小写英文字母；</span><br><span class="line">S 不包含子串 T；</span><br><span class="line">例如：abc 和 abcde 是 abcde 的子串，abd 不是 abcde 的子串。</span><br><span class="line">请问共有多少种不同的密码满足要求？</span><br><span class="line">由于答案会非常大，请输出答案模 <span class="number">109</span>+<span class="number">7</span> 的余数。</span><br><span class="line">输入格式</span><br><span class="line">第一行输入整数N，表示密码的长度。</span><br><span class="line">第二行输入字符串T，T中只包含小写字母。</span><br><span class="line">    输出格式</span><br><span class="line">输出一个正整数，表示总方案数模 <span class="number">109</span>+<span class="number">7</span> 后的结果。</span><br><span class="line">数据范围</span><br><span class="line"><span class="number">1</span>≤N≤<span class="number">50</span>,</span><br><span class="line"><span class="number">1</span>≤|T|≤N，|T|是T的长度。</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; str + <span class="number">1</span>;</span><br><span class="line">m = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ ) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; str[i] != str[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line"><span class="keyword">if</span> (str[i] == str[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> k = <span class="string">&#x27;a&#x27;</span>; k &lt;= <span class="string">&#x27;z&#x27;</span>; k ++ ) &#123;</span><br><span class="line"><span class="type">int</span> u = j;</span><br><span class="line"><span class="keyword">while</span> (u &amp;&amp; k != str[u + <span class="number">1</span>]) u = ne[u];</span><br><span class="line"><span class="keyword">if</span> (k == str[u + <span class="number">1</span>]) u ++ ;</span><br><span class="line"><span class="keyword">if</span> (u &lt; m) f[i + <span class="number">1</span>][u] = (f[i + <span class="number">1</span>][u] + f[i][j]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) res = (res + f[n][i]) % mod;</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC****自动机"></a><strong>AC****自动机</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">DNA看作是一个由’A’, ‘G’ , ‘C’ , ‘T’构成的字符串。修复技术就是通过改变字符串中的一些字</span><br><span class="line">符，从而消除字符串中包含的致病片段。</span><br><span class="line">例如，我们可以通过改变两个字符，将DNA片段”AAGCAG”变为”AGGCAC”，从而使得DNA片段中不再包含</span><br><span class="line">致病片段”AAG”，”AGC”，”CAG”，以达到修复该DNA片段的目的。需注意，被修复的DNA片段中，仍然只能包</span><br><span class="line">含字符’A’, ‘G’ , ‘C’ , ‘T’。</span><br><span class="line">请你帮助生物学家修复给定的DNA片段，并且修复过程中改变的字符数量要尽可能的少。</span><br><span class="line">输入格式</span><br><span class="line">输入包含多组测试数据。每组数据第一行包含整数N，表示致病DNA片段的数量。</span><br><span class="line">接下来N行，每行包含一个长度不超过<span class="number">20</span>的非空字符串，字符串中仅包含字符’A’, ‘G’ , ‘C’ ,</span><br><span class="line">‘T’，用以表示致病DNA片段,再一行，包含一个长度不超过<span class="number">1000</span>的非空字符串，字符串中仅包含字符’A’,</span><br><span class="line">‘G’ , ‘C’ , ‘T’，用以表示待修复DNA片段。</span><br><span class="line">最后一组测试数据后面跟一行，包含一个<span class="number">0</span>，表示输入结束。</span><br><span class="line">输出格式</span><br><span class="line">每组数据输出一个结果，每个结果占一行。输入形如”Case x: y”，其中x为测试数据编号（从<span class="number">1</span>开</span><br><span class="line">始），y为修复过程中所需改变的字符数量的最小值，如果无法修复给定DNA片段，则y为”<span class="number">-1</span>”。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">4</span>], dar[N], idx;</span><br><span class="line"><span class="type">int</span> q[N], ne[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;T&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="string">&#x27;G&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">get</span>(str[i]);</span><br><span class="line"><span class="keyword">if</span> (tr[p][t] == <span class="number">0</span>) tr[p][t] = ++ idx;</span><br><span class="line">p = tr[p][t];</span><br><span class="line">&#125;</span><br><span class="line">dar[p] = <span class="number">1</span>; <span class="comment">// 终结符标识</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )</span><br><span class="line"><span class="keyword">if</span> (tr[<span class="number">0</span>][i])</span><br><span class="line">q[ ++ tt] = tr[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> p = tr[t][i];</span><br><span class="line"><span class="keyword">if</span> (!p) tr[t][i] = tr[ne[t]][i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ne[p] = tr[ne[t]][i];</span><br><span class="line">q[ ++ tt] = p;</span><br><span class="line">dar[p] |= dar[ne[p]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n) &#123;</span><br><span class="line"><span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line"><span class="built_in">memset</span>(dar, <span class="number">0</span>, <span class="keyword">sizeof</span> dar);</span><br><span class="line"><span class="built_in">memset</span>(ne, <span class="number">0</span>, <span class="keyword">sizeof</span> ne);</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"><span class="built_in">insert</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line">m = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= idx; j ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k ++ ) &#123;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">get</span>(str[i + <span class="number">1</span>]) != k;</span><br><span class="line"><span class="type">int</span> p = tr[j][k];</span><br><span class="line"><span class="keyword">if</span> (!dar[p]) f[i + <span class="number">1</span>][p] = <span class="built_in">min</span>(f[i + <span class="number">1</span>][p], f[i][j] + t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i ++ ) res = <span class="built_in">min</span>(res, f[m][i]);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">0x3f3f3f3f</span>) res = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, T ++, res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">小明最近在研究一门新的语言，叫做 QQ 语言。</span><br><span class="line">QQ 语言单词和文章都可以用且仅用只含有小写英文字母的字符串表示，任何由这些字母组成的字符串也都是</span><br><span class="line">一篇合法的 QQ 语言文章。</span><br><span class="line">在 QQ 语言的所有单词中，小明选出了他认为最重要的 n 个。使用这些单词，小明可以评价一篇 QQ 语言文</span><br><span class="line">章的“重要度”。</span><br><span class="line">文章“重要度”的定义为：在该文章中，所有重要的 QQ 语言单词出现次数的总和。其中多次出现的单词，不论</span><br><span class="line">是否发生包含、重叠等情况，每次出现均计算在内。</span><br><span class="line">例如，假设 n=<span class="number">2</span>n=<span class="number">2</span>，小明选出的单词是 `gvagv` 和 `agva`。</span><br><span class="line">在文章 `gvagvagvagv` 中，`gvagv` 出现了 <span class="number">3</span> 次，`agva` 出现了 <span class="number">2</span> 次，因此这篇文章的重要度为</span><br><span class="line"><span class="number">3</span>+<span class="number">2</span>=<span class="number">5</span></span><br><span class="line">现在，小明想知道，一篇由 m 个字母组成的 QQ 语言文章，重要度最高能达到多少。</span><br><span class="line">#### 输入格式</span><br><span class="line">输入的第一行包含两个整数 n,m表示小明选出的单词个数和最终文章包含的字母个数。</span><br><span class="line">接下来 n 行，每行包含一个仅由英文小写字母构成的字符串，表示小明选出的这 n 个单词。</span><br><span class="line">#### 输出格式</span><br><span class="line">输出一行一个整数，表示由 m 个字母组成的 QQ 语言文章中，重要度最高的文章的重要度。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL m;</span><br><span class="line"><span class="type">int</span> tr[N][<span class="number">26</span>], cnt[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line">LL ans[N][N], w[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!tr[p][u]) tr[p][u] = ++ idx;</span><br><span class="line">p = tr[p][u];</span><br><span class="line">&#125;</span><br><span class="line">cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ )</span><br><span class="line"><span class="keyword">if</span> (tr[<span class="number">0</span>][i])</span><br><span class="line">q[ ++ tt] = tr[<span class="number">0</span>][i];</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt) &#123;</span><br><span class="line"><span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ ) &#123;</span><br><span class="line">    <span class="type">int</span> p = tr[t][i];</span><br><span class="line"><span class="keyword">if</span> (!p) tr[t][i] = tr[ne[t]][i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ne[p] = tr[ne[t]][i];</span><br><span class="line"><span class="comment">// 本题需要存一下当前节点是多少模式串的终点</span></span><br><span class="line">cnt[p] += cnt[ne[p]];</span><br><span class="line">q[ ++ tt] = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(LL c[][N], LL a[][N], LL b[][N])</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> LL tmp[N][N];</span><br><span class="line"><span class="built_in">memset</span>(tmp, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= idx; j ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= idx; k ++ )</span><br><span class="line">tmp[i][j] = <span class="built_in">max</span>(tmp[i][j], a[i][k] + b[k][j]);</span><br><span class="line"><span class="built_in">memcpy</span>(c, tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="keyword">while</span> (n -- ) &#123;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"><span class="built_in">insert</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>();</span><br><span class="line"><span class="built_in">memset</span>(w, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> w);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i ++ )</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j ++ ) &#123;</span><br><span class="line"><span class="type">int</span> k = tr[i][j];</span><br><span class="line">w[i][k] = <span class="built_in">max</span>(w[i][k], (LL)cnt[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= idx; i ++ ) ans[<span class="number">0</span>][i] = -INF;</span><br><span class="line"><span class="keyword">while</span> (m) &#123;</span><br><span class="line"><span class="keyword">if</span> (m &amp; <span class="number">1</span>) <span class="built_in">mul</span>(ans, ans, w);</span><br><span class="line"><span class="built_in">mul</span>(w, w, w);</span><br><span class="line">m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">LL res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i ++ ) res = <span class="built_in">max</span>(res, ans[<span class="number">0</span>][i]);</span><br><span class="line">cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="25-欧拉路径"><a href="#25-欧拉路径" class="headerlink" title="25. 欧拉路径"></a><strong>25.</strong> <strong>欧拉路径</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">对于无向图：</span><br><span class="line">欧拉路径存在的充分必要条件：度数为奇数的点个数为<span class="number">2</span>个或<span class="number">0</span>个</span><br><span class="line">欧拉回路存在的充分必要条件：度数为奇数的点个数为<span class="number">0</span>个</span><br><span class="line">度数为奇数的点有<span class="number">2</span>个时，起点的度数不能是偶数：</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">城市中有 n 个交叉路口，m 条街道连接在这些交叉路口之间，每条街道的首尾都正好连接着一个交叉路</span><br><span class="line">口。除开街道的首尾端点，街道不会在其他位置与其他街道相交。每个交叉路口都至少连接着一条街道，有的</span><br><span class="line">交叉路口可能只连接着一条或两条街道。</span><br><span class="line">小明希望设计一个方案，从编号为 <span class="number">1</span> 的交叉路口出发，每次必须沿街道去往街道另一端的路口，再从新</span><br><span class="line">的路口出发去往下一个路口，直到所有的街道都经过了正好一次。</span><br><span class="line">输入格式</span><br><span class="line">输入的第一行包含两个整数 n,m，表示交叉路口的数量和街道的数量，交叉路口从 <span class="number">1</span> 到 n 标号。</span><br><span class="line">接下来 m 行，每行两个整数 a,<span class="built_in">b</span>(a≠b)，表示和标号为 a 的交叉路口和标号为 b 的交叉路口之间有</span><br><span class="line">一条街道，街道是双向的，小明可以从任意一端走向另一端。两个路口之间最多有一条街道。</span><br><span class="line">输出格式</span><br><span class="line">如果小明可以经过每条街道正好一次，则输出一行包含 m+<span class="number">1</span> 个整数 p1,p2,p3,…,pm+<span class="number">1</span>，表示小明经</span><br><span class="line">过的路口的顺序，相邻两个整数之间用一个空格分隔。如果有多种方案满足条件，则输出字典序最小的一种方</span><br><span class="line">案，即首先保证 p1 最小，p1 最小的前提下再保证 p2 最小，依此类推。如果不存在方案使得小明经过每条</span><br><span class="line">街道正好一次，则输出一个整数 −<span class="number">1</span>。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> ans[M], top;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line"><span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录一种走法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (g[u].<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="type">int</span> t = *g[u].<span class="built_in">begin</span>();</span><br><span class="line">g[u].<span class="built_in">erase</span>(t), g[t].<span class="built_in">erase</span>(u);</span><br><span class="line"><span class="built_in">dfs</span>(t);</span><br><span class="line">&#125;</span><br><span class="line">ans[ ++ top] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">g[a].<span class="built_in">insert</span>(b), g[b].<span class="built_in">insert</span>(a);</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(i) != <span class="built_in">find</span>(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (g[i].<span class="built_in">size</span>() % <span class="number">2</span>) s ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存在欧拉路径 则 奇顶点个数为 0 或 2 且 如果为2，则起点度数为奇数</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span> &amp;&amp; s != <span class="number">2</span> || s == <span class="number">2</span> &amp;&amp; g[<span class="number">1</span>].<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = top; i; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-AC自动机"><a href="#26-AC自动机" class="headerlink" title="26. AC自动机"></a><strong>26. AC自动机</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">给定 n 个模式串 s_i 和一个文本串 t，求有多少个不同的模式串在文本串里出现过。</span><br><span class="line">两个模式串不同当且仅当他们编号不同。</span><br><span class="line">输入格式</span><br><span class="line">第一行是一个整数，表示模式串的个数 n。</span><br><span class="line">第 <span class="number">2</span> 到第 (n + <span class="number">1</span>) 行，每行一个字符串，第 (i + <span class="number">1</span>) 行的字符串表示编号为 i 的模式串 s_i</span><br><span class="line">最后一行是一个字符串，表示文本串 t。</span><br><span class="line">输出格式</span><br><span class="line">输出一行一个整数表示答案。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span><span class="comment">//字典树</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="type">int</span> fail;<span class="comment">//失配指针</span></span><br><span class="line"><span class="type">int</span> son[<span class="number">26</span>];<span class="comment">//子节点的位置</span></span><br><span class="line"><span class="type">int</span> end;<span class="comment">//标记有几个单词以这个节点结尾</span></span><br><span class="line">&#125;AC[<span class="number">1000010</span>];<span class="comment">//Trie树</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//Trie的指针</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Build</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;<span class="comment">//字典树的当前指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)<span class="comment">//构造Trie树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(AC[now].son[s[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)<span class="comment">//Trie树没有这个子节点</span></span><br><span class="line">AC[now].son[s[i]-<span class="string">&#x27;a&#x27;</span>]= ++cnt;<span class="comment">//构造出来</span></span><br><span class="line">now = AC[now].son[s[i]-<span class="string">&#x27;a&#x27;</span>];<span class="comment">//向下构造</span></span><br><span class="line">&#125;</span><br><span class="line">AC[now].end += <span class="number">1</span>;<span class="comment">//标记单词结尾</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_fail</span><span class="params">()</span><span class="comment">//构造fail指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; Q;<span class="comment">//队列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;<span class="comment">//第二层的fail指针提前处理一下</span></span><br><span class="line"><span class="keyword">if</span>(AC[<span class="number">0</span>].son[i] != <span class="number">0</span>) &#123;</span><br><span class="line">AC[AC[<span class="number">0</span>].son[i]].fail = <span class="number">0</span>;<span class="comment">//指向根节点</span></span><br><span class="line">Q.<span class="built_in">push</span>(AC[<span class="number">0</span>].son[i]);<span class="comment">//压入队列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()) &#123;<span class="comment">//BFS求fail指针</span></span><br><span class="line"><span class="type">int</span> u = Q.<span class="built_in">front</span>();</span><br><span class="line">Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>; ++i) &#123;<span class="comment">//枚举所有子节点(仅有小写字母 26个)</span></span><br><span class="line"><span class="keyword">if</span>(AC[u].son[i] != <span class="number">0</span>) &#123; <span class="comment">//存在这个子节点</span></span><br><span class="line">AC[AC[u].son[i]].fail=AC[AC[u].fail].son[i];</span><br><span class="line"><span class="comment">//子节点的fail指针指向当前节点的</span></span><br><span class="line"><span class="comment">//fail指针所指向的节点的相同子节点</span></span><br><span class="line">Q.<span class="built_in">push</span>(AC[u].son[i]);<span class="comment">//压入队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> AC[u].son[i] = AC[AC[u].fail].son[i];</span><br><span class="line"><span class="comment">//当前节点的这个子节点指向当</span></span><br><span class="line"><span class="comment">//前节点fail指针的这个子节点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span><span class="comment">//AC自动机匹配</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> l = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; ++i)</span><br><span class="line">&#123;</span><br><span class="line">now = AC[now].son[s[i]-<span class="string">&#x27;a&#x27;</span>];<span class="comment">//向下一层</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t = now; t &amp;&amp; AC[t].end != <span class="number">-1</span>; t = AC[t].fail)<span class="comment">//循环求解</span></span><br><span class="line">&#123;</span><br><span class="line">ans += AC[t].end;</span><br><span class="line">AC[t].end = <span class="number">-1</span>;</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="built_in">Build</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">AC[<span class="number">0</span>].fail=<span class="number">0</span>;<span class="comment">//结束标志</span></span><br><span class="line"><span class="built_in">Get_fail</span>();<span class="comment">//求出失配指针</span></span><br><span class="line">cin &gt;&gt; s;<span class="comment">//文本串</span></span><br><span class="line">cout&lt;&lt; <span class="built_in">query</span>(s) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-区间DP"><a href="#27-区间DP" class="headerlink" title="27. 区间DP"></a><strong>27.</strong> <strong>区间DP</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line">将 n 堆石子绕圆形操场排放，现要将石子有序地合并成一堆。</span><br><span class="line">规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。</span><br><span class="line">请编写一个程序，读入堆数 n 及每堆的石子数，并进行如下计算：</span><br><span class="line">选择一种合并石子的方案，使得做 n−<span class="number">1</span> 次合并得分总和最大。</span><br><span class="line">选择一种合并石子的方案，使得做 n−<span class="number">1</span> 次合并得分总和最小。</span><br><span class="line">输入格式</span><br><span class="line">第一行包含整数 n，表示共有 n 堆石子。</span><br><span class="line">第二行包含 n 个整数，分别表示每堆石子的数量。</span><br><span class="line">输出格式</span><br><span class="line">输出共两行：</span><br><span class="line">第一行为合并得分总和最小值，</span><br><span class="line">第二行为合并得分总和最大值。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">410</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"><span class="type">int</span> f[N][N], g[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) a[i] = a[i - n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">-0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= n; len ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line"><span class="type">int</span> l = i, r = i + len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">f[l][r] = g[l][r] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt; r; k ++) &#123;</span><br><span class="line">f[l][r] = <span class="built_in">min</span>(f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>], f[l]</span><br><span class="line">[r]);</span><br><span class="line">g[l][r] = <span class="built_in">max</span>(g[l][k] + g[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>], g[l]</span><br><span class="line">[r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mi = <span class="number">0x3f3f3f3f</span>, ma = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++) &#123;</span><br><span class="line">mi = <span class="built_in">min</span>(f[l][l + n - <span class="number">1</span>], mi);</span><br><span class="line">ma = <span class="built_in">max</span>(g[l][l + n - <span class="number">1</span>], ma);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mi &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ma &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-树型DP"><a href="#28-树型DP" class="headerlink" title="28.树型DP"></a><strong>28.树型DP</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">有一座城市，城市中有 N 个公交站，公交站之间通过 N−<span class="number">1</span> 条道路连接，每条道路有相应的长度。</span><br><span class="line">保证所有公交站两两之间能够通过一唯一的通路互相达到。两个公交站之间路径长度定义为两个公交站之间路</span><br><span class="line">径上所有边的边权和。</span><br><span class="line">现在要对城市进行规划，将其中 M 个公交站定为“重要的”。</span><br><span class="line">现在想从中选出 K 个节点，使得这 K 个公交站两两之间路径长度总和最小。输出路径长度总和即可（节点编</span><br><span class="line">号从 <span class="number">1</span> 开始）。</span><br><span class="line">输入格式</span><br><span class="line">第 <span class="number">1</span> 行包含三个正整数 N，M 和 K 分别表示树的节点数，重要的节点数，需要选出的节点数。</span><br><span class="line">第 <span class="number">2</span> 行包含 M 个正整数，表示 M 个重要的节点的节点编号。</span><br><span class="line">接下来 N–<span class="number">1</span> 行，每行包含三个正整数 a，b，c，表示编号为 a 的节点与编号为 b 的节点之间有一条</span><br><span class="line">权值为 c 的无向边。</span><br><span class="line">每行中相邻两个数之间用一个空格分隔。</span><br><span class="line">输出格式</span><br><span class="line">输出只有一行，包含一个整数表示路径长度总和的最小值。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n, m, K;</span><br><span class="line"><span class="type">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="comment">// f[i][j] 表示以 i 为 根的树中选 j 个点, 该子树所有边对答案的贡献值</span></span><br><span class="line">LL f[N][<span class="number">110</span>];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="comment">// 记录子树大小</span></span><br><span class="line"><span class="type">int</span> sz[N];</span><br><span class="line">LL ans = <span class="number">1e18</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">f[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (st[u]) f[u][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">sz[u] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 分组背包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[u]; ~i; i = ne[i]) <span class="comment">// 枚举物品组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ver = e[i];</span><br><span class="line"><span class="comment">// 父节点不搜</span></span><br><span class="line"><span class="keyword">if</span> (ver == fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(ver, u);</span><br><span class="line">sz[u] += sz[ver];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">min</span>(sz[u], K); j &gt;= <span class="number">0</span>; j -- ) <span class="comment">// 枚举体积</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="built_in">min</span>(j, sz[ver]); k ++ ) <span class="comment">// 枚举决策</span></span><br><span class="line">f[u][j] = <span class="built_in">min</span>(f[u][j], f[u][j - k] + f[ver][k] + (LL)w[i] * k *</span><br><span class="line">(K - k));</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">min</span>(ans, f[u][K]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;K);</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">st[x] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) &#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="built_in">add</span>(a, b, c), <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="comment">// 第二个参数记录父节点, 无向图避免往回搜</span></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：链表</title>
    <url>/2024/08/04/%E7%AE%97%E6%B3%95%EF%BC%9A%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p>这里进行交换的是列表的物理阶段而不是链表节点中的值，这里需要用到虚拟头节点的方式。这里做交换最值班的思想是先取出一个交换基元，能够知道我们需要设置的指针有：当前指针cur、两个临时指针，分别用于存储下一个当前指针的存放位置和下一个当前指针存放位置的下一个节点。这个基础单元一共有三个位置，在最开始的情况中还有一个虚拟头接点这个虚拟头接点，是当前最开始的位置（只有这个位置能够改变前面两个指针的指向）</p>
<p>现在我们要分析指针改变方向的一个方式，我们是首先将当前指针（cur）的下一个指针，指向原本指针（cur）的下一个指针的下一个指针，然后我们要进行的是将原本指针（cur）的下一个指针的下一个指针指向原本指针的下一个指针（temp），这个指针我们是用临时指针存储过的，所以说我们可以直接指向临时指针。</p>
<p>然后对于我们这个单元其实是一般化的，在这个情况我们会遇到就是末尾，会还有一个节点或者说没有节点的情况，如果说有节点的话，那他就是一个奇数的链表。这个时候我们需要判断一下，因为这个时候当前指针已经来到了倒数第二个指针的位置，如果是这个时候的话当前指针（cur）的下一个指针的下一个指针它是空指针；如果说是偶数指针的话，偶数节点的话那他的下一位已经是空指针。就是当前指针（cur）的下一位是空指针，所以说我们需要了解的就是，如果说进行完这样一次操作之后，当前指针的下一个指针或者下下个指针为空指针的时候这个操作就应该结束了。最后要求返回头节点，其实就是返回我们的虚拟头节点的下一个指针。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyhead=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next=head;</span><br><span class="line">        ListNode *cur=dummyhead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">nullptr</span>&amp;&amp;cur-&gt;next-&gt;next!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode *temp=cur-&gt;next;</span><br><span class="line">            ListNode *temp1=temp-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next=temp-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next=temp;</span><br><span class="line">            temp-&gt;next-&gt;next-&gt;next=temp1;</span><br><span class="line">            cur=temp;</span><br><span class="line">            <span class="comment">//ListNode *temp=cur-&gt;next;</span></span><br><span class="line">            <span class="comment">//ListNode *temp1=temp-&gt;next-&gt;next;</span></span><br><span class="line">            <span class="comment">//cur-&gt;next=cur-&gt;next-&gt;next;</span></span><br><span class="line">            <span class="comment">//cur-&gt;next-&gt;next=cur-&gt;next;</span></span><br><span class="line">            <span class="comment">//temp-&gt;next-&gt;next-&gt;next=temp1;</span></span><br><span class="line">            <span class="comment">//cur=temp;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<ul>
<li><h4 id="虚拟头结点"><a href="#虚拟头结点" class="headerlink" title="虚拟头结点"></a>虚拟头结点</h4></li>
</ul>
<p>我们在处理链表问题时,通常会用到虚拟头结点这个工具,虚拟头结点本身不储存任何数据,它的存在只是为了更方便我们去对链表中的元素进行操作.</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
<th>g</th>
</tr>
</thead>
<tbody><tr>
<td>dummyhead</td>
<td>head</td>
<td>head-&gt;next</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>如果我们要删除头结点,那么就只需要将dummyhead的指针指向head-&gt;next所在的节点,清理掉头结点的内存,然后head节点指向dummyhead.</p>
<p>这里我们要删除链表的倒数第二个元素，首先我们要知道链表，我们是无法直接指定他到某个索引找出它的节点，我们需要用到一些方法就是快慢指针的那一种方式。</p>
<p>快慢指针的方式：快指针先走n步，慢指针后走，这样能在两个指针之间形成n个节点的间隔，当快指针走到空指针的位置的时候，慢指针刚好在倒数第n个节点的前一个节点的位置，之后对倒数第n个元素进行删除就好了，这里我们还需要使用到虚拟头接点的方式，有了虚拟头节点我们就方便地进行链表节点的删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyhead= <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyhead-&gt;next=head;</span><br><span class="line">        ListNode* fast=dummyhead;</span><br><span class="line">        ListNode* slow=dummyhead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next=slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.postimg.cc/WzGdvtRY/A0-A70-DA070-ECE89284-F06-FC7-C8-FBC855.png" alt="删除链表的倒数第n个元素"></p>
<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h3><p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 104]</code></li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>
<p><strong>进阶：</strong>你能用 <code>O(1)</code>（即，常量）内存解决此问题吗？</p>
<p>弗洛伊德法：使用快慢指针，如果链表中出现了环，那么快慢指针最后都到不了空指针的位置，如果链表中没有环，那么我们的快指针本身或者它前项的指针必定有一个是空指针。</p>
<p>快指针，在这里我们规定它的速度是两个节点一步，而慢指针的速度是一个节点一步。</p>
<p>整体是一个布尔类型的函数，最后的返回值是验证是否存在环。</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast=head;</span><br><span class="line">        ListNode* slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.postimg.cc/WzGdvtRY/A0-A70-DA070-ECE89284-F06-FC7-C8-FBC855.png" alt="环形链表"></p>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<p>可以使用快慢指针法， 分别定义 fast 和 slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</p>
<p>为什么slow指针不会多走几圈呢</p>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="img"></p>
<p>为什么fast 走两个节点，slow走一个节点，有环的话，一定会在环内相遇呢，而不是永远的错开呢</p>
<p>首先第一点： fast指针一定先进入环中，如果fast 指针和slow指针相遇的话，一定是在环中相遇，这是毋庸置疑的。可以画一个环，然后让 fast指针在任意一个节点开始追赶slow指针。会发现最终都是这种情况， 如下图：</p>
<p><img src="https://code-thinking.cdn.bcebos.com/gifs/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%EF%BC%88%E6%B1%82%E5%85%A5%E5%8F%A3%EF%BC%89.gif" alt="142.环形链表II（求入口）"></p>
<p>假设从头结点到环形入口节点 的节点数为x。<br>环形入口节点到 fast指针与slow指针相遇节点 节点数为y。<br>从相遇节点 再到环形入口节点节点数为 z。 如图所示：<br>slow指针走过的节点数为:<br>$$<br>x+y+n_1(y+z)<br>$$</p>
<p>fast指针走过的节点数：<br>$$<br>x + y + n _2(y + z)<br>$$</p>
<p>n为fast指针在环内走了n圈才遇到slow指针， <strong>（y+z）</strong>为 一圈内节点的个数</p>
<p>总方程（原理：总步数相等）<br>$$<br>[(x+y)+n_1(y+z)] * 2 &#x3D; x + y + n_2 (y + z)<br>$$</p>
<p>即<br>$$<br>x + y &#x3D; n_3 (y + z)\\<br>n_3&#x3D;n_2-2n_1<br>$$</p>
<p>环形的入口<br>$$<br>x  &#x3D; n_3 (y + z)-y&#x3D;(n_3-1)(y+z)+z<br>$$</p>
<p>也就是在相遇节点处，定义一个指针<strong>index1</strong>，在头结点处定一个指针<strong>index2</strong>。</p>
<p>n如果大于1是什么情况呢，就是fast指针在环形转n圈之后才遇到 slow指针。</p>
<p>其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode*fast=head;</span><br><span class="line">        ListNode*slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)</span><br><span class="line">            &#123;</span><br><span class="line">                ListNode*index1=fast;</span><br><span class="line">                ListNode*index2=head;</span><br><span class="line">                <span class="keyword">while</span>(index1!=index2)</span><br><span class="line">                &#123;</span><br><span class="line">                    index1=index1-&gt;next;</span><br><span class="line">                    index2=index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>层次分析</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//外层为具体条件,while语句对链表进行扫描</span></span><br><span class="line"><span class="comment">//slow一次移动一个节点,fast则移动两个</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(slow==fast)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode*index1=fast;</span><br><span class="line">    ListNode*index2=head;</span><br><span class="line">    <span class="comment">//用index1和index2标记头结点和fast节点</span></span><br><span class="line">    <span class="comment">//标记slow也可以</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span>(index1!=index2)</span><br><span class="line">            &#123;</span><br><span class="line">                index1=index1-&gt;next;</span><br><span class="line">                index2=index2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> index2;</span><br><span class="line"><span class="comment">//用快指针定位,已知x=(n-1)(y+z)+z</span></span><br><span class="line"><span class="comment">//就是当index1(fast)指针到达相交点后,index2(head)指针也在这里</span></span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<p>通常我们会在大厂里的第一道比较简单的面试题里面，见到反转链表这样的题目，这是对单链表数据结构的基本操作，是需要掌握的知识点。</p>
<p>众所周知，链表中一个基础结构叫做节点，节点之中有<strong>数据域和指针域</strong>两个部分，一个链表由<strong>头节点决定链表整体的地址信息</strong>，头接点可以遍历整个链表，而要把链表反转，就是让每个节点的<strong>指针域进行反向操作</strong>，这是比较高级的做法，下面从最开始接触到反转链表的问题的想法。</p>
<p>最容易想到的是，利用双指针的方法，进一步说明就是利用左右指针的算法，从链表两侧往中间遍历。对于整个链表，基本操作方式就是，左指针从链表的左侧一直往右侧移动，右测的指针往左测移动，当左右指针都能移动一步过后，我们把这两个指针所在的节点的数据域进行交换。但是，这里交换数据域出现问题，我们不能直接像数组一样，利用索引就调出某个元素的值，这边我们要调用单列表的某个元素是，只能从头节点开始遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;target;i++)</span><br><span class="line">&#123;</span><br><span class="line">    currPtr=currPtr-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果像这样去调用每个对象的数据域，会出现currPtr的指向一直在变化，我们要调用两个镜像的节点的数据域需要考虑预设中间节点，但是我们没有回退的指针运算，不管如何，都得从头节点出发。如果是能够从中间开始，这里就需要考虑元素的奇偶性，必然会导致“数数”的过程，增加运算的步骤，出现这样的情况。</p>
<blockquote>
<p>注意：如果出现奇偶的情况，最先考虑二者最后的执行情况是否能一致。</p>
</blockquote>
<p>很显然，反转链表是一道简单题，如果是选择数据域进行操作，可以计算一下操作的自由度：这里存在链表给予的空间自由度，还有链表本身的一维遍历自由度.</p>
<p>单链表有一个特点:每一个节点之间以一个next指针连接,要遍历整个链表只需找头接点,头接点规定为链表的末尾节点,接着将所有的指针域反转,就可以实现链表反转的目标.</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
<th>空</th>
</tr>
</thead>
<tbody><tr>
<td>head</td>
<td>head-&gt;next</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td>nullptr</td>
</tr>
<tr>
<td>currPtr</td>
<td>currPtr-&gt;next</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>prevPtr</td>
</tr>
<tr>
<td></td>
<td>temPtr</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://pic.leetcode-cn.com/1631933586-mEtOBg-008eGmZEly1gnrf1oboupg30gy0c44qp.gif" alt="img"></p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
<th>f</th>
<th>空</th>
</tr>
</thead>
<tbody><tr>
<td>head</td>
<td>head-&gt;next</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td>~</td>
<td>nullptr</td>
</tr>
<tr>
<td>currPtr</td>
<td>currPtr-&gt;next</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>prevPtr</td>
</tr>
<tr>
<td></td>
<td>temPtr</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>存c下一位,转向切换</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* currPtr=head;</span><br><span class="line">        ListNode* prevPtr=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(currPtr!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode*temPtr=currPtr-&gt;next;</span><br><span class="line">            <span class="comment">//①</span></span><br><span class="line">            currPtr-&gt;next=prevPtr;</span><br><span class="line">            <span class="comment">//其实是调转方向的指令②</span></span><br><span class="line">            prevPtr=currPtr;</span><br><span class="line">            <span class="comment">//③</span></span><br><span class="line">            currPtr=temPtr;</span><br><span class="line">            <span class="comment">//④</span></span><br><span class="line">            <span class="comment">//①④是完成操作后,使c前进一位</span></span><br><span class="line">            <span class="comment">//③是完成调转方向后,使p前进一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prevPtr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>链表的操作可以微元化单个步骤的重复.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(currPtr!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode*temPtr=currPtr-&gt;next;</span><br><span class="line">            <span class="comment">//①</span></span><br><span class="line">            currPtr-&gt;next=prevPtr;</span><br><span class="line">            <span class="comment">//其实是调转方向的指令②</span></span><br><span class="line">            prevPtr=currPtr;</span><br><span class="line">            <span class="comment">//③</span></span><br><span class="line">            currPtr=temPtr;</span><br><span class="line">            <span class="comment">//④</span></span><br><span class="line">            <span class="comment">//①④是完成操作后,使c前进一位</span></span><br><span class="line">            <span class="comment">//③是完成调转方向后,使p前进一位</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* pre,ListNode* cur)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span> pre;</span><br><span class="line">ListNode* temp = cur-&gt;next;</span><br><span class="line">cur-&gt;next = pre;</span><br><span class="line"><span class="comment">// 可以和双指针法的代码进⾏对⽐，如下递归的写法，其实就是做了这两步</span></span><br><span class="line"><span class="comment">// pre = cur;</span></span><br><span class="line"><span class="comment">// cur = temp;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse</span>(cur,temp);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 和双指针法初始化是⼀样的逻辑</span></span><br><span class="line"><span class="comment">// ListNode* cur = head;</span></span><br><span class="line"><span class="comment">// ListNode* pre = NULL;</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reverse</span>(<span class="literal">NULL</span>, head);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="虚拟头结点-1"><a href="#虚拟头结点-1" class="headerlink" title="虚拟头结点"></a>虚拟头结点</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代⽅法：增加虚头结点，使⽤头插法实现链表翻转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList1</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"><span class="comment">// 创建虚头结点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">dumpyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">dumpyHead.next = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 遍历所有节点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line"><span class="comment">// 头插法</span></span><br><span class="line">cur.next = dumpyHead.next;</span><br><span class="line">dumpyHead.next = cur;</span><br><span class="line">cur = temp;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> dumpyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h4><p>递归这个方法已经很久没有用到过了，现在在这里复习一下。要讲递归这一方法，可以从斐波那契数列开讲，斐波那契数列有一个通式<br>$$<br>F_n&#x3D;F_{n-1}+F_{n-2}\\(n&gt;2)<br>$$<br>若是想求出某一个项的值，可以采用递归的方式，这个式子满足一个特点，满足数列前后项的一定关系，这个关系是可以一直递推到最开始的情况<br>$$<br>F_3&#x3D;F_1+F_2&#x3D;1+1&#x3D;2<br>$$<br>这使得只要将这个递推进行到底，总能得到最后的结果，所谓的递归，就是调用某个函数之后。反复调用这一个函数，直到达到所预设的边界。这里提到了调用函数，在C++里面，调用某个函数过后，除了最后的返回值，在函数内部的其他数据成员最后都会被析构，也就是说已经得出的结果，不能在其他时候进行复用，在这个时候，就出现了动态规划这一算法。</p>
<h5 id="递归求斐波那契数列"><a href="#递归求斐波那契数列" class="headerlink" title="递归求斐波那契数列"></a>递归求斐波那契数列</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fbnq</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n=<span class="number">2</span>||n=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fbnq</span>(n<span class="number">-1</span>)+<span class="built_in">fbnq</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="动态规划（Dynamic-Programing）"><a href="#动态规划（Dynamic-Programing）" class="headerlink" title="动态规划（Dynamic Programing）"></a>动态规划（Dynamic Programing）</h4><h5 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">斐波那契数列可以看作一个简易的DP问题</span><br><span class="line"><span class="built_in">F</span>(n)=<span class="built_in">F</span>(n<span class="number">-1</span>)+<span class="built_in">F</span>(n<span class="number">-2</span>);(n&gt;=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">F</span>(<span class="number">10</span>)=<span class="built_in">F</span>(<span class="number">9</span>)+<span class="built_in">F</span>(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">F</span>(<span class="number">9</span>)=<span class="built_in">F</span>(<span class="number">8</span>)+<span class="built_in">F</span>(<span class="number">7</span>);</span><br><span class="line">……</span><br><span class="line"><span class="built_in">F</span>(<span class="number">3</span>)=<span class="built_in">F</span>(<span class="number">2</span>)+<span class="built_in">F</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>如果是使用递归思路，那么程序需要将每一次需要的元素都重新算一次，会导致重复的运算，如果是在DP算法里面，每一次算过的数都用一个数组或者哈希表存储起来，之后就可以复用了，这样能减少运算量。</p>
<h5 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h5><h6 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h6><p>F(n-1)和F(n-2)称为F(n)的最优子结构</p>
<h6 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h6><p>F(n)&#x3D;F(n-1)+F(n-2)就称为状态转移方程</p>
<h6 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h6><p>F(1) &#x3D; 1, F(2) &#x3D; 2 就是边界啦</p>
<h6 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h6><p>比如F(10)&#x3D; F(9)+F(8),F(9) &#x3D; F(8) + F(7) ,f(8)就是重叠子问题</p>
<h5 id="DP计算斐波那契数列"><a href="#DP计算斐波那契数列" class="headerlink" title="DP计算斐波那契数列"></a>DP计算斐波那契数列</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">ans.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">ans.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    ans[i]=ans[i<span class="number">-1</span>]+ans[i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>自定义评测：</strong></p>
<p><strong>评测系统</strong> 的输入如下（你设计的程序 <strong>不适用</strong> 此输入）：</p>
<ul>
<li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li>
<li><code>listA</code> - 第一个链表</li>
<li><code>listB</code> - 第二个链表</li>
<li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li>
<li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li>
</ul>
<p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 <strong>视作正确答案</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br><span class="line">— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li><code>1 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li>
</ul>
<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(m + n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<h4 id="逻辑环-双指针"><a href="#逻辑环-双指针" class="headerlink" title="逻辑环+双指针"></a>逻辑环+双指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *A=headA,*B=headB;</span><br><span class="line">        <span class="keyword">while</span>(A!=B)</span><br><span class="line">        &#123;</span><br><span class="line">            A=A!=<span class="literal">nullptr</span>?A-&gt;next:headB;</span><br><span class="line">            B=B!=<span class="literal">nullptr</span>?B-&gt;next:headA;</span><br><span class="line">            <span class="comment">//相当于将两个链表结成一个环，当两个指针完全一致的时候，就返回对应的指针</span></span><br><span class="line">            <span class="comment">//这里的环只是逻辑上的环，实际上并没有改变链表的任何数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="复杂双指针"><a href="#复杂双指针" class="headerlink" title="复杂双指针"></a>复杂双指针</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表A的长度</span></span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">NULL</span>) &#123; <span class="comment">// 求链表B的长度</span></span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">// 让curA为最长链表的头，lenA为其长度</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求长度差</span></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">        <span class="comment">// 让curA和curB在同一起点上（末尾位置对齐）</span></span><br><span class="line">        <span class="keyword">while</span> (gap--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历curA 和 curB，遇到相同则直接返回</span></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：高精度问题</title>
    <url>/2022/10/21/%E7%AE%97%E6%B3%95%EF%BC%9A%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​	我们在使用c++在进行一系列运算的过程中，不能按照我们在日常生活中的思维，因为在编程语言的计算中，往往还需要考虑内存的问题，位数过高的数据会超过系统能提供的内存大小，导致报错，而我们又需要进行一些高精度的计算问题，所以会出现专门解决高精度运算的高精度算法。</p>
<p>​	高精度算法有四个基本的类型：高精度加法、高精度减法、高精度乘法、高精度除法。在本文中，我们将由浅入深，由易到难，层层剥开高精度算法背后的秘密。</p>
<h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><p>​	由于通常的存储计位方式会导致我们的内存出现越界的情况，在高精度加法的运算中，我们采取了使用字符串存储目标数据的方式。</p>
<p>​	整个程序的设计思路应该从，语言选择-&gt;输出选项-&gt;无效数据的排除-&gt;数据处理-&gt;结果输出的路线出发，下面给出一个高精度加法的例题，我们将从这个例题出发，剖析高精度加法的算法。</p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>高精度加法。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>两个整数<em>a</em>,<em>b</em>。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>结果。</p>
<h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><p><strong>输入 #1</strong>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>输出 #1</strong>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h4><ul>
<li><p>20%20% 数据 <em>a</em>,<em>b</em> 在 long long 范围内；</p>
</li>
<li><p>100% 数据 0&lt;𝑎,𝑏≤$10^1008#</p>
</li>
<li><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int main()
&#123;
    string s=&#123;s1,s2&#125;;
    for(int i=0;i&lt;=1;i++)
    &#123;
        s[i]=getline(cin,line);
    &#125;
    for(int )
    
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">​	在计算这个高精度问题的时候，我们需要知道我们现在其实是在用字符串进行着计算，所以我们做的事情其实是将运算转化为字符串的计算，而联想我们平时用到的加法运算方式，就能发现，其实我们在进行多位数运算的时候，其实很多时候是使用了进位法的，所以现在我们需要解决的问题就是，研究明白字符串的进位运算方式。</span><br><span class="line"></span><br><span class="line">​	在我们的思考过程中，我们先遍历一遍我们给如的这两个字符串的所有情况，不难发现，我们的运算位数和短的那个字符串相关，最简单的情况是，我们变换的位数和短字符串是一样的，一般的情况呢是需要运算比短字符串多一位的，最特殊的情况就是需要连续进位，这样就不能确定具体多少次了，最高位需要特殊处理，而一般位数的相加我只需要进行以下操作。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">for(int i=0;i&lt;minlength;i++)</span><br><span class="line">&#123;</span><br><span class="line">	int tem=s1[s1.size()-i]-&#x27;&#x27;+s2[s2.size()-i]-&#x27;&#x27;;</span><br><span class="line">if(i=minlength-1&amp;&amp;tem&gt;9)</span><br><span class="line">&#123;</span><br><span class="line">	flag=1;</span><br><span class="line">	break;</span><br><span class="line">&#125;</span><br><span class="line">if(tem&gt;9)</span><br><span class="line">&#123;</span><br><span class="line">	s[i]+=tem%10;</span><br><span class="line">	s[i+1]++;</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">	s[i]+=tem%10;   	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>在处理最高位的时候，我们需要考虑的事情在于，短字符串的最高位和其对应的长字符串的那一位相加之后的结果，这里其实可以分为三个类型：第一是相加的结果小于10，这样就直接结束处理过程，准备进入输出过程，而如果相加的结果大于10的话，这个时候也要分两种情况，第一种是进位的时候，不会导致下一位的结果也大于等于10，反之就又需要进位。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=minlength;i&lt;maxlength;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]&gt;<span class="number">9</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i]+=s1[i];</span><br><span class="line">        s[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理器：c++预处理器</title>
    <url>/2024/08/02/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%9Ac-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p>ss</p>
<h1 id="C-C-预处理器参考"><a href="#C-C-预处理器参考" class="headerlink" title="C&#x2F;C++ 预处理器参考"></a>C&#x2F;C++ 预处理器参考</h1><p>本文内容</p>
<p>“C&#x2F;C++ 预处理器参考”对在 Microsoft C&#x2F;C++ 中实现的预处理器进行了说明。 在将 C 和 C++ 文件传递到编译器之前，预处理器将对这些文件执行预先操作。 可以使用预处理器有条件地编译代码、插入文件、指定编译时错误消息以及将计算机特定规则应用于代码节。</p>
<p>在 Visual Studio 2019 中，<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/zc-preprocessor?view=msvc-170">&#x2F;Zc:preprocessor</a> 编译器选项提供完全一致的 C11 和 C17 预处理器。 使用编译器标志 <code>/std:c11</code> 或 <code>/std:c17</code> 时，这是默认设置。</p>
<h2 id="本部分内容"><a href="#本部分内容" class="headerlink" title="本部分内容"></a>本部分内容</h2><p><a href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/preprocessor?view=msvc-170">预处理器</a><br>概述传统预处理器和符合要求的新预处理器。</p>
<p><a href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/preprocessor-directives?view=msvc-170">预处理器指令</a><br>介绍通常用于使源程序易于在不同的执行环境中更改和编译的指令。</p>
<p><a href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/preprocessor-operators?view=msvc-170">预处理器运算符</a><br>讨论在 <code>#define</code> 指令的上下文中使用的四个预处理器特定运算符。</p>
<p><a href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/predefined-macros?view=msvc-170">预定义宏</a><br>讨论由 C 和 C++ 标准以及 Microsoft C++ 指定的预定义宏。</p>
<p><a href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/pragma-directives-and-the-pragma-keyword?view=msvc-170">杂注</a><br>讨论杂注，杂注提供了一种方法来让每个编译器提供计算机和操作系统特定的功能，同时保持与 C 和 C++ 语言的整体兼容性。</p>
<h2 id="相关章节"><a href="#相关章节" class="headerlink" title="相关章节"></a>相关章节</h2><p><a href="https://learn.microsoft.com/zh-cn/cpp/cpp/cpp-language-reference?view=msvc-170">C++ 语言参考</a><br>提供有关 Microsoft 的 C++ 语言实现的参考材料。</p>
<p><a href="https://learn.microsoft.com/zh-cn/cpp/c-language/c-language-reference?view=msvc-170">C 语言参考</a><br>提供有关 Microsoft 的 C 语言实现的参考材料。</p>
<p><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/c-cpp-building-reference?view=msvc-170">C&#x2F;C++ 生成参考</a><br>提供指向讨论编译器和链接器选项的主题的链接。</p>
<p><a href="https://learn.microsoft.com/zh-cn/cpp/build/creating-and-managing-visual-cpp-projects?view=msvc-170">Visual Studio projects - C++</a><br>描述 Visual Studio 中使您能够指定目录（项目系统将在其中进行搜索以找到 C++ 项目的文件）的用户界面。</p>
]]></content>
      <tags>
        <tag>预处理器</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向工程</title>
    <url>/2025/05/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="第一章：关于逆向工程"><a href="#第一章：关于逆向工程" class="headerlink" title="第一章：关于逆向工程"></a><strong>第一章：关于逆向工程</strong></h1><h2 id="1-1-逆向工程（Reverse-Engineering）"><a href="#1-1-逆向工程（Reverse-Engineering）" class="headerlink" title="1.1 逆向工程（Reverse Engineering）"></a>1.1 逆向工程（Reverse Engineering）</h2><h2 id="1-2-代码逆向工程（Reverse-Code-Engineering）"><a href="#1-2-代码逆向工程（Reverse-Code-Engineering）" class="headerlink" title="1.2 代码逆向工程（Reverse Code Engineering）"></a>1.2 代码逆向工程（Reverse Code Engineering）</h2><h3 id="1-2-1-逆向分析法"><a href="#1-2-1-逆向分析法" class="headerlink" title="1.2.1 逆向分析法"></a>1.2.1 逆向分析法</h3><ol>
<li>静态分析法</li>
<li>动态分析法</li>
</ol>
<h3 id="1-2-2-源代码、十六进制代码、汇编代码"><a href="#1-2-2-源代码、十六进制代码、汇编代码" class="headerlink" title="1.2.2 源代码、十六进制代码、汇编代码"></a>1.2.2 源代码、十六进制代码、汇编代码</h3><h3 id="1-2-3-”打补丁”与“破解”"><a href="#1-2-3-”打补丁”与“破解”" class="headerlink" title="1.2.3 ”打补丁”与“破解”"></a>1.2.3 ”打补丁”与“破解”</h3><h2 id="1-3-代码逆向准备"><a href="#1-3-代码逆向准备" class="headerlink" title="1.3 代码逆向准备"></a>1.3 代码逆向准备</h2><h3 id="1-3-1-目标"><a href="#1-3-1-目标" class="headerlink" title="1.3.1 目标"></a>1.3.1 目标</h3><h3 id="1-3-2-激情"><a href="#1-3-2-激情" class="headerlink" title="1.3.2 激情"></a>1.3.2 激情</h3><h3 id="1-3-3-谷歌"><a href="#1-3-3-谷歌" class="headerlink" title="1.3.3 谷歌"></a>1.3.3 谷歌</h3><h2 id="1-4-逆向分析技术的禁忌"><a href="#1-4-逆向分析技术的禁忌" class="headerlink" title="1.4 逆向分析技术的禁忌"></a>1.4 逆向分析技术的禁忌</h2><h3 id="1-4-1-贪心"><a href="#1-4-1-贪心" class="headerlink" title="1.4.1 贪心"></a>1.4.1 贪心</h3><h3 id="1-4-2-急躁"><a href="#1-4-2-急躁" class="headerlink" title="1.4.2 急躁"></a>1.4.2 急躁</h3><h2 id="1-5-逆向分析技术的乐趣"><a href="#1-5-逆向分析技术的乐趣" class="headerlink" title="1.5 逆向分析技术的乐趣"></a>1.5 逆向分析技术的乐趣</h2><h1 id="第二章-逆向分析Hello-World！"><a href="#第二章-逆向分析Hello-World！" class="headerlink" title="第二章 逆向分析Hello World！"></a><strong>第二章 逆向分析Hello World！</strong></h1><h2 id="2-1-Hello-World！程序"><a href="#2-1-Hello-World！程序" class="headerlink" title="2.1 Hello World！程序"></a>2.1 Hello World！程序</h2><p>先用源代码文件生成exe文件</p>
<h2 id="2-2-调试HelloWorld-exe程序"><a href="#2-2-调试HelloWorld-exe程序" class="headerlink" title="2.2 调试HelloWorld.exe程序"></a>2.2 调试HelloWorld.exe程序</h2><p>exe是二进制文件，我们需要用Debugger（调试器），它内嵌了Disassembler（反汇编）模块，可以用它将二进制代码转化为Assembly（汇编）指令代码。</p>
<h3 id="2-2-1-调试目标"><a href="#2-2-1-调试目标" class="headerlink" title="2.2.1 调试目标"></a>2.2.1 调试目标</h3><p>找到转换得到的汇编语言代码中的main()函数。</p>
<h3 id="2-2-2-开始调试"><a href="#2-2-2-开始调试" class="headerlink" title="2.2.2 开始调试"></a>2.2.2 开始调试</h3><p>工具：OllyDbg<br>工具的基本介绍：<!--![[Image_269761186866128.jpg]]--><br><img src="https://i.imgur.com/IxqLk7M.jpeg"></p>
<p>步骤：使用OllyDbg打开HelloWorld.exe程序。</p>
<!--![[Image_269837128878617.jpg]]-->
<p><img src="https://i.imgur.com/wMi4aIQ.jpeg"></p>
<h3 id="2-2-3-入口点"><a href="#2-2-3-入口点" class="headerlink" title="2.2.3 入口点"></a>2.2.3 入口点</h3><p>调试停止的地点是HelloWorld.exe执行的起始点（4011A0），它是一段EP（EntryPoint）代码。<br>重要指令：CALL&amp;JMP<!--![[Screenshot_20250303_103950.jpg]]--><br><img src="https://i.imgur.com/LHndYOe.jpeg"></p>
<p>代码含义：调用40270C处的函数，再跳转到40104F的函数处。</p>
<h3 id="2-2-4-跟踪40270C函数"><a href="#2-2-4-跟踪40270C函数" class="headerlink" title="2.2.4 跟踪40270C函数"></a>2.2.4 跟踪40270C函数</h3><!--![[Screenshot_20250303_104214.jpg]]-->
<p><img src="https://i.imgur.com/FMZoS8i.jpeg"></p>
<p>在EP代码的4011A0处，按F7（step into），进入该处的函数内部：</p>
<!--<!--![[Screenshot_20250303_104420.j-->pg]]-->
<p><img src="https://i.imgur.com/Kb3tn4m.jpeg"></p>
<p><img src="https://i.imgur.com/m3PSNrw.jpeg"></p>
<!--⚠️Imgur upload failed, check dev console-->

<p>右边是&#x3D;&#x3D;OllyDbg&#x3D;&#x3D;的注释，红色的字是代码调用的&#x3D;&#x3D;API&#x3D;&#x3D;函数名称，这些函数并不是源码中的内容，是保证程序正常运行而被添加的内容。目前不需要关注这些API函数，可以直接按&#x3D;&#x3D;F8（Step over）&#x3D;&#x3D;命令或者跳过。在&#x3D;&#x3D;4027A1&#x3D;&#x3D;处有&#x3D;&#x3D;RETN&#x3D;&#x3D;指令，直接按&#x3D;&#x3D;F8（Step over）&#x3D;&#x3D;命令或者&#x3D;&#x3D;Ctrl+F9（Execute till Return）&#x3D;&#x3D;，继续操作按F7&#x2F;F8执行RETN指令，程序会跳转到&#x3D;&#x3D;4011A5&#x3D;&#x3D;地址处，也就是结束了目前的函数，进入了下一个点。</p>
<h3 id="2-2-5-跟踪40104F跳转语句"><a href="#2-2-5-跟踪40104F跳转语句" class="headerlink" title="2.2.5 跟踪40104F跳转语句"></a>2.2.5 跟踪40104F跳转语句</h3><p>执行&#x3D;&#x3D;4011A5&#x3D;&#x3D;的跳转命令&#x3D;&#x3D;JMP 0040104F&#x3D;&#x3D;，跳转到&#x3D;&#x3D;40104F&#x3D;&#x3D;地址处，结果如下：</p>
<!--![[Screenshot_20250303_105621.jpg]]-->
<p><img src="https://i.imgur.com/Q8FSRW6.jpeg"></p>
<p>这些看上去很复杂，实质上只是启动函数，跟着这个函数，我们就能查找到目标的main()函数。</p>
<h3 id="2-2-6-查找main-函数"><a href="#2-2-6-查找main-函数" class="headerlink" title="2.2.6 查找main()函数"></a>2.2.6 查找main()函数</h3><p>逐条分析&#x3D;&#x3D;40104F&#x3D;&#x3D;就可以找到要查找的main()函数，这是一种笨拙的方式。<br>OllyDbg的四种指令：Restart（F2）、Step Into（F7）、Step Over（F8）、Execute till Return（Ctrl+F9）.<br>从&#x3D;&#x3D;40104F&#x3D;&#x3D;地址开始，没执行一次F7就下移动一行代码，移动到401056地址处的CALL 402524函数调用指令时，执行Step Into进入&#x3D;&#x3D;402524&#x3D;&#x3D;函数。<!--![[Screenshot_20250303_111310.jpg]]--><br><img src="https://i.imgur.com/Fs77NNt.jpeg"></p>
<p>没有看到&#x3D;&#x3D;MessageBox()API&#x3D;&#x3D;的代码，这个函数不是main()函数，就跳出这个函数。</p>
<!--<!--![[Screenshot_20250303_111717.j-->pg]]-->
<p><img src="https://i.imgur.com/iEsDh4X.jpeg"></p>
<p><img src="https://i.imgur.com/W5N83o0.jpeg"></p>
<p>如果在调试过程中遇到以下的代码，像&#x3D;&#x3D;4010E4&#x3D;&#x3D;地址处的&#x3D;&#x3D;CALL Kernel32.GetCommandLineW&#x3D;&#x3D;指令，那就直接&#x3D;&#x3D;F8&#x3D;&#x3D;跳过，这是调用&#x3D;&#x3D;Win32 API&#x3D;&#x3D;的代码。<br>如果一切正常，则可以看到如下的代码：<!--![[Screenshot_20250303_112028.jpg]]--><br><img src="https://i.imgur.com/EuftB4Q.jpeg"></p>
<p>在当前地址处有一个&#x3D;&#x3D;CALL 401000&#x3D;&#x3D;指令，用于调用&#x3D;&#x3D;401000&#x3D;&#x3D;函数，按F7进入这个函数。</p>
<!--![[Screenshot_20250303_112148.jpg]]-->
<p><img src="https://i.imgur.com/JTBN7ij.jpeg"></p>
<p>这里出现了&#x3D;&#x3D;MessageBoxW()API的代码&#x3D;&#x3D;，参数是“<a href="http://www.reversecore.com”和“hello/">www.reversecore.com”和“Hello</a> World！”两个字符串，所以这就是main()函数。</p>
<h2 id="2-3-进一步熟悉调试器"><a href="#2-3-进一步熟悉调试器" class="headerlink" title="2.3 进一步熟悉调试器"></a>2.3 进一步熟悉调试器</h2><h3 id="2-3-1-调试器指令"><a href="#2-3-1-调试器指令" class="headerlink" title="2.3.1 调试器指令"></a>2.3.1 调试器指令</h3><!--![[Screenshot_20250303_112610.jpg]]-->
<p><img src="https://i.imgur.com/AVlm4IC.jpeg"></p>
<h3 id="2-3-2-“大本营”"><a href="#2-3-2-“大本营”" class="headerlink" title="2.3.2 “大本营”"></a>2.3.2 “大本营”</h3><p>重新运行调试器的时候，调试都会返回到EP处，使用起来不方便。调试代码时需要寻找重要的地址，以方便在重新调试的时候，快速回到这里。</p>
<h3 id="2-3-3-设置“大本营”的四种方法"><a href="#2-3-3-设置“大本营”的四种方法" class="headerlink" title="2.3.3 设置“大本营”的四种方法"></a>2.3.3 设置“大本营”的四种方法</h3><ol>
<li><p>Goto命令<br>确定“大本营”的地址为40104F，执行&#x3D;&#x3D;Go to（Ctrl+G）&#x3D;&#x3D;命令，打开一个&#x3D;&#x3D;Enter expression to follow&#x3D;&#x3D;对话框，在文本框中输入“40104F”。<br>下一次直接执行&#x3D;&#x3D;Execute till cursor（F4）&#x3D;&#x3D;命令，就可以直接到这个点了。</p>
<!--![[Screenshot_20250303_113305.jpg]]-->
<p><img src="https://i.imgur.com/bNTxHpU.jpeg"></p>
</li>
<li><p>设置断点<br>直接设置&#x3D;&#x3D;BP（Break Point）F2&#x3D;&#x3D;让调试流转到大本营。</p>
</li>
</ol>
<!--![[Screenshot_20250303_113323.jpg]]-->
<p><img src="https://i.imgur.com/SMMF2Rj.jpeg"></p>
<p>在&#x3D;&#x3D;OllyDbg&#x3D;&#x3D;菜单栏依次选择&#x3D;&#x3D;View-Breakpoints（ALT+B）&#x3D;&#x3D;，打开BPS对话框，可以看到设置过的断点，直接双击可以跳转到相应的位置。<br>2. 注释<br>按；键可以在指定地址添加注释：</p>
<!--![[Screenshot_20250303_113612.jpg]]-->
<p><img src="https://i.imgur.com/s7kHjCL.jpeg"></p>
<p>鼠标右键，选择 Search for-user defined comment，可以找到所有注释，双击对应注释可以跳转到对应位置。</p>
<!--![[Screenshot_20250303_113823.jpg]]-->
<p><img src="https://i.imgur.com/kSyGSqy.jpeg"></p>
<ol>
<li>标签<br>按：键可以输入标签，加入标签之后，我们可以直接在代码窗口中看到标签。标签也可以用类似的方式进行搜索。<!--![[Screenshot_20250303_113952.jpg]]-->
<img src="https://i.imgur.com/2YOYWDy.jpeg"></li>
</ol>
<h2 id="2-4-快速查找指定代码的四种方法"><a href="#2-4-快速查找指定代码的四种方法" class="headerlink" title="2.4 快速查找指定代码的四种方法"></a>2.4 快速查找指定代码的四种方法</h2><h3 id="2-4-1-代码执行法"><a href="#2-4-1-代码执行法" class="headerlink" title="2.4.1 代码执行法"></a>2.4.1 代码执行法</h3><p>要查找的是main()函数中调用MessageBox()函数的代码。在调试时，一直F8总会在某个时候被调用出来，这就是原理。先从大本营开始，一直按F8，直到出现弹窗信息，按Ctrl+F2再次载入待调试的可执行文件并重新调试，如果出现弹窗了，那对应调用的函数就是main()函数。</p>
<h3 id="2-4-2-字符串检索法"><a href="#2-4-2-字符串检索法" class="headerlink" title="2.4.2 字符串检索法"></a>2.4.2 字符串检索法</h3><p>基于OllyDbg的预分析工程列出的表格，会列出程序代码引用的字符串，像下面的表格中，&#x3D;&#x3D;401007&#x3D;&#x3D;处有一个&#x3D;&#x3D;PUSH 004092A0&#x3D;&#x3D;命令，这里引用的&#x3D;&#x3D;004092A0&#x3D;&#x3D;就是字符串“Hello World！”。双击字符串就可以跳转到调用&#x3D;&#x3D;MessageBoxW(）&#x3D;&#x3D;函数的代码处。接下来可以使用Go to命令，进一步寻找目标地址的字符串。</p>
<!--<!--![[Screenshot_20250303_135513.j-->pg]]-->
<p><img src="https://i.imgur.com/ghJhYTK.jpeg"></p>
<p><img src="https://i.imgur.com/mklhl1B.jpeg"></p>
<p>灰色部分是“Hello World！”字符串，它用Unicode码形式表示，字符串后面被填充了NULL值。VC++里，static字符串（在程序内部被硬编码（Hard Coding）的字符串）会被默认保存为Unicode码形式。从409地址和401地址的区别可以知道，代码和数据所在的区域是彼此分开的。</p>
<h3 id="2-4-3-API检索法（1）：在调用代码中设置断点"><a href="#2-4-3-API检索法（1）：在调用代码中设置断点" class="headerlink" title="2.4.3 API检索法（1）：在调用代码中设置断点"></a>2.4.3 API检索法（1）：在调用代码中设置断点</h3><p>右键菜单，Search for-All intermodular calls。<br>原理：要想向显示器显示内容，需要使用Win32 API向OS请求显示输出。我们在观察一个程序的功能后，能大致推测处它在运行时调用的Win32 API，比如我们运行时出现弹窗时，就能知道它调用了user32.MessageBoxW()API。<br>注意：OllyDbg的预分析的内容不止分析程序中的字符串，还可以摘录处运行时调用的API函数列表。&#x3D;&#x3D;All intermodular calls&#x3D;&#x3D;命令可以只查看调用了哪些API函数。</p>
<!--<!--![[Screenshot_20250303_140532.j-->pg]]-->
<p><img src="https://i.imgur.com/F1zBbxk.jpeg"></p>
<p><img src="https://i.imgur.com/qQ1PCCH.jpeg"></p>
<p>从这里可以看到调用MessageBoxW()的代码，该函数的地址也放出来了，双击地址就可以进行定位。这是一个快速分析程序结构的方法。</p>
<h3 id="2-4-4-API检索法（2）：在API代码中设置断点"><a href="#2-4-4-API检索法（2）：在API代码中设置断点" class="headerlink" title="2.4.4 API检索法（2）：在API代码中设置断点"></a>2.4.4 API检索法（2）：在API代码中设置断点</h3><p>鼠标右键：Search for-Name in all calls<br>Ollydbg并不能为所有可执行文件都列出API函数调用，使用压缩器或者&#x2F;保护器工具对可执行文件进行压缩或保护之后，文件的结构就会发生改变。</p>
<!--![[Screenshot_20250303_141725.jpg]]-->
<p><img src="https://i.imgur.com/Tlkq5Df.jpeg"></p>
<p>这种情况下，DLL代码库被加载到进程内存后，我们可以直接向DLL代码库当中添加断点，API是操作系统对用户程序提供的一系列函数，存在C:\Windows\systems32文件夹中的*.dll文件夹。就是需要使用API向OS提出请求，然后DLL文件会被加载到程序的进程内存。<br>在OllyDbg菜单栏中依次选择View-Memory菜单（ALT+M），打开内存映射窗口。</p>
<!--![[Screenshot_20250303_142156.jpg]]-->
<p><img src="https://i.imgur.com/Yr1xQUx.jpeg"></p>
<p>使用OllyDbg中的&#x3D;&#x3D;Name in all modules&#x3D;&#x3D;命令可以列出被加载的DLL文件中所提供的所有API。使用&#x3D;&#x3D;Name in all modules&#x3D;&#x3D;命令打开All names窗口，搜索出来&#x3D;&#x3D;MessageBoxW&#x3D;&#x3D;。</p>
<!--![[Screenshot_20250303_142533.jpg]]-->
<p><img src="https://i.imgur.com/Qhhh2sO.jpeg"></p>
<p>USER32模块中有一个Export类型的&#x3D;&#x3D;MessageBoxW&#x3D;&#x3D;函数，双击就可以显示它的代码，就像刚才说的，实现是在<br>USER32.dll库中的。</p>
<!--![[Screenshot_20250303_142943.jpg]]-->
<p><img src="https://i.imgur.com/Ym50rZO.jpeg"></p>
<p>观察MessageBoxW函数和HelloWorld.exe的地址，会发现完全不同，在函数起始地址上按F2，设置好断点之后按F9继续执行，</p>
<!--![[Screenshot_20250303_143349.jpg]]-->
<p><img src="https://i.imgur.com/jauv6P0.jpeg"></p>
<!--⚠️Imgur upload failed, check dev console-->


<p>如果运行程序的过程中，调用了MessageBoxW()API的花，则调用程序时，程序运行到这里就会停。</p>
<!--![[Screenshot_20250303_143529.jpg]]-->
<p><img src="https://i.imgur.com/MOjLvte.jpeg"></p>
<p>ESP的值是&#x3D;&#x3D;0012FF30&#x3D;&#x3D;，对应的返回地址是&#x3D;&#x3D;401014&#x3D;&#x3D;，当main函数调用完MessageBoxW函数时，程序执行流将会返回到该地址处。按Ctril+F9就可以运行到RETN处，按F7可以返回401014处。</p>
<h2 id="2-5-使用“打补丁”方式修改“Hello-World！”字符串"><a href="#2-5-使用“打补丁”方式修改“Hello-World！”字符串" class="headerlink" title="2.5 使用“打补丁”方式修改“Hello World！”字符串"></a>2.5 使用“打补丁”方式修改“Hello World！”字符串</h2><h3 id="2-5-1-“打补丁”"><a href="#2-5-1-“打补丁”" class="headerlink" title="2.5.1 “打补丁”"></a>2.5.1 “打补丁”</h3><p>在找到MessageBoxW的部分和“Hello World！”地址后，按Ctrl+F2重新调试，并将调试流运行到main函数的起始地址处（401000），在这里设置断点（F2），再按F9执行程序。main()函数的地址401000被作为前进营。</p>
<!--![[Screenshot_20250303_144406.jpg]]-->
<p><img src="https://i.imgur.com/JVuWD1p.jpeg"></p>
<h3 id="2-5-2-修改字符串的两种方法"><a href="#2-5-2-修改字符串的两种方法" class="headerlink" title="2.5.2 修改字符串的两种方法"></a>2.5.2 修改字符串的两种方法</h3><ol start="2">
<li>直接修改字符串缓冲区（buffer）<br>直接修改MessageBoxW函数中的字符串，就可以成功，在Dump窗口中按Ctrl+G快捷键执行Go to命令，输入4092A0进入字符串缓冲区，然后选中这里的字符串，按Ctrl+E快捷键打开编辑窗口。<!--<!--![[Screenshot_20250303_145121.j-->pg]]-->
<img src="https://i.imgur.com/he5neXf.jpeg"></li>
</ol>
<p><img src="https://i.imgur.com/9JQPMbC.jpeg"></p>
<p>这里可以看出“Hello World！”字符串占据的区域为4092A0～4092B0.用新字符串覆盖该区域。<br>新字符串长度大于原有字符串，执行覆盖操作时，可能损坏字符串后面的数据，所以一定要小心。<br>注意：在Unicode字符串必须以NULL结束，占据两个字节（在HEX项目中添加）。</p>
<!--![[Screenshot_20250303_145843.jpg]]-->
<p><img src="https://i.imgur.com/QR4EIA1.jpeg"></p>
<p>回到原本的main()函数，<br>![[Screenshot_20250303_145947.jpg]]<br><img src="/2025/05/12/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" alt="Uploading file...8i4w2"></p>
<!--⚠️Imgur upload failed, check dev console-->

<p>现在修改已经成功了，按F9运行程序，就可以看到修改的内容。可执行文件保存字符串一般会给字符串多流出一些空间，有可能不会遇到那个爆内存的问题。<br>保存更改到可执行文件：调试得到的只是一个展示的效果，需要建立一些新的可执行文件。在Dump窗口中，选中更改后的“Hello Reserving”字符串，单击右键，在弹出的菜单中选择Copy to executable file菜单，打开Hex窗口，在这个窗口右键，然后选择sava file，输入文件名，然后保存为可执行文件。</p>
<ol start="3">
<li>在其他内存区域生成新字符串并传递给消息函数<br>Ctrl+F2快捷键重启调试，按F9运行，此时程序停在之前设置的断点处：<!--![[Screenshot_20250303_151849.jpg]]-->
<img src="https://i.imgur.com/gwFXZBA.jpeg"></li>
</ol>
<!--⚠️Imgur upload failed, check dev console-->

<p>401007地址处有一条PUSH 004092A0命令，它把4092A0地址处的“Hello World！”字符串以参数形式传递到MessageBoxW函数中的。传递字符串参数的时候，传递的是字符串所在区域的首地址，我们可以在某个地方新开一个长字符串，然后把新字符串的首地址传递给MessageBoxW()函数。<br>使用Dump查看4092A0查看NULL填充部分的内容，程序被加载到内存时，有一个最小的内存分配大小，一般为1000，即使程序运行是只占用100内存，夹在的时候也会被分到1000左右的内存，这些程序的一部分是程序，其余的被填充为NULL。<br>使用这些填充为NULL的部分作为字符串缓冲区传递给MessageBoxW函数，使用Ctrl+E向结尾部分适当位置（409F50）写入新字符串（“Hello Reserving World!!!”）即可</p>
<!--![[Screenshot_20250303_155027.jpg]]-->
<p><img src="https://i.imgur.com/qh0kWMe.jpeg"></p>
<p>我们需要用汇编命令修改代码，将光标置于401007处，按空格打开Assemble窗口。</p>
<!--![[Screenshot_20250303_155147.jpg]]-->
<p><img src="https://i.imgur.com/qpS2cFn.jpeg"></p>
<p>输入上面的指令过后，就完成了地址转换。但是这个程序另存之后不能正常运行。</p>
<h2 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h2><!--![[Screenshot_20250303_155321.jpg]]-->
<p><img src="https://i.imgur.com/7CJg3g0.jpeg"></p>
<!--![[Screenshot_20250303_155336.jpg]]-->
<p><img src="https://i.imgur.com/3EsSZoV.jpeg"></p>
<!--![[Screenshot_20250303_155353.jpg]]-->
<p><img src="https://i.imgur.com/uXCMyzM.jpeg"></p>
<!--![[Screenshot_20250303_155414.jpg]]-->
<p><img src="https://i.imgur.com/OxDxQww.jpeg"></p>
<!--![[Screenshot_20250303_155428.jpg]]-->
<p><img src="https://i.imgur.com/An7xFXO.jpeg"></p>
<h1 id="第三章-小端序标记法"><a href="#第三章-小端序标记法" class="headerlink" title="第三章 小端序标记法"></a><strong>第三章 小端序标记法</strong></h1><p>字节序（Byte Ordering）是多字节数据在计算机内存中存储或网络传输时各字节的存储顺序，一类是小端序（Little endian），另一类是大端序（Big endian）</p>
<h2 id="3-1-字节序"><a href="#3-1-字节序" class="headerlink" title="3.1 字节序"></a>3.1 字节序</h2><!--![[Screenshot_20250306_192816.jpg]]-->
<p><img src="https://i.imgur.com/LFvr4iy.jpeg"></p>
<p>对于上面的这些代码，一共有四种数据类型，它们的大小不同，可以根据下图判断同一个数据根据不同字节序保存时的不同之处：</p>
<!--![[Screenshot_20250306_192940.jpg]]-->
<p><img src="https://i.imgur.com/J7lrZ40.jpeg"></p>
<p>当类型为BYTE的时候，单个字节大小的两种序列的表示一样，大于或等于两个字节的时候，会用不同字节序列的存储顺序。采用大端序的时候，内存地址低位存储数据的高位，内存地址高位存储数据的低位，是最直观的字节存储顺序；采用小端序存储数据时，地址高于存储数据的高位，地址低位存储数据的低位，这是一种逆序存储方式。在str中，因为数组的存储在内存当中是连续的，因此存储顺序都相同。</p>
<h3 id="3-1-1-大断序和小端序"><a href="#3-1-1-大断序和小端序" class="headerlink" title="3.1.1 大断序和小端序"></a>3.1.1 大断序和小端序</h3><p>大端序保存多字节数据非常直观，常用于大型UNIX服务器的RISC系列的CPU中。网络协议中也常用大端序方式。Intel x86 CPU采用的是小端序，用小端序进行算数运算以及扩展&#x2F;缩小数据时，效率都非常高。</p>
<h3 id="3-1-2-在Ollydbg中查看小程序"><a href="#3-1-2-在Ollydbg中查看小程序" class="headerlink" title="3.1.2 在Ollydbg中查看小程序"></a>3.1.2 在Ollydbg中查看小程序</h3><!--<!--![[Screenshot_20250306_193811.j-->pg]]-->
<p><img src="https://i.imgur.com/Az9qMji.jpeg"></p>
<p><img src="https://i.imgur.com/oKmOqaU.jpeg"></p>
<p>编成代码过后，生成LittleEndian.exe文件，使用OllyDbg调试，用Go to命令，跳转到401000地址处</p>
<!--![[Screenshot_20250306_193933.jpg]]-->
<p><img src="https://i.imgur.com/kkWVnrG.jpeg"></p>
<p>main()函数地址为401000，全局变量b、w、dw、str的地址分别为40AC40、40AC44、40AC48、40AC4C。下面通过OllyDbg的数据窗口分别查看它们所在的内存区域，先使用Go to命令，跳转到40AC40处：</p>
<!--![[Screenshot_20250306_194237.jpg]]-->
<p><img src="https://i.imgur.com/Zc0pL3o.jpeg"></p>
<p>可以看出来w、dw的都是以小端序方式存储。</p>
<h1 id="第四章-IA-32寄存器基本讲解"><a href="#第四章-IA-32寄存器基本讲解" class="headerlink" title="第四章 IA-32寄存器基本讲解"></a><strong>第四章 IA-32寄存器基本讲解</strong></h1><h2 id="4-1-什么是CPU寄存器"><a href="#4-1-什么是CPU寄存器" class="headerlink" title="4.1 什么是CPU寄存器"></a>4.1 什么是CPU寄存器</h2><p>寄存器（register）是CPU内部用来存放数据的一些小型存储区域，它与我们常说的RAM（Random Access Memory，随机存储器，内存）略有不同。CPU访问RAM中的数据时，要经过较长的物理路径，花费的时间长一点，寄存器集成在CPU内部，拥有非常高的读写速度。<br><strong>学习的原因：</strong><br>必须学习调试器解析（Disassenble，反汇编）出的汇编指令。IA-32为我们提供了数量非常庞大的汇编指令，汇编指令大部分用于操作寄存器或者检查其中的数据，因此我们需要学习寄存器相关的内容。</p>
<h2 id="4-2-IA-32寄存器"><a href="#4-2-IA-32寄存器" class="headerlink" title="4.2 IA-32寄存器"></a>4.2 IA-32寄存器</h2><!--![[Screenshot_20250306_195350.jpg]]-->
<p><img src="https://i.imgur.com/1ymgnFA.jpeg"></p>
<p>之后会继续学习控制寄存器（control regisers）、内存管理寄存器（Memory management）、调试寄存器（Debug registers）的知识。</p>
<h3 id="基本程序运行寄存器"><a href="#基本程序运行寄存器" class="headerlink" title="基本程序运行寄存器"></a>基本程序运行寄存器</h3><!--![[Screenshot_20250306_195541.jpg]]-->
<p><img src="https://i.imgur.com/WVxHUYx.jpeg"></p>
<p>寄存器名称缩略语之前添加字母E，表示寄存器在16位CPU（IA-16）时就已经存在，并且其大小在IA-32下由原16位扩展为32位。</p>
<h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>顾名思义，通用寄存器是一种通用型的寄存器，用于传送和暂存数据，也可以参与算数逻辑运算，并且保存运算结果，IA-32中每个通用寄存器的大小都是32位，即四个字节，主要用于保存常量和地址等，由特定的汇编指令操作特定寄存器。</p>
<!--![[Screenshot_20250306_200342.jpg]]-->
<p><img src="https://i.imgur.com/eZRHHEy.jpeg"></p>
<p>为了实现对低16位的兼容，各寄存器又可以分为高（H：High）、低（L：Low）几个独立寄存器。</p>
<ul>
<li>EAX：（0～31）32位</li>
<li>AX：（0～15）EAX的低16位</li>
<li>AH：（8～15）AX的高8位<br>若想使用四个字节，就用EAX；两个字节用AX；AX本身分为高8位的AH和低8位的AL两个独立寄存器。因此可以将32位寄存器分别用作8位、16位、32位寄存器。<br>寄存器的名字：<br>EAX：针对操作数和结果数据的累加器<br>EBX：DS段中的数据指针基址寄存器<br>ECX：字符串和循环操作的计数器<br>EDX：I&#x2F;O指针数据寄存器<br>上面的四个寄存器主要用在算数运算：ADD、SUB、XOR、OR指令中，常常用于保存变量和常量的值。某些指令：MUL、DIV、LODS等，可以直接用来操作特定寄存器，执行这些命令仅改变特定寄存器的值。<br>ECX和EAX也可以用来作特殊用途。LOOP命令中，ECX用来循环计数（loop count），每执行一次循环，ECX都会减1.EAX一般用在函数返回值上，所有Win32 API函数都会先把返回值保存到EAX再返回。<br>在编写Windows汇编程序时，Win32 API函数在内部会使用ECX与EDX，调用这些API时，ECX和EDX的值就会改变。因此在ECX和EDX中保存了重要数据时，调用API之前需要先把这些数据备份到其他寄存器或栈。<br>其他寄存器：<br>EBP：SS段中栈内数据指针扩展基址指针寄存器<br>ESI：字符串操作源目标指针目的变址寄存器<br>ESP：SS段中栈指针寄存器<br>ESP指示栈区域的栈顶地址，某些指令（PUSH、POP、CALL、RET）可以直接用来操作ESP。<br>EBP表示栈区域的基地址，函数被调用时保存ESP的值，函数返回时再将值返回ESP，保证栈不会崩溃（这叫栈帧（Stack Frame）技术，他是代码逆向分析技术中的一个重要概念）。ESI与EDI和特定指令（LODS、STOS、REP、MOVS等）一起使用，主要用于内存复制。</li>
</ul>
<h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><p>段（Segment）这一术语来自IA-32的内存管理模型，学习段寄存器前，先了解一下的内容：<br>IA-32的保护模式中，段是一种内存保护技术，它将内存分为多个区段，并为每个区段赋予起始地址、范围、访问权限等，以保护内存。此外，它还同分页技术（Paging）一起用于将虚拟内存变更为实际物理内存。段内存记录在SDT（Segment Descriptor Table，段描述符表）中，而段寄存器就持有这些SDT的索引（index）。<br>段寄存器共由六种寄存器组成，分别为CS、SS、DS、ES、FS、GS，每个寄存器的大小为16为，即两个字节。此外每个段寄存器指向的段描述符（Segment Descriptor）与虚拟内存结合，形成一个线性地址（Linear Address），借助分页技术，线性地址最终被转换为实际的物理地址（Physical Address）。<br>不使用分页技术的操作系统中，线性地址直接变为物理地址。<br>CS：Code Segment 代码段寄存器<br>SS：Stack Segment 栈段寄存器<br>DS：Date Segment 数据段寄存器<br>ES：Extra Segment 附加数据段寄存器<br>FS：Data Segment 数据段寄存器<br>GS：Date Segment 数据段寄存器</p>
<!--<!--![[Screenshot_20250306_203222.j-->pg]]-->
<p><img src="https://i.imgur.com/LZQLAmF.jpeg"></p>
<p><img src="https://i.imgur.com/kBNRnqY.jpeg"></p>
<p>程序调试中常用到FS寄存器，它用于计算SEH（Structured Exception Handler结构化异常处理机制）、TEB（Thread Environment Block，线程环境块）、PEB（Process Environment Block，进程环境块）等地址，这些都是高级调试技术。</p>
<h4 id="程序状态与控制寄存器"><a href="#程序状态与控制寄存器" class="headerlink" title="程序状态与控制寄存器"></a>程序状态与控制寄存器</h4><ul>
<li>EFLAGS：Flag Register，标志寄存器<br>IA-32中标志寄存器的名称为EFLAGS，其大小为4个字节（32位），由原来的16位FLAGS寄存器扩展而来。EFLAGS寄存器的每位都有意义，每位的值是1或者0，代表on&#x2F;off或者True&#x2F;False。其中有些位由系统直接设定，有的则根据程序命令的执行结果设置。<!--<!--![[Screenshot_20250306_205050.j-->pg]]-->
<img src="https://i.imgur.com/KE1YqBn.jpeg"></li>
</ul>
<p><img src="https://i.imgur.com/lXlWvps.jpeg"></p>
<p>EFLASG有32个位元，掌握每位的含义是很苦难的，初阶段掌握三个标志即可：ZF（Zero Flag，零标志）、OF（Overflow Flag，溢出标志）、CF（Carry Flag，进位标志）。<br>因为在Jcc（条件跳转）指令中要检查这三个标志的值。<br>ZF：若运算结果为0，则为真，反之则为假<br>OF：有符号整数（signed integer）溢出时，OF值被设置为1.MSB（Most Significant Bit，最高有效位）改变时，其值也被设为1.<br>CF：无符号整数（unsigned integer）溢出时，其值也被置为1.</p>
<h4 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h4><p>ELP：Instruction Pointer，指令指针寄存器<br>指令指针寄存器保存着CPU要执行的指令地址，四个字节，由16位扩展而来</p>
<!--![[Screenshot_20250306_213701.jpg]]-->
<p><img src="https://i.imgur.com/CeTvAAI.jpeg"></p>
<h1 id="第五章：栈"><a href="#第五章：栈" class="headerlink" title="第五章：栈"></a><strong>第五章：栈</strong></h1><p>栈（Stack）的用途广泛，用来存储局部变量、传递函数参数、保存函数返回地址等。调试程序时需要不断查看栈内存。</p>
<h2 id="5-1-栈"><a href="#5-1-栈" class="headerlink" title="5.1 栈"></a>5.1 栈</h2><p>栈内存进程中的作用如下：</p>
<ol>
<li>暂时保存函数内的局部变量</li>
<li>调用函数时传递参数</li>
<li>保存函数返回后的地址<br>栈是一种数据结构，按照FILO（First In Last Out）的原则存储数据。</li>
</ol>
<h3 id="5-1-1-栈的特征"><a href="#5-1-1-栈的特征" class="headerlink" title="5.1.1 栈的特征"></a>5.1.1 栈的特征</h3><!--![[Screenshot_20250310_192322.jpg]]-->
<p><img src="https://i.imgur.com/zXP7g2E.jpeg"></p>
<p>一个进程中，栈顶指针（ESP）初始状态指向栈底端。执行PUSH命令将数据压入栈时，栈顶指针就会上移到栈顶端。执行POP命令从栈中弹出数据时，若栈为空，则栈顶指针重新移动到栈底端。这就是栈的逆向扩展。</p>
<h3 id="5-1-2-栈操作示例"><a href="#5-1-2-栈操作示例" class="headerlink" title="5.1.2 栈操作示例"></a>5.1.2 栈操作示例</h3><p>现在准备一个Stack.exe作为验证栈工作原理的文件，这个文件已经被修改了内部运行代码，直接双击运行它会发生错误。另外在调试过程中，寄存器的初始值和栈的初址等会随着运行环境的不同而不同。</p>
<!--![[Screenshot_20250310_192818.jpg]]-->
<p><img src="https://i.imgur.com/y5bjXaO.jpeg"></p>
<p>可以看到栈顶指针的值为12FF8C，观测右下角的栈窗口，可以看到ESP指向的地址和值。这个时候我们Steo into进入401000地址的PUSH命令。可以看到ESP的值变成12FF88，比原本减少了4个字节，并且栈顶指针指向12FF88这个地址，这个地址保存着100这个值，换言之就是执行PUSH命令之后，数值100被压入栈，ESP随之向上移动，这样ESP的值就减少了四个字节，然后再按F7，执行401005地址处的POP EAX命令。</p>
<!--<!--![[Screenshot_20250310_194010.j-->pg]]-->
<p><img src="https://i.imgur.com/PoUKeHE.jpeg"></p>
<p><img src="https://i.imgur.com/zLiLdH2.jpeg"></p>
<p>执行完POP EAX命令后，ESP值又增加了4个字节，变为12FF8C，栈又变为图中的初始状态。</p>
<!--![[Screenshot_20250310_194122.jpg]]-->
<p><img src="https://i.imgur.com/ytTzGj5.jpeg"></p>
<h1 id="第六章-分析abex’-crackme-1"><a href="#第六章-分析abex’-crackme-1" class="headerlink" title="第六章 分析abex’ crackme 1"></a><strong>第六章 分析abex’ crackme 1</strong></h1><h2 id="6-1-abex’-crackme-1"><a href="#6-1-abex’-crackme-1" class="headerlink" title="6.1 abex’ crackme #1"></a>6.1 abex’ crackme #1</h2><p>首先运行这个程序尝试了解它，双击程序过后可以得到以下的消息窗口</p>
<!--![[Screenshot_20250310_194353.jpg]]-->
<p><img src="https://i.imgur.com/cTFT30g.jpeg"></p>
<p>消息的最后部分出现了“CD-Rom”这个词，我们推测它前面的HD为HDD（Hard Disk Drive），我们继续确定这个选择，过后就会发现程序弹出Error消息之后就停止运行了，但是abex的详细情况还是不得而知。下面直接调试它，来把握这个小程序的意图。</p>
<!--<!--![[Screenshot_20250310_194809.j-->pg]]-->
<p><img src="https://i.imgur.com/1QbTilB.jpeg"></p>
<p><img src="https://i.imgur.com/FK3AakO.jpeg"></p>
<p>大多数crackme小程序都让我们猜测序列号（serial key），但是abex#1稍显特殊。</p>
<h3 id="6-1-1-开始调试"><a href="#6-1-1-开始调试" class="headerlink" title="6.1.1 开始调试"></a>6.1.1 开始调试</h3><p>使用OllyDbg软件加载进入小程序，代码窗口中可以看到程序的汇编代码<!--![[Screenshot_20250310_195050.jpg]]--><br><img src="https://i.imgur.com/dkYvgyE.jpeg"></p>
<p>EP代码很短，和之前的程序不一样，因为这个程序是直接用汇编语言写出来的可执行文件。使用VC++、VC、Delphi等开发工具编写程序的时候，除了自己编写的代码，还有一部分启动函数是由编译器添加的，经过反编译后，代码就变得特别复杂，直接用汇编语言写程序，汇编代码就会变成反汇编代码，可以看到图中main()直接出现在EP当中。</p>
<h3 id="6-1-2-分析代码"><a href="#6-1-2-分析代码" class="headerlink" title="6.1.2 分析代码"></a>6.1.2 分析代码</h3><p>代码非常简短，我们可以直接分析右上角Win32 API调用的内容</p>
<!--![[Screenshot_20250310_195646.jpg]]-->
<p><img src="https://i.imgur.com/kY3AXIq.jpeg"></p>
<h2 id="6-2-破解"><a href="#6-2-破解" class="headerlink" title="6.2 破解"></a>6.2 破解</h2><h2 id="6-3-将参数压入栈"><a href="#6-3-将参数压入栈" class="headerlink" title="6.3 将参数压入栈"></a>6.3 将参数压入栈</h2><h2 id="6-4-小结"><a href="#6-4-小结" class="headerlink" title="6.4 小结"></a>6.4 小结</h2><h1 id="第七章-栈帧"><a href="#第七章-栈帧" class="headerlink" title="第七章 栈帧"></a><strong>第七章 栈帧</strong></h1><h1 id="7-1-栈帧"><a href="#7-1-栈帧" class="headerlink" title="7.1 栈帧"></a>7.1 栈帧</h1><ol>
<li><strong>栈帧原理</strong><ul>
<li>栈帧是利用 EBP（栈帧指针，非 ESP ）寄存器访问栈内局部变量、参数、函数返回地址等的手段。</li>
<li>ESP 寄存器为栈顶指针，值随时变化；EBP 寄存器行使栈帧指针职能。程序运行时，调用函数先将 ESP 值保存到 EBP 并维持在函数内部，以 EBP 值为基准可安全访问相关数据。</li>
</ul>
</li>
<li><strong>栈帧结构汇编代码</strong><img src="https://i.imgur.com/33uCx8C.png"><ul>
<li><code>PUSH EBP</code>：函数开始，先把 EBP 原值保存到栈中。</li>
<li><code>MOV EBP, ESP</code>：保存当前 ESP 到 EBP 。</li>
<li><code>; 函数体</code>：无论 ESP 值如何变化，EBP 保持不变，可安全访问函数局部变量、参数 。</li>
<li><code>MOV ESP, EBP</code>：将函数起始地址返回到 ESP 中。</li>
<li><code>POP EBP</code>：函数返回前弹出保存在栈中的 EBP 值。</li>
<li><code>RETN</code>：函数终止。</li>
</ul>
</li>
<li><strong>栈帧作用</strong><ul>
<li>借助栈帧技术管理函数调用，能很好地对调用栈进行管理与维护，无论函数调用深度和复杂度如何。</li>
</ul>
</li>
<li><strong>提示</strong><ul>
<li>最新编译器 “优化”（Optimization）选项，编译简单函数时不会生成栈帧。</li>
<li>栈中保存函数返回地址存在安全隐患，攻击者可利用缓冲区溢出技术更改返回地址。</li>
</ul>
</li>
</ol>
<h1 id="7-2-调试示例：stackframe-exe"><a href="#7-2-调试示例：stackframe-exe" class="headerlink" title="7.2 调试示例：stackframe.exe"></a>7.2 调试示例：stackframe.exe</h1><h2 id="7-2-1-Stackframe-cpp"><a href="#7-2-1-Stackframe-cpp" class="headerlink" title="7.2.1 Stackframe.cpp"></a>7.2.1 Stackframe.cpp</h2><h4 id="一、C-代码示例"><a href="#一、C-代码示例" class="headerlink" title="一、C++ 代码示例"></a>一、C++ 代码示例</h4><ol>
<li><strong>文件信息</strong><ul>
<li><strong>文件名</strong>：StackFrame.cpp</li>
<li><strong>头文件引入</strong>：<code>#include &quot;stdio.h&quot;</code></li>
</ul>
</li>
<li><strong>函数定义</strong><ul>
<li><strong><code>add</code> 函数</strong><ul>
<li><strong>功能</strong>：接收两个 <code>long</code> 类型参数 <code>a</code> 和 <code>b</code>，将其分别赋值给局部变量 <code>x</code> 和 <code>y</code>，然后返回 <code>x + y</code> 的结果。</li>
<li><strong>代码</strong>：</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">add</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> x = a, y = b;</span><br><span class="line">    <span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>main</code> 函数</strong><ul>
<li><strong>功能</strong>：定义局部变量 <code>a = 1</code>，<code>b = 2</code>，调用 <code>add</code> 函数计算两数之和，并使用 <code>printf</code> 输出结果，最后返回 <code>0</code> 表示程序正常结束。</li>
<li><strong>代码</strong>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">add</span>(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>编译提示</strong>：为更好地观察栈帧相关情况，需关闭 Visual C++ 的优化选项（&#x2F;Od）后再编译程序。</li>
</ol>
<h4 id="二、调试操作"><a href="#二、调试操作" class="headerlink" title="二、调试操作"></a>二、调试操作</h4><ol>
<li><strong>工具及指令</strong>：使用 OllyDbg 调试工具打开生成的 StackFrame.exe 文件，通过按 <code>Ctrl+G</code> 快捷键（Go to 命令）转到 401000 地址进行观察调试。</li>
<li><strong>汇编代码注释说明</strong>：图 7 - 1 右侧的注释是人为添加的，不同调试环境可能有不同标注。后续会通过与 C 语言源代码对照，分析代码执行各阶段栈内数据变化，帮助理解。</li>
</ol>
<h4 id="三、汇编代码示例（以-401000-地址附近为例-）"><a href="#三、汇编代码示例（以-401000-地址附近为例-）" class="headerlink" title="三、汇编代码示例（以 401000 地址附近为例 ）"></a>三、汇编代码示例（以 401000 地址附近为例 ）</h4><ol>
<li><strong><code>add</code> 函数相关汇编指令</strong><ul>
<li><code>00401000</code> ：<code>PUSH EBP</code> ，保存旧的 EBP 值，为建立新栈帧做准备。</li>
<li><code>00401001</code> ：<code>MOV EBP, ESP</code> ，将当前栈顶指针 ESP 的值赋给 EBP，建立新的栈帧基准。</li>
<li><code>00401003</code> ：<code>MOV EAX,DWORD PTR SS:[EBP+8]</code> ，从栈中获取参数 <code>a</code> （<code>[EBP+8]</code> 指向参数 <code>a</code> ）并存储到 EAX 寄存器。</li>
<li><code>00401006</code> ：<code>MOV DWORD PTR SS:[EBP - 8],EAX</code> ，将 EAX 中的值（即参数 <code>a</code> ）存储到栈中局部变量 <code>x</code> 的位置（<code>[EBP - 8]</code> ） 。</li>
<li>后续指令类似，用于获取参数 <code>b</code> 并存储到局部变量 <code>y</code> ，以及进行加法运算等操作。</li>
<li><code>00401015</code> ：<code>MOV ESP,EBP</code> ，恢复栈顶指针 ESP 到函数调用前的位置。</li>
<li><code>00401018</code> ：<code>POP EBP</code> ，恢复旧的 EBP 值。</li>
<li><code>00401019</code> ：<code>RETN</code> ，函数返回。</li>
</ul>
</li>
<li><strong><code>main</code> 函数相关汇编指令</strong><ul>
<li>包含局部变量存储操作，如 <code>MOV DWORD PTR SS:[EBP - 4],1</code> 将值 <code>1</code> 存储到局部变量 <code>a</code> 的位置（<code>[EBP - 4]</code> ） 。</li>
<li>有函数调用指令 <code>CALL 00401000</code> 调用 <code>add</code> 函数 ，并进行参数传递等操作。</li>
<li>还有 <code>printf</code> 函数调用相关指令，用于输出结果</li>
</ul>
</li>
</ol>
<h2 id="7-2-2-开始执行main-函数-生成栈帧"><a href="#7-2-2-开始执行main-函数-生成栈帧" class="headerlink" title="7.2.2 开始执行main()函数&amp;生成栈帧"></a>7.2.2 开始执行main()函数&amp;生成栈帧</h2><ol>
<li><p><strong>调试准备与初始状态</strong><img src="https://i.imgur.com/FpfDP2t.png"></p>
<ul>
<li>在 OllyDbg 中，于 <code>main()</code> 函数起始地址（401020）处按 F2 键设断点，按 F9 运行程序，程序会在断点处暂停。</li>
<li>初始时，ESP 值为 12FF44，EBP 值为 12FF88 。地址 401250 存于 ESP（12FF44 ）中，是 <code>main()</code> 函数执行完要返回的地址。不同运行环境地址可能不同。</li>
</ul>
</li>
<li><p><strong>生成栈帧过程</strong></p>
<ul>
<li><strong>压栈保存 EBP 原值</strong>：<code>main()</code> 函数起始指令 <code>00401020 PUSH EBP</code> ，<code>PUSH</code> 是压栈指令，将 EBP 原值压入栈中，用于在函数执行完毕返回前恢复 EBP 值。</li>
<li><strong>设置新 EBP</strong>：<code>00401021 MOV EBP,ESP</code> ，<code>MOV</code> 为数据传送指令，把 ESP 值传送给 EBP 。自此 EBP 值与当前 ESP 相同，且在 <code>main()</code> 函数执行期间保持不变，方便通过 EBP 安全访问栈中函数参数与局部变量 ，执行完这两条指令，<code>main()</code> 函数栈帧生成。</li>
</ul>
</li>
<li><p>**栈窗口观察操作<img src="https://i.imgur.com/ZepAeWe.png"><br>**</p>
<ul>
<li>进入 OllyDbg 栈窗口，右键依次选 Address - Relative to EBP，可将地址转换为相对于 EBP 的偏移，更直观观察栈内情况。此时 EBP 值为 12FF40（与 ESP 一致 ），12FF40 地址处保存着 <code>main()</code> 函数开始执行时 EBP 的初始值 12FF88 。<img src="https://i.imgur.com/RqreTms.png"></li>
</ul>
</li>
</ol>
<h2 id="7-2-3-设置局部变量"><a href="#7-2-3-设置局部变量" class="headerlink" title="7.2.3 设置局部变量"></a>7.2.3 设置局部变量</h2><h2 id="7-2-4-add-函数参数传递与调用"><a href="#7-2-4-add-函数参数传递与调用" class="headerlink" title="7.2.4 add()函数参数传递与调用"></a>7.2.4 add()函数参数传递与调用</h2><h2 id="7-2-5-开始执行add-函数-生成栈帧"><a href="#7-2-5-开始执行add-函数-生成栈帧" class="headerlink" title="7.2.5 开始执行add()函数&amp;生成栈帧"></a>7.2.5 开始执行add()函数&amp;生成栈帧</h2><h2 id="7-2-6-设置add-函数的局部变量-x-y"><a href="#7-2-6-设置add-函数的局部变量-x-y" class="headerlink" title="7.2.6 设置add()函数的局部变量(x,y)"></a>7.2.6 设置add()函数的局部变量(x,y)</h2><h2 id="7-2-7-ADD运算"><a href="#7-2-7-ADD运算" class="headerlink" title="7.2.7 ADD运算"></a>7.2.7 ADD运算</h2><h2 id="7-2-8-删除函数add-的栈帧-函数执行完毕-返回"><a href="#7-2-8-删除函数add-的栈帧-函数执行完毕-返回" class="headerlink" title="7.2.8 删除函数add()的栈帧&amp;函数执行完毕(返回)"></a>7.2.8 删除函数add()的栈帧&amp;函数执行完毕(返回)</h2><h2 id="7-2-9-从栈中删除函数add-的函数-整理栈"><a href="#7-2-9-从栈中删除函数add-的函数-整理栈" class="headerlink" title="7.2.9 从栈中删除函数add()的函数(整理栈)"></a>7.2.9 从栈中删除函数add()的函数(整理栈)</h2><h2 id="7-2-10-调用printf-函数"><a href="#7-2-10-调用printf-函数" class="headerlink" title="7.2.10 调用printf()函数"></a>7.2.10 调用printf()函数</h2><h2 id="7-2-11-设置返回值"><a href="#7-2-11-设置返回值" class="headerlink" title="7.2.11 设置返回值"></a>7.2.11 设置返回值</h2><h1 id="7-3-设置OllyDbg选项"><a href="#7-3-设置OllyDbg选项" class="headerlink" title="7.3 设置OllyDbg选项"></a>7.3 设置OllyDbg选项</h1><h2 id="7-3-1-Disasm选项"><a href="#7-3-1-Disasm选项" class="headerlink" title="7.3.1 Disasm选项"></a>7.3.1 Disasm选项</h2><h2 id="7-3-2-Analysis选项"><a href="#7-3-2-Analysis选项" class="headerlink" title="7.3.2 Analysis选项"></a>7.3.2 Analysis选项</h2>]]></content>
  </entry>
  <entry>
    <title>预处理器：/Zc:preprocessor</title>
    <url>/2024/08/02/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%9A-Zc-preprocessor/</url>
    <content><![CDATA[<h1 id="Zc-preprocessor（启用预处理器一致性模式）"><a href="#Zc-preprocessor（启用预处理器一致性模式）" class="headerlink" title="/Zc:preprocessor（启用预处理器一致性模式）"></a><code>/Zc:preprocessor</code>（启用预处理器一致性模式）</h1><p>本文内容<a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/zc-preprocessor?view=msvc-170#syntax">语法</a><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/zc-preprocessor?view=msvc-170#remarks">备注</a><a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/zc-preprocessor?view=msvc-170#see-also">另请参阅</a></p>
<p>此选项将启用一个符合 C99 和 C++11 及更高标准的基于标记的预处理器。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/cpp/preprocessor/preprocessor-experimental-overview?view=msvc-170">MSVC 新预处理器概述</a>。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote>
<p><strong><code>/Zc:preprocessor</code></strong>[<strong><code>-</code></strong>]</p>
</blockquote>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>使用 <strong><code>/Zc:preprocessor</code></strong> 编译器选项可启用符合标准的预处理器。 可以使用 <strong><code>/Zc:preprocessor-</code></strong> 选项显式指定传统（不符合标准）的预处理器。</p>
<p>从 Visual Studio 2019 版本 16.5 开始，**<code>/Zc:preprocessor</code>** 选项可用。 从 Visual Studio 2017 版本 15.8 开始，Visual Studio 版本中提供了早期、不完整版本的新预处理器选项。 有关详细信息，请参阅 <a href="https://learn.microsoft.com/zh-cn/cpp/build/reference/experimental-preprocessor?view=msvc-170"><code>/experimental:preprocessor</code></a>。</p>
<h3 id="在-Visual-Studio-开发环境中设置此编译器选项"><a href="#在-Visual-Studio-开发环境中设置此编译器选项" class="headerlink" title="在 Visual Studio 开发环境中设置此编译器选项"></a>在 Visual Studio 开发环境中设置此编译器选项</h3><ol>
<li>打开项目的“属性页” 对话框。 有关详细信息，请参阅<a href="https://learn.microsoft.com/zh-cn/cpp/build/working-with-project-properties?view=msvc-170">在 Visual Studio 中设置 C++ 编译器和生成属性</a>。</li>
<li>选择“配置属性”&gt;“C&#x2F;C++”&gt;“预处理器”属性页。</li>
<li>修改“使用符合标准的预处理器”属性，然后选择“确定”。</li>
</ol>
]]></content>
      <tags>
        <tag>/Zc:preprocessor</tag>
      </tags>
  </entry>
  <entry>
    <title>项目：Locale_Emulator破解</title>
    <url>/2024/08/02/%E9%A1%B9%E7%9B%AE%EF%BC%9ALocale-Emulator%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="文件类型的学习"><a href="#文件类型的学习" class="headerlink" title="文件类型的学习"></a>文件类型的学习</h2><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><p>​	Lua 是一个小巧的脚本语言。它是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo三人所组成的研究小组于1993年开发的。</p>
<p>​	 其设计目的是为了通过灵活嵌入应用程序中从而为应用程序提供灵活的扩展和定制功能。Lua由标准C编写而成，几乎在所有操作系统和平台上都可以编译，运行。Lua并没有提供强大的库，这是由它的定位决定的。所以Lua不适合作为开发独立应用程序的语言。Lua 有一个同时进行的JIT项目，提供在特定平台上的即时编译功能。</p>
<p>​	Lua脚本可以很容易的被C&#x2F;C++ 代码调用，也可以反过来调用C&#x2F;C++的函数，这使得Lua在应用程序中可以被广泛应用。不仅仅作为扩展脚本，也可以作为普通的配置文件，代替XML,ini等文件格式，并且更容易理解和维护。 Lua由标准C编写而成，代码简洁优美，几乎在所有操作系统和平台上都可以编译，运行。一个完整的Lua解释器不过200k，在所有脚本引擎中，Lua的速度是最快的。这一切都决定了Lua是作为嵌入式脚本的最佳选择。</p>
<h3 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h3><p>在软件开发项目中，LICENSE文件是指许可证文件，它包含了关于软件授权和使用的条款和条件。LICENSE文件用于明确告知其他人在使用、修改或分发项目的源代码或二进制文件时需要遵守的规则。</p>
<p>LICENSE文件的存在对于开源软件项目尤为重要，因为它定义了项目的开源许可证类型和条款。开源许可证允许用户自由地使用、修改和分发软件，同时也规定了一些限制和责任。</p>
<p>常见的开源许可证类型包括：</p>
<ul>
<li>GNU通用公共许可证（GNU General Public License，GPL）：</li>
</ul>
<p>这是一种最为广泛使用的开源许可证之一。它要求任何修改或衍生作品也必须使用GPL许可证发布。</p>
<ul>
<li>MIT许可证：</li>
</ul>
<p>这是一种宽松的许可证，允许用户在满足许可证条件的情况下自由地使用、修改和分发软件。</p>
<ul>
<li>Apache许可证：</li>
</ul>
<p>这是一种较为灵活的许可证，要求用户在满足许可证条件的情况下使用、修改和分发软件，同时保留原始许可证和版权声明。</p>
<ul>
<li>BSD许可证：</li>
</ul>
<p>这是一系列开源许可证的名称，如BSD 2-Clause License和BSD 3-Clause License。BSD许可证相对宽松，允许用户自由地使用、修改和分发软件。</p>
<p>LICENSE文件通常是文本文件，其中包含了许可证的全文或摘要，以及版权信息和作者的声明。它提供了对软件的法律授权和使用规则的清晰说明，有助于保护软件项目和维护开源社区的准则。在使用开源软件或参与开源项目时，非常重要的一点是仔细阅读和遵守LICENSE文件中所规定的许可证条款和条件。这有助于确保遵守开源软件的法律要求，并与其他开发者和用户建立良好的合作关系。</p>
<h3 id="clang-format"><a href="#clang-format" class="headerlink" title=".clang-format"></a>.clang-format</h3><p>详情参考网页</p>
<h3 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h3><p>hpp，Header plus plus的缩写，实质是将.cpp的实现代码混入.h头文件，即声明与定义（实现）都包含在同一个文件中。</p>
<p>该类的调用者只需要include该hpp文件即可，无需再将cpp加入到project中进行编译。</p>
<p>实现代码将直接编译到调用者的obj文件中，不再生成单独的obj。</p>
<p>采用hpp将大幅度减小project中的cpp文件数与编译次数，也不再发布烦人的lib与dll，因此非常适合用来编写公用的开源库。</p>
<p>hpp文件与h文件的联系：</p>
<ol>
<li>与*.h类似，hpp是C++程序的头文件</li>
</ol>
<p>（2）是VCL（Visual Component Library的缩写，即可视组件库）专用的头文件，已预编译</p>
<p>（3）是一般模板类的头文件</p>
<p>（4）一般来说，*.h里面只有声明，没有实现；而*.hpp里面既有声明也有实现，显然后者可以减少.cpp文件的数量。</p>
<h4 id="base-cpp"><a href="#base-cpp" class="headerlink" title="base.cpp"></a>base.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;macro.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;basic_type.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NAMESPACE_BEGIN</span>(global)</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> is_debug</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LIBRARY_DEBUG</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="literal">false</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> is_release = !is_debug;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus &lt;= 202202L</span></span><br><span class="line"></span><br><span class="line">[[noreturn]] <span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">unreachable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// https://en.cppreference.com/w/cpp/utility/unreachable</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__ <span class="comment">// GCC, Clang, ICC</span></span></span><br><span class="line">    __builtin_unreachable();</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER <span class="comment">// MSVC</span></span></span><br><span class="line">    __assume(<span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NAMESPACE_END</span>(global)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="basic-type-hpp"><a href="#basic-type-hpp" class="headerlink" title="basic_type.hpp"></a>basic_type.hpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> u8  = std::<span class="type">uint_least8_t</span>;</span><br><span class="line"><span class="keyword">using</span> u16 = std::<span class="type">uint_least16_t</span>;</span><br><span class="line"><span class="keyword">using</span> u32 = std::<span class="type">uint_least32_t</span>;</span><br><span class="line"><span class="keyword">using</span> u64 = std::<span class="type">uint_least64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i8  = std::<span class="type">int_least8_t</span>;</span><br><span class="line"><span class="keyword">using</span> i16 = std::<span class="type">int_least16_t</span>;</span><br><span class="line"><span class="keyword">using</span> i32 = std::<span class="type">int_least32_t</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = std::<span class="type">int_least64_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> usize = std::<span class="type">size_t</span>;</span><br><span class="line"><span class="comment">// see https://en.cppreference.com/w/cpp/iterator/size</span></span><br><span class="line"><span class="keyword">using</span> isize = std::<span class="type">common_type_t</span>&lt;std::<span class="type">ptrdiff_t</span>, std::<span class="type">make_signed_t</span>&lt;usize&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> f32 = <span class="type">float</span>;</span><br><span class="line"><span class="keyword">using</span> f64 = <span class="type">double</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(u8)  &gt;= <span class="number">1</span> &amp;&amp; <span class="built_in">sizeof</span>(i8)  &gt;= <span class="number">1</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(u16) &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">sizeof</span>(i16) &gt;= <span class="number">2</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(u32) &gt;= <span class="number">4</span> &amp;&amp; <span class="built_in">sizeof</span>(i32) &gt;= <span class="number">4</span>);</span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(u64) &gt;= <span class="number">8</span> &amp;&amp; <span class="built_in">sizeof</span>(i64) &gt;= <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(f32) == <span class="number">4</span> &amp;&amp; <span class="built_in">sizeof</span>(f64) == <span class="number">8</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="macro-hpp"><a href="#macro-hpp" class="headerlink" title="macro.hpp"></a>macro.hpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NAMESPACE_BEGIN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESPACE_BEGIN(name) namespace name &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NAMESPACE_END</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESPACE_END(name) &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> ALWAYS_INLINE</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> ALWAYS_INLINE __forceinline</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> ALWAYS_INLINE [[gnu::always_inline]]</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PROJECT_SET_SYMBOL</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> defined(_WIN32) || defined(__CYGWIN__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> PROJECT_EXPORT __attribute__(dllexport)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> PROJECT_IMPORT __attribute__(dllimport)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> PROJECT_EXPORT __declspec(dllexport)</span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> PROJECT_IMPORT __declspec(dllimport)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> defined(__GNUC__) || defined(__clang__)</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> PROJECT_EXPORT __attribute__((visibility (<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> PROJECT_IMPORT __attribute__((visibility (<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> PROJECT_EXPORT</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> PROJECT_EXPORT</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> PROJECT_IMPORT</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> PROJECT_IMPORT</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(PROJECT_DEBUG) &amp;&amp; !defined(NDEBUG) &amp;&amp; defined(DEBUG) &amp;&amp; defined(_DEBUG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJECT_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h3><h4 id="export-def"><a href="#export-def" class="headerlink" title="export.def"></a>export.def</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LIBRARY locale_emulator_plus</span><br><span class="line"></span><br><span class="line">EXPORTS</span><br><span class="line">    DetourFinishHelperProcess @<span class="number">1</span> NONAME</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="global"><a href="#global" class="headerlink" title="global"></a>global</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;base/macro.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> HANDLE WINAPI <span class="title">original_GetProcessHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> <span class="keyword">volatile</span> p_GetProcessHeap =</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;<span class="keyword">decltype</span>(&amp;::GetProcessHeap)&gt;(</span><br><span class="line">            ::<span class="built_in">GetProcAddress</span>(</span><br><span class="line">            ::<span class="built_in">GetModuleHandleW</span>(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;GetProcessHeap&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p_GetProcessHeap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">p_GetProcessHeap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ::<span class="built_in">SetLastError</span>(ERROR_CALL_NOT_IMPLEMENTED);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EXTERN_C HANDLE WINAPI <span class="title">compile_time_hook_GetProcessHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> global_info.heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_M_IX86)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(suppress:4483)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(selectany) <span class="type">void</span> <span class="type">const</span>* <span class="type">const</span> __identifier(<span class="string">&quot;_imp__GetProcessHeap@703&quot;</span>) = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> <span class="type">const</span>*&gt;(::compile_time_hook_GetProcessHeap);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/include:__imp__GetProcessHeap@703&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(selectany) <span class="type">void</span> <span class="type">const</span>* <span class="type">const</span> __imp_GetProcessHeap = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> <span class="type">const</span>*&gt;(::compile_time_hook_GetProcessHeap);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/include:__imp_GetProcessHeap&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">get_global_info_from_pipe</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> HANDLE pipe = ::<span class="built_in">CreateFileA</span>(GLOBAL_PIPENAME, GENERIC_READ, <span class="number">0</span>, <span class="literal">nullptr</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    DWORD timeout = <span class="number">1000</span>;</span><br><span class="line">    ::<span class="built_in">SetNamedPipeHandleState</span>(pipe, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line"></span><br><span class="line">    DWORD lpNumberOfBytesRead;</span><br><span class="line">    BOOL result = ::<span class="built_in">ReadFile</span>(pipe, &amp;global_info, <span class="built_in">sizeof</span>(global_info), &amp;lpNumberOfBytesRead, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!result || lpNumberOfBytesRead != <span class="built_in">sizeof</span>(global_info))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> error handle</span></span><br><span class="line">    &#125;</span><br><span class="line">    ::<span class="built_in">CloseHandle</span>(pipe);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PROJECT_DEBUG</span></span><br><span class="line">    <span class="keyword">while</span> (!::<span class="built_in">IsDebuggerPresent</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ::<span class="built_in">Sleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// get_global_info_from_pipe();</span></span><br><span class="line">    global_info.code_page = ::<span class="built_in">GetACP</span>();</span><br><span class="line">    global_info.heap = ::<span class="built_in">original_GetProcessHeap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="global-hpp"><a href="#global-hpp" class="headerlink" title="global.hpp"></a>global.hpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Encoding</span> : UINT</span><br><span class="line">&#123;</span><br><span class="line">    shift_jis = <span class="number">932</span>,</span><br><span class="line">    gbk = <span class="number">936</span>,</span><br><span class="line">    big5 = <span class="number">950</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">locale_info</span></span><br><span class="line">&#123;</span><br><span class="line">    UINT code_page;</span><br><span class="line">    <span class="type">void</span>* heap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> GLOBAL_PIPENAME = <span class="string">R&quot;(\\.\pipe\Locale Emulator Plus)&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> locale_info global_info;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="hook-cpp"><a href="#hook-cpp" class="headerlink" title="hook.cpp"></a>hook.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;detours.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;table.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">attach</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; api : HOOK_LIST)</span><br><span class="line">    &#123;</span><br><span class="line">        ::<span class="built_in">DetourAttach</span>(</span><br><span class="line">            std::<span class="built_in">addressof</span>(<span class="built_in">reinterpret_cast</span>&lt;PVOID&amp;&gt;(api.src)),</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;PVOID&gt;(api.dst));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">detach</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; api : HOOK_LIST)</span><br><span class="line">    &#123;</span><br><span class="line">        ::<span class="built_in">DetourDetach</span>(</span><br><span class="line">            std::<span class="built_in">addressof</span>(<span class="built_in">reinterpret_cast</span>&lt;PVOID&amp;&gt;(api.src)),</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;PVOID&gt;(api.dst));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">DetourIsHelperProcess</span>())</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fdwReason == DLL_PROCESS_ATTACH)</span><br><span class="line">    &#123;</span><br><span class="line">        ::<span class="built_in">initialize</span>();</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">DetourRestoreAfterWith</span>();</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">DetourTransactionBegin</span>();</span><br><span class="line">        ::<span class="built_in">DetourUpdateThread</span>(::<span class="built_in">GetCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">attach</span>();</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">DetourTransactionCommit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fdwReason == DLL_PROCESS_DETACH)</span><br><span class="line">    &#123;</span><br><span class="line">        ::<span class="built_in">DetourTransactionBegin</span>();</span><br><span class="line">        ::<span class="built_in">DetourUpdateThread</span>(<span class="built_in">GetCurrentThread</span>());</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">detach</span>();</span><br><span class="line"></span><br><span class="line">        ::<span class="built_in">DetourTransactionCommit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="implement-cpp"><a href="#implement-cpp" class="headerlink" title="implement.cpp"></a>implement.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;global.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;table.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/macro.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NAMESPACE_BEGIN</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> char_type&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">string</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span>(char_type* ptr = <span class="literal">nullptr</span>) :</span><br><span class="line">        <span class="built_in">ptr</span>(ptr)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">string</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            std::<span class="built_in">free</span>(ptr);</span><br><span class="line">            ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="type">const</span> char_type*() <span class="keyword">noexcept</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    char_type* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string&lt;<span class="type">wchar_t</span>&gt; <span class="title">char2wide</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* src, UINT code_page = CP_ACP)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!src)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> src_size = ::<span class="built_in">lstrlenA</span>(src);</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> dst_size = ::<span class="built_in">MultiByteToWideChar</span>(code_page, <span class="number">0</span>, src, src_size, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> dst_capacity = (dst_size + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>);</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> dst = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">wchar_t</span>*&gt;(std::<span class="built_in">malloc</span>(dst_capacity));</span><br><span class="line"></span><br><span class="line">    [[maybe_unused]] <span class="keyword">auto</span> <span class="type">const</span> result = ::<span class="built_in">MultiByteToWideChar</span>(code_page, <span class="number">0</span>, src, src_size, dst, dst_size);</span><br><span class="line"></span><br><span class="line">    dst[dst_size] = <span class="string">L&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;dst&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string&lt;<span class="type">char</span>&gt; <span class="title">wide2char</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* src, UINT code_page = CP_ACP)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!src)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> src_size = ::<span class="built_in">lstrlenW</span>(src);</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> dst_size = ::<span class="built_in">WideCharToMultiByte</span>(code_page, <span class="number">0</span>, src, src_size, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> dst_capacity = (dst_size + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> dst = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(std::<span class="built_in">malloc</span>(dst_capacity));</span><br><span class="line"></span><br><span class="line">    [[maybe_unused]] <span class="keyword">auto</span> <span class="type">const</span> result = ::<span class="built_in">WideCharToMultiByte</span>(code_page, <span class="number">0</span>, src, src_size, dst, dst_size, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    dst[dst_size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;dst&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string&lt;<span class="type">wchar_t</span>&gt; <span class="title">shiftjis2gbk</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* <span class="type">const</span> src)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">char2wide</span>(<span class="built_in">wide2char</span>(src, (UINT)Encoding::gbk), (UINT)Encoding::shift_jis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NAMESPACE_END</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">NAMESPACE_BEGIN</span>(hook)</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;hook_function_help fn_name&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hook_struct_help</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER(fn_name)                                \</span></span><br><span class="line"><span class="meta">    template <span class="string">&lt;&gt;</span>                                          \</span></span><br><span class="line"><span class="meta">    struct hook_struct_help<span class="string">&lt;hook_function_help::fn_name&gt;</span> \</span></span><br><span class="line"><span class="meta">    &#123;                                                    \</span></span><br><span class="line"><span class="meta">        using fn_type = decltype(&amp;::fn_name);            \</span></span><br><span class="line"><span class="meta">    &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;hook_function_help T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_original_function_ptr</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> c++23 std::to_underlying</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;hook_struct_help&lt;T&gt;::fn_type&gt;(HOOK_LIST[<span class="built_in">static_cast</span>&lt;usize&gt;(T)].src);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">REGISTER</span>(MessageBoxA)</span><br><span class="line"><span class="built_in">REGISTER</span>(MessageBoxW)</span><br><span class="line"><span class="built_in">REGISTER</span>(SetWindowTextA)</span><br><span class="line"><span class="built_in">REGISTER</span>(SetWindowTextW)</span><br><span class="line"><span class="built_in">REGISTER</span>(RegisterClassExA)</span><br><span class="line"><span class="built_in">REGISTER</span>(RegisterClassExW)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">MessageBoxA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> original = <span class="built_in">get_original_function_ptr</span>&lt;hook_function_help::MessageBoxW&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">original</span>(hWnd, <span class="built_in">char2wide</span>(lpText, global_info.code_page), <span class="built_in">char2wide</span>(lpCaption, global_info.code_page), uType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> WINAPI <span class="title">MessageBoxW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> original = <span class="built_in">get_original_function_ptr</span>&lt;hook_function_help::MessageBoxW&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">original</span>(hWnd, <span class="built_in">shiftjis2gbk</span>(lpText), <span class="built_in">shiftjis2gbk</span>(lpCaption), uType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">SetWindowTextA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> original = <span class="built_in">get_original_function_ptr</span>&lt;hook_function_help::SetWindowTextW&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">original</span>(hWnd, <span class="built_in">char2wide</span>(lpString));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">SetWindowTextW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> original = <span class="built_in">get_original_function_ptr</span>&lt;hook_function_help::SetWindowTextW&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">original</span>(hWnd, <span class="built_in">shiftjis2gbk</span>(lpString));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ATOM WINAPI <span class="title">RegisterClassExA</span><span class="params">(_In_ CONST WNDCLASSEXA* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> original = <span class="built_in">get_original_function_ptr</span>&lt;hook_function_help::RegisterClassExW&gt;();</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> class_name = <span class="built_in">char2wide</span>(src-&gt;lpszClassName);</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> menu_name = <span class="built_in">char2wide</span>(src-&gt;lpszMenuName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dst = *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> WNDCLASSEXW*&gt;(src);</span><br><span class="line">    dst.lpszClassName = class_name.ptr;</span><br><span class="line">    dst.lpszMenuName = menu_name.ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">original</span>(&amp;dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ATOM WINAPI <span class="title">RegisterClassExW</span><span class="params">(_In_ CONST WNDCLASSEXW* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> original = <span class="built_in">get_original_function_ptr</span>&lt;hook_function_help::RegisterClassExW&gt;();</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> class_name = <span class="built_in">shiftjis2gbk</span>(src-&gt;lpszClassName);</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> menu_name = <span class="built_in">shiftjis2gbk</span>(src-&gt;lpszMenuName);</span><br><span class="line"></span><br><span class="line">    WNDCLASSEXW dst = *src;</span><br><span class="line">    dst.lpszClassName = class_name.ptr;</span><br><span class="line">    dst.lpszMenuName = menu_name.ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">original</span>(&amp;dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">GetModuleFileNameA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_writes_to_(nSize, ((<span class="keyword">return</span> &lt; nSize) ? (<span class="keyword">return</span> +<span class="number">1</span>) : nSize)) LPSTR lpFilename,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD nSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">wchar_t</span> filename[MAX_PATH];</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> ret = ::<span class="built_in">GetModuleFileNameW</span>(hModule, filename, nSize);</span><br><span class="line">    ::<span class="built_in">WideCharToMultiByte</span>(global_info.code_page, <span class="number">0</span>, filename, MAX_PATH, lpFilename, MAX_PATH, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NAMESPACE_END</span>(hook)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base/base.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hook_function</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span>* src = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">void</span>* dst = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NAMESPACE_BEGIN</span>(hook)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">MessageBoxA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ UINT uType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">MessageBoxW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ UINT uType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">SetWindowTextA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpString)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">SetWindowTextW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCWSTR lpString)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ATOM</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">RegisterClassExA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ CONST WNDCLASSEXA *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ATOM</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">RegisterClassExW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ CONST WNDCLASSEXW *)</span></span>;</span><br><span class="line"></span><br><span class="line">_Success_(<span class="keyword">return</span> != <span class="number">0</span>)</span><br><span class="line">_Ret_range_(<span class="number">1</span>,nSize)</span><br><span class="line"><span class="function">DWORD</span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">GetModuleFileNameA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_writes_to_(nSize,((<span class="keyword">return</span> &lt; nSize) ? (<span class="keyword">return</span> + <span class="number">1</span>) : nSize)) LPSTR lpFilename,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD nSize</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function">WINAPI</span></span><br><span class="line"><span class="function"><span class="title">MultiByteToWideChar</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ UINT CodePage,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ DWORD dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_NLS_string_(cbMultiByte) LPCCH lpMultiByteStr,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ <span class="type">int</span> cbMultiByte,</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_writes_to_opt_(cchWideChar,<span class="keyword">return</span>) LPWSTR lpWideCharStr,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ <span class="type">int</span> cchWideChar</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NAMESPACE_END</span>(hook)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">hook_function_help</span></span><br><span class="line">&#123;</span><br><span class="line">    MessageBoxA = <span class="number">0</span>,</span><br><span class="line">    MessageBoxW,</span><br><span class="line">    SetWindowTextA,</span><br><span class="line">    SetWindowTextW,</span><br><span class="line">    RegisterClassExA,</span><br><span class="line">    RegisterClassExW,</span><br><span class="line">    GetModuleFileNameA,</span><br><span class="line">    MAX,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOOK_LIST_HELP(fn_name) &#123;::fn_name, ::hook::fn_name&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> hook_function HOOK_LIST[]</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">HOOK_LIST_HELP</span>(MessageBoxA),</span><br><span class="line">    <span class="built_in">HOOK_LIST_HELP</span>(MessageBoxW),</span><br><span class="line">    <span class="built_in">HOOK_LIST_HELP</span>(SetWindowTextA),</span><br><span class="line">    <span class="built_in">HOOK_LIST_HELP</span>(SetWindowTextW),</span><br><span class="line">    <span class="built_in">HOOK_LIST_HELP</span>(RegisterClassExA),</span><br><span class="line">    <span class="built_in">HOOK_LIST_HELP</span>(RegisterClassExW),</span><br><span class="line">    <span class="built_in">HOOK_LIST_HELP</span>(GetModuleFileNameA),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">static_cast</span>&lt;usize&gt;(hook_function_help::MAX) == std::<span class="built_in">size</span>(HOOK_LIST));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="tool"><a href="#tool" class="headerlink" title="tool"></a>tool</h3><h4 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shlwapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;detours.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;base/basic_type.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="keyword">auto</span> <span class="title">get_dll_name</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>(<span class="type">void</span>*) == <span class="number">8</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;locale_emulator_plus64.dll&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (<span class="built_in">sizeof</span>(<span class="type">void</span>*) == <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;locale_emulator_plus32.dll&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> DLL_NAME</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LOCALE_EMULATOR_PLUS_DLL_NAME</span></span><br><span class="line">    <span class="built_in">get_dll_name</span>()</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    LOCALE_EMULATOR_PLUS_DLL_NAME</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fixed_buffer</span></span><br><span class="line">&#123;</span><br><span class="line">    usize size = <span class="number">0</span>;</span><br><span class="line">    <span class="type">wchar_t</span> data[MAX_PATH];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> fixed_buffer <span class="title">string2wstring</span><span class="params">(<span class="type">const</span> std::string_view string)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    usize size = ::<span class="built_in">MultiByteToWideChar</span>(CP_ACP, <span class="number">0</span>, string.<span class="built_in">data</span>(), string.<span class="built_in">size</span>(), <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixed_buffer buffer&#123;size&#125;;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">MultiByteToWideChar</span>(CP_ACP, <span class="number">0</span>, string.<span class="built_in">data</span>(), string.<span class="built_in">size</span>(), buffer.data, size) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.data[size] = <span class="string">L&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TCHAR absolute_dll_path[MAX_PATH];</span><br><span class="line">    ::<span class="built_in">GetModuleFileNameA</span>(<span class="literal">nullptr</span>, absolute_dll_path, MAX_PATH);</span><br><span class="line">    ::<span class="built_in">PathRemoveFileSpecA</span>(absolute_dll_path);</span><br><span class="line">    ::<span class="built_in">PathAppendA</span>(absolute_dll_path, DLL_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="type">const</span> [size, program_path] = ::<span class="built_in">string2wstring</span>(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ::PROCESS_INFORMATION process_info&#123;&#125;;</span><br><span class="line">    ::STARTUPINFOW startup_info&#123;.cb = <span class="built_in">sizeof</span>(startup_info)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wchar_t cur_dir[MAX_PATH];</span></span><br><span class="line">    <span class="comment">// std::memcpy(cur_dir, program_path, size * sizeof(wchar_t) + 1);</span></span><br><span class="line">    <span class="comment">// ::PathRemoveFileSpecW(cur_dir);</span></span><br><span class="line"></span><br><span class="line">    BOOL result = ::<span class="built_in">DetourCreateProcessWithDllExW</span>(</span><br><span class="line">        program_path, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="literal">nullptr</span>, FALSE, CREATE_DEFAULT_ERROR_MODE, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>,</span><br><span class="line">        &amp;startup_info, &amp;process_info, absolute_dll_path, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
</search>
